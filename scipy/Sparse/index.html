


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.2.3">
    
    
      
        <title>Sparse - OCaml scikit-learn interface</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6e35a1a6.min.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a46bcfb3.min.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#attributes" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="OCaml scikit-learn interface" class="md-header-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            OCaml scikit-learn interface
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Sparse
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
          

  

<nav class="md-tabs md-tabs--active" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../np/" class="md-tabs__link">
          Np
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../" class="md-tabs__link md-tabs__link--active">
          Scipy
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../sklearn/Base/" class="md-tabs__link">
          Sklearn
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OCaml scikit-learn interface" class="md-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    OCaml scikit-learn interface
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Np
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Np" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Np
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/" title="Numpy for OCaml" class="md-nav__link">
      Numpy for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/Numpy/" title="Numpy" class="md-nav__link">
      Numpy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/NumpyRaw/" title="NumpyRaw" class="md-nav__link">
      NumpyRaw
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/PyList/" title="PyList" class="md-nav__link">
      PyList
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/dtype/" title="Dtype" class="md-nav__link">
      Dtype
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/obj/" title="Obj" class="md-nav__link">
      Obj
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Scipy
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Scipy" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Scipy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="SciPy library for OCaml" class="md-nav__link">
      SciPy library for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Constants/" title="Constants" class="md-nav__link">
      Constants
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fft/" title="Fft" class="md-nav__link">
      Fft
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fftpack/" title="Fftpack" class="md-nav__link">
      Fftpack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Integrate/" title="Integrate" class="md-nav__link">
      Integrate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interpolate/" title="Interpolate" class="md-nav__link">
      Interpolate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Io/" title="Io" class="md-nav__link">
      Io
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Linalg/" title="Linalg" class="md-nav__link">
      Linalg
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Misc/" title="Misc" class="md-nav__link">
      Misc
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Ndimage/" title="Ndimage" class="md-nav__link">
      Ndimage
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Odr/" title="Odr" class="md-nav__link">
      Odr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Optimize/" title="Optimize" class="md-nav__link">
      Optimize
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Signal/" title="Signal" class="md-nav__link">
      Signal
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Sparse" class="md-nav__link md-nav__link--active">
      Sparse
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Spatial/" title="Spatial" class="md-nav__link">
      Spatial
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Special/" title="Special" class="md-nav__link">
      Special
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Stats/" title="Stats" class="md-nav__link">
      Stats
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Version/" title="Version" class="md-nav__link">
      Version
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Sklearn
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Sklearn" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Sklearn
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Base/" title="Base" class="md-nav__link">
      Base
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Calibration/" title="Calibration" class="md-nav__link">
      Calibration
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Compose/" title="Compose" class="md-nav__link">
      Compose
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Covariance/" title="Covariance" class="md-nav__link">
      Covariance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cross_decomposition/" title="Cross decomposition" class="md-nav__link">
      Cross decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Datasets/" title="Datasets" class="md-nav__link">
      Datasets
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Decomposition/" title="Decomposition" class="md-nav__link">
      Decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Discriminant_analysis/" title="Discriminant analysis" class="md-nav__link">
      Discriminant analysis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Dummy/" title="Dummy" class="md-nav__link">
      Dummy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Ensemble/" title="Ensemble" class="md-nav__link">
      Ensemble
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Exceptions/" title="Exceptions" class="md-nav__link">
      Exceptions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Experimental/" title="Experimental" class="md-nav__link">
      Experimental
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Externals/" title="Externals" class="md-nav__link">
      Externals
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_extraction/" title="Feature extraction" class="md-nav__link">
      Feature extraction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_selection/" title="Feature selection" class="md-nav__link">
      Feature selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Gaussian_process/" title="Gaussian process" class="md-nav__link">
      Gaussian process
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Impute/" title="Impute" class="md-nav__link">
      Impute
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Inspection/" title="Inspection" class="md-nav__link">
      Inspection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Isotonic/" title="Isotonic" class="md-nav__link">
      Isotonic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_approximation/" title="Kernel approximation" class="md-nav__link">
      Kernel approximation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_ridge/" title="Kernel ridge" class="md-nav__link">
      Kernel ridge
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Linear_model/" title="Linear model" class="md-nav__link">
      Linear model
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Manifold/" title="Manifold" class="md-nav__link">
      Manifold
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Metrics/" title="Metrics" class="md-nav__link">
      Metrics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Mixture/" title="Mixture" class="md-nav__link">
      Mixture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Model_selection/" title="Model selection" class="md-nav__link">
      Model selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multiclass/" title="Multiclass" class="md-nav__link">
      Multiclass
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multioutput/" title="Multioutput" class="md-nav__link">
      Multioutput
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Naive_bayes/" title="Naive bayes" class="md-nav__link">
      Naive bayes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neighbors/" title="Neighbors" class="md-nav__link">
      Neighbors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neural_network/" title="Neural network" class="md-nav__link">
      Neural network
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Pipeline/" title="Pipeline" class="md-nav__link">
      Pipeline
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Preprocessing/" title="Preprocessing" class="md-nav__link">
      Preprocessing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Random_projection/" title="Random projection" class="md-nav__link">
      Random projection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Semi_supervised/" title="Semi supervised" class="md-nav__link">
      Semi supervised
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Svm/" title="Svm" class="md-nav__link">
      Svm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tests/" title="Tests" class="md-nav__link">
      Tests
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tree/" title="Tree" class="md-nav__link">
      Tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Utils/" title="Utils" class="md-nav__link">
      Utils
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/arr/" title="Arr" class="md-nav__link">
      Arr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/dict/" title="Dict" class="md-nav__link">
      Dict
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/lehy/ocaml-sklearn/edit/master/docs/scipy/Sparse.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  
                
                
                <p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">SparseEfficiencyWarning</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">SparseEfficiencyWarning</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SparseEfficiencyWarning</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">SparseWarning</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">SparseWarning</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SparseWarning</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Bsr_matrix</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Bsr_matrix</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArrayLike</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bsr_matrix</span> <span class="o">|</span> <span class="o">`</span><span class="nc">IndexMixin</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_index</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">IndexMixin</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">blocksize</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">arg1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Block Sparse Row matrix</p>
<p>This can be instantiated in several ways:
bsr_matrix(D, [blocksize=(R,C)])
where D is a dense matrix or 2-D ndarray.</p>
<p>bsr_matrix(S, [blocksize=(R,C)])
with another sparse matrix S (equivalent to S.tobsr())</p>
<p>bsr_matrix((M, N), [blocksize=(R,C), dtype])
to construct an empty matrix with shape (M, N)
dtype is optional, defaulting to dtype='d'.</p>
<p>bsr_matrix((data, ij), [blocksize=(R,C), shape=(M, N)])
where <code>data</code> and <code>ij</code> satisfy <code>a[ij[0, k], ij[1, k]] = data[k]</code></p>
<p>bsr_matrix((data, indices, indptr), [shape=(M, N)])
is the standard BSR representation where the block column
indices for row i are stored in <code>indices[indptr[i]:indptr[i+1]]</code>
and their corresponding block values are stored in
<code>data[ indptr[i]: indptr[i+1] ]</code>.  If the shape parameter is not
supplied, the matrix dimensions are inferred from the index arrays.</p>
<h2 id="attributes">Attributes<a class="headerlink" href="#attributes" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Data type of the matrix
shape : 2-tuple
Shape of the matrix
ndim : int
Number of dimensions (this is always 2)
nnz
Number of stored values, including explicit zeros
data
Data array of the matrix
indices
BSR format index array
indptr
BSR format index pointer array
blocksize
Block size of the matrix
has_sorted_indices
Whether indices are sorted</p>
<h2 id="notes">Notes<a class="headerlink" href="#notes" title="Permanent link">&para;</a></h2>
<p>Sparse matrices can be used in arithmetic operations: they support
addition, subtraction, multiplication, division, and matrix power.</p>
<p><strong>Summary of BSR format</strong></p>
<p>The Block Compressed Row (BSR) format is very similar to the Compressed
Sparse Row (CSR) format.  BSR is appropriate for sparse matrices with dense
sub matrices like the last example below.  Block matrices often arise in
vector-valued finite element discretizations.  In such cases, BSR is
considerably more efficient than CSR and CSC for many sparse arithmetic
operations.</p>
<p><strong>Blocksize</strong></p>
<p>The blocksize (R,C) must evenly divide the shape of the matrix (M,N).
That is, R and C must satisfy the relationship <code>M % R = 0</code> and
<code>N % C = 0</code>.</p>
<p>If no blocksize is specified, a simple heuristic is applied to determine
an appropriate blocksize.</p>
<h2 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import bsr_matrix
bsr_matrix((3, 4), dtype=np.int8).toarray()
array([[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]], dtype=int8)</p>
<p>row = np.array([0, 0, 1, 2, 2, 2])
col = np.array([0, 2, 2, 0, 1, 2])
data = np.array([1, 2, 3 ,4, 5, 6])
bsr_matrix((data, (row, col)), shape=(3, 3)).toarray()
array([[1, 0, 2],
[0, 0, 3],
[4, 5, 6]])</p>
<p>indptr = np.array([0, 2, 3, 6])
indices = np.array([0, 2, 2, 0, 1, 2])
data = np.array([1, 2, 3, 4, 5, 6]).repeat(4).reshape(6, 2, 2)
bsr_matrix((data,indices,indptr), shape=(6, 6)).toarray()
array([[1, 1, 0, 0, 2, 2],
[1, 1, 0, 0, 2, 2],
[0, 0, 0, 0, 3, 3],
[0, 0, 0, 0, 3, 3],
[4, 4, 5, 5, 6, 6],
[4, 4, 5, 5, 6, 6]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">setitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">val_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arcsin</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arcsin.</p>
<p>See numpy.arcsin for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arcsinh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arcsinh.</p>
<p>See numpy.arcsinh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arctan</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arctan.</p>
<p>See numpy.arctan for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arctanh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arctanh.</p>
<p>See numpy.arctanh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argmax</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return indices of maximum elements along an axis.</p>
<p>Implicit zero elements are also taken into account. If there are
several maximum values, the index of the first occurrence is returned.</p>
<h2 id="parameters">Parameters<a class="headerlink" href="#parameters" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None}, optional
Axis along which the argmax is computed. If None (default), index
of the maximum element in the flatten data is returned.
out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except for
the default value, as this argument is not used.</p>
<h2 id="returns">Returns<a class="headerlink" href="#returns" title="Permanent link">&para;</a></h2>
<p>ind : numpy.matrix or int
Indices of maximum elements. If matrix, its size along <code>axis</code> is 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argmin</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return indices of minimum elements along an axis.</p>
<p>Implicit zero elements are also taken into account. If there are
several minimum values, the index of the first occurrence is returned.</p>
<h2 id="parameters_1">Parameters<a class="headerlink" href="#parameters_1" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None}, optional
Axis along which the argmin is computed. If None (default), index
of the minimum element in the flatten data is returned.
out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except for
the default value, as this argument is not used.</p>
<h2 id="returns_1">Returns<a class="headerlink" href="#returns_1" title="Permanent link">&para;</a></h2>
<p>ind : numpy.matrix or int
Indices of minimum elements. If matrix, its size along <code>axis</code> is 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asformat</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">format</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return this matrix in the passed format.</p>
<h2 id="parameters_2">Parameters<a class="headerlink" href="#parameters_2" title="Permanent link">&para;</a></h2>
<p>format : {str, None}
The desired matrix format ('csr', 'csc', 'lil', 'dok', 'array', ...)
or None for no conversion.
copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_2">Returns<a class="headerlink" href="#returns_2" title="Permanent link">&para;</a></h2>
<p>A : This matrix in the passed format.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asfptype</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Upcast matrix to a floating point format (if necessary)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">astype</span> <span class="o">:</span> <span class="o">?</span><span class="n">casting</span><span class="o">:[`</span><span class="nc">No</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Equiv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Safe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same_kind</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Unsafe</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cast the matrix elements to a specified type.</p>
<h2 id="parameters_3">Parameters<a class="headerlink" href="#parameters_3" title="Permanent link">&para;</a></h2>
<p>dtype : string or numpy dtype
Typecode or data-type to which to cast the data.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
Controls what kind of data casting may occur.
Defaults to 'unsafe' for backwards compatibility.
'no' means the data types should not be cast at all.
'equiv' means only byte-order changes are allowed.
'safe' means only casts which can preserve values are allowed.
'same_kind' means only safe casts or casts within a kind,
like float64 to float32, are allowed.
'unsafe' means any data conversions may be done.
copy : bool, optional
If <code>copy</code> is <code>False</code>, the result might share some memory with this
matrix. If <code>copy</code> is <code>True</code>, it is guaranteed that the result and
this matrix do not share any memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ceil</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise ceil.</p>
<p>See numpy.ceil for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_format</span> <span class="o">:</span> <span class="o">?</span><span class="n">full_check</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>check whether the matrix format is valid</p>
<p><em>Parameters</em>:
full_check:
True  - rigorous check, O(N) operations : default
False - basic check, O(1) operations</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conj</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_4">Parameters<a class="headerlink" href="#parameters_4" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_3">Returns<a class="headerlink" href="#returns_3" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjugate</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_5">Parameters<a class="headerlink" href="#parameters_5" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_4">Returns<a class="headerlink" href="#returns_4" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">copy</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of this matrix.</p>
<p>No data/indices will be shared between the returned value and current
matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count_nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of non-zero entries, equivalent to</p>
<p>np.count_nonzero(a.toarray())</p>
<p>Unlike getnnz() and the nnz property, which return the number of stored
entries (the length of the data attribute), this method counts the
actual number of non-zero entries in data.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">deg2rad</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise deg2rad.</p>
<p>See numpy.deg2rad for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the k-th diagonal of the matrix.</p>
<h2 id="parameters_6">Parameters<a class="headerlink" href="#parameters_6" title="Permanent link">&para;</a></h2>
<p>k : int, optional
Which diagonal to get, corresponding to elements a[i, i+k].
Default: 0 (the main diagonal).</p>
<p>.. versionadded:: 1.0</p>
<h2 id="see-also">See also<a class="headerlink" href="#see-also" title="Permanent link">&para;</a></h2>
<p>numpy.diagonal : Equivalent numpy function.</p>
<h2 id="examples_1">Examples<a class="headerlink" href="#examples_1" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
A.diagonal()
array([1, 0, 5])
A.diagonal(k=1)
array([2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Ordinary dot product</p>
<h2 id="examples_2">Examples<a class="headerlink" href="#examples_2" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
v = np.array([1, 0, -1])
A.dot(v)
array([ 1, -3, -1], dtype=int64)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eliminate_zeros</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Remove zero elements in-place.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm1</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise expm1.</p>
<p>See numpy.expm1 for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">floor</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise floor.</p>
<p>See numpy.floor for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getH</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Hermitian transpose of this matrix.</p>
<h2 id="see-also_1">See Also<a class="headerlink" href="#see-also_1" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.getH : NumPy's implementation of <code>getH</code> for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_shape</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get shape of a matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getcol</span> <span class="o">:</span> <span class="n">j</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of column j of the matrix, as an (m x 1) sparse
matrix (column vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getformat</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Format of a matrix representation as a string.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getmaxprint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Maximum number of elements to display when printed.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getnnz</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of stored values, including explicit zeros.</p>
<h2 id="parameters_7">Parameters<a class="headerlink" href="#parameters_7" title="Permanent link">&para;</a></h2>
<p>axis : None, 0, or 1
Select between the number of values across the whole matrix, in
each column, or in each row.</p>
<h2 id="see-also_2">See also<a class="headerlink" href="#see-also_2" title="Permanent link">&para;</a></h2>
<p>count_nonzero : Number of non-zero entries</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getrow</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of row i of the matrix, as a (1 x n) sparse
matrix (row vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">log1p</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise log1p.</p>
<p>See numpy.log1p for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">max</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the maximum of the matrix or maximum along an axis.
This takes all elements into account, not just the non-zero ones.</p>
<h2 id="parameters_8">Parameters<a class="headerlink" href="#parameters_8" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the maximum over all the matrix elements, returning
a scalar (i.e. <code>axis</code> = <code>None</code>).</p>
<p>out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except
for the default value, as this argument is not used.</p>
<h2 id="returns_5">Returns<a class="headerlink" href="#returns_5" title="Permanent link">&para;</a></h2>
<p>amax : coo_matrix or scalar
Maximum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.
If <code>axis</code> is given, the result is a sparse.coo_matrix of dimension
<code>a.ndim - 1</code>.</p>
<h2 id="see-also_3">See Also<a class="headerlink" href="#see-also_3" title="Permanent link">&para;</a></h2>
<p>min : The minimum value of a sparse matrix along a given axis.
numpy.matrix.max : NumPy's implementation of 'max' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise maximum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the matrix elements. The average is taken
over all elements in the matrix by default, otherwise over the
specified axis. <code>float64</code> intermediate and return values are used
for integer inputs.</p>
<h2 id="parameters_9">Parameters<a class="headerlink" href="#parameters_9" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the mean is computed. The default is to compute
the mean of all elements in the matrix (i.e. <code>axis</code> = <code>None</code>).
dtype : data-type, optional
Type to use in computing the mean. For integer inputs, the default
is <code>float64</code>; for floating point inputs, it is the same as the
input dtype.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_6">Returns<a class="headerlink" href="#returns_6" title="Permanent link">&para;</a></h2>
<p>m : np.matrix</p>
<h2 id="see-also_4">See Also<a class="headerlink" href="#see-also_4" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.mean : NumPy's implementation of 'mean' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">min</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the minimum of the matrix or maximum along an axis.
This takes all elements into account, not just the non-zero ones.</p>
<h2 id="parameters_10">Parameters<a class="headerlink" href="#parameters_10" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the minimum over all the matrix elements, returning
a scalar (i.e. <code>axis</code> = <code>None</code>).</p>
<p>out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except for
the default value, as this argument is not used.</p>
<h2 id="returns_7">Returns<a class="headerlink" href="#returns_7" title="Permanent link">&para;</a></h2>
<p>amin : coo_matrix or scalar
Minimum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.
If <code>axis</code> is given, the result is a sparse.coo_matrix of dimension
<code>a.ndim - 1</code>.</p>
<h2 id="see-also_5">See Also<a class="headerlink" href="#see-also_5" title="Permanent link">&para;</a></h2>
<p>max : The maximum value of a sparse matrix along a given axis.
numpy.matrix.min : NumPy's implementation of 'min' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise minimum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">multiply</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Point-wise multiplication by another matrix, vector, or
scalar.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nonzero indices</p>
<p>Returns a tuple of arrays (row,col) containing the indices
of the non-zero elements of the matrix.</p>
<h2 id="examples_3">Examples<a class="headerlink" href="#examples_3" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])
A.nonzero()
(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">power</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>This function performs element-wise power.</p>
<h2 id="parameters_11">Parameters<a class="headerlink" href="#parameters_11" title="Permanent link">&para;</a></h2>
<p>n : n is a scalar</p>
<p>dtype : If dtype is not specified, the current dtype will be preserved.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">prune</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Remove empty space after all non-zero elements.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rad2deg</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise rad2deg.</p>
<p>See numpy.rad2deg for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>reshape(self, shape, order='C', copy=False)</p>
<p>Gives a new shape to a sparse matrix without changing its data.</p>
<h2 id="parameters_12">Parameters<a class="headerlink" href="#parameters_12" title="Permanent link">&para;</a></h2>
<p>shape : length-2 tuple of ints
The new shape should be compatible with the original shape.
order : {'C', 'F'}, optional
Read the elements using this index order. 'C' means to read and
write the elements using C-like index order; e.g. read entire first
row, then second row, etc. 'F' means to read and write the elements
using Fortran-like index order; e.g. read entire first column, then
second column, etc.
copy : bool, optional
Indicates whether or not attributes of self should be copied
whenever possible. The degree to which attributes are copied varies
depending on the type of sparse matrix being used.</p>
<h2 id="returns_8">Returns<a class="headerlink" href="#returns_8" title="Permanent link">&para;</a></h2>
<p>reshaped_matrix : sparse matrix
A sparse matrix with the given <code>shape</code>, not necessarily of the same
format as the current object.</p>
<h2 id="see-also_6">See Also<a class="headerlink" href="#see-also_6" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.reshape : NumPy's implementation of 'reshape' for
matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resize</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Resize the matrix in-place to dimensions given by <code>shape</code></p>
<p>Any elements that lie within the new shape will remain at the same
indices, while non-zero elements lying outside the new shape are
removed.</p>
<h2 id="parameters_13">Parameters<a class="headerlink" href="#parameters_13" title="Permanent link">&para;</a></h2>
<p>shape : (int, int)
number of rows and columns in the new matrix</p>
<h2 id="notes_1">Notes<a class="headerlink" href="#notes_1" title="Permanent link">&para;</a></h2>
<p>The semantics are not identical to <code>numpy.ndarray.resize</code> or
<code>numpy.resize</code>.  Here, the same data will be maintained at each index
before and after reshape, if that index is within the new bounds.  In
numpy, resizing maintains contiguity of the array, moving elements
around in the logical matrix but not within a flattened representation.</p>
<p>We give no guarantees about whether the underlying data attributes
(arrays, etc.) will be modified in place or replaced with new objects.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise rint.</p>
<p>See numpy.rint for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_shape</span> <span class="o">:</span> <span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>See <code>reshape</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setdiag</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">values</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Set diagonal or off-diagonal elements of the array.</p>
<h2 id="parameters_14">Parameters<a class="headerlink" href="#parameters_14" title="Permanent link">&para;</a></h2>
<p>values : array_like
New values of the diagonal elements.</p>
<p>Values may have any length.  If the diagonal is longer than values,
then the remaining diagonal entries will not be set.  If values if
longer than the diagonal, then the remaining values are ignored.</p>
<p>If a scalar value is given, all of the diagonal is set to it.</p>
<p>k : int, optional
Which off-diagonal to set, corresponding to elements a[i,i+k].
Default: 0 (the main diagonal).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sign</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sign.</p>
<p>See numpy.sign for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sin</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sin.</p>
<p>See numpy.sin for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sinh.</p>
<p>See numpy.sinh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sort_indices</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sort the indices of this matrix <em>in place</em></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sorted_indices</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of this matrix with sorted indices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrt</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sqrt.</p>
<p>See numpy.sqrt for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sum the matrix elements over a given axis.</p>
<h2 id="parameters_15">Parameters<a class="headerlink" href="#parameters_15" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the sum of all the matrix elements, returning a scalar
(i.e. <code>axis</code> = <code>None</code>).
dtype : dtype, optional
The type of the returned matrix and of the accumulator in which
the elements are summed.  The dtype of <code>a</code> is used by default
unless <code>a</code> has an integer dtype of less precision than the default
platform integer.  In that case, if <code>a</code> is signed then the platform
integer is used while if <code>a</code> is unsigned then an unsigned integer
of the same precision as the platform integer is used.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_9">Returns<a class="headerlink" href="#returns_9" title="Permanent link">&para;</a></h2>
<p>sum_along_axis : np.matrix
A matrix with the same shape as <code>self</code>, with the specified
axis removed.</p>
<h2 id="see-also_7">See Also<a class="headerlink" href="#see-also_7" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.sum : NumPy's implementation of 'sum' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum_duplicates</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Eliminate duplicate matrix entries by adding them together</p>
<p>The is an <em>in place</em> operation</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tan</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise tan.</p>
<p>See numpy.tan for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise tanh.</p>
<p>See numpy.tanh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense ndarray representation of this matrix.</p>
<h2 id="parameters_16">Parameters<a class="headerlink" href="#parameters_16" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array as the output buffer
instead of allocating a new array to return. The provided
array must have the same shape and dtype as the sparse
matrix on which you are calling the method. For most
sparse types, <code>out</code> is required to be memory contiguous
(either C or Fortran ordered).</p>
<h2 id="returns_10">Returns<a class="headerlink" href="#returns_10" title="Permanent link">&para;</a></h2>
<p>arr : ndarray, 2-dimensional
An array with the same shape and containing the same
data represented by the sparse matrix, with the requested
memory order. If <code>out</code> was passed, the same object is
returned after being modified in-place to contain the
appropriate values.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tobsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">blocksize</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix into Block Sparse Row Format.</p>
<p>With copy=False, the data/indices may be shared between this
matrix and the resultant bsr_matrix.</p>
<p>If blocksize=(R, C) is provided, it will be used for determining
block size of the bsr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocoo</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to COOrdinate format.</p>
<p>When copy=False the data array will be shared between
this matrix and the resultant coo_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsc</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Column format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csc_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense matrix representation of this matrix.</p>
<h2 id="parameters_17">Parameters<a class="headerlink" href="#parameters_17" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array (or <code>numpy.matrix</code>) as the
output buffer instead of allocating a new array to
return. The provided array must have the same shape and
dtype as the sparse matrix on which you are calling the
method.</p>
<h2 id="returns_11">Returns<a class="headerlink" href="#returns_11" title="Permanent link">&para;</a></h2>
<p>arr : numpy.matrix, 2-dimensional
A NumPy matrix object with the same shape and containing
the same data represented by the sparse matrix, with the
requested memory order. If <code>out</code> was passed and was an
array (rather than a <code>numpy.matrix</code>), it will be filled
with the appropriate values and returned wrapped in a
<code>numpy.matrix</code> object that shares the same memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todia</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to sparse DIAgonal format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dia_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todok</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Dictionary Of Keys format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dok_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tolil</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to List of Lists format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant lil_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reverses the dimensions of the sparse matrix.</p>
<h2 id="parameters_18">Parameters<a class="headerlink" href="#parameters_18" title="Permanent link">&para;</a></h2>
<p>axes : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except
for the default value.
copy : bool, optional
Indicates whether or not attributes of <code>self</code> should be
copied whenever possible. The degree to which attributes
are copied varies depending on the type of sparse matrix
being used.</p>
<h2 id="returns_12">Returns<a class="headerlink" href="#returns_12" title="Permanent link">&para;</a></h2>
<p>p : <code>self</code> with the dimensions reversed.</p>
<h2 id="see-also_8">See Also<a class="headerlink" href="#see-also_8" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.transpose : NumPy's implementation of 'transpose'
for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">trunc</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise trunc.</p>
<p>See numpy.trunc for more information.</p>
<p>Attribute dtype: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute dtype: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute shape: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute shape: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute ndim: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute ndim: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute nnz: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute nnz: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute data: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute data: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute indices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute indices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute indptr: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indptr</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute indptr: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indptr_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute blocksize: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">blocksize</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute blocksize: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">blocksize_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute has_sorted_indices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">has_sorted_indices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute has_sorted_indices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">has_sorted_indices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Coo_matrix</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Coo_matrix</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArrayLike</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Coo_matrix</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">arg1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>A sparse matrix in COOrdinate format.</p>
<p>Also known as the 'ijv' or 'triplet' format.</p>
<p>This can be instantiated in several ways:
coo_matrix(D)
with a dense matrix D</p>
<p>coo_matrix(S)
with another sparse matrix S (equivalent to S.tocoo())</p>
<p>coo_matrix((M, N), [dtype])
to construct an empty matrix with shape (M, N)
dtype is optional, defaulting to dtype='d'.</p>
<p>coo_matrix((data, (i, j)), [shape=(M, N)])
to construct from three arrays:
1. data[:]   the entries of the matrix, in any order
2. i[:]      the row indices of the matrix entries
3. j[:]      the column indices of the matrix entries</p>
<p>Where <code>A[i[k], j[k]] = data[k]</code>.  When shape is not
specified, it is inferred from the index arrays</p>
<h2 id="attributes_1">Attributes<a class="headerlink" href="#attributes_1" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Data type of the matrix
shape : 2-tuple
Shape of the matrix
ndim : int
Number of dimensions (this is always 2)
nnz
Number of stored values, including explicit zeros
data
COO format data array of the matrix
row
COO format row index array of the matrix
col
COO format column index array of the matrix</p>
<h2 id="notes_2">Notes<a class="headerlink" href="#notes_2" title="Permanent link">&para;</a></h2>
<p>Sparse matrices can be used in arithmetic operations: they support
addition, subtraction, multiplication, division, and matrix power.</p>
<p>Advantages of the COO format
- facilitates fast conversion among sparse formats
- permits duplicate entries (see example)
- very fast conversion to and from CSR/CSC formats</p>
<p>Disadvantages of the COO format
- does not directly support:
+ arithmetic operations
+ slicing</p>
<p>Intended Usage
- COO is a fast format for constructing sparse matrices
- Once a matrix has been constructed, convert to CSR or
CSC format for fast arithmetic and matrix vector operations
- By default when converting to CSR or CSC format, duplicate (i,j)
entries will be summed together.  This facilitates efficient
construction of finite element matrices and the like. (see example)</p>
<h2 id="examples_4">Examples<a class="headerlink" href="#examples_4" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<h1 id="constructing-an-empty-matrix">Constructing an empty matrix<a class="headerlink" href="#constructing-an-empty-matrix" title="Permanent link">&para;</a></h1>
<p>from scipy.sparse import coo_matrix
coo_matrix((3, 4), dtype=np.int8).toarray()
array([[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]], dtype=int8)</p>
<h1 id="constructing-a-matrix-using-ijv-format">Constructing a matrix using ijv format<a class="headerlink" href="#constructing-a-matrix-using-ijv-format" title="Permanent link">&para;</a></h1>
<p>row  = np.array([0, 3, 1, 0])
col  = np.array([0, 3, 1, 2])
data = np.array([4, 5, 7, 9])
coo_matrix((data, (row, col)), shape=(4, 4)).toarray()
array([[4, 0, 9, 0],
[0, 7, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 5]])</p>
<h1 id="constructing-a-matrix-with-duplicate-indices">Constructing a matrix with duplicate indices<a class="headerlink" href="#constructing-a-matrix-with-duplicate-indices" title="Permanent link">&para;</a></h1>
<p>row  = np.array([0, 0, 1, 3, 1, 0, 0])
col  = np.array([0, 2, 1, 3, 1, 0, 0])
data = np.array([1, 1, 1, 1, 1, 1, 1])
coo = coo_matrix((data, (row, col)), shape=(4, 4))</p>
<h1 id="duplicate-indices-are-maintained-until-implicitly-or-explicitly-summed">Duplicate indices are maintained until implicitly or explicitly summed<a class="headerlink" href="#duplicate-indices-are-maintained-until-implicitly-or-explicitly-summed" title="Permanent link">&para;</a></h1>
<p>np.max(coo.data)
1
coo.toarray()
array([[3, 0, 1, 0],
[0, 2, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arcsin</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arcsin.</p>
<p>See numpy.arcsin for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arcsinh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arcsinh.</p>
<p>See numpy.arcsinh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arctan</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arctan.</p>
<p>See numpy.arctan for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arctanh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arctanh.</p>
<p>See numpy.arctanh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argmax</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return indices of maximum elements along an axis.</p>
<p>Implicit zero elements are also taken into account. If there are
several maximum values, the index of the first occurrence is returned.</p>
<h2 id="parameters_19">Parameters<a class="headerlink" href="#parameters_19" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None}, optional
Axis along which the argmax is computed. If None (default), index
of the maximum element in the flatten data is returned.
out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except for
the default value, as this argument is not used.</p>
<h2 id="returns_13">Returns<a class="headerlink" href="#returns_13" title="Permanent link">&para;</a></h2>
<p>ind : numpy.matrix or int
Indices of maximum elements. If matrix, its size along <code>axis</code> is 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argmin</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return indices of minimum elements along an axis.</p>
<p>Implicit zero elements are also taken into account. If there are
several minimum values, the index of the first occurrence is returned.</p>
<h2 id="parameters_20">Parameters<a class="headerlink" href="#parameters_20" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None}, optional
Axis along which the argmin is computed. If None (default), index
of the minimum element in the flatten data is returned.
out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except for
the default value, as this argument is not used.</p>
<h2 id="returns_14">Returns<a class="headerlink" href="#returns_14" title="Permanent link">&para;</a></h2>
<p>ind : numpy.matrix or int
Indices of minimum elements. If matrix, its size along <code>axis</code> is 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asformat</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">format</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return this matrix in the passed format.</p>
<h2 id="parameters_21">Parameters<a class="headerlink" href="#parameters_21" title="Permanent link">&para;</a></h2>
<p>format : {str, None}
The desired matrix format ('csr', 'csc', 'lil', 'dok', 'array', ...)
or None for no conversion.
copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_15">Returns<a class="headerlink" href="#returns_15" title="Permanent link">&para;</a></h2>
<p>A : This matrix in the passed format.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asfptype</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Upcast matrix to a floating point format (if necessary)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">astype</span> <span class="o">:</span> <span class="o">?</span><span class="n">casting</span><span class="o">:[`</span><span class="nc">No</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Equiv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Safe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same_kind</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Unsafe</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cast the matrix elements to a specified type.</p>
<h2 id="parameters_22">Parameters<a class="headerlink" href="#parameters_22" title="Permanent link">&para;</a></h2>
<p>dtype : string or numpy dtype
Typecode or data-type to which to cast the data.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
Controls what kind of data casting may occur.
Defaults to 'unsafe' for backwards compatibility.
'no' means the data types should not be cast at all.
'equiv' means only byte-order changes are allowed.
'safe' means only casts which can preserve values are allowed.
'same_kind' means only safe casts or casts within a kind,
like float64 to float32, are allowed.
'unsafe' means any data conversions may be done.
copy : bool, optional
If <code>copy</code> is <code>False</code>, the result might share some memory with this
matrix. If <code>copy</code> is <code>True</code>, it is guaranteed that the result and
this matrix do not share any memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ceil</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise ceil.</p>
<p>See numpy.ceil for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conj</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_23">Parameters<a class="headerlink" href="#parameters_23" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_16">Returns<a class="headerlink" href="#returns_16" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjugate</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_24">Parameters<a class="headerlink" href="#parameters_24" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_17">Returns<a class="headerlink" href="#returns_17" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">copy</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of this matrix.</p>
<p>No data/indices will be shared between the returned value and current
matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count_nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of non-zero entries, equivalent to</p>
<p>np.count_nonzero(a.toarray())</p>
<p>Unlike getnnz() and the nnz property, which return the number of stored
entries (the length of the data attribute), this method counts the
actual number of non-zero entries in data.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">deg2rad</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise deg2rad.</p>
<p>See numpy.deg2rad for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the k-th diagonal of the matrix.</p>
<h2 id="parameters_25">Parameters<a class="headerlink" href="#parameters_25" title="Permanent link">&para;</a></h2>
<p>k : int, optional
Which diagonal to get, corresponding to elements a[i, i+k].
Default: 0 (the main diagonal).</p>
<p>.. versionadded:: 1.0</p>
<h2 id="see-also_9">See also<a class="headerlink" href="#see-also_9" title="Permanent link">&para;</a></h2>
<p>numpy.diagonal : Equivalent numpy function.</p>
<h2 id="examples_5">Examples<a class="headerlink" href="#examples_5" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
A.diagonal()
array([1, 0, 5])
A.diagonal(k=1)
array([2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Ordinary dot product</p>
<h2 id="examples_6">Examples<a class="headerlink" href="#examples_6" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
v = np.array([1, 0, -1])
A.dot(v)
array([ 1, -3, -1], dtype=int64)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eliminate_zeros</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Remove zero entries from the matrix</p>
<p>This is an <em>in place</em> operation</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm1</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise expm1.</p>
<p>See numpy.expm1 for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">floor</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise floor.</p>
<p>See numpy.floor for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getH</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Hermitian transpose of this matrix.</p>
<h2 id="see-also_10">See Also<a class="headerlink" href="#see-also_10" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.getH : NumPy's implementation of <code>getH</code> for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_shape</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get shape of a matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getcol</span> <span class="o">:</span> <span class="n">j</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of column j of the matrix, as an (m x 1) sparse
matrix (column vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getformat</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Format of a matrix representation as a string.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getmaxprint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Maximum number of elements to display when printed.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getnnz</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of stored values, including explicit zeros.</p>
<h2 id="parameters_26">Parameters<a class="headerlink" href="#parameters_26" title="Permanent link">&para;</a></h2>
<p>axis : None, 0, or 1
Select between the number of values across the whole matrix, in
each column, or in each row.</p>
<h2 id="see-also_11">See also<a class="headerlink" href="#see-also_11" title="Permanent link">&para;</a></h2>
<p>count_nonzero : Number of non-zero entries</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getrow</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of row i of the matrix, as a (1 x n) sparse
matrix (row vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">log1p</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise log1p.</p>
<p>See numpy.log1p for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">max</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the maximum of the matrix or maximum along an axis.
This takes all elements into account, not just the non-zero ones.</p>
<h2 id="parameters_27">Parameters<a class="headerlink" href="#parameters_27" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the maximum over all the matrix elements, returning
a scalar (i.e. <code>axis</code> = <code>None</code>).</p>
<p>out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except
for the default value, as this argument is not used.</p>
<h2 id="returns_18">Returns<a class="headerlink" href="#returns_18" title="Permanent link">&para;</a></h2>
<p>amax : coo_matrix or scalar
Maximum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.
If <code>axis</code> is given, the result is a sparse.coo_matrix of dimension
<code>a.ndim - 1</code>.</p>
<h2 id="see-also_12">See Also<a class="headerlink" href="#see-also_12" title="Permanent link">&para;</a></h2>
<p>min : The minimum value of a sparse matrix along a given axis.
numpy.matrix.max : NumPy's implementation of 'max' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise maximum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the matrix elements. The average is taken
over all elements in the matrix by default, otherwise over the
specified axis. <code>float64</code> intermediate and return values are used
for integer inputs.</p>
<h2 id="parameters_28">Parameters<a class="headerlink" href="#parameters_28" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the mean is computed. The default is to compute
the mean of all elements in the matrix (i.e. <code>axis</code> = <code>None</code>).
dtype : data-type, optional
Type to use in computing the mean. For integer inputs, the default
is <code>float64</code>; for floating point inputs, it is the same as the
input dtype.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_19">Returns<a class="headerlink" href="#returns_19" title="Permanent link">&para;</a></h2>
<p>m : np.matrix</p>
<h2 id="see-also_13">See Also<a class="headerlink" href="#see-also_13" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.mean : NumPy's implementation of 'mean' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">min</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the minimum of the matrix or maximum along an axis.
This takes all elements into account, not just the non-zero ones.</p>
<h2 id="parameters_29">Parameters<a class="headerlink" href="#parameters_29" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the minimum over all the matrix elements, returning
a scalar (i.e. <code>axis</code> = <code>None</code>).</p>
<p>out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except for
the default value, as this argument is not used.</p>
<h2 id="returns_20">Returns<a class="headerlink" href="#returns_20" title="Permanent link">&para;</a></h2>
<p>amin : coo_matrix or scalar
Minimum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.
If <code>axis</code> is given, the result is a sparse.coo_matrix of dimension
<code>a.ndim - 1</code>.</p>
<h2 id="see-also_14">See Also<a class="headerlink" href="#see-also_14" title="Permanent link">&para;</a></h2>
<p>max : The maximum value of a sparse matrix along a given axis.
numpy.matrix.min : NumPy's implementation of 'min' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise minimum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">multiply</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Point-wise multiplication by another matrix</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nonzero indices</p>
<p>Returns a tuple of arrays (row,col) containing the indices
of the non-zero elements of the matrix.</p>
<h2 id="examples_7">Examples<a class="headerlink" href="#examples_7" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])
A.nonzero()
(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">power</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>This function performs element-wise power.</p>
<h2 id="parameters_30">Parameters<a class="headerlink" href="#parameters_30" title="Permanent link">&para;</a></h2>
<p>n : n is a scalar</p>
<p>dtype : If dtype is not specified, the current dtype will be preserved.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rad2deg</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise rad2deg.</p>
<p>See numpy.rad2deg for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>reshape(self, shape, order='C', copy=False)</p>
<p>Gives a new shape to a sparse matrix without changing its data.</p>
<h2 id="parameters_31">Parameters<a class="headerlink" href="#parameters_31" title="Permanent link">&para;</a></h2>
<p>shape : length-2 tuple of ints
The new shape should be compatible with the original shape.
order : {'C', 'F'}, optional
Read the elements using this index order. 'C' means to read and
write the elements using C-like index order; e.g. read entire first
row, then second row, etc. 'F' means to read and write the elements
using Fortran-like index order; e.g. read entire first column, then
second column, etc.
copy : bool, optional
Indicates whether or not attributes of self should be copied
whenever possible. The degree to which attributes are copied varies
depending on the type of sparse matrix being used.</p>
<h2 id="returns_21">Returns<a class="headerlink" href="#returns_21" title="Permanent link">&para;</a></h2>
<p>reshaped_matrix : sparse matrix
A sparse matrix with the given <code>shape</code>, not necessarily of the same
format as the current object.</p>
<h2 id="see-also_15">See Also<a class="headerlink" href="#see-also_15" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.reshape : NumPy's implementation of 'reshape' for
matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resize</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Resize the matrix in-place to dimensions given by <code>shape</code></p>
<p>Any elements that lie within the new shape will remain at the same
indices, while non-zero elements lying outside the new shape are
removed.</p>
<h2 id="parameters_32">Parameters<a class="headerlink" href="#parameters_32" title="Permanent link">&para;</a></h2>
<p>shape : (int, int)
number of rows and columns in the new matrix</p>
<h2 id="notes_3">Notes<a class="headerlink" href="#notes_3" title="Permanent link">&para;</a></h2>
<p>The semantics are not identical to <code>numpy.ndarray.resize</code> or
<code>numpy.resize</code>.  Here, the same data will be maintained at each index
before and after reshape, if that index is within the new bounds.  In
numpy, resizing maintains contiguity of the array, moving elements
around in the logical matrix but not within a flattened representation.</p>
<p>We give no guarantees about whether the underlying data attributes
(arrays, etc.) will be modified in place or replaced with new objects.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise rint.</p>
<p>See numpy.rint for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_shape</span> <span class="o">:</span> <span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>See <code>reshape</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setdiag</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">values</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Set diagonal or off-diagonal elements of the array.</p>
<h2 id="parameters_33">Parameters<a class="headerlink" href="#parameters_33" title="Permanent link">&para;</a></h2>
<p>values : array_like
New values of the diagonal elements.</p>
<p>Values may have any length.  If the diagonal is longer than values,
then the remaining diagonal entries will not be set.  If values if
longer than the diagonal, then the remaining values are ignored.</p>
<p>If a scalar value is given, all of the diagonal is set to it.</p>
<p>k : int, optional
Which off-diagonal to set, corresponding to elements a[i,i+k].
Default: 0 (the main diagonal).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sign</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sign.</p>
<p>See numpy.sign for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sin</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sin.</p>
<p>See numpy.sin for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sinh.</p>
<p>See numpy.sinh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrt</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sqrt.</p>
<p>See numpy.sqrt for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sum the matrix elements over a given axis.</p>
<h2 id="parameters_34">Parameters<a class="headerlink" href="#parameters_34" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the sum of all the matrix elements, returning a scalar
(i.e. <code>axis</code> = <code>None</code>).
dtype : dtype, optional
The type of the returned matrix and of the accumulator in which
the elements are summed.  The dtype of <code>a</code> is used by default
unless <code>a</code> has an integer dtype of less precision than the default
platform integer.  In that case, if <code>a</code> is signed then the platform
integer is used while if <code>a</code> is unsigned then an unsigned integer
of the same precision as the platform integer is used.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_22">Returns<a class="headerlink" href="#returns_22" title="Permanent link">&para;</a></h2>
<p>sum_along_axis : np.matrix
A matrix with the same shape as <code>self</code>, with the specified
axis removed.</p>
<h2 id="see-also_16">See Also<a class="headerlink" href="#see-also_16" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.sum : NumPy's implementation of 'sum' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum_duplicates</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Eliminate duplicate matrix entries by adding them together</p>
<p>This is an <em>in place</em> operation</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tan</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise tan.</p>
<p>See numpy.tan for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise tanh.</p>
<p>See numpy.tanh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>See the docstring for <code>spmatrix.toarray</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tobsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">blocksize</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Block Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant bsr_matrix.</p>
<p>When blocksize=(R, C) is provided, it will be used for construction of
the bsr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocoo</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to COOrdinate format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant coo_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsc</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Column format</p>
<p>Duplicate entries will be summed together.</p>
<h2 id="examples_8">Examples<a class="headerlink" href="#examples_8" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy import array
from scipy.sparse import coo_matrix
row  = array([0, 0, 1, 3, 1, 0, 0])
col  = array([0, 2, 1, 3, 1, 0, 0])
data = array([1, 1, 1, 1, 1, 1, 1])
A = coo_matrix((data, (row, col)), shape=(4, 4)).tocsc()
A.toarray()
array([[3, 0, 1, 0],
[0, 2, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Row format</p>
<p>Duplicate entries will be summed together.</p>
<h2 id="examples_9">Examples<a class="headerlink" href="#examples_9" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy import array
from scipy.sparse import coo_matrix
row  = array([0, 0, 1, 3, 1, 0, 0])
col  = array([0, 2, 1, 3, 1, 0, 0])
data = array([1, 1, 1, 1, 1, 1, 1])
A = coo_matrix((data, (row, col)), shape=(4, 4)).tocsr()
A.toarray()
array([[3, 0, 1, 0],
[0, 2, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense matrix representation of this matrix.</p>
<h2 id="parameters_35">Parameters<a class="headerlink" href="#parameters_35" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array (or <code>numpy.matrix</code>) as the
output buffer instead of allocating a new array to
return. The provided array must have the same shape and
dtype as the sparse matrix on which you are calling the
method.</p>
<h2 id="returns_23">Returns<a class="headerlink" href="#returns_23" title="Permanent link">&para;</a></h2>
<p>arr : numpy.matrix, 2-dimensional
A NumPy matrix object with the same shape and containing
the same data represented by the sparse matrix, with the
requested memory order. If <code>out</code> was passed and was an
array (rather than a <code>numpy.matrix</code>), it will be filled
with the appropriate values and returned wrapped in a
<code>numpy.matrix</code> object that shares the same memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todia</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to sparse DIAgonal format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dia_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todok</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Dictionary Of Keys format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dok_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tolil</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to List of Lists format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant lil_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reverses the dimensions of the sparse matrix.</p>
<h2 id="parameters_36">Parameters<a class="headerlink" href="#parameters_36" title="Permanent link">&para;</a></h2>
<p>axes : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except
for the default value.
copy : bool, optional
Indicates whether or not attributes of <code>self</code> should be
copied whenever possible. The degree to which attributes
are copied varies depending on the type of sparse matrix
being used.</p>
<h2 id="returns_24">Returns<a class="headerlink" href="#returns_24" title="Permanent link">&para;</a></h2>
<p>p : <code>self</code> with the dimensions reversed.</p>
<h2 id="see-also_17">See Also<a class="headerlink" href="#see-also_17" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.transpose : NumPy's implementation of 'transpose'
for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">trunc</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise trunc.</p>
<p>See numpy.trunc for more information.</p>
<p>Attribute dtype: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute dtype: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute shape: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute shape: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute ndim: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute ndim: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute nnz: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute nnz: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute data: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute data: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute row: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">row</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute row: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">row_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute col: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">col</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute col: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">col_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Csc_matrix</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Csc_matrix</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArrayLike</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Csc_matrix</span> <span class="o">|</span> <span class="o">`</span><span class="nc">IndexMixin</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_index</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">IndexMixin</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">arg1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Compressed Sparse Column matrix</p>
<p>This can be instantiated in several ways:</p>
<p>csc_matrix(D)
with a dense matrix or rank-2 ndarray D</p>
<p>csc_matrix(S)
with another sparse matrix S (equivalent to S.tocsc())</p>
<p>csc_matrix((M, N), [dtype])
to construct an empty matrix with shape (M, N)
dtype is optional, defaulting to dtype='d'.</p>
<p>csc_matrix((data, (row_ind, col_ind)), [shape=(M, N)])
where <code>data</code>, <code>row_ind</code> and <code>col_ind</code> satisfy the
relationship <code>a[row_ind[k], col_ind[k]] = data[k]</code>.</p>
<p>csc_matrix((data, indices, indptr), [shape=(M, N)])
is the standard CSC representation where the row indices for
column i are stored in <code>indices[indptr[i]:indptr[i+1]]</code>
and their corresponding values are stored in
<code>data[indptr[i]:indptr[i+1]]</code>.  If the shape parameter is
not supplied, the matrix dimensions are inferred from
the index arrays.</p>
<h2 id="attributes_2">Attributes<a class="headerlink" href="#attributes_2" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Data type of the matrix
shape : 2-tuple
Shape of the matrix
ndim : int
Number of dimensions (this is always 2)
nnz
Number of stored values, including explicit zeros
data
Data array of the matrix
indices
CSC format index array
indptr
CSC format index pointer array
has_sorted_indices
Whether indices are sorted</p>
<h2 id="notes_4">Notes<a class="headerlink" href="#notes_4" title="Permanent link">&para;</a></h2>
<p>Sparse matrices can be used in arithmetic operations: they support
addition, subtraction, multiplication, division, and matrix power.</p>
<p>Advantages of the CSC format
- efficient arithmetic operations CSC + CSC, CSC * CSC, etc.
- efficient column slicing
- fast matrix vector products (CSR, BSR may be faster)</p>
<p>Disadvantages of the CSC format
- slow row slicing operations (consider CSR)
- changes to the sparsity structure are expensive (consider LIL or DOK)</p>
<h2 id="examples_10">Examples<a class="headerlink" href="#examples_10" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import csc_matrix
csc_matrix((3, 4), dtype=np.int8).toarray()
array([[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]], dtype=int8)</p>
<p>row = np.array([0, 2, 2, 0, 1, 2])
col = np.array([0, 0, 1, 2, 2, 2])
data = np.array([1, 2, 3, 4, 5, 6])
csc_matrix((data, (row, col)), shape=(3, 3)).toarray()
array([[1, 0, 4],
[0, 0, 5],
[2, 3, 6]])</p>
<p>indptr = np.array([0, 2, 3, 6])
indices = np.array([0, 2, 2, 0, 1, 2])
data = np.array([1, 2, 3, 4, 5, 6])
csc_matrix((data, indices, indptr), shape=(3, 3)).toarray()
array([[1, 0, 4],
[0, 0, 5],
[2, 3, 6]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">setitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arcsin</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arcsin.</p>
<p>See numpy.arcsin for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arcsinh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arcsinh.</p>
<p>See numpy.arcsinh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arctan</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arctan.</p>
<p>See numpy.arctan for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arctanh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arctanh.</p>
<p>See numpy.arctanh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argmax</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return indices of maximum elements along an axis.</p>
<p>Implicit zero elements are also taken into account. If there are
several maximum values, the index of the first occurrence is returned.</p>
<h2 id="parameters_37">Parameters<a class="headerlink" href="#parameters_37" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None}, optional
Axis along which the argmax is computed. If None (default), index
of the maximum element in the flatten data is returned.
out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except for
the default value, as this argument is not used.</p>
<h2 id="returns_25">Returns<a class="headerlink" href="#returns_25" title="Permanent link">&para;</a></h2>
<p>ind : numpy.matrix or int
Indices of maximum elements. If matrix, its size along <code>axis</code> is 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argmin</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return indices of minimum elements along an axis.</p>
<p>Implicit zero elements are also taken into account. If there are
several minimum values, the index of the first occurrence is returned.</p>
<h2 id="parameters_38">Parameters<a class="headerlink" href="#parameters_38" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None}, optional
Axis along which the argmin is computed. If None (default), index
of the minimum element in the flatten data is returned.
out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except for
the default value, as this argument is not used.</p>
<h2 id="returns_26">Returns<a class="headerlink" href="#returns_26" title="Permanent link">&para;</a></h2>
<p>ind : numpy.matrix or int
Indices of minimum elements. If matrix, its size along <code>axis</code> is 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asformat</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">format</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return this matrix in the passed format.</p>
<h2 id="parameters_39">Parameters<a class="headerlink" href="#parameters_39" title="Permanent link">&para;</a></h2>
<p>format : {str, None}
The desired matrix format ('csr', 'csc', 'lil', 'dok', 'array', ...)
or None for no conversion.
copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_27">Returns<a class="headerlink" href="#returns_27" title="Permanent link">&para;</a></h2>
<p>A : This matrix in the passed format.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asfptype</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Upcast matrix to a floating point format (if necessary)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">astype</span> <span class="o">:</span> <span class="o">?</span><span class="n">casting</span><span class="o">:[`</span><span class="nc">No</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Equiv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Safe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same_kind</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Unsafe</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cast the matrix elements to a specified type.</p>
<h2 id="parameters_40">Parameters<a class="headerlink" href="#parameters_40" title="Permanent link">&para;</a></h2>
<p>dtype : string or numpy dtype
Typecode or data-type to which to cast the data.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
Controls what kind of data casting may occur.
Defaults to 'unsafe' for backwards compatibility.
'no' means the data types should not be cast at all.
'equiv' means only byte-order changes are allowed.
'safe' means only casts which can preserve values are allowed.
'same_kind' means only safe casts or casts within a kind,
like float64 to float32, are allowed.
'unsafe' means any data conversions may be done.
copy : bool, optional
If <code>copy</code> is <code>False</code>, the result might share some memory with this
matrix. If <code>copy</code> is <code>True</code>, it is guaranteed that the result and
this matrix do not share any memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ceil</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise ceil.</p>
<p>See numpy.ceil for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_format</span> <span class="o">:</span> <span class="o">?</span><span class="n">full_check</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>check whether the matrix format is valid</p>
<h2 id="parameters_41">Parameters<a class="headerlink" href="#parameters_41" title="Permanent link">&para;</a></h2>
<p>full_check : bool, optional
If <code>True</code>, rigorous check, O(N) operations. Otherwise
basic check, O(1) operations (default True).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conj</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_42">Parameters<a class="headerlink" href="#parameters_42" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_28">Returns<a class="headerlink" href="#returns_28" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjugate</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_43">Parameters<a class="headerlink" href="#parameters_43" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_29">Returns<a class="headerlink" href="#returns_29" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">copy</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of this matrix.</p>
<p>No data/indices will be shared between the returned value and current
matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count_nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of non-zero entries, equivalent to</p>
<p>np.count_nonzero(a.toarray())</p>
<p>Unlike getnnz() and the nnz property, which return the number of stored
entries (the length of the data attribute), this method counts the
actual number of non-zero entries in data.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">deg2rad</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise deg2rad.</p>
<p>See numpy.deg2rad for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the k-th diagonal of the matrix.</p>
<h2 id="parameters_44">Parameters<a class="headerlink" href="#parameters_44" title="Permanent link">&para;</a></h2>
<p>k : int, optional
Which diagonal to get, corresponding to elements a[i, i+k].
Default: 0 (the main diagonal).</p>
<p>.. versionadded:: 1.0</p>
<h2 id="see-also_18">See also<a class="headerlink" href="#see-also_18" title="Permanent link">&para;</a></h2>
<p>numpy.diagonal : Equivalent numpy function.</p>
<h2 id="examples_11">Examples<a class="headerlink" href="#examples_11" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
A.diagonal()
array([1, 0, 5])
A.diagonal(k=1)
array([2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Ordinary dot product</p>
<h2 id="examples_12">Examples<a class="headerlink" href="#examples_12" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
v = np.array([1, 0, -1])
A.dot(v)
array([ 1, -3, -1], dtype=int64)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eliminate_zeros</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Remove zero entries from the matrix</p>
<p>This is an <em>in place</em> operation</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm1</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise expm1.</p>
<p>See numpy.expm1 for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">floor</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise floor.</p>
<p>See numpy.floor for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getH</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Hermitian transpose of this matrix.</p>
<h2 id="see-also_19">See Also<a class="headerlink" href="#see-also_19" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.getH : NumPy's implementation of <code>getH</code> for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_shape</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get shape of a matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getcol</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of column i of the matrix, as a (m x 1)
CSC matrix (column vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getformat</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Format of a matrix representation as a string.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getmaxprint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Maximum number of elements to display when printed.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getnnz</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of stored values, including explicit zeros.</p>
<h2 id="parameters_45">Parameters<a class="headerlink" href="#parameters_45" title="Permanent link">&para;</a></h2>
<p>axis : None, 0, or 1
Select between the number of values across the whole matrix, in
each column, or in each row.</p>
<h2 id="see-also_20">See also<a class="headerlink" href="#see-also_20" title="Permanent link">&para;</a></h2>
<p>count_nonzero : Number of non-zero entries</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getrow</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of row i of the matrix, as a (1 x n)
CSR matrix (row vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">log1p</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise log1p.</p>
<p>See numpy.log1p for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">max</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the maximum of the matrix or maximum along an axis.
This takes all elements into account, not just the non-zero ones.</p>
<h2 id="parameters_46">Parameters<a class="headerlink" href="#parameters_46" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the maximum over all the matrix elements, returning
a scalar (i.e. <code>axis</code> = <code>None</code>).</p>
<p>out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except
for the default value, as this argument is not used.</p>
<h2 id="returns_30">Returns<a class="headerlink" href="#returns_30" title="Permanent link">&para;</a></h2>
<p>amax : coo_matrix or scalar
Maximum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.
If <code>axis</code> is given, the result is a sparse.coo_matrix of dimension
<code>a.ndim - 1</code>.</p>
<h2 id="see-also_21">See Also<a class="headerlink" href="#see-also_21" title="Permanent link">&para;</a></h2>
<p>min : The minimum value of a sparse matrix along a given axis.
numpy.matrix.max : NumPy's implementation of 'max' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise maximum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the matrix elements. The average is taken
over all elements in the matrix by default, otherwise over the
specified axis. <code>float64</code> intermediate and return values are used
for integer inputs.</p>
<h2 id="parameters_47">Parameters<a class="headerlink" href="#parameters_47" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the mean is computed. The default is to compute
the mean of all elements in the matrix (i.e. <code>axis</code> = <code>None</code>).
dtype : data-type, optional
Type to use in computing the mean. For integer inputs, the default
is <code>float64</code>; for floating point inputs, it is the same as the
input dtype.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_31">Returns<a class="headerlink" href="#returns_31" title="Permanent link">&para;</a></h2>
<p>m : np.matrix</p>
<h2 id="see-also_22">See Also<a class="headerlink" href="#see-also_22" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.mean : NumPy's implementation of 'mean' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">min</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the minimum of the matrix or maximum along an axis.
This takes all elements into account, not just the non-zero ones.</p>
<h2 id="parameters_48">Parameters<a class="headerlink" href="#parameters_48" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the minimum over all the matrix elements, returning
a scalar (i.e. <code>axis</code> = <code>None</code>).</p>
<p>out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except for
the default value, as this argument is not used.</p>
<h2 id="returns_32">Returns<a class="headerlink" href="#returns_32" title="Permanent link">&para;</a></h2>
<p>amin : coo_matrix or scalar
Minimum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.
If <code>axis</code> is given, the result is a sparse.coo_matrix of dimension
<code>a.ndim - 1</code>.</p>
<h2 id="see-also_23">See Also<a class="headerlink" href="#see-also_23" title="Permanent link">&para;</a></h2>
<p>max : The maximum value of a sparse matrix along a given axis.
numpy.matrix.min : NumPy's implementation of 'min' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise minimum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">multiply</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Point-wise multiplication by another matrix, vector, or
scalar.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nonzero indices</p>
<p>Returns a tuple of arrays (row,col) containing the indices
of the non-zero elements of the matrix.</p>
<h2 id="examples_13">Examples<a class="headerlink" href="#examples_13" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])
A.nonzero()
(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">power</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>This function performs element-wise power.</p>
<h2 id="parameters_49">Parameters<a class="headerlink" href="#parameters_49" title="Permanent link">&para;</a></h2>
<p>n : n is a scalar</p>
<p>dtype : If dtype is not specified, the current dtype will be preserved.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">prune</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Remove empty space after all non-zero elements.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rad2deg</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise rad2deg.</p>
<p>See numpy.rad2deg for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>reshape(self, shape, order='C', copy=False)</p>
<p>Gives a new shape to a sparse matrix without changing its data.</p>
<h2 id="parameters_50">Parameters<a class="headerlink" href="#parameters_50" title="Permanent link">&para;</a></h2>
<p>shape : length-2 tuple of ints
The new shape should be compatible with the original shape.
order : {'C', 'F'}, optional
Read the elements using this index order. 'C' means to read and
write the elements using C-like index order; e.g. read entire first
row, then second row, etc. 'F' means to read and write the elements
using Fortran-like index order; e.g. read entire first column, then
second column, etc.
copy : bool, optional
Indicates whether or not attributes of self should be copied
whenever possible. The degree to which attributes are copied varies
depending on the type of sparse matrix being used.</p>
<h2 id="returns_33">Returns<a class="headerlink" href="#returns_33" title="Permanent link">&para;</a></h2>
<p>reshaped_matrix : sparse matrix
A sparse matrix with the given <code>shape</code>, not necessarily of the same
format as the current object.</p>
<h2 id="see-also_24">See Also<a class="headerlink" href="#see-also_24" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.reshape : NumPy's implementation of 'reshape' for
matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resize</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Resize the matrix in-place to dimensions given by <code>shape</code></p>
<p>Any elements that lie within the new shape will remain at the same
indices, while non-zero elements lying outside the new shape are
removed.</p>
<h2 id="parameters_51">Parameters<a class="headerlink" href="#parameters_51" title="Permanent link">&para;</a></h2>
<p>shape : (int, int)
number of rows and columns in the new matrix</p>
<h2 id="notes_5">Notes<a class="headerlink" href="#notes_5" title="Permanent link">&para;</a></h2>
<p>The semantics are not identical to <code>numpy.ndarray.resize</code> or
<code>numpy.resize</code>.  Here, the same data will be maintained at each index
before and after reshape, if that index is within the new bounds.  In
numpy, resizing maintains contiguity of the array, moving elements
around in the logical matrix but not within a flattened representation.</p>
<p>We give no guarantees about whether the underlying data attributes
(arrays, etc.) will be modified in place or replaced with new objects.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise rint.</p>
<p>See numpy.rint for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_shape</span> <span class="o">:</span> <span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>See <code>reshape</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setdiag</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">values</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Set diagonal or off-diagonal elements of the array.</p>
<h2 id="parameters_52">Parameters<a class="headerlink" href="#parameters_52" title="Permanent link">&para;</a></h2>
<p>values : array_like
New values of the diagonal elements.</p>
<p>Values may have any length.  If the diagonal is longer than values,
then the remaining diagonal entries will not be set.  If values if
longer than the diagonal, then the remaining values are ignored.</p>
<p>If a scalar value is given, all of the diagonal is set to it.</p>
<p>k : int, optional
Which off-diagonal to set, corresponding to elements a[i,i+k].
Default: 0 (the main diagonal).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sign</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sign.</p>
<p>See numpy.sign for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sin</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sin.</p>
<p>See numpy.sin for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sinh.</p>
<p>See numpy.sinh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sort_indices</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sort the indices of this matrix <em>in place</em></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sorted_indices</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of this matrix with sorted indices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrt</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sqrt.</p>
<p>See numpy.sqrt for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sum the matrix elements over a given axis.</p>
<h2 id="parameters_53">Parameters<a class="headerlink" href="#parameters_53" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the sum of all the matrix elements, returning a scalar
(i.e. <code>axis</code> = <code>None</code>).
dtype : dtype, optional
The type of the returned matrix and of the accumulator in which
the elements are summed.  The dtype of <code>a</code> is used by default
unless <code>a</code> has an integer dtype of less precision than the default
platform integer.  In that case, if <code>a</code> is signed then the platform
integer is used while if <code>a</code> is unsigned then an unsigned integer
of the same precision as the platform integer is used.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_34">Returns<a class="headerlink" href="#returns_34" title="Permanent link">&para;</a></h2>
<p>sum_along_axis : np.matrix
A matrix with the same shape as <code>self</code>, with the specified
axis removed.</p>
<h2 id="see-also_25">See Also<a class="headerlink" href="#see-also_25" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.sum : NumPy's implementation of 'sum' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum_duplicates</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Eliminate duplicate matrix entries by adding them together</p>
<p>The is an <em>in place</em> operation</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tan</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise tan.</p>
<p>See numpy.tan for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise tanh.</p>
<p>See numpy.tanh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense ndarray representation of this matrix.</p>
<h2 id="parameters_54">Parameters<a class="headerlink" href="#parameters_54" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array as the output buffer
instead of allocating a new array to return. The provided
array must have the same shape and dtype as the sparse
matrix on which you are calling the method. For most
sparse types, <code>out</code> is required to be memory contiguous
(either C or Fortran ordered).</p>
<h2 id="returns_35">Returns<a class="headerlink" href="#returns_35" title="Permanent link">&para;</a></h2>
<p>arr : ndarray, 2-dimensional
An array with the same shape and containing the same
data represented by the sparse matrix, with the requested
memory order. If <code>out</code> was passed, the same object is
returned after being modified in-place to contain the
appropriate values.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tobsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">blocksize</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Block Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant bsr_matrix.</p>
<p>When blocksize=(R, C) is provided, it will be used for construction of
the bsr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocoo</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to COOrdinate format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant coo_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsc</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Column format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csc_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense matrix representation of this matrix.</p>
<h2 id="parameters_55">Parameters<a class="headerlink" href="#parameters_55" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array (or <code>numpy.matrix</code>) as the
output buffer instead of allocating a new array to
return. The provided array must have the same shape and
dtype as the sparse matrix on which you are calling the
method.</p>
<h2 id="returns_36">Returns<a class="headerlink" href="#returns_36" title="Permanent link">&para;</a></h2>
<p>arr : numpy.matrix, 2-dimensional
A NumPy matrix object with the same shape and containing
the same data represented by the sparse matrix, with the
requested memory order. If <code>out</code> was passed and was an
array (rather than a <code>numpy.matrix</code>), it will be filled
with the appropriate values and returned wrapped in a
<code>numpy.matrix</code> object that shares the same memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todia</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to sparse DIAgonal format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dia_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todok</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Dictionary Of Keys format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dok_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tolil</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to List of Lists format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant lil_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reverses the dimensions of the sparse matrix.</p>
<h2 id="parameters_56">Parameters<a class="headerlink" href="#parameters_56" title="Permanent link">&para;</a></h2>
<p>axes : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except
for the default value.
copy : bool, optional
Indicates whether or not attributes of <code>self</code> should be
copied whenever possible. The degree to which attributes
are copied varies depending on the type of sparse matrix
being used.</p>
<h2 id="returns_37">Returns<a class="headerlink" href="#returns_37" title="Permanent link">&para;</a></h2>
<p>p : <code>self</code> with the dimensions reversed.</p>
<h2 id="see-also_26">See Also<a class="headerlink" href="#see-also_26" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.transpose : NumPy's implementation of 'transpose'
for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">trunc</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise trunc.</p>
<p>See numpy.trunc for more information.</p>
<p>Attribute dtype: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute dtype: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute shape: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute shape: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute ndim: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute ndim: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute nnz: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute nnz: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute data: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute data: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute indices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute indices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute indptr: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indptr</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute indptr: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indptr_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute has_sorted_indices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">has_sorted_indices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute has_sorted_indices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">has_sorted_indices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Csr_matrix</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Csr_matrix</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArrayLike</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Csr_matrix</span> <span class="o">|</span> <span class="o">`</span><span class="nc">IndexMixin</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_index</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">IndexMixin</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">arg1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Compressed Sparse Row matrix</p>
<p>This can be instantiated in several ways:
csr_matrix(D)
with a dense matrix or rank-2 ndarray D</p>
<p>csr_matrix(S)
with another sparse matrix S (equivalent to S.tocsr())</p>
<p>csr_matrix((M, N), [dtype])
to construct an empty matrix with shape (M, N)
dtype is optional, defaulting to dtype='d'.</p>
<p>csr_matrix((data, (row_ind, col_ind)), [shape=(M, N)])
where <code>data</code>, <code>row_ind</code> and <code>col_ind</code> satisfy the
relationship <code>a[row_ind[k], col_ind[k]] = data[k]</code>.</p>
<p>csr_matrix((data, indices, indptr), [shape=(M, N)])
is the standard CSR representation where the column indices for
row i are stored in <code>indices[indptr[i]:indptr[i+1]]</code> and their
corresponding values are stored in <code>data[indptr[i]:indptr[i+1]]</code>.
If the shape parameter is not supplied, the matrix dimensions
are inferred from the index arrays.</p>
<h2 id="attributes_3">Attributes<a class="headerlink" href="#attributes_3" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Data type of the matrix
shape : 2-tuple
Shape of the matrix
ndim : int
Number of dimensions (this is always 2)
nnz
Number of stored values, including explicit zeros
data
CSR format data array of the matrix
indices
CSR format index array of the matrix
indptr
CSR format index pointer array of the matrix
has_sorted_indices
Whether indices are sorted</p>
<h2 id="notes_6">Notes<a class="headerlink" href="#notes_6" title="Permanent link">&para;</a></h2>
<p>Sparse matrices can be used in arithmetic operations: they support
addition, subtraction, multiplication, division, and matrix power.</p>
<p>Advantages of the CSR format
- efficient arithmetic operations CSR + CSR, CSR * CSR, etc.
- efficient row slicing
- fast matrix vector products</p>
<p>Disadvantages of the CSR format
- slow column slicing operations (consider CSC)
- changes to the sparsity structure are expensive (consider LIL or DOK)</p>
<h2 id="examples_14">Examples<a class="headerlink" href="#examples_14" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import csr_matrix
csr_matrix((3, 4), dtype=np.int8).toarray()
array([[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]], dtype=int8)</p>
<p>row = np.array([0, 0, 1, 2, 2, 2])
col = np.array([0, 2, 2, 0, 1, 2])
data = np.array([1, 2, 3, 4, 5, 6])
csr_matrix((data, (row, col)), shape=(3, 3)).toarray()
array([[1, 0, 2],
[0, 0, 3],
[4, 5, 6]])</p>
<p>indptr = np.array([0, 2, 3, 6])
indices = np.array([0, 2, 2, 0, 1, 2])
data = np.array([1, 2, 3, 4, 5, 6])
csr_matrix((data, indices, indptr), shape=(3, 3)).toarray()
array([[1, 0, 2],
[0, 0, 3],
[4, 5, 6]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>As an example of how to construct a CSR matrix incrementally,
the following snippet builds a term-document matrix from texts:</p>
<blockquote>
<blockquote>
<blockquote>
<p>docs = [['hello', 'world', 'hello'], ['goodbye', 'cruel', 'world']]
indptr = [0]
indices = []
data = []
vocabulary = {}
for d in docs:
...     for term in d:
...         index = vocabulary.setdefault(term, len(vocabulary))
...         indices.append(index)
...         data.append(1)
...     indptr.append(len(indices))
...
csr_matrix((data, indices, indptr), dtype=int).toarray()
array([[2, 1, 0, 0],
[0, 1, 1, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">setitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arcsin</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arcsin.</p>
<p>See numpy.arcsin for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arcsinh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arcsinh.</p>
<p>See numpy.arcsinh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arctan</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arctan.</p>
<p>See numpy.arctan for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arctanh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arctanh.</p>
<p>See numpy.arctanh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argmax</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return indices of maximum elements along an axis.</p>
<p>Implicit zero elements are also taken into account. If there are
several maximum values, the index of the first occurrence is returned.</p>
<h2 id="parameters_57">Parameters<a class="headerlink" href="#parameters_57" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None}, optional
Axis along which the argmax is computed. If None (default), index
of the maximum element in the flatten data is returned.
out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except for
the default value, as this argument is not used.</p>
<h2 id="returns_38">Returns<a class="headerlink" href="#returns_38" title="Permanent link">&para;</a></h2>
<p>ind : numpy.matrix or int
Indices of maximum elements. If matrix, its size along <code>axis</code> is 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argmin</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return indices of minimum elements along an axis.</p>
<p>Implicit zero elements are also taken into account. If there are
several minimum values, the index of the first occurrence is returned.</p>
<h2 id="parameters_58">Parameters<a class="headerlink" href="#parameters_58" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None}, optional
Axis along which the argmin is computed. If None (default), index
of the minimum element in the flatten data is returned.
out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except for
the default value, as this argument is not used.</p>
<h2 id="returns_39">Returns<a class="headerlink" href="#returns_39" title="Permanent link">&para;</a></h2>
<p>ind : numpy.matrix or int
Indices of minimum elements. If matrix, its size along <code>axis</code> is 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asformat</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">format</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return this matrix in the passed format.</p>
<h2 id="parameters_59">Parameters<a class="headerlink" href="#parameters_59" title="Permanent link">&para;</a></h2>
<p>format : {str, None}
The desired matrix format ('csr', 'csc', 'lil', 'dok', 'array', ...)
or None for no conversion.
copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_40">Returns<a class="headerlink" href="#returns_40" title="Permanent link">&para;</a></h2>
<p>A : This matrix in the passed format.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asfptype</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Upcast matrix to a floating point format (if necessary)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">astype</span> <span class="o">:</span> <span class="o">?</span><span class="n">casting</span><span class="o">:[`</span><span class="nc">No</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Equiv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Safe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same_kind</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Unsafe</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cast the matrix elements to a specified type.</p>
<h2 id="parameters_60">Parameters<a class="headerlink" href="#parameters_60" title="Permanent link">&para;</a></h2>
<p>dtype : string or numpy dtype
Typecode or data-type to which to cast the data.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
Controls what kind of data casting may occur.
Defaults to 'unsafe' for backwards compatibility.
'no' means the data types should not be cast at all.
'equiv' means only byte-order changes are allowed.
'safe' means only casts which can preserve values are allowed.
'same_kind' means only safe casts or casts within a kind,
like float64 to float32, are allowed.
'unsafe' means any data conversions may be done.
copy : bool, optional
If <code>copy</code> is <code>False</code>, the result might share some memory with this
matrix. If <code>copy</code> is <code>True</code>, it is guaranteed that the result and
this matrix do not share any memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ceil</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise ceil.</p>
<p>See numpy.ceil for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_format</span> <span class="o">:</span> <span class="o">?</span><span class="n">full_check</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>check whether the matrix format is valid</p>
<h2 id="parameters_61">Parameters<a class="headerlink" href="#parameters_61" title="Permanent link">&para;</a></h2>
<p>full_check : bool, optional
If <code>True</code>, rigorous check, O(N) operations. Otherwise
basic check, O(1) operations (default True).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conj</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_62">Parameters<a class="headerlink" href="#parameters_62" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_41">Returns<a class="headerlink" href="#returns_41" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjugate</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_63">Parameters<a class="headerlink" href="#parameters_63" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_42">Returns<a class="headerlink" href="#returns_42" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">copy</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of this matrix.</p>
<p>No data/indices will be shared between the returned value and current
matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count_nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of non-zero entries, equivalent to</p>
<p>np.count_nonzero(a.toarray())</p>
<p>Unlike getnnz() and the nnz property, which return the number of stored
entries (the length of the data attribute), this method counts the
actual number of non-zero entries in data.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">deg2rad</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise deg2rad.</p>
<p>See numpy.deg2rad for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the k-th diagonal of the matrix.</p>
<h2 id="parameters_64">Parameters<a class="headerlink" href="#parameters_64" title="Permanent link">&para;</a></h2>
<p>k : int, optional
Which diagonal to get, corresponding to elements a[i, i+k].
Default: 0 (the main diagonal).</p>
<p>.. versionadded:: 1.0</p>
<h2 id="see-also_27">See also<a class="headerlink" href="#see-also_27" title="Permanent link">&para;</a></h2>
<p>numpy.diagonal : Equivalent numpy function.</p>
<h2 id="examples_15">Examples<a class="headerlink" href="#examples_15" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
A.diagonal()
array([1, 0, 5])
A.diagonal(k=1)
array([2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Ordinary dot product</p>
<h2 id="examples_16">Examples<a class="headerlink" href="#examples_16" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
v = np.array([1, 0, -1])
A.dot(v)
array([ 1, -3, -1], dtype=int64)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eliminate_zeros</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Remove zero entries from the matrix</p>
<p>This is an <em>in place</em> operation</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm1</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise expm1.</p>
<p>See numpy.expm1 for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">floor</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise floor.</p>
<p>See numpy.floor for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getH</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Hermitian transpose of this matrix.</p>
<h2 id="see-also_28">See Also<a class="headerlink" href="#see-also_28" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.getH : NumPy's implementation of <code>getH</code> for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_shape</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get shape of a matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getcol</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of column i of the matrix, as a (m x 1)
CSR matrix (column vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getformat</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Format of a matrix representation as a string.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getmaxprint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Maximum number of elements to display when printed.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getnnz</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of stored values, including explicit zeros.</p>
<h2 id="parameters_65">Parameters<a class="headerlink" href="#parameters_65" title="Permanent link">&para;</a></h2>
<p>axis : None, 0, or 1
Select between the number of values across the whole matrix, in
each column, or in each row.</p>
<h2 id="see-also_29">See also<a class="headerlink" href="#see-also_29" title="Permanent link">&para;</a></h2>
<p>count_nonzero : Number of non-zero entries</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getrow</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of row i of the matrix, as a (1 x n)
CSR matrix (row vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">log1p</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise log1p.</p>
<p>See numpy.log1p for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">max</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the maximum of the matrix or maximum along an axis.
This takes all elements into account, not just the non-zero ones.</p>
<h2 id="parameters_66">Parameters<a class="headerlink" href="#parameters_66" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the maximum over all the matrix elements, returning
a scalar (i.e. <code>axis</code> = <code>None</code>).</p>
<p>out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except
for the default value, as this argument is not used.</p>
<h2 id="returns_43">Returns<a class="headerlink" href="#returns_43" title="Permanent link">&para;</a></h2>
<p>amax : coo_matrix or scalar
Maximum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.
If <code>axis</code> is given, the result is a sparse.coo_matrix of dimension
<code>a.ndim - 1</code>.</p>
<h2 id="see-also_30">See Also<a class="headerlink" href="#see-also_30" title="Permanent link">&para;</a></h2>
<p>min : The minimum value of a sparse matrix along a given axis.
numpy.matrix.max : NumPy's implementation of 'max' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise maximum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the matrix elements. The average is taken
over all elements in the matrix by default, otherwise over the
specified axis. <code>float64</code> intermediate and return values are used
for integer inputs.</p>
<h2 id="parameters_67">Parameters<a class="headerlink" href="#parameters_67" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the mean is computed. The default is to compute
the mean of all elements in the matrix (i.e. <code>axis</code> = <code>None</code>).
dtype : data-type, optional
Type to use in computing the mean. For integer inputs, the default
is <code>float64</code>; for floating point inputs, it is the same as the
input dtype.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_44">Returns<a class="headerlink" href="#returns_44" title="Permanent link">&para;</a></h2>
<p>m : np.matrix</p>
<h2 id="see-also_31">See Also<a class="headerlink" href="#see-also_31" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.mean : NumPy's implementation of 'mean' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">min</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the minimum of the matrix or maximum along an axis.
This takes all elements into account, not just the non-zero ones.</p>
<h2 id="parameters_68">Parameters<a class="headerlink" href="#parameters_68" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the minimum over all the matrix elements, returning
a scalar (i.e. <code>axis</code> = <code>None</code>).</p>
<p>out : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except for
the default value, as this argument is not used.</p>
<h2 id="returns_45">Returns<a class="headerlink" href="#returns_45" title="Permanent link">&para;</a></h2>
<p>amin : coo_matrix or scalar
Minimum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.
If <code>axis</code> is given, the result is a sparse.coo_matrix of dimension
<code>a.ndim - 1</code>.</p>
<h2 id="see-also_32">See Also<a class="headerlink" href="#see-also_32" title="Permanent link">&para;</a></h2>
<p>max : The maximum value of a sparse matrix along a given axis.
numpy.matrix.min : NumPy's implementation of 'min' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise minimum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">multiply</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Point-wise multiplication by another matrix, vector, or
scalar.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nonzero indices</p>
<p>Returns a tuple of arrays (row,col) containing the indices
of the non-zero elements of the matrix.</p>
<h2 id="examples_17">Examples<a class="headerlink" href="#examples_17" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])
A.nonzero()
(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">power</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>This function performs element-wise power.</p>
<h2 id="parameters_69">Parameters<a class="headerlink" href="#parameters_69" title="Permanent link">&para;</a></h2>
<p>n : n is a scalar</p>
<p>dtype : If dtype is not specified, the current dtype will be preserved.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">prune</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Remove empty space after all non-zero elements.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rad2deg</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise rad2deg.</p>
<p>See numpy.rad2deg for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>reshape(self, shape, order='C', copy=False)</p>
<p>Gives a new shape to a sparse matrix without changing its data.</p>
<h2 id="parameters_70">Parameters<a class="headerlink" href="#parameters_70" title="Permanent link">&para;</a></h2>
<p>shape : length-2 tuple of ints
The new shape should be compatible with the original shape.
order : {'C', 'F'}, optional
Read the elements using this index order. 'C' means to read and
write the elements using C-like index order; e.g. read entire first
row, then second row, etc. 'F' means to read and write the elements
using Fortran-like index order; e.g. read entire first column, then
second column, etc.
copy : bool, optional
Indicates whether or not attributes of self should be copied
whenever possible. The degree to which attributes are copied varies
depending on the type of sparse matrix being used.</p>
<h2 id="returns_46">Returns<a class="headerlink" href="#returns_46" title="Permanent link">&para;</a></h2>
<p>reshaped_matrix : sparse matrix
A sparse matrix with the given <code>shape</code>, not necessarily of the same
format as the current object.</p>
<h2 id="see-also_33">See Also<a class="headerlink" href="#see-also_33" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.reshape : NumPy's implementation of 'reshape' for
matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resize</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Resize the matrix in-place to dimensions given by <code>shape</code></p>
<p>Any elements that lie within the new shape will remain at the same
indices, while non-zero elements lying outside the new shape are
removed.</p>
<h2 id="parameters_71">Parameters<a class="headerlink" href="#parameters_71" title="Permanent link">&para;</a></h2>
<p>shape : (int, int)
number of rows and columns in the new matrix</p>
<h2 id="notes_7">Notes<a class="headerlink" href="#notes_7" title="Permanent link">&para;</a></h2>
<p>The semantics are not identical to <code>numpy.ndarray.resize</code> or
<code>numpy.resize</code>.  Here, the same data will be maintained at each index
before and after reshape, if that index is within the new bounds.  In
numpy, resizing maintains contiguity of the array, moving elements
around in the logical matrix but not within a flattened representation.</p>
<p>We give no guarantees about whether the underlying data attributes
(arrays, etc.) will be modified in place or replaced with new objects.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise rint.</p>
<p>See numpy.rint for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_shape</span> <span class="o">:</span> <span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>See <code>reshape</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setdiag</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">values</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Set diagonal or off-diagonal elements of the array.</p>
<h2 id="parameters_72">Parameters<a class="headerlink" href="#parameters_72" title="Permanent link">&para;</a></h2>
<p>values : array_like
New values of the diagonal elements.</p>
<p>Values may have any length.  If the diagonal is longer than values,
then the remaining diagonal entries will not be set.  If values if
longer than the diagonal, then the remaining values are ignored.</p>
<p>If a scalar value is given, all of the diagonal is set to it.</p>
<p>k : int, optional
Which off-diagonal to set, corresponding to elements a[i,i+k].
Default: 0 (the main diagonal).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sign</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sign.</p>
<p>See numpy.sign for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sin</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sin.</p>
<p>See numpy.sin for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sinh.</p>
<p>See numpy.sinh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sort_indices</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sort the indices of this matrix <em>in place</em></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sorted_indices</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of this matrix with sorted indices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrt</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sqrt.</p>
<p>See numpy.sqrt for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sum the matrix elements over a given axis.</p>
<h2 id="parameters_73">Parameters<a class="headerlink" href="#parameters_73" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the sum of all the matrix elements, returning a scalar
(i.e. <code>axis</code> = <code>None</code>).
dtype : dtype, optional
The type of the returned matrix and of the accumulator in which
the elements are summed.  The dtype of <code>a</code> is used by default
unless <code>a</code> has an integer dtype of less precision than the default
platform integer.  In that case, if <code>a</code> is signed then the platform
integer is used while if <code>a</code> is unsigned then an unsigned integer
of the same precision as the platform integer is used.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_47">Returns<a class="headerlink" href="#returns_47" title="Permanent link">&para;</a></h2>
<p>sum_along_axis : np.matrix
A matrix with the same shape as <code>self</code>, with the specified
axis removed.</p>
<h2 id="see-also_34">See Also<a class="headerlink" href="#see-also_34" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.sum : NumPy's implementation of 'sum' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum_duplicates</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Eliminate duplicate matrix entries by adding them together</p>
<p>The is an <em>in place</em> operation</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tan</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise tan.</p>
<p>See numpy.tan for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise tanh.</p>
<p>See numpy.tanh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense ndarray representation of this matrix.</p>
<h2 id="parameters_74">Parameters<a class="headerlink" href="#parameters_74" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array as the output buffer
instead of allocating a new array to return. The provided
array must have the same shape and dtype as the sparse
matrix on which you are calling the method. For most
sparse types, <code>out</code> is required to be memory contiguous
(either C or Fortran ordered).</p>
<h2 id="returns_48">Returns<a class="headerlink" href="#returns_48" title="Permanent link">&para;</a></h2>
<p>arr : ndarray, 2-dimensional
An array with the same shape and containing the same
data represented by the sparse matrix, with the requested
memory order. If <code>out</code> was passed, the same object is
returned after being modified in-place to contain the
appropriate values.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tobsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">blocksize</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Block Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant bsr_matrix.</p>
<p>When blocksize=(R, C) is provided, it will be used for construction of
the bsr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocoo</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to COOrdinate format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant coo_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsc</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Column format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csc_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense matrix representation of this matrix.</p>
<h2 id="parameters_75">Parameters<a class="headerlink" href="#parameters_75" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array (or <code>numpy.matrix</code>) as the
output buffer instead of allocating a new array to
return. The provided array must have the same shape and
dtype as the sparse matrix on which you are calling the
method.</p>
<h2 id="returns_49">Returns<a class="headerlink" href="#returns_49" title="Permanent link">&para;</a></h2>
<p>arr : numpy.matrix, 2-dimensional
A NumPy matrix object with the same shape and containing
the same data represented by the sparse matrix, with the
requested memory order. If <code>out</code> was passed and was an
array (rather than a <code>numpy.matrix</code>), it will be filled
with the appropriate values and returned wrapped in a
<code>numpy.matrix</code> object that shares the same memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todia</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to sparse DIAgonal format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dia_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todok</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Dictionary Of Keys format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dok_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tolil</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to List of Lists format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant lil_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reverses the dimensions of the sparse matrix.</p>
<h2 id="parameters_76">Parameters<a class="headerlink" href="#parameters_76" title="Permanent link">&para;</a></h2>
<p>axes : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except
for the default value.
copy : bool, optional
Indicates whether or not attributes of <code>self</code> should be
copied whenever possible. The degree to which attributes
are copied varies depending on the type of sparse matrix
being used.</p>
<h2 id="returns_50">Returns<a class="headerlink" href="#returns_50" title="Permanent link">&para;</a></h2>
<p>p : <code>self</code> with the dimensions reversed.</p>
<h2 id="see-also_35">See Also<a class="headerlink" href="#see-also_35" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.transpose : NumPy's implementation of 'transpose'
for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">trunc</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise trunc.</p>
<p>See numpy.trunc for more information.</p>
<p>Attribute dtype: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute dtype: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute shape: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute shape: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute ndim: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute ndim: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute nnz: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute nnz: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute data: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute data: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute indices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute indices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute indptr: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indptr</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute indptr: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indptr_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute has_sorted_indices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">has_sorted_indices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute has_sorted_indices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">has_sorted_indices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Dia_matrix</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Dia_matrix</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArrayLike</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dia_matrix</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">arg1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Sparse matrix with DIAgonal storage</p>
<p>This can be instantiated in several ways:
dia_matrix(D)
with a dense matrix</p>
<p>dia_matrix(S)
with another sparse matrix S (equivalent to S.todia())</p>
<p>dia_matrix((M, N), [dtype])
to construct an empty matrix with shape (M, N),
dtype is optional, defaulting to dtype='d'.</p>
<p>dia_matrix((data, offsets), shape=(M, N))
where the <code>data[k,:]</code> stores the diagonal entries for
diagonal <code>offsets[k]</code> (See example below)</p>
<h2 id="attributes_4">Attributes<a class="headerlink" href="#attributes_4" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Data type of the matrix
shape : 2-tuple
Shape of the matrix
ndim : int
Number of dimensions (this is always 2)
nnz
Number of stored values, including explicit zeros
data
DIA format data array of the matrix
offsets
DIA format offset array of the matrix</p>
<h2 id="notes_8">Notes<a class="headerlink" href="#notes_8" title="Permanent link">&para;</a></h2>
<p>Sparse matrices can be used in arithmetic operations: they support
addition, subtraction, multiplication, division, and matrix power.</p>
<h2 id="examples_18">Examples<a class="headerlink" href="#examples_18" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import dia_matrix
dia_matrix((3, 4), dtype=np.int8).toarray()
array([[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]], dtype=int8)</p>
<p>data = np.array([[1, 2, 3, 4]]).repeat(3, axis=0)
offsets = np.array([0, -1, 2])
dia_matrix((data, offsets), shape=(4, 4)).toarray()
array([[1, 0, 3, 0],
[1, 2, 0, 4],
[0, 2, 3, 0],
[0, 0, 3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arcsin</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arcsin.</p>
<p>See numpy.arcsin for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arcsinh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arcsinh.</p>
<p>See numpy.arcsinh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arctan</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arctan.</p>
<p>See numpy.arctan for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arctanh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise arctanh.</p>
<p>See numpy.arctanh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asformat</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">format</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return this matrix in the passed format.</p>
<h2 id="parameters_77">Parameters<a class="headerlink" href="#parameters_77" title="Permanent link">&para;</a></h2>
<p>format : {str, None}
The desired matrix format ('csr', 'csc', 'lil', 'dok', 'array', ...)
or None for no conversion.
copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_51">Returns<a class="headerlink" href="#returns_51" title="Permanent link">&para;</a></h2>
<p>A : This matrix in the passed format.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asfptype</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Upcast matrix to a floating point format (if necessary)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">astype</span> <span class="o">:</span> <span class="o">?</span><span class="n">casting</span><span class="o">:[`</span><span class="nc">No</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Equiv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Safe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same_kind</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Unsafe</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cast the matrix elements to a specified type.</p>
<h2 id="parameters_78">Parameters<a class="headerlink" href="#parameters_78" title="Permanent link">&para;</a></h2>
<p>dtype : string or numpy dtype
Typecode or data-type to which to cast the data.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
Controls what kind of data casting may occur.
Defaults to 'unsafe' for backwards compatibility.
'no' means the data types should not be cast at all.
'equiv' means only byte-order changes are allowed.
'safe' means only casts which can preserve values are allowed.
'same_kind' means only safe casts or casts within a kind,
like float64 to float32, are allowed.
'unsafe' means any data conversions may be done.
copy : bool, optional
If <code>copy</code> is <code>False</code>, the result might share some memory with this
matrix. If <code>copy</code> is <code>True</code>, it is guaranteed that the result and
this matrix do not share any memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ceil</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise ceil.</p>
<p>See numpy.ceil for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conj</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_79">Parameters<a class="headerlink" href="#parameters_79" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_52">Returns<a class="headerlink" href="#returns_52" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjugate</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_80">Parameters<a class="headerlink" href="#parameters_80" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_53">Returns<a class="headerlink" href="#returns_53" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">copy</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of this matrix.</p>
<p>No data/indices will be shared between the returned value and current
matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count_nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of non-zero entries, equivalent to</p>
<p>np.count_nonzero(a.toarray())</p>
<p>Unlike getnnz() and the nnz property, which return the number of stored
entries (the length of the data attribute), this method counts the
actual number of non-zero entries in data.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">deg2rad</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise deg2rad.</p>
<p>See numpy.deg2rad for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the k-th diagonal of the matrix.</p>
<h2 id="parameters_81">Parameters<a class="headerlink" href="#parameters_81" title="Permanent link">&para;</a></h2>
<p>k : int, optional
Which diagonal to get, corresponding to elements a[i, i+k].
Default: 0 (the main diagonal).</p>
<p>.. versionadded:: 1.0</p>
<h2 id="see-also_36">See also<a class="headerlink" href="#see-also_36" title="Permanent link">&para;</a></h2>
<p>numpy.diagonal : Equivalent numpy function.</p>
<h2 id="examples_19">Examples<a class="headerlink" href="#examples_19" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
A.diagonal()
array([1, 0, 5])
A.diagonal(k=1)
array([2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Ordinary dot product</p>
<h2 id="examples_20">Examples<a class="headerlink" href="#examples_20" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
v = np.array([1, 0, -1])
A.dot(v)
array([ 1, -3, -1], dtype=int64)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm1</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise expm1.</p>
<p>See numpy.expm1 for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">floor</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise floor.</p>
<p>See numpy.floor for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getH</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Hermitian transpose of this matrix.</p>
<h2 id="see-also_37">See Also<a class="headerlink" href="#see-also_37" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.getH : NumPy's implementation of <code>getH</code> for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_shape</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get shape of a matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getcol</span> <span class="o">:</span> <span class="n">j</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of column j of the matrix, as an (m x 1) sparse
matrix (column vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getformat</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Format of a matrix representation as a string.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getmaxprint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Maximum number of elements to display when printed.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getnnz</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of stored values, including explicit zeros.</p>
<h2 id="parameters_82">Parameters<a class="headerlink" href="#parameters_82" title="Permanent link">&para;</a></h2>
<p>axis : None, 0, or 1
Select between the number of values across the whole matrix, in
each column, or in each row.</p>
<h2 id="see-also_38">See also<a class="headerlink" href="#see-also_38" title="Permanent link">&para;</a></h2>
<p>count_nonzero : Number of non-zero entries</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getrow</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of row i of the matrix, as a (1 x n) sparse
matrix (row vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">log1p</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise log1p.</p>
<p>See numpy.log1p for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise maximum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the matrix elements. The average is taken
over all elements in the matrix by default, otherwise over the
specified axis. <code>float64</code> intermediate and return values are used
for integer inputs.</p>
<h2 id="parameters_83">Parameters<a class="headerlink" href="#parameters_83" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the mean is computed. The default is to compute
the mean of all elements in the matrix (i.e. <code>axis</code> = <code>None</code>).
dtype : data-type, optional
Type to use in computing the mean. For integer inputs, the default
is <code>float64</code>; for floating point inputs, it is the same as the
input dtype.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_54">Returns<a class="headerlink" href="#returns_54" title="Permanent link">&para;</a></h2>
<p>m : np.matrix</p>
<h2 id="see-also_39">See Also<a class="headerlink" href="#see-also_39" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.mean : NumPy's implementation of 'mean' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise minimum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">multiply</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Point-wise multiplication by another matrix</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nonzero indices</p>
<p>Returns a tuple of arrays (row,col) containing the indices
of the non-zero elements of the matrix.</p>
<h2 id="examples_21">Examples<a class="headerlink" href="#examples_21" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])
A.nonzero()
(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">power</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>This function performs element-wise power.</p>
<h2 id="parameters_84">Parameters<a class="headerlink" href="#parameters_84" title="Permanent link">&para;</a></h2>
<p>n : n is a scalar</p>
<p>dtype : If dtype is not specified, the current dtype will be preserved.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rad2deg</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise rad2deg.</p>
<p>See numpy.rad2deg for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>reshape(self, shape, order='C', copy=False)</p>
<p>Gives a new shape to a sparse matrix without changing its data.</p>
<h2 id="parameters_85">Parameters<a class="headerlink" href="#parameters_85" title="Permanent link">&para;</a></h2>
<p>shape : length-2 tuple of ints
The new shape should be compatible with the original shape.
order : {'C', 'F'}, optional
Read the elements using this index order. 'C' means to read and
write the elements using C-like index order; e.g. read entire first
row, then second row, etc. 'F' means to read and write the elements
using Fortran-like index order; e.g. read entire first column, then
second column, etc.
copy : bool, optional
Indicates whether or not attributes of self should be copied
whenever possible. The degree to which attributes are copied varies
depending on the type of sparse matrix being used.</p>
<h2 id="returns_55">Returns<a class="headerlink" href="#returns_55" title="Permanent link">&para;</a></h2>
<p>reshaped_matrix : sparse matrix
A sparse matrix with the given <code>shape</code>, not necessarily of the same
format as the current object.</p>
<h2 id="see-also_40">See Also<a class="headerlink" href="#see-also_40" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.reshape : NumPy's implementation of 'reshape' for
matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resize</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Resize the matrix in-place to dimensions given by <code>shape</code></p>
<p>Any elements that lie within the new shape will remain at the same
indices, while non-zero elements lying outside the new shape are
removed.</p>
<h2 id="parameters_86">Parameters<a class="headerlink" href="#parameters_86" title="Permanent link">&para;</a></h2>
<p>shape : (int, int)
number of rows and columns in the new matrix</p>
<h2 id="notes_9">Notes<a class="headerlink" href="#notes_9" title="Permanent link">&para;</a></h2>
<p>The semantics are not identical to <code>numpy.ndarray.resize</code> or
<code>numpy.resize</code>.  Here, the same data will be maintained at each index
before and after reshape, if that index is within the new bounds.  In
numpy, resizing maintains contiguity of the array, moving elements
around in the logical matrix but not within a flattened representation.</p>
<p>We give no guarantees about whether the underlying data attributes
(arrays, etc.) will be modified in place or replaced with new objects.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise rint.</p>
<p>See numpy.rint for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_shape</span> <span class="o">:</span> <span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>See <code>reshape</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setdiag</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">values</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Set diagonal or off-diagonal elements of the array.</p>
<h2 id="parameters_87">Parameters<a class="headerlink" href="#parameters_87" title="Permanent link">&para;</a></h2>
<p>values : array_like
New values of the diagonal elements.</p>
<p>Values may have any length.  If the diagonal is longer than values,
then the remaining diagonal entries will not be set.  If values if
longer than the diagonal, then the remaining values are ignored.</p>
<p>If a scalar value is given, all of the diagonal is set to it.</p>
<p>k : int, optional
Which off-diagonal to set, corresponding to elements a[i,i+k].
Default: 0 (the main diagonal).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sign</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sign.</p>
<p>See numpy.sign for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sin</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sin.</p>
<p>See numpy.sin for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sinh.</p>
<p>See numpy.sinh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrt</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise sqrt.</p>
<p>See numpy.sqrt for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sum the matrix elements over a given axis.</p>
<h2 id="parameters_88">Parameters<a class="headerlink" href="#parameters_88" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the sum of all the matrix elements, returning a scalar
(i.e. <code>axis</code> = <code>None</code>).
dtype : dtype, optional
The type of the returned matrix and of the accumulator in which
the elements are summed.  The dtype of <code>a</code> is used by default
unless <code>a</code> has an integer dtype of less precision than the default
platform integer.  In that case, if <code>a</code> is signed then the platform
integer is used while if <code>a</code> is unsigned then an unsigned integer
of the same precision as the platform integer is used.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_56">Returns<a class="headerlink" href="#returns_56" title="Permanent link">&para;</a></h2>
<p>sum_along_axis : np.matrix
A matrix with the same shape as <code>self</code>, with the specified
axis removed.</p>
<h2 id="see-also_41">See Also<a class="headerlink" href="#see-also_41" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.sum : NumPy's implementation of 'sum' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tan</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise tan.</p>
<p>See numpy.tan for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanh</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise tanh.</p>
<p>See numpy.tanh for more information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense ndarray representation of this matrix.</p>
<h2 id="parameters_89">Parameters<a class="headerlink" href="#parameters_89" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array as the output buffer
instead of allocating a new array to return. The provided
array must have the same shape and dtype as the sparse
matrix on which you are calling the method. For most
sparse types, <code>out</code> is required to be memory contiguous
(either C or Fortran ordered).</p>
<h2 id="returns_57">Returns<a class="headerlink" href="#returns_57" title="Permanent link">&para;</a></h2>
<p>arr : ndarray, 2-dimensional
An array with the same shape and containing the same
data represented by the sparse matrix, with the requested
memory order. If <code>out</code> was passed, the same object is
returned after being modified in-place to contain the
appropriate values.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tobsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">blocksize</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Block Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant bsr_matrix.</p>
<p>When blocksize=(R, C) is provided, it will be used for construction of
the bsr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocoo</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to COOrdinate format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant coo_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsc</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Column format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csc_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense matrix representation of this matrix.</p>
<h2 id="parameters_90">Parameters<a class="headerlink" href="#parameters_90" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array (or <code>numpy.matrix</code>) as the
output buffer instead of allocating a new array to
return. The provided array must have the same shape and
dtype as the sparse matrix on which you are calling the
method.</p>
<h2 id="returns_58">Returns<a class="headerlink" href="#returns_58" title="Permanent link">&para;</a></h2>
<p>arr : numpy.matrix, 2-dimensional
A NumPy matrix object with the same shape and containing
the same data represented by the sparse matrix, with the
requested memory order. If <code>out</code> was passed and was an
array (rather than a <code>numpy.matrix</code>), it will be filled
with the appropriate values and returned wrapped in a
<code>numpy.matrix</code> object that shares the same memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todia</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to sparse DIAgonal format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dia_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todok</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Dictionary Of Keys format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dok_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tolil</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to List of Lists format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant lil_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reverses the dimensions of the sparse matrix.</p>
<h2 id="parameters_91">Parameters<a class="headerlink" href="#parameters_91" title="Permanent link">&para;</a></h2>
<p>axes : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except
for the default value.
copy : bool, optional
Indicates whether or not attributes of <code>self</code> should be
copied whenever possible. The degree to which attributes
are copied varies depending on the type of sparse matrix
being used.</p>
<h2 id="returns_59">Returns<a class="headerlink" href="#returns_59" title="Permanent link">&para;</a></h2>
<p>p : <code>self</code> with the dimensions reversed.</p>
<h2 id="see-also_42">See Also<a class="headerlink" href="#see-also_42" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.transpose : NumPy's implementation of 'transpose'
for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">trunc</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise trunc.</p>
<p>See numpy.trunc for more information.</p>
<p>Attribute dtype: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute dtype: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute shape: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute shape: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute ndim: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute ndim: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute nnz: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute nnz: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute data: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute data: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute offsets: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">offsets</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute offsets: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">offsets_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Dok_matrix</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Dok_matrix</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArrayLike</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dok_matrix</span> <span class="o">|</span> <span class="o">`</span><span class="nc">IndexMixin</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_index</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">IndexMixin</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">arg1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Dictionary Of Keys based sparse matrix.</p>
<p>This is an efficient structure for constructing sparse
matrices incrementally.</p>
<p>This can be instantiated in several ways:
dok_matrix(D)
with a dense matrix, D</p>
<p>dok_matrix(S)
with a sparse matrix, S</p>
<p>dok_matrix((M,N), [dtype])
create the matrix with initial shape (M,N)
dtype is optional, defaulting to dtype='d'</p>
<h2 id="attributes_5">Attributes<a class="headerlink" href="#attributes_5" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Data type of the matrix
shape : 2-tuple
Shape of the matrix
ndim : int
Number of dimensions (this is always 2)
nnz
Number of nonzero elements</p>
<h2 id="notes_10">Notes<a class="headerlink" href="#notes_10" title="Permanent link">&para;</a></h2>
<p>Sparse matrices can be used in arithmetic operations: they support
addition, subtraction, multiplication, division, and matrix power.</p>
<p>Allows for efficient O(1) access of individual elements.
Duplicates are not allowed.
Can be efficiently converted to a coo_matrix once constructed.</p>
<h2 id="examples_22">Examples<a class="headerlink" href="#examples_22" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import dok_matrix
S = dok_matrix((5, 5), dtype=np.float32)
for i in range(5):
...     for j in range(5):
...         S[i, j] = i + j    # Update element</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">setitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asformat</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">format</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return this matrix in the passed format.</p>
<h2 id="parameters_92">Parameters<a class="headerlink" href="#parameters_92" title="Permanent link">&para;</a></h2>
<p>format : {str, None}
The desired matrix format ('csr', 'csc', 'lil', 'dok', 'array', ...)
or None for no conversion.
copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_60">Returns<a class="headerlink" href="#returns_60" title="Permanent link">&para;</a></h2>
<p>A : This matrix in the passed format.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asfptype</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Upcast matrix to a floating point format (if necessary)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">astype</span> <span class="o">:</span> <span class="o">?</span><span class="n">casting</span><span class="o">:[`</span><span class="nc">No</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Equiv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Safe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same_kind</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Unsafe</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cast the matrix elements to a specified type.</p>
<h2 id="parameters_93">Parameters<a class="headerlink" href="#parameters_93" title="Permanent link">&para;</a></h2>
<p>dtype : string or numpy dtype
Typecode or data-type to which to cast the data.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
Controls what kind of data casting may occur.
Defaults to 'unsafe' for backwards compatibility.
'no' means the data types should not be cast at all.
'equiv' means only byte-order changes are allowed.
'safe' means only casts which can preserve values are allowed.
'same_kind' means only safe casts or casts within a kind,
like float64 to float32, are allowed.
'unsafe' means any data conversions may be done.
copy : bool, optional
If <code>copy</code> is <code>False</code>, the result might share some memory with this
matrix. If <code>copy</code> is <code>True</code>, it is guaranteed that the result and
this matrix do not share any memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">clear</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>D.clear() -&gt; None.  Remove all items from D.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conj</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_94">Parameters<a class="headerlink" href="#parameters_94" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_61">Returns<a class="headerlink" href="#returns_61" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjtransp</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the conjugate transpose.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjugate</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_95">Parameters<a class="headerlink" href="#parameters_95" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_62">Returns<a class="headerlink" href="#returns_62" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">copy</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of this matrix.</p>
<p>No data/indices will be shared between the returned value and current
matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count_nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of non-zero entries, equivalent to</p>
<p>np.count_nonzero(a.toarray())</p>
<p>Unlike getnnz() and the nnz property, which return the number of stored
entries (the length of the data attribute), this method counts the
actual number of non-zero entries in data.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the k-th diagonal of the matrix.</p>
<h2 id="parameters_96">Parameters<a class="headerlink" href="#parameters_96" title="Permanent link">&para;</a></h2>
<p>k : int, optional
Which diagonal to get, corresponding to elements a[i, i+k].
Default: 0 (the main diagonal).</p>
<p>.. versionadded:: 1.0</p>
<h2 id="see-also_43">See also<a class="headerlink" href="#see-also_43" title="Permanent link">&para;</a></h2>
<p>numpy.diagonal : Equivalent numpy function.</p>
<h2 id="examples_23">Examples<a class="headerlink" href="#examples_23" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
A.diagonal()
array([1, 0, 5])
A.diagonal(k=1)
array([2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Ordinary dot product</p>
<h2 id="examples_24">Examples<a class="headerlink" href="#examples_24" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
v = np.array([1, 0, -1])
A.dot(v)
array([ 1, -3, -1], dtype=int64)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fromkeys</span> <span class="o">:</span> <span class="o">?</span><span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">iterable</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a new dictionary with keys from iterable and values set to value.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get</span> <span class="o">:</span> <span class="o">?</span><span class="n">default</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>This overrides the dict.get method, providing type checking
but otherwise equivalent functionality.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getH</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Hermitian transpose of this matrix.</p>
<h2 id="see-also_44">See Also<a class="headerlink" href="#see-also_44" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.getH : NumPy's implementation of <code>getH</code> for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_shape</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get shape of a matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getcol</span> <span class="o">:</span> <span class="n">j</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of column j of the matrix, as an (m x 1) sparse
matrix (column vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getformat</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Format of a matrix representation as a string.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getmaxprint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Maximum number of elements to display when printed.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getnnz</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of stored values, including explicit zeros.</p>
<h2 id="parameters_97">Parameters<a class="headerlink" href="#parameters_97" title="Permanent link">&para;</a></h2>
<p>axis : None, 0, or 1
Select between the number of values across the whole matrix, in
each column, or in each row.</p>
<h2 id="see-also_45">See also<a class="headerlink" href="#see-also_45" title="Permanent link">&para;</a></h2>
<p>count_nonzero : Number of non-zero entries</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getrow</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of row i of the matrix, as a (1 x n) sparse
matrix (row vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">items</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>D.items() -&gt; a set-like object providing a view on D's items</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">keys</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>D.keys() -&gt; a set-like object providing a view on D's keys</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise maximum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the matrix elements. The average is taken
over all elements in the matrix by default, otherwise over the
specified axis. <code>float64</code> intermediate and return values are used
for integer inputs.</p>
<h2 id="parameters_98">Parameters<a class="headerlink" href="#parameters_98" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the mean is computed. The default is to compute
the mean of all elements in the matrix (i.e. <code>axis</code> = <code>None</code>).
dtype : data-type, optional
Type to use in computing the mean. For integer inputs, the default
is <code>float64</code>; for floating point inputs, it is the same as the
input dtype.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_63">Returns<a class="headerlink" href="#returns_63" title="Permanent link">&para;</a></h2>
<p>m : np.matrix</p>
<h2 id="see-also_46">See Also<a class="headerlink" href="#see-also_46" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.mean : NumPy's implementation of 'mean' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise minimum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">multiply</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Point-wise multiplication by another matrix</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nonzero indices</p>
<p>Returns a tuple of arrays (row,col) containing the indices
of the non-zero elements of the matrix.</p>
<h2 id="examples_25">Examples<a class="headerlink" href="#examples_25" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])
A.nonzero()
(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pop</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">popitem</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Remove and return a (key, value) pair as a 2-tuple.</p>
<p>Pairs are returned in LIFO (last-in, first-out) order.
Raises KeyError if the dict is empty.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">power</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise power.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>reshape(self, shape, order='C', copy=False)</p>
<p>Gives a new shape to a sparse matrix without changing its data.</p>
<h2 id="parameters_99">Parameters<a class="headerlink" href="#parameters_99" title="Permanent link">&para;</a></h2>
<p>shape : length-2 tuple of ints
The new shape should be compatible with the original shape.
order : {'C', 'F'}, optional
Read the elements using this index order. 'C' means to read and
write the elements using C-like index order; e.g. read entire first
row, then second row, etc. 'F' means to read and write the elements
using Fortran-like index order; e.g. read entire first column, then
second column, etc.
copy : bool, optional
Indicates whether or not attributes of self should be copied
whenever possible. The degree to which attributes are copied varies
depending on the type of sparse matrix being used.</p>
<h2 id="returns_64">Returns<a class="headerlink" href="#returns_64" title="Permanent link">&para;</a></h2>
<p>reshaped_matrix : sparse matrix
A sparse matrix with the given <code>shape</code>, not necessarily of the same
format as the current object.</p>
<h2 id="see-also_47">See Also<a class="headerlink" href="#see-also_47" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.reshape : NumPy's implementation of 'reshape' for
matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resize</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Resize the matrix in-place to dimensions given by <code>shape</code></p>
<p>Any elements that lie within the new shape will remain at the same
indices, while non-zero elements lying outside the new shape are
removed.</p>
<h2 id="parameters_100">Parameters<a class="headerlink" href="#parameters_100" title="Permanent link">&para;</a></h2>
<p>shape : (int, int)
number of rows and columns in the new matrix</p>
<h2 id="notes_11">Notes<a class="headerlink" href="#notes_11" title="Permanent link">&para;</a></h2>
<p>The semantics are not identical to <code>numpy.ndarray.resize</code> or
<code>numpy.resize</code>.  Here, the same data will be maintained at each index
before and after reshape, if that index is within the new bounds.  In
numpy, resizing maintains contiguity of the array, moving elements
around in the logical matrix but not within a flattened representation.</p>
<p>We give no guarantees about whether the underlying data attributes
(arrays, etc.) will be modified in place or replaced with new objects.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_shape</span> <span class="o">:</span> <span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>See <code>reshape</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setdefault</span> <span class="o">:</span> <span class="o">?</span><span class="n">default</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Insert key with a value of default if key is not in the dictionary.</p>
<p>Return the value for key if key is in the dictionary, else default.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setdiag</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">values</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Set diagonal or off-diagonal elements of the array.</p>
<h2 id="parameters_101">Parameters<a class="headerlink" href="#parameters_101" title="Permanent link">&para;</a></h2>
<p>values : array_like
New values of the diagonal elements.</p>
<p>Values may have any length.  If the diagonal is longer than values,
then the remaining diagonal entries will not be set.  If values if
longer than the diagonal, then the remaining values are ignored.</p>
<p>If a scalar value is given, all of the diagonal is set to it.</p>
<p>k : int, optional
Which off-diagonal to set, corresponding to elements a[i,i+k].
Default: 0 (the main diagonal).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sum the matrix elements over a given axis.</p>
<h2 id="parameters_102">Parameters<a class="headerlink" href="#parameters_102" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the sum of all the matrix elements, returning a scalar
(i.e. <code>axis</code> = <code>None</code>).
dtype : dtype, optional
The type of the returned matrix and of the accumulator in which
the elements are summed.  The dtype of <code>a</code> is used by default
unless <code>a</code> has an integer dtype of less precision than the default
platform integer.  In that case, if <code>a</code> is signed then the platform
integer is used while if <code>a</code> is unsigned then an unsigned integer
of the same precision as the platform integer is used.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_65">Returns<a class="headerlink" href="#returns_65" title="Permanent link">&para;</a></h2>
<p>sum_along_axis : np.matrix
A matrix with the same shape as <code>self</code>, with the specified
axis removed.</p>
<h2 id="see-also_48">See Also<a class="headerlink" href="#see-also_48" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.sum : NumPy's implementation of 'sum' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense ndarray representation of this matrix.</p>
<h2 id="parameters_103">Parameters<a class="headerlink" href="#parameters_103" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array as the output buffer
instead of allocating a new array to return. The provided
array must have the same shape and dtype as the sparse
matrix on which you are calling the method. For most
sparse types, <code>out</code> is required to be memory contiguous
(either C or Fortran ordered).</p>
<h2 id="returns_66">Returns<a class="headerlink" href="#returns_66" title="Permanent link">&para;</a></h2>
<p>arr : ndarray, 2-dimensional
An array with the same shape and containing the same
data represented by the sparse matrix, with the requested
memory order. If <code>out</code> was passed, the same object is
returned after being modified in-place to contain the
appropriate values.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tobsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">blocksize</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Block Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant bsr_matrix.</p>
<p>When blocksize=(R, C) is provided, it will be used for construction of
the bsr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocoo</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to COOrdinate format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant coo_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsc</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Column format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csc_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense matrix representation of this matrix.</p>
<h2 id="parameters_104">Parameters<a class="headerlink" href="#parameters_104" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array (or <code>numpy.matrix</code>) as the
output buffer instead of allocating a new array to
return. The provided array must have the same shape and
dtype as the sparse matrix on which you are calling the
method.</p>
<h2 id="returns_67">Returns<a class="headerlink" href="#returns_67" title="Permanent link">&para;</a></h2>
<p>arr : numpy.matrix, 2-dimensional
A NumPy matrix object with the same shape and containing
the same data represented by the sparse matrix, with the
requested memory order. If <code>out</code> was passed and was an
array (rather than a <code>numpy.matrix</code>), it will be filled
with the appropriate values and returned wrapped in a
<code>numpy.matrix</code> object that shares the same memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todia</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to sparse DIAgonal format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dia_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todok</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Dictionary Of Keys format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dok_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tolil</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to List of Lists format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant lil_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reverses the dimensions of the sparse matrix.</p>
<h2 id="parameters_105">Parameters<a class="headerlink" href="#parameters_105" title="Permanent link">&para;</a></h2>
<p>axes : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except
for the default value.
copy : bool, optional
Indicates whether or not attributes of <code>self</code> should be
copied whenever possible. The degree to which attributes
are copied varies depending on the type of sparse matrix
being used.</p>
<h2 id="returns_68">Returns<a class="headerlink" href="#returns_68" title="Permanent link">&para;</a></h2>
<p>p : <code>self</code> with the dimensions reversed.</p>
<h2 id="see-also_49">See Also<a class="headerlink" href="#see-also_49" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.transpose : NumPy's implementation of 'transpose'
for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="n">val_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.
If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
In either case, this is followed by: for k in F:  D[k] = F[k]</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">values</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>D.values() -&gt; an object providing a view on D's values</p>
<p>Attribute dtype: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute dtype: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute shape: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute shape: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute ndim: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute ndim: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute nnz: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute nnz: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Lil_matrix</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Lil_matrix</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArrayLike</span> <span class="o">|</span> <span class="o">`</span><span class="nc">IndexMixin</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lil_matrix</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_index</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">IndexMixin</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">arg1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Row-based list of lists sparse matrix</p>
<p>This is a structure for constructing sparse matrices incrementally.
Note that inserting a single item can take linear time in the worst case;
to construct a matrix efficiently, make sure the items are pre-sorted by
index, per row.</p>
<p>This can be instantiated in several ways:
lil_matrix(D)
with a dense matrix or rank-2 ndarray D</p>
<p>lil_matrix(S)
with another sparse matrix S (equivalent to S.tolil())</p>
<p>lil_matrix((M, N), [dtype])
to construct an empty matrix with shape (M, N)
dtype is optional, defaulting to dtype='d'.</p>
<h2 id="attributes_6">Attributes<a class="headerlink" href="#attributes_6" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Data type of the matrix
shape : 2-tuple
Shape of the matrix
ndim : int
Number of dimensions (this is always 2)
nnz
Number of stored values, including explicit zeros
data
LIL format data array of the matrix
rows
LIL format row index array of the matrix</p>
<h2 id="notes_12">Notes<a class="headerlink" href="#notes_12" title="Permanent link">&para;</a></h2>
<p>Sparse matrices can be used in arithmetic operations: they support
addition, subtraction, multiplication, division, and matrix power.</p>
<p>Advantages of the LIL format
- supports flexible slicing
- changes to the matrix sparsity structure are efficient</p>
<p>Disadvantages of the LIL format
- arithmetic operations LIL + LIL are slow (consider CSR or CSC)
- slow column slicing (consider CSC)
- slow matrix vector products (consider CSR or CSC)</p>
<p>Intended Usage
- LIL is a convenient format for constructing sparse matrices
- once a matrix has been constructed, convert to CSR or
CSC format for fast arithmetic and matrix vector operations
- consider using the COO format when constructing large matrices</p>
<p>Data Structure
- An array (<code>self.rows</code>) of rows, each of which is a sorted
list of column indices of non-zero elements.
- The corresponding nonzero values are stored in similar
fashion in <code>self.data</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">setitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asformat</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">format</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return this matrix in the passed format.</p>
<h2 id="parameters_106">Parameters<a class="headerlink" href="#parameters_106" title="Permanent link">&para;</a></h2>
<p>format : {str, None}
The desired matrix format ('csr', 'csc', 'lil', 'dok', 'array', ...)
or None for no conversion.
copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_69">Returns<a class="headerlink" href="#returns_69" title="Permanent link">&para;</a></h2>
<p>A : This matrix in the passed format.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asfptype</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Upcast matrix to a floating point format (if necessary)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">astype</span> <span class="o">:</span> <span class="o">?</span><span class="n">casting</span><span class="o">:[`</span><span class="nc">No</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Equiv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Safe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same_kind</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Unsafe</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cast the matrix elements to a specified type.</p>
<h2 id="parameters_107">Parameters<a class="headerlink" href="#parameters_107" title="Permanent link">&para;</a></h2>
<p>dtype : string or numpy dtype
Typecode or data-type to which to cast the data.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
Controls what kind of data casting may occur.
Defaults to 'unsafe' for backwards compatibility.
'no' means the data types should not be cast at all.
'equiv' means only byte-order changes are allowed.
'safe' means only casts which can preserve values are allowed.
'same_kind' means only safe casts or casts within a kind,
like float64 to float32, are allowed.
'unsafe' means any data conversions may be done.
copy : bool, optional
If <code>copy</code> is <code>False</code>, the result might share some memory with this
matrix. If <code>copy</code> is <code>True</code>, it is guaranteed that the result and
this matrix do not share any memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conj</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_108">Parameters<a class="headerlink" href="#parameters_108" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_70">Returns<a class="headerlink" href="#returns_70" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjugate</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_109">Parameters<a class="headerlink" href="#parameters_109" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_71">Returns<a class="headerlink" href="#returns_71" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">copy</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of this matrix.</p>
<p>No data/indices will be shared between the returned value and current
matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count_nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of non-zero entries, equivalent to</p>
<p>np.count_nonzero(a.toarray())</p>
<p>Unlike getnnz() and the nnz property, which return the number of stored
entries (the length of the data attribute), this method counts the
actual number of non-zero entries in data.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the k-th diagonal of the matrix.</p>
<h2 id="parameters_110">Parameters<a class="headerlink" href="#parameters_110" title="Permanent link">&para;</a></h2>
<p>k : int, optional
Which diagonal to get, corresponding to elements a[i, i+k].
Default: 0 (the main diagonal).</p>
<p>.. versionadded:: 1.0</p>
<h2 id="see-also_50">See also<a class="headerlink" href="#see-also_50" title="Permanent link">&para;</a></h2>
<p>numpy.diagonal : Equivalent numpy function.</p>
<h2 id="examples_26">Examples<a class="headerlink" href="#examples_26" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
A.diagonal()
array([1, 0, 5])
A.diagonal(k=1)
array([2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Ordinary dot product</p>
<h2 id="examples_27">Examples<a class="headerlink" href="#examples_27" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
v = np.array([1, 0, -1])
A.dot(v)
array([ 1, -3, -1], dtype=int64)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getH</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Hermitian transpose of this matrix.</p>
<h2 id="see-also_51">See Also<a class="headerlink" href="#see-also_51" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.getH : NumPy's implementation of <code>getH</code> for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_shape</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get shape of a matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getcol</span> <span class="o">:</span> <span class="n">j</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of column j of the matrix, as an (m x 1) sparse
matrix (column vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getformat</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Format of a matrix representation as a string.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getmaxprint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Maximum number of elements to display when printed.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getnnz</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of stored values, including explicit zeros.</p>
<h2 id="parameters_111">Parameters<a class="headerlink" href="#parameters_111" title="Permanent link">&para;</a></h2>
<p>axis : None, 0, or 1
Select between the number of values across the whole matrix, in
each column, or in each row.</p>
<h2 id="see-also_52">See also<a class="headerlink" href="#see-also_52" title="Permanent link">&para;</a></h2>
<p>count_nonzero : Number of non-zero entries</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getrow</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of the 'i'th row.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getrowview</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a view of the 'i'th row (without copying).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise maximum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the matrix elements. The average is taken
over all elements in the matrix by default, otherwise over the
specified axis. <code>float64</code> intermediate and return values are used
for integer inputs.</p>
<h2 id="parameters_112">Parameters<a class="headerlink" href="#parameters_112" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the mean is computed. The default is to compute
the mean of all elements in the matrix (i.e. <code>axis</code> = <code>None</code>).
dtype : data-type, optional
Type to use in computing the mean. For integer inputs, the default
is <code>float64</code>; for floating point inputs, it is the same as the
input dtype.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_72">Returns<a class="headerlink" href="#returns_72" title="Permanent link">&para;</a></h2>
<p>m : np.matrix</p>
<h2 id="see-also_53">See Also<a class="headerlink" href="#see-also_53" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.mean : NumPy's implementation of 'mean' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise minimum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">multiply</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Point-wise multiplication by another matrix</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nonzero indices</p>
<p>Returns a tuple of arrays (row,col) containing the indices
of the non-zero elements of the matrix.</p>
<h2 id="examples_28">Examples<a class="headerlink" href="#examples_28" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])
A.nonzero()
(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">power</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise power.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>reshape(self, shape, order='C', copy=False)</p>
<p>Gives a new shape to a sparse matrix without changing its data.</p>
<h2 id="parameters_113">Parameters<a class="headerlink" href="#parameters_113" title="Permanent link">&para;</a></h2>
<p>shape : length-2 tuple of ints
The new shape should be compatible with the original shape.
order : {'C', 'F'}, optional
Read the elements using this index order. 'C' means to read and
write the elements using C-like index order; e.g. read entire first
row, then second row, etc. 'F' means to read and write the elements
using Fortran-like index order; e.g. read entire first column, then
second column, etc.
copy : bool, optional
Indicates whether or not attributes of self should be copied
whenever possible. The degree to which attributes are copied varies
depending on the type of sparse matrix being used.</p>
<h2 id="returns_73">Returns<a class="headerlink" href="#returns_73" title="Permanent link">&para;</a></h2>
<p>reshaped_matrix : sparse matrix
A sparse matrix with the given <code>shape</code>, not necessarily of the same
format as the current object.</p>
<h2 id="see-also_54">See Also<a class="headerlink" href="#see-also_54" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.reshape : NumPy's implementation of 'reshape' for
matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resize</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Resize the matrix in-place to dimensions given by <code>shape</code></p>
<p>Any elements that lie within the new shape will remain at the same
indices, while non-zero elements lying outside the new shape are
removed.</p>
<h2 id="parameters_114">Parameters<a class="headerlink" href="#parameters_114" title="Permanent link">&para;</a></h2>
<p>shape : (int, int)
number of rows and columns in the new matrix</p>
<h2 id="notes_13">Notes<a class="headerlink" href="#notes_13" title="Permanent link">&para;</a></h2>
<p>The semantics are not identical to <code>numpy.ndarray.resize</code> or
<code>numpy.resize</code>.  Here, the same data will be maintained at each index
before and after reshape, if that index is within the new bounds.  In
numpy, resizing maintains contiguity of the array, moving elements
around in the logical matrix but not within a flattened representation.</p>
<p>We give no guarantees about whether the underlying data attributes
(arrays, etc.) will be modified in place or replaced with new objects.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_shape</span> <span class="o">:</span> <span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>See <code>reshape</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setdiag</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">values</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Set diagonal or off-diagonal elements of the array.</p>
<h2 id="parameters_115">Parameters<a class="headerlink" href="#parameters_115" title="Permanent link">&para;</a></h2>
<p>values : array_like
New values of the diagonal elements.</p>
<p>Values may have any length.  If the diagonal is longer than values,
then the remaining diagonal entries will not be set.  If values if
longer than the diagonal, then the remaining values are ignored.</p>
<p>If a scalar value is given, all of the diagonal is set to it.</p>
<p>k : int, optional
Which off-diagonal to set, corresponding to elements a[i,i+k].
Default: 0 (the main diagonal).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sum the matrix elements over a given axis.</p>
<h2 id="parameters_116">Parameters<a class="headerlink" href="#parameters_116" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the sum of all the matrix elements, returning a scalar
(i.e. <code>axis</code> = <code>None</code>).
dtype : dtype, optional
The type of the returned matrix and of the accumulator in which
the elements are summed.  The dtype of <code>a</code> is used by default
unless <code>a</code> has an integer dtype of less precision than the default
platform integer.  In that case, if <code>a</code> is signed then the platform
integer is used while if <code>a</code> is unsigned then an unsigned integer
of the same precision as the platform integer is used.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_74">Returns<a class="headerlink" href="#returns_74" title="Permanent link">&para;</a></h2>
<p>sum_along_axis : np.matrix
A matrix with the same shape as <code>self</code>, with the specified
axis removed.</p>
<h2 id="see-also_55">See Also<a class="headerlink" href="#see-also_55" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.sum : NumPy's implementation of 'sum' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense ndarray representation of this matrix.</p>
<h2 id="parameters_117">Parameters<a class="headerlink" href="#parameters_117" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array as the output buffer
instead of allocating a new array to return. The provided
array must have the same shape and dtype as the sparse
matrix on which you are calling the method. For most
sparse types, <code>out</code> is required to be memory contiguous
(either C or Fortran ordered).</p>
<h2 id="returns_75">Returns<a class="headerlink" href="#returns_75" title="Permanent link">&para;</a></h2>
<p>arr : ndarray, 2-dimensional
An array with the same shape and containing the same
data represented by the sparse matrix, with the requested
memory order. If <code>out</code> was passed, the same object is
returned after being modified in-place to contain the
appropriate values.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tobsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">blocksize</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Block Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant bsr_matrix.</p>
<p>When blocksize=(R, C) is provided, it will be used for construction of
the bsr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocoo</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to COOrdinate format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant coo_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsc</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Column format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csc_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense matrix representation of this matrix.</p>
<h2 id="parameters_118">Parameters<a class="headerlink" href="#parameters_118" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array (or <code>numpy.matrix</code>) as the
output buffer instead of allocating a new array to
return. The provided array must have the same shape and
dtype as the sparse matrix on which you are calling the
method.</p>
<h2 id="returns_76">Returns<a class="headerlink" href="#returns_76" title="Permanent link">&para;</a></h2>
<p>arr : numpy.matrix, 2-dimensional
A NumPy matrix object with the same shape and containing
the same data represented by the sparse matrix, with the
requested memory order. If <code>out</code> was passed and was an
array (rather than a <code>numpy.matrix</code>), it will be filled
with the appropriate values and returned wrapped in a
<code>numpy.matrix</code> object that shares the same memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todia</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to sparse DIAgonal format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dia_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todok</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Dictionary Of Keys format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dok_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tolil</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to List of Lists format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant lil_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reverses the dimensions of the sparse matrix.</p>
<h2 id="parameters_119">Parameters<a class="headerlink" href="#parameters_119" title="Permanent link">&para;</a></h2>
<p>axes : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except
for the default value.
copy : bool, optional
Indicates whether or not attributes of <code>self</code> should be
copied whenever possible. The degree to which attributes
are copied varies depending on the type of sparse matrix
being used.</p>
<h2 id="returns_77">Returns<a class="headerlink" href="#returns_77" title="Permanent link">&para;</a></h2>
<p>p : <code>self</code> with the dimensions reversed.</p>
<h2 id="see-also_56">See Also<a class="headerlink" href="#see-also_56" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.transpose : NumPy's implementation of 'transpose'
for matrices</p>
<p>Attribute dtype: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute dtype: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute shape: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute shape: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute ndim: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute ndim: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndim_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute nnz: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute nnz: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnz_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute data: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute data: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute rows: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rows</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute rows: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rows_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Spmatrix</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Spmatrix</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArrayLike</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">maxprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>This class provides a base class for all sparse matrices.  It
cannot be instantiated.  Most of the work is provided by subclasses.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asformat</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">format</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return this matrix in the passed format.</p>
<h2 id="parameters_120">Parameters<a class="headerlink" href="#parameters_120" title="Permanent link">&para;</a></h2>
<p>format : {str, None}
The desired matrix format ('csr', 'csc', 'lil', 'dok', 'array', ...)
or None for no conversion.
copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_78">Returns<a class="headerlink" href="#returns_78" title="Permanent link">&para;</a></h2>
<p>A : This matrix in the passed format.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asfptype</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Upcast matrix to a floating point format (if necessary)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">astype</span> <span class="o">:</span> <span class="o">?</span><span class="n">casting</span><span class="o">:[`</span><span class="nc">No</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Equiv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Safe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same_kind</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Unsafe</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cast the matrix elements to a specified type.</p>
<h2 id="parameters_121">Parameters<a class="headerlink" href="#parameters_121" title="Permanent link">&para;</a></h2>
<p>dtype : string or numpy dtype
Typecode or data-type to which to cast the data.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
Controls what kind of data casting may occur.
Defaults to 'unsafe' for backwards compatibility.
'no' means the data types should not be cast at all.
'equiv' means only byte-order changes are allowed.
'safe' means only casts which can preserve values are allowed.
'same_kind' means only safe casts or casts within a kind,
like float64 to float32, are allowed.
'unsafe' means any data conversions may be done.
copy : bool, optional
If <code>copy</code> is <code>False</code>, the result might share some memory with this
matrix. If <code>copy</code> is <code>True</code>, it is guaranteed that the result and
this matrix do not share any memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conj</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_122">Parameters<a class="headerlink" href="#parameters_122" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_79">Returns<a class="headerlink" href="#returns_79" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjugate</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise complex conjugation.</p>
<p>If the matrix is of non-complex data type and <code>copy</code> is False,
this method does nothing and the data is not copied.</p>
<h2 id="parameters_123">Parameters<a class="headerlink" href="#parameters_123" title="Permanent link">&para;</a></h2>
<p>copy : bool, optional
If True, the result is guaranteed to not share data with self.</p>
<h2 id="returns_80">Returns<a class="headerlink" href="#returns_80" title="Permanent link">&para;</a></h2>
<p>A : The element-wise complex conjugate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">copy</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of this matrix.</p>
<p>No data/indices will be shared between the returned value and current
matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count_nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of non-zero entries, equivalent to</p>
<p>np.count_nonzero(a.toarray())</p>
<p>Unlike getnnz() and the nnz property, which return the number of stored
entries (the length of the data attribute), this method counts the
actual number of non-zero entries in data.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the k-th diagonal of the matrix.</p>
<h2 id="parameters_124">Parameters<a class="headerlink" href="#parameters_124" title="Permanent link">&para;</a></h2>
<p>k : int, optional
Which diagonal to get, corresponding to elements a[i, i+k].
Default: 0 (the main diagonal).</p>
<p>.. versionadded:: 1.0</p>
<h2 id="see-also_57">See also<a class="headerlink" href="#see-also_57" title="Permanent link">&para;</a></h2>
<p>numpy.diagonal : Equivalent numpy function.</p>
<h2 id="examples_29">Examples<a class="headerlink" href="#examples_29" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
A.diagonal()
array([1, 0, 5])
A.diagonal(k=1)
array([2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Ordinary dot product</p>
<h2 id="examples_30">Examples<a class="headerlink" href="#examples_30" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import csr_matrix
A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
v = np.array([1, 0, -1])
A.dot(v)
array([ 1, -3, -1], dtype=int64)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getH</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Hermitian transpose of this matrix.</p>
<h2 id="see-also_58">See Also<a class="headerlink" href="#see-also_58" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.getH : NumPy's implementation of <code>getH</code> for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_shape</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get shape of a matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getcol</span> <span class="o">:</span> <span class="n">j</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of column j of the matrix, as an (m x 1) sparse
matrix (column vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getformat</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Format of a matrix representation as a string.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getmaxprint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Maximum number of elements to display when printed.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getnnz</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of stored values, including explicit zeros.</p>
<h2 id="parameters_125">Parameters<a class="headerlink" href="#parameters_125" title="Permanent link">&para;</a></h2>
<p>axis : None, 0, or 1
Select between the number of values across the whole matrix, in
each column, or in each row.</p>
<h2 id="see-also_59">See also<a class="headerlink" href="#see-also_59" title="Permanent link">&para;</a></h2>
<p>count_nonzero : Number of non-zero entries</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getrow</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a copy of row i of the matrix, as a (1 x n) sparse
matrix (row vector).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise maximum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the matrix elements. The average is taken
over all elements in the matrix by default, otherwise over the
specified axis. <code>float64</code> intermediate and return values are used
for integer inputs.</p>
<h2 id="parameters_126">Parameters<a class="headerlink" href="#parameters_126" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the mean is computed. The default is to compute
the mean of all elements in the matrix (i.e. <code>axis</code> = <code>None</code>).
dtype : data-type, optional
Type to use in computing the mean. For integer inputs, the default
is <code>float64</code>; for floating point inputs, it is the same as the
input dtype.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_81">Returns<a class="headerlink" href="#returns_81" title="Permanent link">&para;</a></h2>
<p>m : np.matrix</p>
<h2 id="see-also_60">See Also<a class="headerlink" href="#see-also_60" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.mean : NumPy's implementation of 'mean' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise minimum between this and another matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">multiply</span> <span class="o">:</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Point-wise multiplication by another matrix</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nonzero indices</p>
<p>Returns a tuple of arrays (row,col) containing the indices
of the non-zero elements of the matrix.</p>
<h2 id="examples_31">Examples<a class="headerlink" href="#examples_31" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])
A.nonzero()
(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">power</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Element-wise power.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>reshape(self, shape, order='C', copy=False)</p>
<p>Gives a new shape to a sparse matrix without changing its data.</p>
<h2 id="parameters_127">Parameters<a class="headerlink" href="#parameters_127" title="Permanent link">&para;</a></h2>
<p>shape : length-2 tuple of ints
The new shape should be compatible with the original shape.
order : {'C', 'F'}, optional
Read the elements using this index order. 'C' means to read and
write the elements using C-like index order; e.g. read entire first
row, then second row, etc. 'F' means to read and write the elements
using Fortran-like index order; e.g. read entire first column, then
second column, etc.
copy : bool, optional
Indicates whether or not attributes of self should be copied
whenever possible. The degree to which attributes are copied varies
depending on the type of sparse matrix being used.</p>
<h2 id="returns_82">Returns<a class="headerlink" href="#returns_82" title="Permanent link">&para;</a></h2>
<p>reshaped_matrix : sparse matrix
A sparse matrix with the given <code>shape</code>, not necessarily of the same
format as the current object.</p>
<h2 id="see-also_61">See Also<a class="headerlink" href="#see-also_61" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.reshape : NumPy's implementation of 'reshape' for
matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resize</span> <span class="o">:</span> <span class="n">shape</span><span class="o">:(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Resize the matrix in-place to dimensions given by <code>shape</code></p>
<p>Any elements that lie within the new shape will remain at the same
indices, while non-zero elements lying outside the new shape are
removed.</p>
<h2 id="parameters_128">Parameters<a class="headerlink" href="#parameters_128" title="Permanent link">&para;</a></h2>
<p>shape : (int, int)
number of rows and columns in the new matrix</p>
<h2 id="notes_14">Notes<a class="headerlink" href="#notes_14" title="Permanent link">&para;</a></h2>
<p>The semantics are not identical to <code>numpy.ndarray.resize</code> or
<code>numpy.resize</code>.  Here, the same data will be maintained at each index
before and after reshape, if that index is within the new bounds.  In
numpy, resizing maintains contiguity of the array, moving elements
around in the logical matrix but not within a flattened representation.</p>
<p>We give no guarantees about whether the underlying data attributes
(arrays, etc.) will be modified in place or replaced with new objects.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_shape</span> <span class="o">:</span> <span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>See <code>reshape</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setdiag</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">values</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Set diagonal or off-diagonal elements of the array.</p>
<h2 id="parameters_129">Parameters<a class="headerlink" href="#parameters_129" title="Permanent link">&para;</a></h2>
<p>values : array_like
New values of the diagonal elements.</p>
<p>Values may have any length.  If the diagonal is longer than values,
then the remaining diagonal entries will not be set.  If values if
longer than the diagonal, then the remaining values are ignored.</p>
<p>If a scalar value is given, all of the diagonal is set to it.</p>
<p>k : int, optional
Which off-diagonal to set, corresponding to elements a[i,i+k].
Default: 0 (the main diagonal).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sum the matrix elements over a given axis.</p>
<h2 id="parameters_130">Parameters<a class="headerlink" href="#parameters_130" title="Permanent link">&para;</a></h2>
<p>axis : {-2, -1, 0, 1, None} optional
Axis along which the sum is computed. The default is to
compute the sum of all the matrix elements, returning a scalar
(i.e. <code>axis</code> = <code>None</code>).
dtype : dtype, optional
The type of the returned matrix and of the accumulator in which
the elements are summed.  The dtype of <code>a</code> is used by default
unless <code>a</code> has an integer dtype of less precision than the default
platform integer.  In that case, if <code>a</code> is signed then the platform
integer is used while if <code>a</code> is unsigned then an unsigned integer
of the same precision as the platform integer is used.</p>
<p>.. versionadded:: 0.18.0</p>
<p>out : np.matrix, optional
Alternative output matrix in which to place the result. It must
have the same shape as the expected output, but the type of the
output values will be cast if necessary.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_83">Returns<a class="headerlink" href="#returns_83" title="Permanent link">&para;</a></h2>
<p>sum_along_axis : np.matrix
A matrix with the same shape as <code>self</code>, with the specified
axis removed.</p>
<h2 id="see-also_62">See Also<a class="headerlink" href="#see-also_62" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.sum : NumPy's implementation of 'sum' for matrices</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense ndarray representation of this matrix.</p>
<h2 id="parameters_131">Parameters<a class="headerlink" href="#parameters_131" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array as the output buffer
instead of allocating a new array to return. The provided
array must have the same shape and dtype as the sparse
matrix on which you are calling the method. For most
sparse types, <code>out</code> is required to be memory contiguous
(either C or Fortran ordered).</p>
<h2 id="returns_84">Returns<a class="headerlink" href="#returns_84" title="Permanent link">&para;</a></h2>
<p>arr : ndarray, 2-dimensional
An array with the same shape and containing the same
data represented by the sparse matrix, with the requested
memory order. If <code>out</code> was passed, the same object is
returned after being modified in-place to contain the
appropriate values.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tobsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">blocksize</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Block Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant bsr_matrix.</p>
<p>When blocksize=(R, C) is provided, it will be used for construction of
the bsr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocoo</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to COOrdinate format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant coo_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsc</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Column format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csc_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tocsr</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Compressed Sparse Row format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant csr_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense matrix representation of this matrix.</p>
<h2 id="parameters_132">Parameters<a class="headerlink" href="#parameters_132" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F'}, optional
Whether to store multi-dimensional data in C (row-major)
or Fortran (column-major) order in memory. The default
is 'None', indicating the NumPy default of C-ordered.
Cannot be specified in conjunction with the <code>out</code>
argument.</p>
<p>out : ndarray, 2-dimensional, optional
If specified, uses this array (or <code>numpy.matrix</code>) as the
output buffer instead of allocating a new array to
return. The provided array must have the same shape and
dtype as the sparse matrix on which you are calling the
method.</p>
<h2 id="returns_85">Returns<a class="headerlink" href="#returns_85" title="Permanent link">&para;</a></h2>
<p>arr : numpy.matrix, 2-dimensional
A NumPy matrix object with the same shape and containing
the same data represented by the sparse matrix, with the
requested memory order. If <code>out</code> was passed and was an
array (rather than a <code>numpy.matrix</code>), it will be filled
with the appropriate values and returned wrapped in a
<code>numpy.matrix</code> object that shares the same memory.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todia</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to sparse DIAgonal format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dia_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todok</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to Dictionary Of Keys format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant dok_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tolil</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert this matrix to List of Lists format.</p>
<p>With copy=False, the data/indices may be shared between this matrix and
the resultant lil_matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reverses the dimensions of the sparse matrix.</p>
<h2 id="parameters_133">Parameters<a class="headerlink" href="#parameters_133" title="Permanent link">&para;</a></h2>
<p>axes : None, optional
This argument is in the signature <em>solely</em> for NumPy
compatibility reasons. Do not pass in anything except
for the default value.
copy : bool, optional
Indicates whether or not attributes of <code>self</code> should be
copied whenever possible. The degree to which attributes
are copied varies depending on the type of sparse matrix
being used.</p>
<h2 id="returns_86">Returns<a class="headerlink" href="#returns_86" title="Permanent link">&para;</a></h2>
<p>p : <code>self</code> with the dimensions reversed.</p>
<h2 id="see-also_63">See Also<a class="headerlink" href="#see-also_63" title="Permanent link">&para;</a></h2>
<p>numpy.matrix.transpose : NumPy's implementation of 'transpose'
for matrices</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Base</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">SparseFormatWarning</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">SparseFormatWarning</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SparseFormatWarning</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">asmatrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">broadcast_to</span> <span class="o">:</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="kt">array</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Broadcast an array to a new shape.</p>
<h2 id="parameters_134">Parameters<a class="headerlink" href="#parameters_134" title="Permanent link">&para;</a></h2>
<p>array : array_like
The array to broadcast.
shape : tuple
The shape of the desired array.
subok : bool, optional
If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).</p>
<h2 id="returns_87">Returns<a class="headerlink" href="#returns_87" title="Permanent link">&para;</a></h2>
<p>broadcast : array
A readonly view on the original array with the given shape. It is
typically not contiguous. Furthermore, more than one element of a
broadcasted array may refer to a single memory location.</p>
<h2 id="raises">Raises<a class="headerlink" href="#raises" title="Permanent link">&para;</a></h2>
<p>ValueError
If the array is not compatible with the new shape according to NumPy's
broadcasting rules.</p>
<h2 id="notes_15">Notes<a class="headerlink" href="#notes_15" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 1.10.0</p>
<h2 id="examples_32">Examples<a class="headerlink" href="#examples_32" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3])
np.broadcast_to(x, (3, 3))
array([[1, 2, 3],
[1, 2, 3],
[1, 2, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_reshape_kwargs</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Unpack keyword arguments for reshape function.</p>
<p>This is useful because keyword arguments after star arguments are not
allowed in Python 2, but star keyword arguments are. This function unpacks
'order' and 'copy' from the star keyword arguments (with defaults) and
throws an error for any remaining.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_shape</span> <span class="o">:</span> <span class="o">?</span><span class="n">current_shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Imitate numpy.matrix handling of shape arguments</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_sum_dtype</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Mimic numpy's casting for np.sum</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isdense</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isintlike</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x appropriate as an index into a sparse matrix? Returns True
if it can be cast safely to a machine int.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isscalarlike</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x either a scalar, an array scalar, or a 0-dim array?</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">issparse</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_135">Parameters<a class="headerlink" href="#parameters_135" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_88">Returns<a class="headerlink" href="#returns_88" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_16">Notes<a class="headerlink" href="#notes_16" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_33">Examples<a class="headerlink" href="#examples_33" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_136">Parameters<a class="headerlink" href="#parameters_136" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_89">Returns<a class="headerlink" href="#returns_89" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_17">Notes<a class="headerlink" href="#notes_17" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_34">Examples<a class="headerlink" href="#examples_34" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">validateaxis</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Bsr</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">check_shape</span> <span class="o">:</span> <span class="o">?</span><span class="n">current_shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Imitate numpy.matrix handling of shape arguments</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_index_dtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_contents</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Based on input (integer) arrays <code>a</code>, determine a suitable index data
type that can hold the data in the arrays.</p>
<h2 id="parameters_137">Parameters<a class="headerlink" href="#parameters_137" title="Permanent link">&para;</a></h2>
<p>arrays : tuple of array_like
Input arrays whose types/contents to check
maxval : float, optional
Maximum value needed
check_contents : bool, optional
Whether to check the values in the arrays and not just their types.
Default: False (check only the types)</p>
<h2 id="returns_90">Returns<a class="headerlink" href="#returns_90" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Suitable index data type (int32 or int64)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getdtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">default</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Function used to simplify argument processing.  If 'dtype' is not
specified (is None), returns a.dtype; otherwise returns a np.dtype
object created from the specified dtype argument.  If 'dtype' and 'a'
are both None, construct a data type out of the 'default' parameter.
Furthermore, 'dtype' must be in 'allowed' set.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">nonneg</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x a valid 2-tuple of dimensions?</p>
<p>If nonneg, also checks that the dimensions are non-negative.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_138">Parameters<a class="headerlink" href="#parameters_138" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_91">Returns<a class="headerlink" href="#returns_91" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_18">Notes<a class="headerlink" href="#notes_18" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_35">Examples<a class="headerlink" href="#examples_35" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_bsr</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a bsr_matrix type?</p>
<h2 id="parameters_139">Parameters<a class="headerlink" href="#parameters_139" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a bsr matrix</p>
<h2 id="returns_92">Returns<a class="headerlink" href="#returns_92" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a bsr matrix, False otherwise</p>
<h2 id="examples_36">Examples<a class="headerlink" href="#examples_36" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import bsr_matrix, isspmatrix_bsr
isspmatrix_bsr(bsr_matrix([[5]]))
True</p>
<p>from scipy.sparse import bsr_matrix, csr_matrix, isspmatrix_bsr
isspmatrix_bsr(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_native</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the nearest supported sparse dtype for the
combination of one or more types.</p>
<p>upcast(t0, t1, ..., tn) -&gt; T  where T is a supported dtype</p>
<h2 id="examples_37">Examples<a class="headerlink" href="#examples_37" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>upcast('int32')
<type 'numpy.int32'>
upcast('bool')
<type 'numpy.bool_'>
upcast('int32','float32')
<type 'numpy.float64'>
upcast('bool',complex,float)
<type 'numpy.complex128'></p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">warn</span> <span class="o">:</span> <span class="o">?</span><span class="n">category</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stacklevel</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">source</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">message</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Issue a warning, or maybe ignore it or raise an exception.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Compressed</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">IndexMixin</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IndexMixin</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IndexMixin</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>This class provides common dispatching and validation logic for indexing.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">setitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getcol</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of column i of the matrix, as a (m x 1) column vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getrow</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of row i of the matrix, as a (1 x n) row vector.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">asmatrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_shape</span> <span class="o">:</span> <span class="o">?</span><span class="n">current_shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Imitate numpy.matrix handling of shape arguments</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">downcast_intp_index</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Down-cast index array to np.intp dtype if it is of a larger dtype.</p>
<p>Raise an error if the array contains a value that is too large for
intp.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_index_dtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_contents</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Based on input (integer) arrays <code>a</code>, determine a suitable index data
type that can hold the data in the arrays.</p>
<h2 id="parameters_140">Parameters<a class="headerlink" href="#parameters_140" title="Permanent link">&para;</a></h2>
<p>arrays : tuple of array_like
Input arrays whose types/contents to check
maxval : float, optional
Maximum value needed
check_contents : bool, optional
Whether to check the values in the arrays and not just their types.
Default: False (check only the types)</p>
<h2 id="returns_93">Returns<a class="headerlink" href="#returns_93" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Suitable index data type (int32 or int64)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_sum_dtype</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Mimic numpy's casting for np.sum</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getdtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">default</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Function used to simplify argument processing.  If 'dtype' is not
specified (is None), returns a.dtype; otherwise returns a np.dtype
object created from the specified dtype argument.  If 'dtype' and 'a'
are both None, construct a data type out of the 'default' parameter.
Furthermore, 'dtype' must be in 'allowed' set.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isdense</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isintlike</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x appropriate as an index into a sparse matrix? Returns True
if it can be cast safely to a machine int.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isscalarlike</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x either a scalar, an array scalar, or a 0-dim array?</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">nonneg</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x a valid 2-tuple of dimensions?</p>
<p>If nonneg, also checks that the dimensions are non-negative.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_141">Parameters<a class="headerlink" href="#parameters_141" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_94">Returns<a class="headerlink" href="#returns_94" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_19">Notes<a class="headerlink" href="#notes_19" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_38">Examples<a class="headerlink" href="#examples_38" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_native</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the nearest supported sparse dtype for the
combination of one or more types.</p>
<p>upcast(t0, t1, ..., tn) -&gt; T  where T is a supported dtype</p>
<h2 id="examples_39">Examples<a class="headerlink" href="#examples_39" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>upcast('int32')
<type 'numpy.int32'>
upcast('bool')
<type 'numpy.bool_'>
upcast('int32','float32')
<type 'numpy.float64'>
upcast('bool',complex,float)
<type 'numpy.complex128'></p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast_char</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Same as <code>upcast</code> but taking dtype.char as input (faster).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">warn</span> <span class="o">:</span> <span class="o">?</span><span class="n">category</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stacklevel</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">source</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">message</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Issue a warning, or maybe ignore it or raise an exception.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Construct</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">block_diag</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">mats</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Build a block diagonal sparse matrix from provided matrices.</p>
<h2 id="parameters_142">Parameters<a class="headerlink" href="#parameters_142" title="Permanent link">&para;</a></h2>
<p>mats : sequence of matrices
Input matrices.
format : str, optional
The sparse format of the result (e.g. 'csr').  If not given, the matrix
is returned in 'coo' format.
dtype : dtype specifier, optional
The data-type of the output matrix.  If not given, the dtype is
determined from that of <code>blocks</code>.</p>
<h2 id="returns_95">Returns<a class="headerlink" href="#returns_95" title="Permanent link">&para;</a></h2>
<p>res : sparse matrix</p>
<h2 id="notes_20">Notes<a class="headerlink" href="#notes_20" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.11.0</p>
<h2 id="see-also_64">See Also<a class="headerlink" href="#see-also_64" title="Permanent link">&para;</a></h2>
<p>bmat, diags</p>
<h2 id="examples_40">Examples<a class="headerlink" href="#examples_40" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import coo_matrix, block_diag
A = coo_matrix([[1, 2], [3, 4]])
B = coo_matrix([[5], [6]])
C = coo_matrix([[7]])
block_diag((A, B, C)).toarray()
array([[1, 2, 0, 0],
[3, 4, 0, 0],
[0, 0, 5, 0],
[0, 0, 6, 0],
[0, 0, 0, 7]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bmat</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:[`</span><span class="nc">Lil</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bsr</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Csr</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Csc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Coo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dia</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dok</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">blocks</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Build a sparse matrix from sparse sub-blocks</p>
<h2 id="parameters_143">Parameters<a class="headerlink" href="#parameters_143" title="Permanent link">&para;</a></h2>
<p>blocks : array_like
Grid of sparse matrices with compatible shapes.
An entry of None implies an all-zero matrix.
format : {'bsr', 'coo', 'csc', 'csr', 'dia', 'dok', 'lil'}, optional
The sparse format of the result (e.g. 'csr').  By default an
appropriate sparse matrix format is returned.
This choice is subject to change.
dtype : dtype, optional
The data-type of the output matrix.  If not given, the dtype is
determined from that of <code>blocks</code>.</p>
<h2 id="returns_96">Returns<a class="headerlink" href="#returns_96" title="Permanent link">&para;</a></h2>
<p>bmat : sparse matrix</p>
<h2 id="see-also_65">See Also<a class="headerlink" href="#see-also_65" title="Permanent link">&para;</a></h2>
<p>block_diag, diags</p>
<h2 id="examples_41">Examples<a class="headerlink" href="#examples_41" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import coo_matrix, bmat
A = coo_matrix([[1, 2], [3, 4]])
B = coo_matrix([[5], [6]])
C = coo_matrix([[7]])
bmat([[A, B], [None, C]]).toarray()
array([[1, 2, 5],
[3, 4, 6],
[0, 0, 7]])</p>
<p>bmat([[A, None], [None, C]]).toarray()
array([[1, 2, 0],
[3, 4, 0],
[0, 0, 7]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diags</span> <span class="o">:</span> <span class="o">?</span><span class="n">offsets</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:[`</span><span class="nc">Lil</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Csr</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Csc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dia</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">diagonals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a sparse matrix from diagonals.</p>
<h2 id="parameters_144">Parameters<a class="headerlink" href="#parameters_144" title="Permanent link">&para;</a></h2>
<p>diagonals : sequence of array_like
Sequence of arrays containing the matrix diagonals,
corresponding to <code>offsets</code>.
offsets : sequence of int or an int, optional
Diagonals to set:
- k = 0  the main diagonal (default)
- k &gt; 0  the k-th upper diagonal
- k &lt; 0  the k-th lower diagonal
shape : tuple of int, optional
Shape of the result. If omitted, a square matrix large enough
to contain the diagonals is returned.
format : {'dia', 'csr', 'csc', 'lil', ...}, optional
Matrix format of the result.  By default (format=None) an
appropriate sparse matrix format is returned.  This choice is
subject to change.
dtype : dtype, optional
Data type of the matrix.</p>
<h2 id="see-also_66">See Also<a class="headerlink" href="#see-also_66" title="Permanent link">&para;</a></h2>
<p>spdiags : construct matrix from diagonals</p>
<h2 id="notes_21">Notes<a class="headerlink" href="#notes_21" title="Permanent link">&para;</a></h2>
<p>This function differs from <code>spdiags</code> in the way it handles
off-diagonals.</p>
<p>The result from <code>diags</code> is the sparse equivalent of::</p>
<p>np.diag(diagonals[0], offsets[0])
+ ...
+ np.diag(diagonals[k], offsets[k])</p>
<p>Repeated diagonal offsets are disallowed.</p>
<p>.. versionadded:: 0.11</p>
<h2 id="examples_42">Examples<a class="headerlink" href="#examples_42" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import diags
diagonals = [[1, 2, 3, 4], [1, 2, 3], [1, 2]]
diags(diagonals, [0, -1, 2]).toarray()
array([[1, 0, 1, 0],
[1, 2, 0, 2],
[0, 2, 3, 0],
[0, 0, 3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Broadcasting of scalars is supported (but shape needs to be
specified):</p>
<blockquote>
<blockquote>
<blockquote>
<p>diags([1, -2, 1], [-1, 0, 1], shape=(4, 4)).toarray()
array([[-2.,  1.,  0.,  0.],
[ 1., -2.,  1.,  0.],
[ 0.,  1., -2.,  1.],
[ 0.,  0.,  1., -2.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>If only one diagonal is wanted (as in <code>numpy.diag</code>), the following
works as well:</p>
<blockquote>
<blockquote>
<blockquote>
<p>diags([1, 2, 3], 1).toarray()
array([[ 0.,  1.,  0.,  0.],
[ 0.,  0.,  2.,  0.],
[ 0.,  0.,  0.,  3.],
[ 0.,  0.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eye</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sparse matrix with ones on diagonal</p>
<p>Returns a sparse (m x n) matrix where the k-th diagonal
is all ones and everything else is zeros.</p>
<h2 id="parameters_145">Parameters<a class="headerlink" href="#parameters_145" title="Permanent link">&para;</a></h2>
<p>m : int
Number of rows in the matrix.
n : int, optional
Number of columns. Default: <code>m</code>.
k : int, optional
Diagonal to place ones on. Default: 0 (main diagonal).
dtype : dtype, optional
Data type of the matrix.
format : str, optional
Sparse format of the result, e.g. format='csr', etc.</p>
<h2 id="examples_43">Examples<a class="headerlink" href="#examples_43" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import sparse
sparse.eye(3).toarray()
array([[ 1.,  0.,  0.],
[ 0.,  1.,  0.],
[ 0.,  0.,  1.]])
sparse.eye(3, dtype=np.int8)
&lt;3x3 sparse matrix of type '<class 'numpy.int8'>'
with 3 stored elements (1 diagonals) in DIAgonal format&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_index_dtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_contents</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Based on input (integer) arrays <code>a</code>, determine a suitable index data
type that can hold the data in the arrays.</p>
<h2 id="parameters_146">Parameters<a class="headerlink" href="#parameters_146" title="Permanent link">&para;</a></h2>
<p>arrays : tuple of array_like
Input arrays whose types/contents to check
maxval : float, optional
Maximum value needed
check_contents : bool, optional
Whether to check the values in the arrays and not just their types.
Default: False (check only the types)</p>
<h2 id="returns_97">Returns<a class="headerlink" href="#returns_97" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Suitable index data type (int32 or int64)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_randint</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hstack</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">blocks</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Stack sparse matrices horizontally (column wise)</p>
<h2 id="parameters_147">Parameters<a class="headerlink" href="#parameters_147" title="Permanent link">&para;</a></h2>
<p>blocks
sequence of sparse matrices with compatible shapes
format : str
sparse format of the result (e.g. 'csr')
by default an appropriate sparse matrix format is returned.
This choice is subject to change.
dtype : dtype, optional
The data-type of the output matrix.  If not given, the dtype is
determined from that of <code>blocks</code>.</p>
<h2 id="see-also_67">See Also<a class="headerlink" href="#see-also_67" title="Permanent link">&para;</a></h2>
<p>vstack : stack sparse matrices vertically (row wise)</p>
<h2 id="examples_44">Examples<a class="headerlink" href="#examples_44" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import coo_matrix, hstack
A = coo_matrix([[1, 2], [3, 4]])
B = coo_matrix([[5], [6]])
hstack([A,B]).toarray()
array([[1, 2, 5],
[3, 4, 6]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">identity</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Identity matrix in sparse format</p>
<p>Returns an identity matrix with shape (n,n) using a given
sparse format and dtype.</p>
<h2 id="parameters_148">Parameters<a class="headerlink" href="#parameters_148" title="Permanent link">&para;</a></h2>
<p>n : int
Shape of the identity matrix.
dtype : dtype, optional
Data type of the matrix
format : str, optional
Sparse format of the result, e.g. format='csr', etc.</p>
<h2 id="examples_45">Examples<a class="headerlink" href="#examples_45" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import identity
identity(3).toarray()
array([[ 1.,  0.,  0.],
[ 0.,  1.,  0.],
[ 0.,  0.,  1.]])
identity(3, dtype='int8', format='dia')
&lt;3x3 sparse matrix of type '<class 'numpy.int8'>'
with 3 stored elements (1 diagonals) in DIAgonal format&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isscalarlike</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x either a scalar, an array scalar, or a 0-dim array?</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">issparse</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_149">Parameters<a class="headerlink" href="#parameters_149" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_98">Returns<a class="headerlink" href="#returns_98" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_22">Notes<a class="headerlink" href="#notes_22" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_46">Examples<a class="headerlink" href="#examples_46" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kron</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kronecker product of sparse matrices A and B</p>
<h2 id="parameters_150">Parameters<a class="headerlink" href="#parameters_150" title="Permanent link">&para;</a></h2>
<p>A : sparse or dense matrix
first matrix of the product
B : sparse or dense matrix
second matrix of the product
format : str, optional
format of the result (e.g. 'csr')</p>
<h2 id="returns_99">Returns<a class="headerlink" href="#returns_99" title="Permanent link">&para;</a></h2>
<p>kronecker product in a sparse matrix format</p>
<h2 id="examples_47">Examples<a class="headerlink" href="#examples_47" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import sparse
A = sparse.csr_matrix(np.array([[0, 2], [5, 0]]))
B = sparse.csr_matrix(np.array([[1, 2], [3, 4]]))
sparse.kron(A, B).toarray()
array([[ 0,  0,  2,  4],
[ 0,  0,  6,  8],
[ 5, 10,  0,  0],
[15, 20,  0,  0]])</p>
<p>sparse.kron(A, [[1, 2], [3, 4]]).toarray()
array([[ 0,  0,  2,  4],
[ 0,  0,  6,  8],
[ 5, 10,  0,  0],
[15, 20,  0,  0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kronsum</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kronecker sum of sparse matrices A and B</p>
<p>Kronecker sum of two sparse matrices is a sum of two Kronecker
products kron(I_n,A) + kron(B,I_m) where A has shape (m,m)
and B has shape (n,n) and I_m and I_n are identity matrices
of shape (m,m) and (n,n) respectively.</p>
<h2 id="parameters_151">Parameters<a class="headerlink" href="#parameters_151" title="Permanent link">&para;</a></h2>
<p>A
square matrix
B
square matrix
format : str
format of the result (e.g. 'csr')</p>
<h2 id="returns_100">Returns<a class="headerlink" href="#returns_100" title="Permanent link">&para;</a></h2>
<p>kronecker sum in a sparse matrix format</p>
<h2 id="examples_48">Examples<a class="headerlink" href="#examples_48" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rand</span> <span class="o">:</span> <span class="o">?</span><span class="n">density</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">random_state</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Numpy_random_RandomState</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Generate a sparse matrix of the given shape and density with uniformly
distributed values.</p>
<h2 id="parameters_152">Parameters<a class="headerlink" href="#parameters_152" title="Permanent link">&para;</a></h2>
<p>m, n : int
shape of the matrix
density : real, optional
density of the generated matrix: density equal to one means a full
matrix, density of 0 means a matrix with no non-zero items.
format : str, optional
sparse matrix format.
dtype : dtype, optional
type of the returned matrix values.
random_state : {numpy.random.RandomState, int}, optional
Random number generator or random seed. If not given, the singleton
numpy.random will be used.</p>
<h2 id="returns_101">Returns<a class="headerlink" href="#returns_101" title="Permanent link">&para;</a></h2>
<p>res : sparse matrix</p>
<h2 id="notes_23">Notes<a class="headerlink" href="#notes_23" title="Permanent link">&para;</a></h2>
<p>Only float types are supported for now.</p>
<h2 id="see-also_68">See Also<a class="headerlink" href="#see-also_68" title="Permanent link">&para;</a></h2>
<p>scipy.sparse.random : Similar function that allows a user-specified random
data source.</p>
<h2 id="examples_49">Examples<a class="headerlink" href="#examples_49" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import rand
matrix = rand(3, 4, density=0.25, format='csr', random_state=42)
matrix
&lt;3x4 sparse matrix of type '<class 'numpy.float64'>'
with 3 stored elements in Compressed Sparse Row format&gt;
matrix.todense()
matrix([[0.05641158, 0.        , 0.        , 0.65088847],
[0.        , 0.        , 0.        , 0.14286682],
[0.        , 0.        , 0.        , 0.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">random</span> <span class="o">:</span> <span class="o">?</span><span class="n">density</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">random_state</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Numpy_random_RandomState</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">data_rvs</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Generate a sparse matrix of the given shape and density with randomly
distributed values.</p>
<h2 id="parameters_153">Parameters<a class="headerlink" href="#parameters_153" title="Permanent link">&para;</a></h2>
<p>m, n : int
shape of the matrix
density : real, optional
density of the generated matrix: density equal to one means a full
matrix, density of 0 means a matrix with no non-zero items.
format : str, optional
sparse matrix format.
dtype : dtype, optional
type of the returned matrix values.
random_state : {numpy.random.RandomState, int}, optional
Random number generator or random seed. If not given, the singleton
numpy.random will be used.  This random state will be used
for sampling the sparsity structure, but not necessarily for sampling
the values of the structurally nonzero entries of the matrix.
data_rvs : callable, optional
Samples a requested number of random values.
This function should take a single argument specifying the length
of the ndarray that it will return.  The structurally nonzero entries
of the sparse random matrix will be taken from the array sampled
by this function.  By default, uniform [0, 1) random values will be
sampled using the same random state as is used for sampling
the sparsity structure.</p>
<h2 id="returns_102">Returns<a class="headerlink" href="#returns_102" title="Permanent link">&para;</a></h2>
<p>res : sparse matrix</p>
<h2 id="notes_24">Notes<a class="headerlink" href="#notes_24" title="Permanent link">&para;</a></h2>
<p>Only float types are supported for now.</p>
<h2 id="examples_50">Examples<a class="headerlink" href="#examples_50" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import random
from scipy import stats</p>
<p>class CustomRandomState(np.random.RandomState):
...     def randint(self, k):
...         i = np.random.randint(k)
...         return i - i % 2
np.random.seed(12345)
rs = CustomRandomState()
rvs = stats.poisson(25, loc=10).rvs
S = random(3, 4, density=0.25, random_state=rs, data_rvs=rvs)
S.A
array([[ 36.,   0.,  33.,   0.],   # random
[  0.,   0.,   0.,   0.],
[  0.,   0.,  36.,   0.]])</p>
<p>from scipy.sparse import random
from scipy.stats import rv_continuous
class CustomDistribution(rv_continuous):
...     def _rvs(self, <em>args, </em><em>kwargs):
...         return self._random_state.randn( </em>self._size)
X = CustomDistribution(seed=2906)
Y = X()  # get a frozen version of the distribution
S = random(3, 4, density=0.25, random_state=2906, data_rvs=Y.rvs)
S.A
array([[ 0.        ,  0.        ,  0.        ,  0.        ],
[ 0.13569738,  1.9467163 , -0.81205367,  0.        ],
[ 0.        ,  0.        ,  0.        ,  0.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spdiags</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">diags</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a sparse matrix from diagonals.</p>
<h2 id="parameters_154">Parameters<a class="headerlink" href="#parameters_154" title="Permanent link">&para;</a></h2>
<p>data : array_like
matrix diagonals stored row-wise
diags : diagonals to set
- k = 0  the main diagonal
- k &gt; 0  the k-th upper diagonal
- k &lt; 0  the k-th lower diagonal
m, n : int
shape of the result
format : str, optional
Format of the result. By default (format=None) an appropriate sparse
matrix format is returned.  This choice is subject to change.</p>
<h2 id="see-also_69">See Also<a class="headerlink" href="#see-also_69" title="Permanent link">&para;</a></h2>
<p>diags : more convenient form of this function
dia_matrix : the sparse DIAgonal format.</p>
<h2 id="examples_51">Examples<a class="headerlink" href="#examples_51" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import spdiags
data = np.array([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]])
diags = np.array([0, -1, 2])
spdiags(data, diags, 4, 4).toarray()
array([[1, 0, 3, 0],
[1, 2, 0, 4],
[0, 2, 3, 0],
[0, 0, 3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the nearest supported sparse dtype for the
combination of one or more types.</p>
<p>upcast(t0, t1, ..., tn) -&gt; T  where T is a supported dtype</p>
<h2 id="examples_52">Examples<a class="headerlink" href="#examples_52" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>upcast('int32')
<type 'numpy.int32'>
upcast('bool')
<type 'numpy.bool_'>
upcast('int32','float32')
<type 'numpy.float64'>
upcast('bool',complex,float)
<type 'numpy.complex128'></p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vstack</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">blocks</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Stack sparse matrices vertically (row wise)</p>
<h2 id="parameters_155">Parameters<a class="headerlink" href="#parameters_155" title="Permanent link">&para;</a></h2>
<p>blocks
sequence of sparse matrices with compatible shapes
format : str, optional
sparse format of the result (e.g. 'csr')
by default an appropriate sparse matrix format is returned.
This choice is subject to change.
dtype : dtype, optional
The data-type of the output matrix.  If not given, the dtype is
determined from that of <code>blocks</code>.</p>
<h2 id="see-also_70">See Also<a class="headerlink" href="#see-also_70" title="Permanent link">&para;</a></h2>
<p>hstack : stack sparse matrices horizontally (column wise)</p>
<h2 id="examples_53">Examples<a class="headerlink" href="#examples_53" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import coo_matrix, vstack
A = coo_matrix([[1, 2], [3, 4]])
B = coo_matrix([[5, 6]])
vstack([A, B]).toarray()
array([[1, 2],
[3, 4],
[5, 6]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Coo</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Izip</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Zip</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zip</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>zip( *iterables) --&gt; zip object</p>
<p>Return a zip object whose .<strong>next</strong>() method returns a tuple where
the i-th element comes from the i-th iterable argument.  The .<strong>next</strong>()
method continues until the shortest iterable in the argument sequence
is exhausted and then it raises StopIteration.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">check_reshape_kwargs</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Unpack keyword arguments for reshape function.</p>
<p>This is useful because keyword arguments after star arguments are not
allowed in Python 2, but star keyword arguments are. This function unpacks
'order' and 'copy' from the star keyword arguments (with defaults) and
throws an error for any remaining.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_shape</span> <span class="o">:</span> <span class="o">?</span><span class="n">current_shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Imitate numpy.matrix handling of shape arguments</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">downcast_intp_index</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Down-cast index array to np.intp dtype if it is of a larger dtype.</p>
<p>Raise an error if the array contains a value that is too large for
intp.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_index_dtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_contents</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Based on input (integer) arrays <code>a</code>, determine a suitable index data
type that can hold the data in the arrays.</p>
<h2 id="parameters_156">Parameters<a class="headerlink" href="#parameters_156" title="Permanent link">&para;</a></h2>
<p>arrays : tuple of array_like
Input arrays whose types/contents to check
maxval : float, optional
Maximum value needed
check_contents : bool, optional
Whether to check the values in the arrays and not just their types.
Default: False (check only the types)</p>
<h2 id="returns_103">Returns<a class="headerlink" href="#returns_103" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Suitable index data type (int32 or int64)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getdtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">default</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Function used to simplify argument processing.  If 'dtype' is not
specified (is None), returns a.dtype; otherwise returns a np.dtype
object created from the specified dtype argument.  If 'dtype' and 'a'
are both None, construct a data type out of the 'default' parameter.
Furthermore, 'dtype' must be in 'allowed' set.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">nonneg</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x a valid 2-tuple of dimensions?</p>
<p>If nonneg, also checks that the dimensions are non-negative.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_157">Parameters<a class="headerlink" href="#parameters_157" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_104">Returns<a class="headerlink" href="#returns_104" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_25">Notes<a class="headerlink" href="#notes_25" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_54">Examples<a class="headerlink" href="#examples_54" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_coo</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of coo_matrix type?</p>
<h2 id="parameters_158">Parameters<a class="headerlink" href="#parameters_158" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a coo matrix</p>
<h2 id="returns_105">Returns<a class="headerlink" href="#returns_105" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a coo matrix, False otherwise</p>
<h2 id="examples_55">Examples<a class="headerlink" href="#examples_55" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import coo_matrix, isspmatrix_coo
isspmatrix_coo(coo_matrix([[5]]))
True</p>
<p>from scipy.sparse import coo_matrix, csr_matrix, isspmatrix_coo
isspmatrix_coo(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_native</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the nearest supported sparse dtype for the
combination of one or more types.</p>
<p>upcast(t0, t1, ..., tn) -&gt; T  where T is a supported dtype</p>
<h2 id="examples_56">Examples<a class="headerlink" href="#examples_56" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>upcast('int32')
<type 'numpy.int32'>
upcast('bool')
<type 'numpy.bool_'>
upcast('int32','float32')
<type 'numpy.float64'>
upcast('bool',complex,float)
<type 'numpy.complex128'></p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast_char</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Same as <code>upcast</code> but taking dtype.char as input (faster).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">warn</span> <span class="o">:</span> <span class="o">?</span><span class="n">category</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stacklevel</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">source</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">message</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Issue a warning, or maybe ignore it or raise an exception.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Csc</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">get_index_dtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_contents</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Based on input (integer) arrays <code>a</code>, determine a suitable index data
type that can hold the data in the arrays.</p>
<h2 id="parameters_159">Parameters<a class="headerlink" href="#parameters_159" title="Permanent link">&para;</a></h2>
<p>arrays : tuple of array_like
Input arrays whose types/contents to check
maxval : float, optional
Maximum value needed
check_contents : bool, optional
Whether to check the values in the arrays and not just their types.
Default: False (check only the types)</p>
<h2 id="returns_106">Returns<a class="headerlink" href="#returns_106" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Suitable index data type (int32 or int64)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_csc</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of csc_matrix type?</p>
<h2 id="parameters_160">Parameters<a class="headerlink" href="#parameters_160" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a csc matrix</p>
<h2 id="returns_107">Returns<a class="headerlink" href="#returns_107" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a csc matrix, False otherwise</p>
<h2 id="examples_57">Examples<a class="headerlink" href="#examples_57" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix, isspmatrix_csc
isspmatrix_csc(csc_matrix([[5]]))
True</p>
<p>from scipy.sparse import csc_matrix, csr_matrix, isspmatrix_csc
isspmatrix_csc(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the nearest supported sparse dtype for the
combination of one or more types.</p>
<p>upcast(t0, t1, ..., tn) -&gt; T  where T is a supported dtype</p>
<h2 id="examples_58">Examples<a class="headerlink" href="#examples_58" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>upcast('int32')
<type 'numpy.int32'>
upcast('bool')
<type 'numpy.bool_'>
upcast('int32','float32')
<type 'numpy.float64'>
upcast('bool',complex,float)
<type 'numpy.complex128'></p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Csgraph</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">NegativeCycleError</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">NegativeCycleError</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">NegativeCycleError</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">message</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Common base class for all non-exit exceptions.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">bellman_ford</span> <span class="o">:</span> <span class="o">?</span><span class="n">directed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">indices</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_predecessors</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">unweighted</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">csgraph</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>bellman_ford(csgraph, directed=True, indices=None, return_predecessors=False,
unweighted=False)</p>
<p>Compute the shortest path lengths using the Bellman-Ford algorithm.</p>
<p>The Bellman-Ford algorithm can robustly deal with graphs with negative
weights.  If a negative cycle is detected, an error is raised.  For
graphs without negative edge weights, Dijkstra's algorithm may be faster.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_161">Parameters<a class="headerlink" href="#parameters_161" title="Permanent link">&para;</a></h2>
<p>csgraph : array, matrix, or sparse matrix, 2 dimensions
The N x N array of distances representing the input graph.
directed : bool, optional
If True (default), then find the shortest path on a directed graph:
only move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i]
indices : array_like or int, optional
if specified, only compute the paths from the points at the given
indices.
return_predecessors : bool, optional
If True, return the size (N, N) predecesor matrix
unweighted : bool, optional
If True, then find unweighted distances.  That is, rather than finding
the path between each point such that the sum of weights is minimized,
find the path such that the number of edges is minimized.</p>
<h2 id="returns_108">Returns<a class="headerlink" href="#returns_108" title="Permanent link">&para;</a></h2>
<p>dist_matrix : ndarray
The N x N matrix of distances between graph nodes. dist_matrix[i,j]
gives the shortest distance from point i to point j along the graph.</p>
<p>predecessors : ndarray
Returned only if return_predecessors == True.
The N x N matrix of predecessors, which can be used to reconstruct
the shortest paths.  Row i of the predecessor matrix contains
information on the shortest paths from point i: each entry
predecessors[i, j] gives the index of the previous node in the
path from point i to point j.  If no path exists between point
i and j, then predecessors[i, j] = -9999</p>
<h2 id="raises_1">Raises<a class="headerlink" href="#raises_1" title="Permanent link">&para;</a></h2>
<p>NegativeCycleError:
if there are negative cycles in the graph</p>
<h2 id="notes_26">Notes<a class="headerlink" href="#notes_26" title="Permanent link">&para;</a></h2>
<p>This routine is specially designed for graphs with negative edge weights.
If all edge weights are positive, then Dijkstra's algorithm is a better
choice.</p>
<h2 id="examples_59">Examples<a class="headerlink" href="#examples_59" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import bellman_ford</p>
<p>graph = [
... [0, 1 ,2, 0],
... [0, 0, 0, 1],
... [2, 0, 0, 3],
... [0, 0, 0, 0]
... ]
graph = csr_matrix(graph)
print(graph)
(0, 1)    1
(0, 2)    2
(1, 3)    1
(2, 0)    2
(2, 3)    3</p>
<p>dist_matrix, predecessors = bellman_ford(csgraph=graph, directed=False, indices=0, return_predecessors=True)
dist_matrix
array([ 0.,  1.,  2.,  2.])
predecessors
array([-9999,     0,     0,     1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">breadth_first_order</span> <span class="o">:</span> <span class="o">?</span><span class="n">directed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_predecessors</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">csgraph</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">i_start</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>breadth_first_order(csgraph, i_start, directed=True, return_predecessors=True)</p>
<p>Return a breadth-first ordering starting with specified node.</p>
<p>Note that a breadth-first order is not unique, but the tree which it
generates is unique.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_162">Parameters<a class="headerlink" href="#parameters_162" title="Permanent link">&para;</a></h2>
<p>csgraph : array_like or sparse matrix
The N x N compressed sparse graph.  The input csgraph will be
converted to csr format for the calculation.
i_start : int
The index of starting node.
directed : bool, optional
If True (default), then operate on a directed graph: only
move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].
return_predecessors : bool, optional
If True (default), then return the predecesor array (see below).</p>
<h2 id="returns_109">Returns<a class="headerlink" href="#returns_109" title="Permanent link">&para;</a></h2>
<p>node_array : ndarray, one dimension
The breadth-first list of nodes, starting with specified node.  The
length of node_array is the number of nodes reachable from the
specified node.
predecessors : ndarray, one dimension
Returned only if return_predecessors is True.
The length-N list of predecessors of each node in a breadth-first
tree.  If node i is in the tree, then its parent is given by
predecessors[i]. If node i is not in the tree (and for the parent
node) then predecessors[i] = -9999.</p>
<h2 id="examples_60">Examples<a class="headerlink" href="#examples_60" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import breadth_first_order</p>
<p>graph = [
... [0, 1 , 2, 0],
... [0, 0, 0, 1],
... [2, 0, 0, 3],
... [0, 0, 0, 0]
... ]
graph = csr_matrix(graph)
print(graph)
(0, 1)    1
(0, 2)    2
(1, 3)    1
(2, 0)    2
(2, 3)    3</p>
<p>breadth_first_order(graph,0)
(array([0, 1, 2, 3], dtype=int32), array([-9999,     0,     0,     1], dtype=int32))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">breadth_first_tree</span> <span class="o">:</span> <span class="o">?</span><span class="n">directed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">csgraph</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">i_start</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>breadth_first_tree(csgraph, i_start, directed=True)</p>
<p>Return the tree generated by a breadth-first search</p>
<p>Note that a breadth-first tree from a specified node is unique.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_163">Parameters<a class="headerlink" href="#parameters_163" title="Permanent link">&para;</a></h2>
<p>csgraph : array_like or sparse matrix
The N x N matrix representing the compressed sparse graph.  The input
csgraph will be converted to csr format for the calculation.
i_start : int
The index of starting node.
directed : bool, optional
If True (default), then operate on a directed graph: only
move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].</p>
<h2 id="returns_110">Returns<a class="headerlink" href="#returns_110" title="Permanent link">&para;</a></h2>
<p>cstree : csr matrix
The N x N directed compressed-sparse representation of the breadth-
first tree drawn from csgraph, starting at the specified node.</p>
<h2 id="examples_61">Examples<a class="headerlink" href="#examples_61" title="Permanent link">&para;</a></h2>
<p>The following example shows the computation of a depth-first tree
over a simple four-component graph, starting at node 0::</p>
<p>input graph          breadth first tree from (0)</p>
<p>(0)                         (0)
/   \                       /   \
3     8                     3     8
/       \                   /       \
(3)---5---(1)               (3)       (1)
\       /                           /
6     2                           2
\   /                           /
(2)                         (2)</p>
<p>In compressed sparse representation, the solution looks like this:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import breadth_first_tree
X = csr_matrix([[0, 8, 0, 3],
...                 [0, 0, 2, 5],
...                 [0, 0, 0, 6],
...                 [0, 0, 0, 0]])
Tcsr = breadth_first_tree(X, 0, directed=False)
Tcsr.toarray().astype(int)
array([[0, 8, 0, 3],
[0, 0, 2, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that the resulting graph is a Directed Acyclic Graph which spans
the graph.  A breadth-first tree from a given node is unique.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">connected_components</span> <span class="o">:</span> <span class="o">?</span><span class="n">directed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">connection</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_labels</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">csgraph</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>connected_components(csgraph, directed=True, connection='weak',
return_labels=True)</p>
<p>Analyze the connected components of a sparse graph</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_164">Parameters<a class="headerlink" href="#parameters_164" title="Permanent link">&para;</a></h2>
<p>csgraph : array_like or sparse matrix
The N x N matrix representing the compressed sparse graph.  The input
csgraph will be converted to csr format for the calculation.
directed : bool, optional
If True (default), then operate on a directed graph: only
move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].
connection : str, optional
['weak'|'strong'].  For directed graphs, the type of connection to
use.  Nodes i and j are strongly connected if a path exists both
from i to j and from j to i. A directed graph is weakly connected
if replacing all of its directed edges with undirected edges produces
a connected (undirected) graph. If directed == False, this keyword
is not referenced.
return_labels : bool, optional
If True (default), then return the labels for each of the connected
components.</p>
<h2 id="returns_111">Returns<a class="headerlink" href="#returns_111" title="Permanent link">&para;</a></h2>
<p>n_components: int
The number of connected components.
labels: ndarray
The length-N array of labels of the connected components.</p>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<p>.. [1] D. J. Pearce, 'An Improved Algorithm for Finding the Strongly
Connected Components of a Directed Graph', Technical Report, 2005</p>
<h2 id="examples_62">Examples<a class="headerlink" href="#examples_62" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import connected_components</p>
<p>graph = [
... [ 0, 1 , 1, 0 , 0 ],
... [ 0, 0 , 1 , 0 ,0 ],
... [ 0, 0, 0, 0, 0],
... [0, 0 , 0, 0, 1],
... [0, 0, 0, 0, 0]
... ]
graph = csr_matrix(graph)
print(graph)
(0, 1)    1
(0, 2)    1
(1, 2)    1
(3, 4)    1</p>
<p>n_components, labels = connected_components(csgraph=graph, directed=False, return_labels=True)
n_components
2
labels
array([0, 0, 0, 1, 1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">csgraph_from_dense</span> <span class="o">:</span> <span class="o">?</span><span class="n">null_value</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nan_null</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">infinity_null</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">graph</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>csgraph_from_dense(graph, null_value=0, nan_null=True, infinity_null=True)</p>
<p>Construct a CSR-format sparse graph from a dense matrix.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_165">Parameters<a class="headerlink" href="#parameters_165" title="Permanent link">&para;</a></h2>
<p>graph : array_like
Input graph.  Shape should be (n_nodes, n_nodes).
null_value : float or None (optional)
Value that denotes non-edges in the graph.  Default is zero.
infinity_null : bool
If True (default), then infinite entries (both positive and negative)
are treated as null edges.
nan_null : bool
If True (default), then NaN entries are treated as non-edges</p>
<h2 id="returns_112">Returns<a class="headerlink" href="#returns_112" title="Permanent link">&para;</a></h2>
<p>csgraph : csr_matrix
Compressed sparse representation of graph,</p>
<h2 id="examples_63">Examples<a class="headerlink" href="#examples_63" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.csgraph import csgraph_from_dense</p>
<p>graph = [
... [0, 1 , 2, 0],
... [0, 0, 0, 1],
... [0, 0, 0, 3],
... [0, 0, 0, 0]
... ]</p>
<p>csgraph_from_dense(graph)
&lt;4x4 sparse matrix of type '<class 'numpy.float64'>'
with 4 stored elements in Compressed Sparse Row format&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">csgraph_from_masked</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>csgraph_from_masked(graph)</p>
<p>Construct a CSR-format graph from a masked array.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_166">Parameters<a class="headerlink" href="#parameters_166" title="Permanent link">&para;</a></h2>
<p>graph : MaskedArray
Input graph.  Shape should be (n_nodes, n_nodes).</p>
<h2 id="returns_113">Returns<a class="headerlink" href="#returns_113" title="Permanent link">&para;</a></h2>
<p>csgraph : csr_matrix
Compressed sparse representation of graph,</p>
<h2 id="examples_64">Examples<a class="headerlink" href="#examples_64" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse.csgraph import csgraph_from_masked</p>
<p>graph_masked = np.ma.masked_array(data =[
... [0, 1 , 2, 0],
... [0, 0, 0, 1],
... [0, 0, 0, 3],
... [0, 0, 0, 0]
...  ],
... mask=[[ True, False, False , True],
... [ True,  True , True, False],
... [ True , True,  True ,False],
... [ True ,True , True , True]],
... fill_value = 0)</p>
<p>csgraph_from_masked(graph_masked)
&lt;4x4 sparse matrix of type '<class 'numpy.float64'>'
with 4 stored elements in Compressed Sparse Row format&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">csgraph_masked_from_dense</span> <span class="o">:</span> <span class="o">?</span><span class="n">null_value</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nan_null</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">infinity_null</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">graph</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>csgraph_masked_from_dense(graph, null_value=0, nan_null=True,
infinity_null=True, copy=True)</p>
<p>Construct a masked array graph representation from a dense matrix.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_167">Parameters<a class="headerlink" href="#parameters_167" title="Permanent link">&para;</a></h2>
<p>graph : array_like
Input graph.  Shape should be (n_nodes, n_nodes).
null_value : float or None (optional)
Value that denotes non-edges in the graph.  Default is zero.
infinity_null : bool
If True (default), then infinite entries (both positive and negative)
are treated as null edges.
nan_null : bool
If True (default), then NaN entries are treated as non-edges</p>
<h2 id="returns_114">Returns<a class="headerlink" href="#returns_114" title="Permanent link">&para;</a></h2>
<p>csgraph : MaskedArray
masked array representation of graph</p>
<h2 id="examples_65">Examples<a class="headerlink" href="#examples_65" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.csgraph import csgraph_masked_from_dense</p>
<p>graph = [
... [0, 1 , 2, 0],
... [0, 0, 0, 1],
... [0, 0, 0, 3],
... [0, 0, 0, 0]
... ]</p>
<p>csgraph_masked_from_dense(graph)
masked_array(
data=[[--, 1, 2, --],
[--, --, --, 1],
[--, --, --, 3],
[--, --, --, --]],
mask=[[ True, False, False,  True],
[ True,  True,  True, False],
[ True,  True,  True, False],
[ True,  True,  True,  True]],
fill_value=0)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">csgraph_to_dense</span> <span class="o">:</span> <span class="o">?</span><span class="n">null_value</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">csgraph</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>csgraph_to_dense(csgraph, null_value=0)</p>
<p>Convert a sparse graph representation to a dense representation</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_168">Parameters<a class="headerlink" href="#parameters_168" title="Permanent link">&para;</a></h2>
<p>csgraph : csr_matrix, csc_matrix, or lil_matrix
Sparse representation of a graph.
null_value : float, optional
The value used to indicate null edges in the dense representation.
Default is 0.</p>
<h2 id="returns_115">Returns<a class="headerlink" href="#returns_115" title="Permanent link">&para;</a></h2>
<p>graph : ndarray
The dense representation of the sparse graph.</p>
<h2 id="notes_27">Notes<a class="headerlink" href="#notes_27" title="Permanent link">&para;</a></h2>
<p>For normal sparse graph representations, calling csgraph_to_dense with
null_value=0 produces an equivalent result to using dense format
conversions in the main sparse package.  When the sparse representations
have repeated values, however, the results will differ.  The tools in
scipy.sparse will add repeating values to obtain a final value.  This
function will select the minimum among repeating values to obtain a
final value.  For example, here we'll create a two-node directed sparse
graph with multiple edges from node 0 to node 1, of weights 2 and 3.
This illustrates the difference in behavior:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, csgraph
data = np.array([2, 3])
indices = np.array([1, 1])
indptr = np.array([0, 2, 2])
M = csr_matrix((data, indices, indptr), shape=(2, 2))
M.toarray()
array([[0, 5],
[0, 0]])
csgraph.csgraph_to_dense(M)
array([[0., 2.],
[0., 0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The reason for this difference is to allow a compressed sparse graph to
represent multiple edges between any two nodes.  As most sparse graph
algorithms are concerned with the single lowest-cost edge between any
two nodes, the default scipy.sparse behavior of summming multiple weights
does not make sense in this context.</p>
<p>The other reason for using this routine is to allow for graphs with
zero-weight edges.  Let's look at the example of a two-node directed
graph, connected by an edge of weight zero:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, csgraph
data = np.array([0.0])
indices = np.array([1])
indptr = np.array([0, 1, 1])
M = csr_matrix((data, indices, indptr), shape=(2, 2))
M.toarray()
array([[0, 0],
[0, 0]])
csgraph.csgraph_to_dense(M, np.inf)
array([[ inf,   0.],
[ inf,  inf]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>In the first case, the zero-weight edge gets lost in the dense
representation.  In the second case, we can choose a different null value
and see the true form of the graph.</p>
<h2 id="examples_66">Examples<a class="headerlink" href="#examples_66" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import csgraph_to_dense</p>
<p>graph = csr_matrix( [
... [0, 1 , 2, 0],
... [0, 0, 0, 1],
... [0, 0, 0, 3],
... [0, 0, 0, 0]
... ])
graph
&lt;4x4 sparse matrix of type '<class 'numpy.int64'>'
with 4 stored elements in Compressed Sparse Row format&gt;</p>
<p>csgraph_to_dense(graph)
array([[ 0.,  1.,  2.,  0.],
[ 0.,  0.,  0.,  1.],
[ 0.,  0.,  0.,  3.],
[ 0.,  0.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">csgraph_to_masked</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>csgraph_to_masked(csgraph)</p>
<p>Convert a sparse graph representation to a masked array representation</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_169">Parameters<a class="headerlink" href="#parameters_169" title="Permanent link">&para;</a></h2>
<p>csgraph : csr_matrix, csc_matrix, or lil_matrix
Sparse representation of a graph.</p>
<h2 id="returns_116">Returns<a class="headerlink" href="#returns_116" title="Permanent link">&para;</a></h2>
<p>graph : MaskedArray
The masked dense representation of the sparse graph.</p>
<h2 id="examples_67">Examples<a class="headerlink" href="#examples_67" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import csgraph_to_masked</p>
<p>graph = csr_matrix( [
... [0, 1 , 2, 0],
... [0, 0, 0, 1],
... [0, 0, 0, 3],
... [0, 0, 0, 0]
... ])
graph
&lt;4x4 sparse matrix of type '<class 'numpy.int64'>'
with 4 stored elements in Compressed Sparse Row format&gt;</p>
<p>csgraph_to_masked(graph)
masked_array(
data=[[--, 1.0, 2.0, --],
[--, --, --, 1.0],
[--, --, --, 3.0],
[--, --, --, --]],
mask=[[ True, False, False,  True],
[ True,  True,  True, False],
[ True,  True,  True, False],
[ True,  True,  True,  True]],
fill_value=1e+20)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">depth_first_order</span> <span class="o">:</span> <span class="o">?</span><span class="n">directed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_predecessors</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">csgraph</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">i_start</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>depth_first_order(csgraph, i_start, directed=True, return_predecessors=True)</p>
<p>Return a depth-first ordering starting with specified node.</p>
<p>Note that a depth-first order is not unique.  Furthermore, for graphs
with cycles, the tree generated by a depth-first search is not
unique either.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_170">Parameters<a class="headerlink" href="#parameters_170" title="Permanent link">&para;</a></h2>
<p>csgraph : array_like or sparse matrix
The N x N compressed sparse graph.  The input csgraph will be
converted to csr format for the calculation.
i_start : int
The index of starting node.
directed : bool, optional
If True (default), then operate on a directed graph: only
move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].
return_predecessors : bool, optional
If True (default), then return the predecesor array (see below).</p>
<h2 id="returns_117">Returns<a class="headerlink" href="#returns_117" title="Permanent link">&para;</a></h2>
<p>node_array : ndarray, one dimension
The depth-first list of nodes, starting with specified node.  The
length of node_array is the number of nodes reachable from the
specified node.
predecessors : ndarray, one dimension
Returned only if return_predecessors is True.
The length-N list of predecessors of each node in a depth-first
tree.  If node i is in the tree, then its parent is given by
predecessors[i]. If node i is not in the tree (and for the parent
node) then predecessors[i] = -9999.</p>
<h2 id="examples_68">Examples<a class="headerlink" href="#examples_68" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import depth_first_order</p>
<p>graph = [
... [0, 1 , 2, 0],
... [0, 0, 0, 1],
... [2, 0, 0, 3],
... [0, 0, 0, 0]
... ]
graph = csr_matrix(graph)
print(graph)
(0, 1)    1
(0, 2)    2
(1, 3)    1
(2, 0)    2
(2, 3)    3</p>
<p>depth_first_order(graph,0)
(array([0, 1, 3, 2], dtype=int32), array([-9999,     0,     0,     1], dtype=int32))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">depth_first_tree</span> <span class="o">:</span> <span class="o">?</span><span class="n">directed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">csgraph</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">i_start</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>depth_first_tree(csgraph, i_start, directed=True)</p>
<p>Return a tree generated by a depth-first search.</p>
<p>Note that a tree generated by a depth-first search is not unique:
it depends on the order that the children of each node are searched.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_171">Parameters<a class="headerlink" href="#parameters_171" title="Permanent link">&para;</a></h2>
<p>csgraph : array_like or sparse matrix
The N x N matrix representing the compressed sparse graph.  The input
csgraph will be converted to csr format for the calculation.
i_start : int
The index of starting node.
directed : bool, optional
If True (default), then operate on a directed graph: only
move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].</p>
<h2 id="returns_118">Returns<a class="headerlink" href="#returns_118" title="Permanent link">&para;</a></h2>
<p>cstree : csr matrix
The N x N directed compressed-sparse representation of the depth-
first tree drawn from csgraph, starting at the specified node.</p>
<h2 id="examples_69">Examples<a class="headerlink" href="#examples_69" title="Permanent link">&para;</a></h2>
<p>The following example shows the computation of a depth-first tree
over a simple four-component graph, starting at node 0::</p>
<p>input graph           depth first tree from (0)</p>
<p>(0)                         (0)
/   \                           \
3     8                           8
/       \                           \
(3)---5---(1)               (3)       (1)
\       /                   \       /
6     2                     6     2
\   /                       \   /
(2)                         (2)</p>
<p>In compressed sparse representation, the solution looks like this:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import depth_first_tree
X = csr_matrix([[0, 8, 0, 3],
...                 [0, 0, 2, 5],
...                 [0, 0, 0, 6],
...                 [0, 0, 0, 0]])
Tcsr = depth_first_tree(X, 0, directed=False)
Tcsr.toarray().astype(int)
array([[0, 8, 0, 0],
[0, 0, 2, 0],
[0, 0, 0, 6],
[0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that the resulting graph is a Directed Acyclic Graph which spans
the graph.  Unlike a breadth-first tree, a depth-first tree of a given
graph is not unique if the graph contains cycles.  If the above solution
had begun with the edge connecting nodes 0 and 3, the result would have
been different.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">floyd_warshall</span> <span class="o">:</span> <span class="o">?</span><span class="n">directed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_predecessors</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">unweighted</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">csgraph</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>floyd_warshall(csgraph, directed=True, return_predecessors=False,
unweighted=False, overwrite=False)</p>
<p>Compute the shortest path lengths using the Floyd-Warshall algorithm</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_172">Parameters<a class="headerlink" href="#parameters_172" title="Permanent link">&para;</a></h2>
<p>csgraph : array, matrix, or sparse matrix, 2 dimensions
The N x N array of distances representing the input graph.
directed : bool, optional
If True (default), then find the shortest path on a directed graph:
only move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i]
return_predecessors : bool, optional
If True, return the size (N, N) predecesor matrix
unweighted : bool, optional
If True, then find unweighted distances.  That is, rather than finding
the path between each point such that the sum of weights is minimized,
find the path such that the number of edges is minimized.
overwrite : bool, optional
If True, overwrite csgraph with the result.  This applies only if
csgraph is a dense, c-ordered array with dtype=float64.</p>
<h2 id="returns_119">Returns<a class="headerlink" href="#returns_119" title="Permanent link">&para;</a></h2>
<p>dist_matrix : ndarray
The N x N matrix of distances between graph nodes. dist_matrix[i,j]
gives the shortest distance from point i to point j along the graph.</p>
<p>predecessors : ndarray
Returned only if return_predecessors == True.
The N x N matrix of predecessors, which can be used to reconstruct
the shortest paths.  Row i of the predecessor matrix contains
information on the shortest paths from point i: each entry
predecessors[i, j] gives the index of the previous node in the
path from point i to point j.  If no path exists between point
i and j, then predecessors[i, j] = -9999</p>
<h2 id="raises_2">Raises<a class="headerlink" href="#raises_2" title="Permanent link">&para;</a></h2>
<p>NegativeCycleError:
if there are negative cycles in the graph</p>
<h2 id="examples_70">Examples<a class="headerlink" href="#examples_70" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import floyd_warshall</p>
<p>graph = [
... [0, 1 , 2, 0],
... [0, 0, 0, 1],
... [2, 0, 0, 3],
... [0, 0, 0, 0]
... ]
graph = csr_matrix(graph)
print(graph)
(0, 1)    1
(0, 2)    2
(1, 3)    1
(2, 0)    2
(2, 3)    3</p>
<p>dist_matrix, predecessors = floyd_warshall(csgraph=graph, directed=False, return_predecessors=True)
dist_matrix
array([[ 0.,  1.,  2.,  2.],
[ 1.,  0.,  3.,  1.],
[ 2.,  3.,  0.,  3.],
[ 2.,  1.,  3.,  0.]])
predecessors
array([[-9999,     0,     0,     1],
[    1, -9999,     0,     1],
[    2,     0, -9999,     2],
[    1,     3,     3, -9999]], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">johnson</span> <span class="o">:</span> <span class="o">?</span><span class="n">directed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">indices</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_predecessors</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">unweighted</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">csgraph</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>johnson(csgraph, directed=True, indices=None, return_predecessors=False,
unweighted=False)</p>
<p>Compute the shortest path lengths using Johnson's algorithm.</p>
<p>Johnson's algorithm combines the Bellman-Ford algorithm and Dijkstra's
algorithm to quickly find shortest paths in a way that is robust to
the presence of negative cycles.  If a negative cycle is detected,
an error is raised.  For graphs without negative edge weights,
dijkstra may be faster.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_173">Parameters<a class="headerlink" href="#parameters_173" title="Permanent link">&para;</a></h2>
<p>csgraph : array, matrix, or sparse matrix, 2 dimensions
The N x N array of distances representing the input graph.
directed : bool, optional
If True (default), then find the shortest path on a directed graph:
only move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i]
indices : array_like or int, optional
if specified, only compute the paths from the points at the given
indices.
return_predecessors : bool, optional
If True, return the size (N, N) predecesor matrix
unweighted : bool, optional
If True, then find unweighted distances.  That is, rather than finding
the path between each point such that the sum of weights is minimized,
find the path such that the number of edges is minimized.</p>
<h2 id="returns_120">Returns<a class="headerlink" href="#returns_120" title="Permanent link">&para;</a></h2>
<p>dist_matrix : ndarray
The N x N matrix of distances between graph nodes. dist_matrix[i,j]
gives the shortest distance from point i to point j along the graph.</p>
<p>predecessors : ndarray
Returned only if return_predecessors == True.
The N x N matrix of predecessors, which can be used to reconstruct
the shortest paths.  Row i of the predecessor matrix contains
information on the shortest paths from point i: each entry
predecessors[i, j] gives the index of the previous node in the
path from point i to point j.  If no path exists between point
i and j, then predecessors[i, j] = -9999</p>
<h2 id="raises_3">Raises<a class="headerlink" href="#raises_3" title="Permanent link">&para;</a></h2>
<p>NegativeCycleError:
if there are negative cycles in the graph</p>
<h2 id="notes_28">Notes<a class="headerlink" href="#notes_28" title="Permanent link">&para;</a></h2>
<p>This routine is specially designed for graphs with negative edge weights.
If all edge weights are positive, then Dijkstra's algorithm is a better
choice.</p>
<h2 id="examples_71">Examples<a class="headerlink" href="#examples_71" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import johnson</p>
<p>graph = [
... [0, 1, 2, 0],
... [0, 0, 0, 1],
... [2, 0, 0, 3],
... [0, 0, 0, 0]
... ]
graph = csr_matrix(graph)
print(graph)
(0, 1)    1
(0, 2)    2
(1, 3)    1
(2, 0)    2
(2, 3)    3</p>
<p>dist_matrix, predecessors = johnson(csgraph=graph, directed=False, indices=0, return_predecessors=True)
dist_matrix
array([ 0.,  1.,  2.,  2.])
predecessors
array([-9999,     0,     0,     1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">laplacian</span> <span class="o">:</span> <span class="o">?</span><span class="n">normed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_diag</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">use_out_degree</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">csgraph</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return the Laplacian matrix of a directed graph.</p>
<h2 id="parameters_174">Parameters<a class="headerlink" href="#parameters_174" title="Permanent link">&para;</a></h2>
<p>csgraph : array_like or sparse matrix, 2 dimensions
compressed-sparse graph, with shape (N, N).
normed : bool, optional
If True, then compute symmetric normalized Laplacian.
return_diag : bool, optional
If True, then also return an array related to vertex degrees.
use_out_degree : bool, optional
If True, then use out-degree instead of in-degree.
This distinction matters only if the graph is asymmetric.
Default: False.</p>
<h2 id="returns_121">Returns<a class="headerlink" href="#returns_121" title="Permanent link">&para;</a></h2>
<p>lap : ndarray or sparse matrix
The N x N laplacian matrix of csgraph. It will be a numpy array (dense)
if the input was dense, or a sparse matrix otherwise.
diag : ndarray, optional
The length-N diagonal of the Laplacian matrix.
For the normalized Laplacian, this is the array of square roots
of vertex degrees or 1 if the degree is zero.</p>
<h2 id="notes_29">Notes<a class="headerlink" href="#notes_29" title="Permanent link">&para;</a></h2>
<p>The Laplacian matrix of a graph is sometimes referred to as the
'Kirchoff matrix' or the 'admittance matrix', and is useful in many
parts of spectral graph theory.  In particular, the eigen-decomposition
of the laplacian matrix can give insight into many properties of the graph.</p>
<h2 id="examples_72">Examples<a class="headerlink" href="#examples_72" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csgraph
G = np.arange(5) * np.arange(5)[:, np.newaxis]
G
array([[ 0,  0,  0,  0,  0],
[ 0,  1,  2,  3,  4],
[ 0,  2,  4,  6,  8],
[ 0,  3,  6,  9, 12],
[ 0,  4,  8, 12, 16]])
csgraph.laplacian(G, normed=False)
array([[  0,   0,   0,   0,   0],
[  0,   9,  -2,  -3,  -4],
[  0,  -2,  16,  -6,  -8],
[  0,  -3,  -6,  21, -12],
[  0,  -4,  -8, -12,  24]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum_bipartite_matching</span> <span class="o">:</span> <span class="o">?</span><span class="n">perm_type</span><span class="o">:[`</span><span class="nc">Row</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Column</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">graph</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>maximum_bipartite_matching(graph, perm_type='row')</p>
<p>Returns a matching of a bipartite graph whose cardinality is as least that
of any given matching of the graph.</p>
<h2 id="parameters_175">Parameters<a class="headerlink" href="#parameters_175" title="Permanent link">&para;</a></h2>
<p>graph : sparse matrix
Input sparse in CSR format whose rows represent one partition of the
graph and whose columns represent the other partition. An edge between
two vertices is indicated by the corresponding entry in the matrix
existing in its sparse representation.
perm_type : str, {'row', 'column'}
Which partition to return the matching in terms of: If <code>'row'</code>, the
function produces an array whose length is the number of columns in the
input, and whose :math:<code>j</code>'th element is the row matched to the
:math:<code>j</code>'th column. Conversely, if <code>perm_type</code> is <code>'column'</code>, this
returns the columns matched to each row.</p>
<h2 id="returns_122">Returns<a class="headerlink" href="#returns_122" title="Permanent link">&para;</a></h2>
<p>perm : ndarray
A matching of the vertices in one of the two partitions. Unmatched
vertices are represented by a <code>-1</code> in the result.</p>
<h2 id="notes_30">Notes<a class="headerlink" href="#notes_30" title="Permanent link">&para;</a></h2>
<p>This function implements the Hopcroft--Karp algorithm [1]_. Its time
complexity is :math:<code>O(\lvert E \rvert \sqrt{\lvert V \rvert})</code>, and its
space complexity is linear in the number of rows. In practice, this
asymmetry between rows and columns means that it can be more efficient to
transpose the input if it contains more columns than rows.</p>
<p>By Konig's theorem, the cardinality of the matching is also the number of
vertices appearing in a minimum vertex cover of the graph.</p>
<p>Note that if the sparse representation contains explicit zeros, these are
still counted as edges.</p>
<p>The implementation was changed in SciPy 1.4.0 to allow matching of general
bipartite graphs, where previous versions would assume that a perfect
matching existed. As such, code written against 1.4.0 will not necessarily
work on older versions.</p>
<h2 id="references_1">References<a class="headerlink" href="#references_1" title="Permanent link">&para;</a></h2>
<p>.. [1] John E. Hopcroft and Richard M. Karp. 'An n^{5 / 2} Algorithm for
Maximum Matchings in Bipartite Graphs' In: SIAM Journal of Computing
2.4 (1973), pp. 225--231. <a href="https://dx.doi.org/10.1137/0202019">https://dx.doi.org/10.1137/0202019</a>.</p>
<h2 id="examples_73">Examples<a class="headerlink" href="#examples_73" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import maximum_bipartite_matching</p>
</blockquote>
</blockquote>
</blockquote>
<p>As a simple example, consider a bipartite graph in which the partitions
contain 2 and 3 elements respectively. Suppose that one partition contains
vertices labelled 0 and 1, and that the other partition contains vertices
labelled A, B, and C. Suppose that there are edges connecting 0 and C,
1 and A, and 1 and B. This graph would then be represented by the following
sparse matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>graph = csr_matrix([[0, 0, 1], [1, 1, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Here, the 1s could be anything, as long as they end up being stored as
elements in the sparse matrix. We can now calculate maximum matchings as
follows:</p>
<blockquote>
<blockquote>
<blockquote>
<p>print(maximum_bipartite_matching(graph, perm_type='column'))
[2 0]
print(maximum_bipartite_matching(graph, perm_type='row'))
[ 1 -1  0]</p>
</blockquote>
</blockquote>
</blockquote>
<p>The first output tells us that 1 and 2 are matched with C and A
respectively, and the second output tells us that A, B, and C are matched
with 1, nothing, and 0 respectively.</p>
<p>Note that explicit zeros are still converted to edges. This means that a
different way to represent the above graph is by using the CSR structure
directly as follows:</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = [0, 0, 0]
indices = [2, 0, 1]
indptr = [0, 1, 3]
graph = csr_matrix((data, indices, indptr))
print(maximum_bipartite_matching(graph, perm_type='column'))
[2 0]
print(maximum_bipartite_matching(graph, perm_type='row'))
[ 1 -1  0]</p>
</blockquote>
</blockquote>
</blockquote>
<p>When one or both of the partitions are empty, the matching is empty as
well:</p>
<blockquote>
<blockquote>
<blockquote>
<p>graph = csr_matrix((2, 0))
print(maximum_bipartite_matching(graph, perm_type='column'))
[-1 -1]
print(maximum_bipartite_matching(graph, perm_type='row'))
[]</p>
</blockquote>
</blockquote>
</blockquote>
<p>When the input matrix is square, and the graph is known to admit a perfect
matching, i.e. a matching with the property that every vertex in the graph
belongs to some edge in the matching, then one can view the output as the
permutation of rows (or columns) turning the input matrix into one with the
property that all diagonal elements are non-empty:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [[0, 1, 2, 0], [1, 0, 0, 1], [2, 0, 0, 3], [0, 1, 3, 0]]
graph = csr_matrix(a)
perm = maximum_bipartite_matching(graph, perm_type='row')
print(graph[perm].toarray())
[[1 0 0 1]
[0 1 2 0]
[0 1 3 0]
[2 0 0 3]]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum_flow</span> <span class="o">:</span> <span class="n">csgraph</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">source</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">sink</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>maximum_flow(csgraph, source, sink)</p>
<p>Maximize the flow between two vertices in a graph.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="parameters_176">Parameters<a class="headerlink" href="#parameters_176" title="Permanent link">&para;</a></h2>
<p>csgraph : csr_matrix
The square matrix representing a directed graph whose (i, j)'th entry
is an integer representing the capacity of the edge between
vertices i and j.
source : int
The source vertex from which the flow flows.
sink : int
The sink vertex to which the flow flows.</p>
<h2 id="returns_123">Returns<a class="headerlink" href="#returns_123" title="Permanent link">&para;</a></h2>
<p>res : MaximumFlowResult
A maximum flow represented by a <code>MaximumFlowResult</code>
which includes the value of the flow in <code>flow_value</code>,
and the residual graph in <code>residual</code>.</p>
<h2 id="raises_4">Raises<a class="headerlink" href="#raises_4" title="Permanent link">&para;</a></h2>
<p>TypeError:
if the input graph is not in CSR format.</p>
<p>ValueError:
if the capacity values are not integers, or the source or sink are out
of bounds.</p>
<h2 id="notes_31">Notes<a class="headerlink" href="#notes_31" title="Permanent link">&para;</a></h2>
<p>This solves the maximum flow problem on a given directed weighted graph:
A flow associates to every edge a value, also called a flow, less than the
capacity of the edge, so that for every vertex (apart from the source and
the sink vertices), the total incoming flow is equal to the total outgoing
flow. The value of a flow is the sum of the flow of all edges leaving the
source vertex, and the maximum flow problem consists of finding a flow
whose value is maximal.</p>
<p>By the max-flow min-cut theorem, the maximal value of the flow is also the
total weight of the edges in a minimum cut.</p>
<p>To solve the problem, we use the Edmonds--Karp algorithm. [1]_ This
particular implementation strives to exploit sparsity. Its time complexity
is :math:<code>O(VE^2)</code> and its space complexity is :math:<code>O(E)</code>.</p>
<p>The maximum flow problem is usually defined with real valued capacities,
but we require that all capacities are integral to ensure convergence. When
dealing with rational capacities, or capacities belonging to
:math:<code>x\mathbb{Q}</code> for some fixed :math:<code>x \in \mathbb{R}</code>, it is possible
to reduce the problem to the integral case by scaling all capacities
accordingly.</p>
<h2 id="references_2">References<a class="headerlink" href="#references_2" title="Permanent link">&para;</a></h2>
<p>.. [1] Edmonds, J. and Karp, R. M.
Theoretical improvements in algorithmic efficiency for network flow
problems. 1972. Journal of the ACM. 19 (2): pp. 248-264
.. [2] Cormen, T. H. and Leiserson, C. E. and Rivest, R. L. and Stein C.
Introduction to Algorithms. Second Edition. 2001. MIT Press.</p>
<h2 id="examples_74">Examples<a class="headerlink" href="#examples_74" title="Permanent link">&para;</a></h2>
<p>Perhaps the simplest flow problem is that of a graph of only two vertices
with an edge from source (0) to sink (1)::</p>
<p>(0) --5--&gt; (1)</p>
<p>Here, the maximum flow is simply the capacity of the edge:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import maximum_flow
graph = csr_matrix([[0, 5], [0, 0]])
maximum_flow(graph, 0, 1).flow_value
5</p>
</blockquote>
</blockquote>
</blockquote>
<p>If, on the other hand, there is a bottleneck between source and sink, that
can reduce the maximum flow::</p>
<p>(0) --5--&gt; (1) --3--&gt; (2)</p>
<blockquote>
<blockquote>
<blockquote>
<p>graph = csr_matrix([[0, 5, 0], [0, 0, 3], [0, 0, 0]])
maximum_flow(graph, 0, 2).flow_value
3</p>
</blockquote>
</blockquote>
</blockquote>
<p>A less trivial example is given in [2]_, Chapter 26.1:</p>
<blockquote>
<blockquote>
<blockquote>
<p>graph = csr_matrix([[0, 16, 13,  0,  0,  0],
...                     [0, 10,  0, 12,  0,  0],
...                     [0,  4,  0,  0, 14,  0],
...                     [0,  0,  9,  0,  0, 20],
...                     [0,  0,  0,  7,  0,  4],
...                     [0,  0,  0,  0,  0,  0]])
maximum_flow(graph, 0, 5).flow_value
23</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is possible to reduce the problem of finding a maximum matching in a
bipartite graph to a maximum flow problem: Let :math:<code>G = ((U, V), E)</code> be a
bipartite graph. Then, add to the graph a source vertex with edges to every
vertex in :math:<code>U</code> and a sink vertex with edges from every vertex in
:math:<code>V</code>. Finally, give every edge in the resulting graph a capacity of 1.
Then, a maximum flow in the new graph gives a maximum matching in the
original graph consisting of the edges in :math:<code>E</code> whose flow is positive.</p>
<p>Assume that the edges are represented by a
:math:<code>\lvert U \rvert \times \lvert V \rvert</code> matrix in CSR format whose
:math:<code>(i, j)</code>'th entry is 1 if there is an edge from :math:<code>i \in U</code> to
:math:<code>j \in V</code> and 0 otherwise; that is, the input is of the form required
by :func:<code>maximum_bipartite_matching</code>. Then the CSR representation of the
graph constructed above contains this matrix as a block. Here's an example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>graph = csr_matrix([[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 1, 0]])
print(graph.toarray())
[[0 1 0 1]
[1 0 1 0]
[0 1 1 0]]
i, j = graph.shape
n = graph.nnz
indptr = np.concatenate([[0],
...                          graph.indptr + i,
...                          np.arange(n + i + 1, n + i + j + 1),
...                          [n + i + j]])
indices = np.concatenate([np.arange(1, i + 1),
...                           graph.indices + i + 1,
...                           np.repeat(i + j + 1, j)])
data = np.ones(n + i + j, dtype=int)</p>
<p>graph_flow = csr_matrix((data, indices, indptr))
print(graph_flow.toarray())
[[0 1 1 1 0 0 0 0 0]
[0 0 0 0 0 1 0 1 0]
[0 0 0 0 1 0 1 0 0]
[0 0 0 0 0 1 1 0 0]
[0 0 0 0 0 0 0 0 1]
[0 0 0 0 0 0 0 0 1]
[0 0 0 0 0 0 0 0 1]
[0 0 0 0 0 0 0 0 1]
[0 0 0 0 0 0 0 0 0]]</p>
</blockquote>
</blockquote>
</blockquote>
<p>At this point, we can find the maximum flow between the added sink and the
added source and the desired matching can be obtained by restricting the
residual graph to the block corresponding to the original graph:</p>
<blockquote>
<blockquote>
<blockquote>
<p>flow = maximum_flow(graph_flow, 0, i+j+1)
matching = flow.residual[1:i+1, i+1:i+j+1]
print(matching.toarray())
[[0 1 0 0]
[1 0 0 0]
[0 0 1 0]]</p>
</blockquote>
</blockquote>
</blockquote>
<p>This tells us that the first, second, and third vertex in :math:<code>U</code> are
matched with the second, first, and third vertex in :math:<code>V</code> respectively.</p>
<p>While this solves the maximum bipartite matching problem in general, note
that algorithms specialized to that problem will perform better. In
particular, :func:<code>maximum_bipartite_matching</code> will be faster when its
preconditions are met.</p>
<p>This approach can also be used to solve various common generalizations of
the maximum bipartite matching problem. If, for instance, some vertices can
be matched with more than one other vertex, this may be handled by
modifying the capacities of the new graph appropriately.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum_spanning_tree</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">csgraph</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>minimum_spanning_tree(csgraph, overwrite=False)</p>
<p>Return a minimum spanning tree of an undirected graph</p>
<p>A minimum spanning tree is a graph consisting of the subset of edges
which together connect all connected nodes, while minimizing the total
sum of weights on the edges.  This is computed using the Kruskal algorithm.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_177">Parameters<a class="headerlink" href="#parameters_177" title="Permanent link">&para;</a></h2>
<p>csgraph : array_like or sparse matrix, 2 dimensions
The N x N matrix representing an undirected graph over N nodes
(see notes below).
overwrite : bool, optional
if true, then parts of the input graph will be overwritten for
efficiency.</p>
<h2 id="returns_124">Returns<a class="headerlink" href="#returns_124" title="Permanent link">&para;</a></h2>
<p>span_tree : csr matrix
The N x N compressed-sparse representation of the undirected minimum
spanning tree over the input (see notes below).</p>
<h2 id="notes_32">Notes<a class="headerlink" href="#notes_32" title="Permanent link">&para;</a></h2>
<p>This routine uses undirected graphs as input and output.  That is, if
graph[i, j] and graph[j, i] are both zero, then nodes i and j do not
have an edge connecting them.  If either is nonzero, then the two are
connected by the minimum nonzero value of the two.</p>
<h2 id="examples_75">Examples<a class="headerlink" href="#examples_75" title="Permanent link">&para;</a></h2>
<p>The following example shows the computation of a minimum spanning tree
over a simple four-component graph::</p>
<p>input graph             minimum spanning tree</p>
<p>(0)                         (0)
/   \                       /
3     8                     3
/       \                   /
(3)---5---(1)               (3)---5---(1)
\       /                           /
6     2                           2
\   /                           /
(2)                         (2)</p>
<p>It is easy to see from inspection that the minimum spanning tree involves
removing the edges with weights 8 and 6.  In compressed sparse
representation, the solution looks like this:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import minimum_spanning_tree
X = csr_matrix([[0, 8, 0, 3],
...                 [0, 0, 2, 5],
...                 [0, 0, 0, 6],
...                 [0, 0, 0, 0]])
Tcsr = minimum_spanning_tree(X)
Tcsr.toarray().astype(int)
array([[0, 0, 0, 3],
[0, 0, 2, 5],
[0, 0, 0, 0],
[0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reconstruct_path</span> <span class="o">:</span> <span class="o">?</span><span class="n">directed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">csgraph</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">predecessors</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One_dimension</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>reconstruct_path(csgraph, predecessors, directed=True)</p>
<p>Construct a tree from a graph and a predecessor list.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_178">Parameters<a class="headerlink" href="#parameters_178" title="Permanent link">&para;</a></h2>
<p>csgraph : array_like or sparse matrix
The N x N matrix representing the directed or undirected graph
from which the predecessors are drawn.
predecessors : array_like, one dimension
The length-N array of indices of predecessors for the tree.  The
index of the parent of node i is given by predecessors[i].
directed : bool, optional
If True (default), then operate on a directed graph: only move from
point i to point j along paths csgraph[i, j].
If False, then operate on an undirected graph: the algorithm can
progress from point i to j along csgraph[i, j] or csgraph[j, i].</p>
<h2 id="returns_125">Returns<a class="headerlink" href="#returns_125" title="Permanent link">&para;</a></h2>
<p>cstree : csr matrix
The N x N directed compressed-sparse representation of the tree drawn
from csgraph which is encoded by the predecessor list.</p>
<h2 id="examples_76">Examples<a class="headerlink" href="#examples_76" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import reconstruct_path</p>
<p>graph = [
... [0, 1 , 2, 0],
... [0, 0, 0, 1],
... [0, 0, 0, 3],
... [0, 0, 0, 0]
... ]
graph = csr_matrix(graph)
print(graph)
(0, 1)    1
(0, 2)    2
(1, 3)    1
(2, 3)    3</p>
<p>pred = np.array([-9999, 0, 0, 1], dtype=np.int32)</p>
<p>cstree = reconstruct_path(csgraph=graph, predecessors=pred, directed=False)
cstree.todense()
matrix([[ 0.,  1.,  2.,  0.],
[ 0.,  0.,  0.,  1.],
[ 0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reverse_cuthill_mckee</span> <span class="o">:</span> <span class="o">?</span><span class="n">symmetric_mode</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">graph</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>reverse_cuthill_mckee(graph, symmetric_mode=False)</p>
<p>Returns the permutation array that orders a sparse CSR or CSC matrix
in Reverse-Cuthill McKee ordering.</p>
<p>It is assumed by default, <code>symmetric_mode=False</code>, that the input matrix
is not symmetric and works on the matrix <code>A+A.T</code>. If you are
guaranteed that the matrix is symmetric in structure (values of matrix
elements do not matter) then set <code>symmetric_mode=True</code>.</p>
<h2 id="parameters_179">Parameters<a class="headerlink" href="#parameters_179" title="Permanent link">&para;</a></h2>
<p>graph : sparse matrix
Input sparse in CSC or CSR sparse matrix format.
symmetric_mode : bool, optional
Is input matrix guaranteed to be symmetric.</p>
<h2 id="returns_126">Returns<a class="headerlink" href="#returns_126" title="Permanent link">&para;</a></h2>
<p>perm : ndarray
Array of permuted row and column indices.</p>
<h2 id="notes_33">Notes<a class="headerlink" href="#notes_33" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.15.0</p>
<h2 id="references_3">References<a class="headerlink" href="#references_3" title="Permanent link">&para;</a></h2>
<p>E. Cuthill and J. McKee, 'Reducing the Bandwidth of Sparse Symmetric Matrices',
ACM '69 Proceedings of the 1969 24th national conference, (1969).</p>
<h2 id="examples_77">Examples<a class="headerlink" href="#examples_77" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import reverse_cuthill_mckee</p>
<p>graph = [
... [0, 1 , 2, 0],
... [0, 0, 0, 1],
... [2, 0, 0, 3],
... [0, 0, 0, 0]
... ]
graph = csr_matrix(graph)
print(graph)
(0, 1)    1
(0, 2)    2
(1, 3)    1
(2, 0)    2
(2, 3)    3</p>
<p>reverse_cuthill_mckee(graph)
array([3, 2, 1, 0], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shortest_path</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">FW</span> <span class="o">|</span> <span class="o">`</span><span class="nc">D</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">directed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_predecessors</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">unweighted</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">indices</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">csgraph</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>shortest_path(csgraph, method='auto', directed=True, return_predecessors=False,
unweighted=False, overwrite=False, indices=None)</p>
<p>Perform a shortest-path graph search on a positive directed or
undirected graph.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="parameters_180">Parameters<a class="headerlink" href="#parameters_180" title="Permanent link">&para;</a></h2>
<p>csgraph : array, matrix, or sparse matrix, 2 dimensions
The N x N array of distances representing the input graph.
method : string ['auto'|'FW'|'D'], optional
Algorithm to use for shortest paths.  Options are:</p>
<p>'auto' -- (default) select the best among 'FW', 'D', 'BF', or 'J'
based on the input data.</p>
<p>'FW'   -- Floyd-Warshall algorithm.  Computational cost is
approximately <code>O[N^3]</code>.  The input csgraph will be
converted to a dense representation.</p>
<p>'D'    -- Dijkstra's algorithm with Fibonacci heaps.  Computational
cost is approximately <code>O[N(N*k + N*log(N))]</code>, where
<code>k</code> is the average number of connected edges per node.
The input csgraph will be converted to a csr
representation.</p>
<p>'BF'   -- Bellman-Ford algorithm.  This algorithm can be used when
weights are negative.  If a negative cycle is encountered,
an error will be raised.  Computational cost is
approximately <code>O[N(N^2 k)]</code>, where <code>k</code> is the average
number of connected edges per node. The input csgraph will
be converted to a csr representation.</p>
<p>'J'    -- Johnson's algorithm.  Like the Bellman-Ford algorithm,
Johnson's algorithm is designed for use when the weights
are negative.  It combines the Bellman-Ford algorithm
with Dijkstra's algorithm for faster computation.</p>
<p>directed : bool, optional
If True (default), then find the shortest path on a directed graph:
only move from point i to point j along paths csgraph[i, j].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i]
return_predecessors : bool, optional
If True, return the size (N, N) predecesor matrix
unweighted : bool, optional
If True, then find unweighted distances.  That is, rather than finding
the path between each point such that the sum of weights is minimized,
find the path such that the number of edges is minimized.
overwrite : bool, optional
If True, overwrite csgraph with the result.  This applies only if
method == 'FW' and csgraph is a dense, c-ordered array with
dtype=float64.
indices : array_like or int, optional
If specified, only compute the paths from the points at the given
indices. Incompatible with method == 'FW'.</p>
<h2 id="returns_127">Returns<a class="headerlink" href="#returns_127" title="Permanent link">&para;</a></h2>
<p>dist_matrix : ndarray
The N x N matrix of distances between graph nodes. dist_matrix[i,j]
gives the shortest distance from point i to point j along the graph.
predecessors : ndarray
Returned only if return_predecessors == True.
The N x N matrix of predecessors, which can be used to reconstruct
the shortest paths.  Row i of the predecessor matrix contains
information on the shortest paths from point i: each entry
predecessors[i, j] gives the index of the previous node in the
path from point i to point j.  If no path exists between point
i and j, then predecessors[i, j] = -9999</p>
<h2 id="raises_5">Raises<a class="headerlink" href="#raises_5" title="Permanent link">&para;</a></h2>
<p>NegativeCycleError:
if there are negative cycles in the graph</p>
<h2 id="notes_34">Notes<a class="headerlink" href="#notes_34" title="Permanent link">&para;</a></h2>
<p>As currently implemented, Dijkstra's algorithm and Johnson's algorithm
do not work for graphs with direction-dependent distances when
directed == False.  i.e., if csgraph[i,j] and csgraph[j,i] are non-equal
edges, method='D' may yield an incorrect result.</p>
<h2 id="examples_78">Examples<a class="headerlink" href="#examples_78" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import shortest_path</p>
<p>graph = [
... [0, 1, 2, 0],
... [0, 0, 0, 1],
... [2, 0, 0, 3],
... [0, 0, 0, 0]
... ]
graph = csr_matrix(graph)
print(graph)
(0, 1)    1
(0, 2)    2
(1, 3)    1
(2, 0)    2
(2, 3)    3</p>
<p>dist_matrix, predecessors = shortest_path(csgraph=graph, directed=False, indices=0, return_predecessors=True)
dist_matrix
array([ 0.,  1.,  2.,  2.])
predecessors
array([-9999,     0,     0,     1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">structural_rank</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>structural_rank(graph)</p>
<p>Compute the structural rank of a graph (matrix) with a given
sparsity pattern.</p>
<p>The structural rank of a matrix is the number of entries in the maximum
transversal of the corresponding bipartite graph, and is an upper bound
on the numerical rank of the matrix. A graph has full structural rank
if it is possible to permute the elements to make the diagonal zero-free.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="parameters_181">Parameters<a class="headerlink" href="#parameters_181" title="Permanent link">&para;</a></h2>
<p>graph : sparse matrix
Input sparse matrix.</p>
<h2 id="returns_128">Returns<a class="headerlink" href="#returns_128" title="Permanent link">&para;</a></h2>
<p>rank : int
The structural rank of the sparse graph.</p>
<h2 id="references_4">References<a class="headerlink" href="#references_4" title="Permanent link">&para;</a></h2>
<p>.. [1] I. S. Duff, 'Computing the Structural Index', SIAM J. Alg. Disc.
Meth., Vol. 7, 594 (1986).</p>
<p>.. [2] http://www.cise.ufl.edu/research/sparse/matrices/legend.html</p>
<h2 id="examples_79">Examples<a class="headerlink" href="#examples_79" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import structural_rank</p>
<p>graph = [
... [0, 1, 2, 0],
... [1, 0, 0, 1],
... [2, 0, 0, 3],
... [0, 1, 3, 0]
... ]
graph = csr_matrix(graph)
print(graph)
(0, 1)    1
(0, 2)    2
(1, 0)    1
(1, 3)    1
(2, 0)    2
(2, 3)    3
(3, 1)    1
(3, 2)    3</p>
<p>structural_rank(graph)
4</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Csr</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Xrange</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Range</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Range</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>range(stop) -&gt; range object
range(start, stop[, step]) -&gt; range object</p>
<p>Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rangeobject.count(value) -&gt; integer -- return number of occurrences of value</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">index</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rangeobject.index(value) -&gt; integer -- return index of value.
Raise ValueError if the value is not present.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">get_index_dtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_contents</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Based on input (integer) arrays <code>a</code>, determine a suitable index data
type that can hold the data in the arrays.</p>
<h2 id="parameters_182">Parameters<a class="headerlink" href="#parameters_182" title="Permanent link">&para;</a></h2>
<p>arrays : tuple of array_like
Input arrays whose types/contents to check
maxval : float, optional
Maximum value needed
check_contents : bool, optional
Whether to check the values in the arrays and not just their types.
Default: False (check only the types)</p>
<h2 id="returns_129">Returns<a class="headerlink" href="#returns_129" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Suitable index data type (int32 or int64)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_csr</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of csr_matrix type?</p>
<h2 id="parameters_183">Parameters<a class="headerlink" href="#parameters_183" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a csr matrix</p>
<h2 id="returns_130">Returns<a class="headerlink" href="#returns_130" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a csr matrix, False otherwise</p>
<h2 id="examples_80">Examples<a class="headerlink" href="#examples_80" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix_csr
isspmatrix_csr(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import csc_matrix, csr_matrix, isspmatrix_csc
isspmatrix_csr(csc_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the nearest supported sparse dtype for the
combination of one or more types.</p>
<p>upcast(t0, t1, ..., tn) -&gt; T  where T is a supported dtype</p>
<h2 id="examples_81">Examples<a class="headerlink" href="#examples_81" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>upcast('int32')
<type 'numpy.int32'>
upcast('bool')
<type 'numpy.bool_'>
upcast('int32','float32')
<type 'numpy.float64'>
upcast('bool',complex,float)
<type 'numpy.complex128'></p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Data</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">isscalarlike</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x either a scalar, an array scalar, or a 0-dim array?</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">npfunc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sign(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Returns an element-wise indication of the sign of a number.</p>
<p>The <code>sign</code> function returns <code>-1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0</code>.  nan
is returned for nan inputs.</p>
<p>For complex inputs, the <code>sign</code> function returns
<code>sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j</code>.</p>
<p>complex(nan, 0) is returned for complex nan inputs.</p>
<h2 id="parameters_184">Parameters<a class="headerlink" href="#parameters_184" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input values.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_131">Returns<a class="headerlink" href="#returns_131" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The sign of <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_35">Notes<a class="headerlink" href="#notes_35" title="Permanent link">&para;</a></h2>
<p>There is more than one definition of sign in common use for complex
numbers.  The definition used here is equivalent to :math:<code>x/\sqrt{x*x}</code>
which is different from a common alternative, :math:<code>x/|x|</code>.</p>
<h2 id="examples_82">Examples<a class="headerlink" href="#examples_82" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.sign([-5., 4.5])
array([-1.,  1.])
np.sign(0)
0
np.sign(5-2j)
(1+0j)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">validateaxis</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Dia</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">check_shape</span> <span class="o">:</span> <span class="o">?</span><span class="n">current_shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Imitate numpy.matrix handling of shape arguments</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_index_dtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_contents</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Based on input (integer) arrays <code>a</code>, determine a suitable index data
type that can hold the data in the arrays.</p>
<h2 id="parameters_185">Parameters<a class="headerlink" href="#parameters_185" title="Permanent link">&para;</a></h2>
<p>arrays : tuple of array_like
Input arrays whose types/contents to check
maxval : float, optional
Maximum value needed
check_contents : bool, optional
Whether to check the values in the arrays and not just their types.
Default: False (check only the types)</p>
<h2 id="returns_132">Returns<a class="headerlink" href="#returns_132" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Suitable index data type (int32 or int64)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_sum_dtype</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Mimic numpy's casting for np.sum</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getdtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">default</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Function used to simplify argument processing.  If 'dtype' is not
specified (is None), returns a.dtype; otherwise returns a np.dtype
object created from the specified dtype argument.  If 'dtype' and 'a'
are both None, construct a data type out of the 'default' parameter.
Furthermore, 'dtype' must be in 'allowed' set.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">nonneg</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x a valid 2-tuple of dimensions?</p>
<p>If nonneg, also checks that the dimensions are non-negative.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_186">Parameters<a class="headerlink" href="#parameters_186" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_133">Returns<a class="headerlink" href="#returns_133" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_36">Notes<a class="headerlink" href="#notes_36" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_83">Examples<a class="headerlink" href="#examples_83" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_dia</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of dia_matrix type?</p>
<h2 id="parameters_187">Parameters<a class="headerlink" href="#parameters_187" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a dia matrix</p>
<h2 id="returns_134">Returns<a class="headerlink" href="#returns_134" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a dia matrix, False otherwise</p>
<h2 id="examples_84">Examples<a class="headerlink" href="#examples_84" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import dia_matrix, isspmatrix_dia
isspmatrix_dia(dia_matrix([[5]]))
True</p>
<p>from scipy.sparse import dia_matrix, csr_matrix, isspmatrix_dia
isspmatrix_dia(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast_char</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Same as <code>upcast</code> but taking dtype.char as input (faster).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">validateaxis</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Dok</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">IndexMixin</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IndexMixin</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IndexMixin</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>This class provides common dispatching and validation logic for indexing.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">setitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getcol</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of column i of the matrix, as a (m x 1) column vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getrow</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of row i of the matrix, as a (1 x n) row vector.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Izip</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Zip</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zip</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>zip( *iterables) --&gt; zip object</p>
<p>Return a zip object whose .<strong>next</strong>() method returns a tuple where
the i-th element comes from the i-th iterable argument.  The .<strong>next</strong>()
method continues until the shortest iterable in the argument sequence
is exhausted and then it raises StopIteration.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Xrange</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Range</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Range</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>range(stop) -&gt; range object
range(start, stop[, step]) -&gt; range object</p>
<p>Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rangeobject.count(value) -&gt; integer -- return number of occurrences of value</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">index</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rangeobject.index(value) -&gt; integer -- return index of value.
Raise ValueError if the value is not present.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">check_shape</span> <span class="o">:</span> <span class="o">?</span><span class="n">current_shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Imitate numpy.matrix handling of shape arguments</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_index_dtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_contents</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Based on input (integer) arrays <code>a</code>, determine a suitable index data
type that can hold the data in the arrays.</p>
<h2 id="parameters_188">Parameters<a class="headerlink" href="#parameters_188" title="Permanent link">&para;</a></h2>
<p>arrays : tuple of array_like
Input arrays whose types/contents to check
maxval : float, optional
Maximum value needed
check_contents : bool, optional
Whether to check the values in the arrays and not just their types.
Default: False (check only the types)</p>
<h2 id="returns_135">Returns<a class="headerlink" href="#returns_135" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Suitable index data type (int32 or int64)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getdtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">default</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Function used to simplify argument processing.  If 'dtype' is not
specified (is None), returns a.dtype; otherwise returns a np.dtype
object created from the specified dtype argument.  If 'dtype' and 'a'
are both None, construct a data type out of the 'default' parameter.
Furthermore, 'dtype' must be in 'allowed' set.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isdense</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isintlike</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x appropriate as an index into a sparse matrix? Returns True
if it can be cast safely to a machine int.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isscalarlike</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x either a scalar, an array scalar, or a 0-dim array?</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">nonneg</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x a valid 2-tuple of dimensions?</p>
<p>If nonneg, also checks that the dimensions are non-negative.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_189">Parameters<a class="headerlink" href="#parameters_189" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_136">Returns<a class="headerlink" href="#returns_136" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_37">Notes<a class="headerlink" href="#notes_37" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_85">Examples<a class="headerlink" href="#examples_85" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_dok</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of dok_matrix type?</p>
<h2 id="parameters_190">Parameters<a class="headerlink" href="#parameters_190" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a dok matrix</p>
<h2 id="returns_137">Returns<a class="headerlink" href="#returns_137" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a dok matrix, False otherwise</p>
<h2 id="examples_86">Examples<a class="headerlink" href="#examples_86" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import dok_matrix, isspmatrix_dok
isspmatrix_dok(dok_matrix([[5]]))
True</p>
<p>from scipy.sparse import dok_matrix, csr_matrix, isspmatrix_dok
isspmatrix_dok(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iteritems</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an iterator over the (key, value) pairs of a dictionary.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iterkeys</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an iterator over the keys of a dictionary.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itervalues</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an iterator over the values of a dictionary.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the nearest supported sparse dtype for the
combination of one or more types.</p>
<p>upcast(t0, t1, ..., tn) -&gt; T  where T is a supported dtype</p>
<h2 id="examples_87">Examples<a class="headerlink" href="#examples_87" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>upcast('int32')
<type 'numpy.int32'>
upcast('bool')
<type 'numpy.bool_'>
upcast('int32','float32')
<type 'numpy.float64'>
upcast('bool',complex,float)
<type 'numpy.complex128'></p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast_scalar</span> <span class="o">:</span> <span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">scalar</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Determine data type for binary operation between an array of
type <code>dtype</code> and a scalar.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Extract</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">find</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Dense</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the indices and values of the nonzero elements of a matrix</p>
<h2 id="parameters_191">Parameters<a class="headerlink" href="#parameters_191" title="Permanent link">&para;</a></h2>
<p>A : dense or sparse matrix
Matrix whose nonzero elements are desired.</p>
<h2 id="returns_138">Returns<a class="headerlink" href="#returns_138" title="Permanent link">&para;</a></h2>
<p>(I,J,V) : tuple of arrays
I,J, and V contain the row indices, column indices, and values
of the nonzero matrix entries.</p>
<h2 id="examples_88">Examples<a class="headerlink" href="#examples_88" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, find
A = csr_matrix([[7.0, 8.0, 0],[0, 0, 9.0]])
find(A)
(array([0, 0, 1], dtype=int32), array([0, 1, 2], dtype=int32), array([ 7.,  8.,  9.]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tril</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Dense</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the lower triangular portion of a matrix in sparse format</p>
<p>Returns the elements on or below the k-th diagonal of the matrix A.
- k = 0 corresponds to the main diagonal
- k &gt; 0 is above the main diagonal
- k &lt; 0 is below the main diagonal</p>
<h2 id="parameters_192">Parameters<a class="headerlink" href="#parameters_192" title="Permanent link">&para;</a></h2>
<p>A : dense or sparse matrix
Matrix whose lower trianglar portion is desired.
k : integer : optional
The top-most diagonal of the lower triangle.
format : string
Sparse format of the result, e.g. format='csr', etc.</p>
<h2 id="returns_139">Returns<a class="headerlink" href="#returns_139" title="Permanent link">&para;</a></h2>
<p>L : sparse matrix
Lower triangular portion of A in sparse format.</p>
<h2 id="see-also_71">See Also<a class="headerlink" href="#see-also_71" title="Permanent link">&para;</a></h2>
<p>triu : upper triangle in sparse format</p>
<h2 id="examples_89">Examples<a class="headerlink" href="#examples_89" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, tril
A = csr_matrix([[1, 2, 0, 0, 3], [4, 5, 0, 6, 7], [0, 0, 8, 9, 0]],
...                dtype='int32')
A.toarray()
array([[1, 2, 0, 0, 3],
[4, 5, 0, 6, 7],
[0, 0, 8, 9, 0]])
tril(A).toarray()
array([[1, 0, 0, 0, 0],
[4, 5, 0, 0, 0],
[0, 0, 8, 0, 0]])
tril(A).nnz
4
tril(A, k=1).toarray()
array([[1, 2, 0, 0, 0],
[4, 5, 0, 0, 0],
[0, 0, 8, 9, 0]])
tril(A, k=-1).toarray()
array([[0, 0, 0, 0, 0],
[4, 0, 0, 0, 0],
[0, 0, 0, 0, 0]])
tril(A, format='csc')
&lt;3x5 sparse matrix of type '<class 'numpy.int32'>'
with 4 stored elements in Compressed Sparse Column format&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">triu</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Dense</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the upper triangular portion of a matrix in sparse format</p>
<p>Returns the elements on or above the k-th diagonal of the matrix A.
- k = 0 corresponds to the main diagonal
- k &gt; 0 is above the main diagonal
- k &lt; 0 is below the main diagonal</p>
<h2 id="parameters_193">Parameters<a class="headerlink" href="#parameters_193" title="Permanent link">&para;</a></h2>
<p>A : dense or sparse matrix
Matrix whose upper trianglar portion is desired.
k : integer : optional
The bottom-most diagonal of the upper triangle.
format : string
Sparse format of the result, e.g. format='csr', etc.</p>
<h2 id="returns_140">Returns<a class="headerlink" href="#returns_140" title="Permanent link">&para;</a></h2>
<p>L : sparse matrix
Upper triangular portion of A in sparse format.</p>
<h2 id="see-also_72">See Also<a class="headerlink" href="#see-also_72" title="Permanent link">&para;</a></h2>
<p>tril : lower triangle in sparse format</p>
<h2 id="examples_90">Examples<a class="headerlink" href="#examples_90" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, triu
A = csr_matrix([[1, 2, 0, 0, 3], [4, 5, 0, 6, 7], [0, 0, 8, 9, 0]],
...                dtype='int32')
A.toarray()
array([[1, 2, 0, 0, 3],
[4, 5, 0, 6, 7],
[0, 0, 8, 9, 0]])
triu(A).toarray()
array([[1, 2, 0, 0, 3],
[0, 5, 0, 6, 7],
[0, 0, 8, 9, 0]])
triu(A).nnz
8
triu(A, k=1).toarray()
array([[0, 2, 0, 0, 3],
[0, 0, 0, 6, 7],
[0, 0, 0, 9, 0]])
triu(A, k=-1).toarray()
array([[1, 2, 0, 0, 3],
[4, 5, 0, 6, 7],
[0, 0, 8, 9, 0]])
triu(A, format='csc')
&lt;3x5 sparse matrix of type '<class 'numpy.int32'>'
with 8 stored elements in Compressed Sparse Column format&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Lil</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">IndexMixin</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IndexMixin</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IndexMixin</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>This class provides common dispatching and validation logic for indexing.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">setitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getcol</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of column i of the matrix, as a (m x 1) column vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getrow</span> <span class="o">:</span> <span class="n">i</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of row i of the matrix, as a (1 x n) row vector.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Xrange</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Range</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Range</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>range(stop) -&gt; range object
range(start, stop[, step]) -&gt; range object</p>
<p>Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rangeobject.count(value) -&gt; integer -- return number of occurrences of value</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">index</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rangeobject.index(value) -&gt; integer -- return index of value.
Raise ValueError if the value is not present.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Zip</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Zip</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zip</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>zip( *iterables) --&gt; zip object</p>
<p>Return a zip object whose .<strong>next</strong>() method returns a tuple where
the i-th element comes from the i-th iterable argument.  The .<strong>next</strong>()
method continues until the shortest iterable in the argument sequence
is exhausted and then it raises StopIteration.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">asmatrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_reshape_kwargs</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Unpack keyword arguments for reshape function.</p>
<p>This is useful because keyword arguments after star arguments are not
allowed in Python 2, but star keyword arguments are. This function unpacks
'order' and 'copy' from the star keyword arguments (with defaults) and
throws an error for any remaining.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_shape</span> <span class="o">:</span> <span class="o">?</span><span class="n">current_shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Imitate numpy.matrix handling of shape arguments</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_index_dtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_contents</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Based on input (integer) arrays <code>a</code>, determine a suitable index data
type that can hold the data in the arrays.</p>
<h2 id="parameters_194">Parameters<a class="headerlink" href="#parameters_194" title="Permanent link">&para;</a></h2>
<p>arrays : tuple of array_like
Input arrays whose types/contents to check
maxval : float, optional
Maximum value needed
check_contents : bool, optional
Whether to check the values in the arrays and not just their types.
Default: False (check only the types)</p>
<h2 id="returns_141">Returns<a class="headerlink" href="#returns_141" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Suitable index data type (int32 or int64)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getdtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">default</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Function used to simplify argument processing.  If 'dtype' is not
specified (is None), returns a.dtype; otherwise returns a np.dtype
object created from the specified dtype argument.  If 'dtype' and 'a'
are both None, construct a data type out of the 'default' parameter.
Furthermore, 'dtype' must be in 'allowed' set.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isscalarlike</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x either a scalar, an array scalar, or a 0-dim array?</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">nonneg</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x a valid 2-tuple of dimensions?</p>
<p>If nonneg, also checks that the dimensions are non-negative.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_195">Parameters<a class="headerlink" href="#parameters_195" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_142">Returns<a class="headerlink" href="#returns_142" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_38">Notes<a class="headerlink" href="#notes_38" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_91">Examples<a class="headerlink" href="#examples_91" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_lil</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of lil_matrix type?</p>
<h2 id="parameters_196">Parameters<a class="headerlink" href="#parameters_196" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a lil matrix</p>
<h2 id="returns_143">Returns<a class="headerlink" href="#returns_143" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a lil matrix, False otherwise</p>
<h2 id="examples_92">Examples<a class="headerlink" href="#examples_92" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import lil_matrix, isspmatrix_lil
isspmatrix_lil(lil_matrix([[5]]))
True</p>
<p>from scipy.sparse import lil_matrix, csr_matrix, isspmatrix_lil
isspmatrix_lil(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast_scalar</span> <span class="o">:</span> <span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">scalar</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Determine data type for binary operation between an array of
type <code>dtype</code> and a scalar.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Linalg</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">ArpackError</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArpackError</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArpackError</span> <span class="o">|</span> <span class="o">`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">infodict</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">info</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>ARPACK error</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">ArpackNoConvergence</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArpackNoConvergence</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArpackNoConvergence</span> <span class="o">|</span> <span class="o">`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">msg</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">eigenvalues</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">eigenvectors</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>ARPACK iteration did not converge</p>
<h2 id="attributes_7">Attributes<a class="headerlink" href="#attributes_7" title="Permanent link">&para;</a></h2>
<p>eigenvalues : ndarray
Partial result. Converged eigenvalues.
eigenvectors : ndarray
Partial result. Converged eigenvectors.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Attribute eigenvalues: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigenvalues</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute eigenvalues: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigenvalues_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute eigenvectors: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigenvectors</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute eigenvectors: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigenvectors_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">LinearOperator</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LinearOperator</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LinearOperator</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Common interface for performing matrix vector products</p>
<p>Many iterative methods (e.g. cg, gmres) do not need to know the
individual entries of a matrix to solve a linear system A<em>x=b.
Such solvers only require the computation of matrix vector
products, A</em>v where v is a dense vector.  This class serves as
an abstract interface between iterative solvers and matrix-like
objects.</p>
<p>To construct a concrete LinearOperator, either pass appropriate
callables to the constructor of this class, or subclass it.</p>
<p>A subclass must implement either one of the methods <code>_matvec</code>
and <code>_matmat</code>, and the attributes/properties <code>shape</code> (pair of
integers) and <code>dtype</code> (may be None). It may call the <code>__init__</code>
on this class to have these attributes validated. Implementing
<code>_matvec</code> automatically implements <code>_matmat</code> (using a naive
algorithm) and vice-versa.</p>
<p>Optionally, a subclass may implement <code>_rmatvec</code> or <code>_adjoint</code>
to implement the Hermitian adjoint (conjugate transpose). As with
<code>_matvec</code> and <code>_matmat</code>, implementing either <code>_rmatvec</code> or
<code>_adjoint</code> implements the other automatically. Implementing
<code>_adjoint</code> is preferable; <code>_rmatvec</code> is mostly there for
backwards compatibility.</p>
<h2 id="parameters_197">Parameters<a class="headerlink" href="#parameters_197" title="Permanent link">&para;</a></h2>
<p>shape : tuple
Matrix dimensions (M, N).
matvec : callable f(v)
Returns returns A * v.
rmatvec : callable f(v)
Returns A^H * v, where A^H is the conjugate transpose of A.
matmat : callable f(V)
Returns A * V, where V is a dense matrix with dimensions (N, K).
dtype : dtype
Data type of the matrix.
rmatmat : callable f(V)
Returns A^H * V, where V is a dense matrix with dimensions (M, K).</p>
<h2 id="attributes_8">Attributes<a class="headerlink" href="#attributes_8" title="Permanent link">&para;</a></h2>
<p>args : tuple
For linear operators describing products etc. of other linear
operators, the operands of the binary operation.</p>
<h2 id="see-also_73">See Also<a class="headerlink" href="#see-also_73" title="Permanent link">&para;</a></h2>
<p>aslinearoperator : Construct LinearOperators</p>
<h2 id="notes_39">Notes<a class="headerlink" href="#notes_39" title="Permanent link">&para;</a></h2>
<p>The user-defined matvec() function must properly handle the case
where v has shape (N,) as well as the (N,1) case.  The shape of
the return type is handled internally by LinearOperator.</p>
<p>LinearOperator instances can also be multiplied, added with each
other and exponentiated, all lazily: the result of these operations
is always a new, composite LinearOperator, that defers linear
operations to the original operators and combines the results.</p>
<p>More details regarding how to subclass a LinearOperator and several
examples of concrete LinearOperator instances can be found in the
external project <code>PyLops &lt;https://pylops.readthedocs.io&gt;</code>_.</p>
<h2 id="examples_93">Examples<a class="headerlink" href="#examples_93" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse.linalg import LinearOperator
def mv(v):
...     return np.array([2<em>v[0], 3</em>v[1]])
...
A = LinearOperator((2,2), matvec=mv)
A
&lt;2x2 _CustomLinearOperator with dtype=float64&gt;
A.matvec(np.ones(2))
array([ 2.,  3.])
A * np.ones(2)
array([ 2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">adjoint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Hermitian adjoint.</p>
<p>Returns the Hermitian adjoint of self, aka the Hermitian
conjugate or Hermitian transpose. For a complex matrix, the
Hermitian adjoint is equal to the conjugate transpose.</p>
<p>Can be abbreviated self.H instead of self.adjoint().</p>
<h2 id="returns_144">Returns<a class="headerlink" href="#returns_144" title="Permanent link">&para;</a></h2>
<p>A_H : LinearOperator
Hermitian adjoint of self.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix or matrix-vector multiplication.</p>
<h2 id="parameters_198">Parameters<a class="headerlink" href="#parameters_198" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-d or 2-d array, representing a vector or matrix.</p>
<h2 id="returns_145">Returns<a class="headerlink" href="#returns_145" title="Permanent link">&para;</a></h2>
<p>Ax : array
1-d or 2-d array (depending on the shape of x) that represents
the result of applying this linear operator on x.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix multiplication.</p>
<p>Performs the operation y=A<em>X where A is an MxN linear
operator and X dense N</em>K matrix or ndarray.</p>
<h2 id="parameters_199">Parameters<a class="headerlink" href="#parameters_199" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
An array with shape (N,K).</p>
<h2 id="returns_146">Returns<a class="headerlink" href="#returns_146" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or ndarray with shape (M,K) depending on
the type of the X argument.</p>
<h2 id="notes_40">Notes<a class="headerlink" href="#notes_40" title="Permanent link">&para;</a></h2>
<p>This matmat wraps any user-specified matmat routine or overridden
_matmat method to ensure that y has the correct type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-vector multiplication.</p>
<p>Performs the operation y=A*x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_200">Parameters<a class="headerlink" href="#parameters_200" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (N,) or (N,1).</p>
<h2 id="returns_147">Returns<a class="headerlink" href="#returns_147" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (M,) or (M,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_41">Notes<a class="headerlink" href="#notes_41" title="Permanent link">&para;</a></h2>
<p>This matvec wraps the user-specified matvec routine or overridden
_matvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-matrix multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array, or 2-d array.
The default implementation defers to the adjoint.</p>
<h2 id="parameters_201">Parameters<a class="headerlink" href="#parameters_201" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
A matrix or 2D array.</p>
<h2 id="returns_148">Returns<a class="headerlink" href="#returns_148" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or 2D array depending on the type of the input.</p>
<h2 id="notes_42">Notes<a class="headerlink" href="#notes_42" title="Permanent link">&para;</a></h2>
<p>This rmatmat wraps the user-specified rmatmat routine.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-vector multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_202">Parameters<a class="headerlink" href="#parameters_202" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (M,) or (M,1).</p>
<h2 id="returns_149">Returns<a class="headerlink" href="#returns_149" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (N,) or (N,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_43">Notes<a class="headerlink" href="#notes_43" title="Permanent link">&para;</a></h2>
<p>This rmatvec wraps the user-specified rmatvec routine or overridden
_rmatvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transpose this linear operator.</p>
<p>Returns a LinearOperator that represents the transpose of this one.
Can be abbreviated self.T instead of self.transpose().</p>
<p>Attribute args: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">args</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute args: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">args_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">MatrixRankWarning</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">MatrixRankWarning</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">MatrixRankWarning</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">SuperLU</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">SuperLU</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SuperLU</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>LU factorization of a sparse matrix.</p>
<p>Factorization is represented as::</p>
<p>Pr * A * Pc = L * U</p>
<p>To construct these <code>SuperLU</code> objects, call the <code>splu</code> and <code>spilu</code>
functions.</p>
<h2 id="attributes_9">Attributes<a class="headerlink" href="#attributes_9" title="Permanent link">&para;</a></h2>
<p>shape
nnz
perm_c
perm_r
L
U</p>
<h2 id="methods">Methods<a class="headerlink" href="#methods" title="Permanent link">&para;</a></h2>
<p>solve</p>
<h2 id="notes_44">Notes<a class="headerlink" href="#notes_44" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.14.0</p>
<h2 id="examples_94">Examples<a class="headerlink" href="#examples_94" title="Permanent link">&para;</a></h2>
<p>The LU decomposition can be used to solve matrix equations. Consider:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import csc_matrix, linalg as sla
A = csc_matrix([[1,2,0,4],[1,0,0,1],[1,0,2,1],[2,2,1,0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>This can be solved for a given right-hand side:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lu = sla.splu(A)
b = np.array([1, 2, 3, 4])
x = lu.solve(b)
A.dot(x)
array([ 1.,  2.,  3.,  4.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The <code>lu</code> object also contains an explicit representation of the
decomposition. The permutations are represented as mappings of
indices:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lu.perm_r
array([0, 2, 1, 3], dtype=int32)
lu.perm_c
array([2, 0, 1, 3], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The L and U factors are sparse matrices in CSC format:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lu.L.A
array([[ 1. ,  0. ,  0. ,  0. ],
[ 0. ,  1. ,  0. ,  0. ],
[ 0. ,  0. ,  1. ,  0. ],
[ 1. ,  0.5,  0.5,  1. ]])
lu.U.A
array([[ 2.,  0.,  1.,  4.],
[ 0.,  2.,  1.,  1.],
[ 0.,  0.,  1.,  1.],
[ 0.,  0.,  0., -5.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The permutation matrices can be constructed:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Pr = csc_matrix((np.ones(4), (lu.perm_r, np.arange(4))))
Pc = csc_matrix((np.ones(4), (np.arange(4), lu.perm_c)))</p>
</blockquote>
</blockquote>
</blockquote>
<p>We can reassemble the original matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>(Pr.T * (lu.L * lu.U) * Pc.T).A
array([[ 1.,  2.,  0.,  4.],
[ 1.,  0.,  0.,  1.],
[ 1.,  0.,  2.,  1.],
[ 2.,  2.,  1.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Attribute shape: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute shape: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Arpack</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">IterInv</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IterInv</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IterInv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>IterInv:
helper class to repeatedly solve M*x=b
using an iterative method.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">adjoint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Hermitian adjoint.</p>
<p>Returns the Hermitian adjoint of self, aka the Hermitian
conjugate or Hermitian transpose. For a complex matrix, the
Hermitian adjoint is equal to the conjugate transpose.</p>
<p>Can be abbreviated self.H instead of self.adjoint().</p>
<h2 id="returns_150">Returns<a class="headerlink" href="#returns_150" title="Permanent link">&para;</a></h2>
<p>A_H : LinearOperator
Hermitian adjoint of self.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix or matrix-vector multiplication.</p>
<h2 id="parameters_203">Parameters<a class="headerlink" href="#parameters_203" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-d or 2-d array, representing a vector or matrix.</p>
<h2 id="returns_151">Returns<a class="headerlink" href="#returns_151" title="Permanent link">&para;</a></h2>
<p>Ax : array
1-d or 2-d array (depending on the shape of x) that represents
the result of applying this linear operator on x.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix multiplication.</p>
<p>Performs the operation y=A<em>X where A is an MxN linear
operator and X dense N</em>K matrix or ndarray.</p>
<h2 id="parameters_204">Parameters<a class="headerlink" href="#parameters_204" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
An array with shape (N,K).</p>
<h2 id="returns_152">Returns<a class="headerlink" href="#returns_152" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or ndarray with shape (M,K) depending on
the type of the X argument.</p>
<h2 id="notes_45">Notes<a class="headerlink" href="#notes_45" title="Permanent link">&para;</a></h2>
<p>This matmat wraps any user-specified matmat routine or overridden
_matmat method to ensure that y has the correct type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-vector multiplication.</p>
<p>Performs the operation y=A*x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_205">Parameters<a class="headerlink" href="#parameters_205" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (N,) or (N,1).</p>
<h2 id="returns_153">Returns<a class="headerlink" href="#returns_153" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (M,) or (M,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_46">Notes<a class="headerlink" href="#notes_46" title="Permanent link">&para;</a></h2>
<p>This matvec wraps the user-specified matvec routine or overridden
_matvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-matrix multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array, or 2-d array.
The default implementation defers to the adjoint.</p>
<h2 id="parameters_206">Parameters<a class="headerlink" href="#parameters_206" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
A matrix or 2D array.</p>
<h2 id="returns_154">Returns<a class="headerlink" href="#returns_154" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or 2D array depending on the type of the input.</p>
<h2 id="notes_47">Notes<a class="headerlink" href="#notes_47" title="Permanent link">&para;</a></h2>
<p>This rmatmat wraps the user-specified rmatmat routine.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-vector multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_207">Parameters<a class="headerlink" href="#parameters_207" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (M,) or (M,1).</p>
<h2 id="returns_155">Returns<a class="headerlink" href="#returns_155" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (N,) or (N,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_48">Notes<a class="headerlink" href="#notes_48" title="Permanent link">&para;</a></h2>
<p>This rmatvec wraps the user-specified rmatvec routine or overridden
_rmatvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transpose this linear operator.</p>
<p>Returns a LinearOperator that represents the transpose of this one.
Can be abbreviated self.T instead of self.transpose().</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">IterOpInv</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IterOpInv</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IterOpInv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>IterOpInv:
helper class to repeatedly solve [A-sigma<em>M]</em>x = b
using an iterative method</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">adjoint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Hermitian adjoint.</p>
<p>Returns the Hermitian adjoint of self, aka the Hermitian
conjugate or Hermitian transpose. For a complex matrix, the
Hermitian adjoint is equal to the conjugate transpose.</p>
<p>Can be abbreviated self.H instead of self.adjoint().</p>
<h2 id="returns_156">Returns<a class="headerlink" href="#returns_156" title="Permanent link">&para;</a></h2>
<p>A_H : LinearOperator
Hermitian adjoint of self.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix or matrix-vector multiplication.</p>
<h2 id="parameters_208">Parameters<a class="headerlink" href="#parameters_208" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-d or 2-d array, representing a vector or matrix.</p>
<h2 id="returns_157">Returns<a class="headerlink" href="#returns_157" title="Permanent link">&para;</a></h2>
<p>Ax : array
1-d or 2-d array (depending on the shape of x) that represents
the result of applying this linear operator on x.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix multiplication.</p>
<p>Performs the operation y=A<em>X where A is an MxN linear
operator and X dense N</em>K matrix or ndarray.</p>
<h2 id="parameters_209">Parameters<a class="headerlink" href="#parameters_209" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
An array with shape (N,K).</p>
<h2 id="returns_158">Returns<a class="headerlink" href="#returns_158" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or ndarray with shape (M,K) depending on
the type of the X argument.</p>
<h2 id="notes_49">Notes<a class="headerlink" href="#notes_49" title="Permanent link">&para;</a></h2>
<p>This matmat wraps any user-specified matmat routine or overridden
_matmat method to ensure that y has the correct type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-vector multiplication.</p>
<p>Performs the operation y=A*x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_210">Parameters<a class="headerlink" href="#parameters_210" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (N,) or (N,1).</p>
<h2 id="returns_159">Returns<a class="headerlink" href="#returns_159" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (M,) or (M,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_50">Notes<a class="headerlink" href="#notes_50" title="Permanent link">&para;</a></h2>
<p>This matvec wraps the user-specified matvec routine or overridden
_matvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-matrix multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array, or 2-d array.
The default implementation defers to the adjoint.</p>
<h2 id="parameters_211">Parameters<a class="headerlink" href="#parameters_211" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
A matrix or 2D array.</p>
<h2 id="returns_160">Returns<a class="headerlink" href="#returns_160" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or 2D array depending on the type of the input.</p>
<h2 id="notes_51">Notes<a class="headerlink" href="#notes_51" title="Permanent link">&para;</a></h2>
<p>This rmatmat wraps the user-specified rmatmat routine.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-vector multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_212">Parameters<a class="headerlink" href="#parameters_212" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (M,) or (M,1).</p>
<h2 id="returns_161">Returns<a class="headerlink" href="#returns_161" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (N,) or (N,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_52">Notes<a class="headerlink" href="#notes_52" title="Permanent link">&para;</a></h2>
<p>This rmatvec wraps the user-specified rmatvec routine or overridden
_rmatvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transpose this linear operator.</p>
<p>Returns a LinearOperator that represents the transpose of this one.
Can be abbreviated self.T instead of self.transpose().</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">LuInv</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LuInv</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LuInv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>LuInv:
helper class to repeatedly solve M*x=b
using an LU-decomposition of M</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">adjoint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Hermitian adjoint.</p>
<p>Returns the Hermitian adjoint of self, aka the Hermitian
conjugate or Hermitian transpose. For a complex matrix, the
Hermitian adjoint is equal to the conjugate transpose.</p>
<p>Can be abbreviated self.H instead of self.adjoint().</p>
<h2 id="returns_162">Returns<a class="headerlink" href="#returns_162" title="Permanent link">&para;</a></h2>
<p>A_H : LinearOperator
Hermitian adjoint of self.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix or matrix-vector multiplication.</p>
<h2 id="parameters_213">Parameters<a class="headerlink" href="#parameters_213" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-d or 2-d array, representing a vector or matrix.</p>
<h2 id="returns_163">Returns<a class="headerlink" href="#returns_163" title="Permanent link">&para;</a></h2>
<p>Ax : array
1-d or 2-d array (depending on the shape of x) that represents
the result of applying this linear operator on x.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix multiplication.</p>
<p>Performs the operation y=A<em>X where A is an MxN linear
operator and X dense N</em>K matrix or ndarray.</p>
<h2 id="parameters_214">Parameters<a class="headerlink" href="#parameters_214" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
An array with shape (N,K).</p>
<h2 id="returns_164">Returns<a class="headerlink" href="#returns_164" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or ndarray with shape (M,K) depending on
the type of the X argument.</p>
<h2 id="notes_53">Notes<a class="headerlink" href="#notes_53" title="Permanent link">&para;</a></h2>
<p>This matmat wraps any user-specified matmat routine or overridden
_matmat method to ensure that y has the correct type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-vector multiplication.</p>
<p>Performs the operation y=A*x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_215">Parameters<a class="headerlink" href="#parameters_215" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (N,) or (N,1).</p>
<h2 id="returns_165">Returns<a class="headerlink" href="#returns_165" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (M,) or (M,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_54">Notes<a class="headerlink" href="#notes_54" title="Permanent link">&para;</a></h2>
<p>This matvec wraps the user-specified matvec routine or overridden
_matvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-matrix multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array, or 2-d array.
The default implementation defers to the adjoint.</p>
<h2 id="parameters_216">Parameters<a class="headerlink" href="#parameters_216" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
A matrix or 2D array.</p>
<h2 id="returns_166">Returns<a class="headerlink" href="#returns_166" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or 2D array depending on the type of the input.</p>
<h2 id="notes_55">Notes<a class="headerlink" href="#notes_55" title="Permanent link">&para;</a></h2>
<p>This rmatmat wraps the user-specified rmatmat routine.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-vector multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_217">Parameters<a class="headerlink" href="#parameters_217" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (M,) or (M,1).</p>
<h2 id="returns_167">Returns<a class="headerlink" href="#returns_167" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (N,) or (N,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_56">Notes<a class="headerlink" href="#notes_56" title="Permanent link">&para;</a></h2>
<p>This rmatvec wraps the user-specified rmatvec routine or overridden
_rmatvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transpose this linear operator.</p>
<p>Returns a LinearOperator that represents the transpose of this one.
Can be abbreviated self.T instead of self.transpose().</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">ReentrancyLock</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ReentrancyLock</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">ReentrancyLock</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Threading lock that raises an exception for reentrant calls.</p>
<p>Calls from different threads are serialized, and nested calls from the
same thread result to an error.</p>
<p>The object can be used as a context manager, or to decorate functions
via the decorate() method.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">decorate</span> <span class="o">:</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">SpLuInv</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">SpLuInv</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SpLuInv</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>SpLuInv:
helper class to repeatedly solve M*x=b
using a sparse LU-decopposition of M</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">adjoint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Hermitian adjoint.</p>
<p>Returns the Hermitian adjoint of self, aka the Hermitian
conjugate or Hermitian transpose. For a complex matrix, the
Hermitian adjoint is equal to the conjugate transpose.</p>
<p>Can be abbreviated self.H instead of self.adjoint().</p>
<h2 id="returns_168">Returns<a class="headerlink" href="#returns_168" title="Permanent link">&para;</a></h2>
<p>A_H : LinearOperator
Hermitian adjoint of self.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix or matrix-vector multiplication.</p>
<h2 id="parameters_218">Parameters<a class="headerlink" href="#parameters_218" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-d or 2-d array, representing a vector or matrix.</p>
<h2 id="returns_169">Returns<a class="headerlink" href="#returns_169" title="Permanent link">&para;</a></h2>
<p>Ax : array
1-d or 2-d array (depending on the shape of x) that represents
the result of applying this linear operator on x.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix multiplication.</p>
<p>Performs the operation y=A<em>X where A is an MxN linear
operator and X dense N</em>K matrix or ndarray.</p>
<h2 id="parameters_219">Parameters<a class="headerlink" href="#parameters_219" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
An array with shape (N,K).</p>
<h2 id="returns_170">Returns<a class="headerlink" href="#returns_170" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or ndarray with shape (M,K) depending on
the type of the X argument.</p>
<h2 id="notes_57">Notes<a class="headerlink" href="#notes_57" title="Permanent link">&para;</a></h2>
<p>This matmat wraps any user-specified matmat routine or overridden
_matmat method to ensure that y has the correct type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-vector multiplication.</p>
<p>Performs the operation y=A*x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_220">Parameters<a class="headerlink" href="#parameters_220" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (N,) or (N,1).</p>
<h2 id="returns_171">Returns<a class="headerlink" href="#returns_171" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (M,) or (M,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_58">Notes<a class="headerlink" href="#notes_58" title="Permanent link">&para;</a></h2>
<p>This matvec wraps the user-specified matvec routine or overridden
_matvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-matrix multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array, or 2-d array.
The default implementation defers to the adjoint.</p>
<h2 id="parameters_221">Parameters<a class="headerlink" href="#parameters_221" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
A matrix or 2D array.</p>
<h2 id="returns_172">Returns<a class="headerlink" href="#returns_172" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or 2D array depending on the type of the input.</p>
<h2 id="notes_59">Notes<a class="headerlink" href="#notes_59" title="Permanent link">&para;</a></h2>
<p>This rmatmat wraps the user-specified rmatmat routine.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-vector multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_222">Parameters<a class="headerlink" href="#parameters_222" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (M,) or (M,1).</p>
<h2 id="returns_173">Returns<a class="headerlink" href="#returns_173" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (N,) or (N,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_60">Notes<a class="headerlink" href="#notes_60" title="Permanent link">&para;</a></h2>
<p>This rmatvec wraps the user-specified rmatvec routine or overridden
_rmatvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transpose this linear operator.</p>
<p>Returns a LinearOperator that represents the transpose of this one.
Can be abbreviated self.T instead of self.transpose().</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">aslinearoperator</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return A as a LinearOperator.</p>
<p>'A' may be any of the following types:
- ndarray
- matrix
- sparse matrix (e.g. csr_matrix, lil_matrix, etc.)
- LinearOperator
- An object with .shape and .matvec attributes</p>
<p>See the LinearOperator documentation for additional information.</p>
<h2 id="notes_61">Notes<a class="headerlink" href="#notes_61" title="Permanent link">&para;</a></h2>
<p>If 'A' has no .dtype attribute, the data type is determined by calling
:func:<code>LinearOperator.matvec()</code> - set the .dtype attribute to prevent this
call upon the linear operator creation.</p>
<h2 id="examples_95">Examples<a class="headerlink" href="#examples_95" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import aslinearoperator
M = np.array([[1,2,3],[4,5,6]], dtype=np.int32)
aslinearoperator(M)
&lt;2x3 MatrixLinearOperator with dtype=int32&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">choose_ncv</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Choose number of lanczos vectors based on target number
of singular/eigen values and vectors to compute, k.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eig</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">left</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">right</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">homogeneous_eigvals</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve an ordinary or generalized eigenvalue problem of a square matrix.</p>
<p>Find eigenvalues w and right or left eigenvectors of a general matrix::</p>
<p>a   vr[:,i] = w[i]        b   vr[:,i]
a.H vl[:,i] = w[i].conj() b.H vl[:,i]</p>
<p>where <code>.H</code> is the Hermitian conjugation.</p>
<h2 id="parameters_223">Parameters<a class="headerlink" href="#parameters_223" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex or real matrix whose eigenvalues and eigenvectors
will be computed.
b : (M, M) array_like, optional
Right-hand side matrix in a generalized eigenvalue problem.
Default is None, identity matrix is assumed.
left : bool, optional
Whether to calculate and return left eigenvectors.  Default is False.
right : bool, optional
Whether to calculate and return right eigenvectors.  Default is True.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.  Default is False.
overwrite_b : bool, optional
Whether to overwrite <code>b</code>; may improve performance.  Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
homogeneous_eigvals : bool, optional
If True, return the eigenvalues in homogeneous coordinates.
In this case <code>w</code> is a (2, M) array so that::</p>
<p>w[1,i] a vr[:,i] = w[0,i] b vr[:,i]</p>
<p>Default is False.</p>
<h2 id="returns_174">Returns<a class="headerlink" href="#returns_174" title="Permanent link">&para;</a></h2>
<p>w : (M,) or (2, M) double or complex ndarray
The eigenvalues, each repeated according to its
multiplicity. The shape is (M,) unless
<code>homogeneous_eigvals=True</code>.
vl : (M, M) double or complex ndarray
The normalized left eigenvector corresponding to the eigenvalue
<code>w[i]</code> is the column vl[:,i]. Only returned if <code>left=True</code>.
vr : (M, M) double or complex ndarray
The normalized right eigenvector corresponding to the eigenvalue
<code>w[i]</code> is the column <code>vr[:,i]</code>.  Only returned if <code>right=True</code>.</p>
<h2 id="raises_6">Raises<a class="headerlink" href="#raises_6" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge.</p>
<h2 id="see-also_74">See Also<a class="headerlink" href="#see-also_74" title="Permanent link">&para;</a></h2>
<p>eigvals : eigenvalues of general arrays
eigh : Eigenvalues and right eigenvectors for symmetric/Hermitian arrays.
eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian
band matrices
eigh_tridiagonal : eigenvalues and right eiegenvectors for
symmetric/Hermitian tridiagonal matrices</p>
<h2 id="examples_96">Examples<a class="headerlink" href="#examples_96" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[0., -1.], [1., 0.]])
linalg.eigvals(a)
array([0.+1.j, 0.-1.j])</p>
<p>b = np.array([[0., 1.], [1., 1.]])
linalg.eigvals(a, b)
array([ 1.+0.j, -1.+0.j])</p>
<p>a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]])
linalg.eigvals(a, homogeneous_eigvals=True)
array([[3.+0.j, 8.+0.j, 7.+0.j],
[1.+0.j, 1.+0.j, 1.+0.j]])</p>
<p>a = np.array([[0., -1.], [1., 0.]])
linalg.eigvals(a) == linalg.eig(a)[0]
array([ True,  True])
linalg.eig(a, left=True, right=False)[1] # normalized left eigenvector
array([[-0.70710678+0.j        , -0.70710678-0.j        ],
[-0.        +0.70710678j, -0.        -0.70710678j]])
linalg.eig(a, left=False, right=True)[1] # normalized right eigenvector
array([[0.70710678+0.j        , 0.70710678-0.j        ],
[0.        -0.70710678j, 0.        +0.70710678j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigh</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">turbo</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eigvals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">type_</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve an ordinary or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.</p>
<p>Find eigenvalues w and optionally eigenvectors v of matrix <code>a</code>, where
<code>b</code> is positive definite::</p>
<p>a v[:,i] = w[i] b v[:,i]
v[i,:].conj() a v[:,i] = w[i]
v[i,:].conj() b v[:,i] = 1</p>
<h2 id="parameters_224">Parameters<a class="headerlink" href="#parameters_224" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex Hermitian or real symmetric matrix whose eigenvalues and
eigenvectors will be computed.
b : (M, M) array_like, optional
A complex Hermitian or real symmetric definite positive matrix in.
If omitted, identity matrix is assumed.
lower : bool, optional
Whether the pertinent array data is taken from the lower or upper
triangle of <code>a</code>. (Default: lower)
eigvals_only : bool, optional
Whether to calculate only eigenvalues and no eigenvectors.
(Default: both are calculated)
turbo : bool, optional
Use divide and conquer algorithm (faster but expensive in memory,
only for generalized eigenvalue problem and if eigvals=None)
eigvals : tuple (lo, hi), optional
Indexes of the smallest and largest (in ascending order) eigenvalues
and corresponding eigenvectors to be returned: 0 &lt;= lo &lt;= hi &lt;= M-1.
If omitted, all eigenvalues and eigenvectors are returned.
type : int, optional
Specifies the problem type to be solved:</p>
<p>type = 1: a   v[:,i] = w[i] b v[:,i]</p>
<p>type = 2: a b v[:,i] = w[i]   v[:,i]</p>
<p>type = 3: b a v[:,i] = w[i]   v[:,i]
overwrite_a : bool, optional
Whether to overwrite data in <code>a</code> (may improve performance)
overwrite_b : bool, optional
Whether to overwrite data in <code>b</code> (may improve performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_175">Returns<a class="headerlink" href="#returns_175" title="Permanent link">&para;</a></h2>
<p>w : (N,) float ndarray
The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each
repeated according to its multiplicity.
v : (M, N) complex ndarray
(if eigvals_only == False)</p>
<p>The normalized selected eigenvector corresponding to the
eigenvalue w[i] is the column v[:,i].</p>
<p>Normalization:</p>
<p>type 1 and 3: v.conj() a      v  = w</p>
<p>type 2: inv(v).conj() a  inv(v) = w</p>
<p>type = 1 or 2: v.conj() b      v  = I</p>
<p>type = 3: v.conj() inv(b) v  = I</p>
<h2 id="raises_7">Raises<a class="headerlink" href="#raises_7" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge,
an error occurred, or b matrix is not definite positive. Note that
if input matrices are not symmetric or hermitian, no error is reported
but results will be wrong.</p>
<h2 id="see-also_75">See Also<a class="headerlink" href="#see-also_75" title="Permanent link">&para;</a></h2>
<p>eigvalsh : eigenvalues of symmetric or Hermitian arrays
eig : eigenvalues and right eigenvectors for non-symmetric arrays
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eigh_tridiagonal : eigenvalues and right eiegenvectors for
symmetric/Hermitian tridiagonal matrices</p>
<h2 id="notes_62">Notes<a class="headerlink" href="#notes_62" title="Permanent link">&para;</a></h2>
<p>This function does not check the input array for being hermitian/symmetric
in order to allow for representing arrays with only their upper/lower
triangular parts.</p>
<h2 id="examples_97">Examples<a class="headerlink" href="#examples_97" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigh
A = np.array([[6, 3, 1, 5], [3, 0, 5, 1], [1, 5, 6, 2], [5, 1, 2, 2]])
w, v = eigh(A)
np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigs</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sigma</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">which</span><span class="o">:[`</span><span class="nc">LM</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SM</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LR</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SR</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LI</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SI</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">v0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ncv</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_eigenvectors</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">minv</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">oPinv</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">oPpart</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find k eigenvalues and eigenvectors of the square matrix A.</p>
<p>Solves <code>A * x[i] = w[i] * x[i]</code>, the standard eigenvalue problem
for w[i] eigenvalues with corresponding eigenvectors x[i].</p>
<p>If M is specified, solves <code>A * x[i] = w[i] * M * x[i]</code>, the
generalized eigenvalue problem for w[i] eigenvalues
with corresponding eigenvectors x[i]</p>
<h2 id="parameters_225">Parameters<a class="headerlink" href="#parameters_225" title="Permanent link">&para;</a></h2>
<p>A : ndarray, sparse matrix or LinearOperator
An array, sparse matrix, or LinearOperator representing
the operation <code>A * x</code>, where A is a real or complex square matrix.
k : int, optional
The number of eigenvalues and eigenvectors desired.
<code>k</code> must be smaller than N-1. It is not possible to compute all
eigenvectors of a matrix.
M : ndarray, sparse matrix or LinearOperator, optional
An array, sparse matrix, or LinearOperator representing
the operation M*x for the generalized eigenvalue problem</p>
<p>A * x = w * M * x.</p>
<p>M must represent a real, symmetric matrix if A is real, and must
represent a complex, hermitian matrix if A is complex. For best
results, the data type of M should be the same as that of A.
Additionally:</p>
<p>If <code>sigma</code> is None, M is positive definite</p>
<p>If sigma is specified, M is positive semi-definite</p>
<p>If sigma is None, eigs requires an operator to compute the solution
of the linear equation <code>M * x = b</code>.  This is done internally via a
(sparse) LU decomposition for an explicit matrix M, or via an
iterative solver for a general linear operator.  Alternatively,
the user can supply the matrix or operator Minv, which gives
<code>x = Minv * b = M^-1 * b</code>.
sigma : real or complex, optional
Find eigenvalues near sigma using shift-invert mode.  This requires
an operator to compute the solution of the linear system
<code>[A - sigma * M] * x = b</code>, where M is the identity matrix if
unspecified. This is computed internally via a (sparse) LU
decomposition for explicit matrices A &amp; M, or via an iterative
solver if either A or M is a general linear operator.
Alternatively, the user can supply the matrix or operator OPinv,
which gives <code>x = OPinv * b = [A - sigma * M]^-1 * b</code>.
For a real matrix A, shift-invert can either be done in imaginary
mode or real mode, specified by the parameter OPpart ('r' or 'i').
Note that when sigma is specified, the keyword 'which' (below)
refers to the shifted eigenvalues <code>w'[i]</code> where:</p>
<p>If A is real and OPpart == 'r' (default),
<code>w'[i] = 1/2 * [1/(w[i]-sigma) + 1/(w[i]-conj(sigma))]</code>.</p>
<p>If A is real and OPpart == 'i',
<code>w'[i] = 1/2i * [1/(w[i]-sigma) - 1/(w[i]-conj(sigma))]</code>.</p>
<p>If A is complex, <code>w'[i] = 1/(w[i]-sigma)</code>.</p>
<p>v0 : ndarray, optional
Starting vector for iteration.
Default: random
ncv : int, optional
The number of Lanczos vectors generated
<code>ncv</code> must be greater than <code>k</code>; it is recommended that <code>ncv &gt; 2*k</code>.
Default: <code>min(n, max(2*k + 1, 20))</code>
which : str, ['LM' | 'SM' | 'LR' | 'SR' | 'LI' | 'SI'], optional
Which <code>k</code> eigenvectors and eigenvalues to find:</p>
<p>'LM' : largest magnitude</p>
<p>'SM' : smallest magnitude</p>
<p>'LR' : largest real part</p>
<p>'SR' : smallest real part</p>
<p>'LI' : largest imaginary part</p>
<p>'SI' : smallest imaginary part</p>
<p>When sigma != None, 'which' refers to the shifted eigenvalues w'[i]
(see discussion in 'sigma', above).  ARPACK is generally better
at finding large values than small values.  If small eigenvalues are
desired, consider using shift-invert mode for better performance.
maxiter : int, optional
Maximum number of Arnoldi update iterations allowed
Default: <code>n*10</code>
tol : float, optional
Relative accuracy for eigenvalues (stopping criterion)
The default value of 0 implies machine precision.
return_eigenvectors : bool, optional
Return eigenvectors (True) in addition to eigenvalues
Minv : ndarray, sparse matrix or LinearOperator, optional
See notes in M, above.
OPinv : ndarray, sparse matrix or LinearOperator, optional
See notes in sigma, above.
OPpart : {'r' or 'i'}, optional
See notes in sigma, above</p>
<h2 id="returns_176">Returns<a class="headerlink" href="#returns_176" title="Permanent link">&para;</a></h2>
<p>w : ndarray
Array of k eigenvalues.
v : ndarray
An array of <code>k</code> eigenvectors.
<code>v[:, i]</code> is the eigenvector corresponding to the eigenvalue w[i].</p>
<h2 id="raises_8">Raises<a class="headerlink" href="#raises_8" title="Permanent link">&para;</a></h2>
<p>ArpackNoConvergence
When the requested convergence is not obtained.
The currently converged eigenvalues and eigenvectors can be found
as <code>eigenvalues</code> and <code>eigenvectors</code> attributes of the exception
object.</p>
<h2 id="see-also_76">See Also<a class="headerlink" href="#see-also_76" title="Permanent link">&para;</a></h2>
<p>eigsh : eigenvalues and eigenvectors for symmetric matrix A
svds : singular value decomposition for a matrix A</p>
<h2 id="notes_63">Notes<a class="headerlink" href="#notes_63" title="Permanent link">&para;</a></h2>
<p>This function is a wrapper to the ARPACK [1]<em> SNEUPD, DNEUPD, CNEUPD,
ZNEUPD, functions which use the Implicitly Restarted Arnoldi Method to
find the eigenvalues and eigenvectors [2]</em>.</p>
<h2 id="references_5">References<a class="headerlink" href="#references_5" title="Permanent link">&para;</a></h2>
<p>.. [1] ARPACK Software, http://www.caam.rice.edu/software/ARPACK/
.. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE:
Solution of Large Scale Eigenvalue Problems by Implicitly Restarted
Arnoldi Methods. SIAM, Philadelphia, PA, 1998.</p>
<h2 id="examples_98">Examples<a class="headerlink" href="#examples_98" title="Permanent link">&para;</a></h2>
<p>Find 6 eigenvectors of the identity matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import eigs
id = np.eye(13)
vals, vecs = eigs(id, k=6)
vals
array([ 1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j])
vecs.shape
(13, 6)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigsh</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sigma</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">which</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">v0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ncv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_eigenvectors</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">minv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">oPinv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find k eigenvalues and eigenvectors of the real symmetric square matrix
or complex hermitian matrix A.</p>
<p>Solves <code>A * x[i] = w[i] * x[i]</code>, the standard eigenvalue problem for
w[i] eigenvalues with corresponding eigenvectors x[i].</p>
<p>If M is specified, solves <code>A * x[i] = w[i] * M * x[i]</code>, the
generalized eigenvalue problem for w[i] eigenvalues
with corresponding eigenvectors x[i].</p>
<h2 id="parameters_226">Parameters<a class="headerlink" href="#parameters_226" title="Permanent link">&para;</a></h2>
<p>A : ndarray, sparse matrix or LinearOperator
A square operator representing the operation <code>A * x</code>, where <code>A</code> is
real symmetric or complex hermitian. For buckling mode (see below)
<code>A</code> must additionally be positive-definite.
k : int, optional
The number of eigenvalues and eigenvectors desired.
<code>k</code> must be smaller than N. It is not possible to compute all
eigenvectors of a matrix.</p>
<h2 id="returns_177">Returns<a class="headerlink" href="#returns_177" title="Permanent link">&para;</a></h2>
<p>w : array
Array of k eigenvalues.
v : array
An array representing the <code>k</code> eigenvectors.  The column <code>v[:, i]</code> is
the eigenvector corresponding to the eigenvalue <code>w[i]</code>.</p>
<h2 id="other-parameters">Other Parameters<a class="headerlink" href="#other-parameters" title="Permanent link">&para;</a></h2>
<p>M : An N x N matrix, array, sparse matrix, or linear operator representing
the operation <code>M @ x</code> for the generalized eigenvalue problem</p>
<p>A @ x = w * M @ x.</p>
<p>M must represent a real, symmetric matrix if A is real, and must
represent a complex, hermitian matrix if A is complex. For best
results, the data type of M should be the same as that of A.
Additionally:</p>
<p>If sigma is None, M is symmetric positive definite.</p>
<p>If sigma is specified, M is symmetric positive semi-definite.</p>
<p>In buckling mode, M is symmetric indefinite.</p>
<p>If sigma is None, eigsh requires an operator to compute the solution
of the linear equation <code>M @ x = b</code>. This is done internally via a
(sparse) LU decomposition for an explicit matrix M, or via an
iterative solver for a general linear operator.  Alternatively,
the user can supply the matrix or operator Minv, which gives
<code>x = Minv @ b = M^-1 @ b</code>.
sigma : real
Find eigenvalues near sigma using shift-invert mode.  This requires
an operator to compute the solution of the linear system
<code>[A - sigma * M] x = b</code>, where M is the identity matrix if
unspecified.  This is computed internally via a (sparse) LU
decomposition for explicit matrices A &amp; M, or via an iterative
solver if either A or M is a general linear operator.
Alternatively, the user can supply the matrix or operator OPinv,
which gives <code>x = OPinv @ b = [A - sigma * M]^-1 @ b</code>.
Note that when sigma is specified, the keyword 'which' refers to
the shifted eigenvalues <code>w'[i]</code> where:</p>
<p>if mode == 'normal', <code>w'[i] = 1 / (w[i] - sigma)</code>.</p>
<p>if mode == 'cayley', <code>w'[i] = (w[i] + sigma) / (w[i] - sigma)</code>.</p>
<p>if mode == 'buckling', <code>w'[i] = w[i] / (w[i] - sigma)</code>.</p>
<p>(see further discussion in 'mode' below)
v0 : ndarray, optional
Starting vector for iteration.
Default: random
ncv : int, optional
The number of Lanczos vectors generated ncv must be greater than k and
smaller than n; it is recommended that <code>ncv &gt; 2*k</code>.
Default: <code>min(n, max(2*k + 1, 20))</code>
which : str ['LM' | 'SM' | 'LA' | 'SA' | 'BE']
If A is a complex hermitian matrix, 'BE' is invalid.
Which <code>k</code> eigenvectors and eigenvalues to find:</p>
<p>'LM' : Largest (in magnitude) eigenvalues.</p>
<p>'SM' : Smallest (in magnitude) eigenvalues.</p>
<p>'LA' : Largest (algebraic) eigenvalues.</p>
<p>'SA' : Smallest (algebraic) eigenvalues.</p>
<p>'BE' : Half (k/2) from each end of the spectrum.</p>
<p>When k is odd, return one more (k/2+1) from the high end.
When sigma != None, 'which' refers to the shifted eigenvalues <code>w'[i]</code>
(see discussion in 'sigma', above).  ARPACK is generally better
at finding large values than small values.  If small eigenvalues are
desired, consider using shift-invert mode for better performance.
maxiter : int, optional
Maximum number of Arnoldi update iterations allowed.
Default: <code>n*10</code>
tol : float
Relative accuracy for eigenvalues (stopping criterion).
The default value of 0 implies machine precision.
Minv : N x N matrix, array, sparse matrix, or LinearOperator
See notes in M, above.
OPinv : N x N matrix, array, sparse matrix, or LinearOperator
See notes in sigma, above.
return_eigenvectors : bool
Return eigenvectors (True) in addition to eigenvalues.
This value determines the order in which eigenvalues are sorted.
The sort order is also dependent on the <code>which</code> variable.</p>
<p>For which = 'LM' or 'SA':
If <code>return_eigenvectors</code> is True, eigenvalues are sorted by
algebraic value.</p>
<p>If <code>return_eigenvectors</code> is False, eigenvalues are sorted by
absolute value.</p>
<p>For which = 'BE' or 'LA':
eigenvalues are always sorted by algebraic value.</p>
<p>For which = 'SM':
If <code>return_eigenvectors</code> is True, eigenvalues are sorted by
algebraic value.</p>
<p>If <code>return_eigenvectors</code> is False, eigenvalues are sorted by
decreasing absolute value.</p>
<p>mode : string ['normal' | 'buckling' | 'cayley']
Specify strategy to use for shift-invert mode.  This argument applies
only for real-valued A and sigma != None.  For shift-invert mode,
ARPACK internally solves the eigenvalue problem
<code>OP * x'[i] = w'[i] * B * x'[i]</code>
and transforms the resulting Ritz vectors x'[i] and Ritz values w'[i]
into the desired eigenvectors and eigenvalues of the problem
<code>A * x[i] = w[i] * M * x[i]</code>.
The modes are as follows:</p>
<p>'normal' :
OP = [A - sigma * M]^-1 @ M,
B = M,
w'[i] = 1 / (w[i] - sigma)</p>
<p>'buckling' :
OP = [A - sigma * M]^-1 @ A,
B = A,
w'[i] = w[i] / (w[i] - sigma)</p>
<p>'cayley' :
OP = [A - sigma * M]^-1 @ [A + sigma * M],
B = M,
w'[i] = (w[i] + sigma) / (w[i] - sigma)</p>
<p>The choice of mode will affect which eigenvalues are selected by
the keyword 'which', and can also impact the stability of
convergence (see [2] for a discussion).</p>
<h2 id="raises_9">Raises<a class="headerlink" href="#raises_9" title="Permanent link">&para;</a></h2>
<p>ArpackNoConvergence
When the requested convergence is not obtained.</p>
<p>The currently converged eigenvalues and eigenvectors can be found
as <code>eigenvalues</code> and <code>eigenvectors</code> attributes of the exception
object.</p>
<h2 id="see-also_77">See Also<a class="headerlink" href="#see-also_77" title="Permanent link">&para;</a></h2>
<p>eigs : eigenvalues and eigenvectors for a general (nonsymmetric) matrix A
svds : singular value decomposition for a matrix A</p>
<h2 id="notes_64">Notes<a class="headerlink" href="#notes_64" title="Permanent link">&para;</a></h2>
<p>This function is a wrapper to the ARPACK [1]<em> SSEUPD and DSEUPD
functions which use the Implicitly Restarted Lanczos Method to
find the eigenvalues and eigenvectors [2]</em>.</p>
<h2 id="references_6">References<a class="headerlink" href="#references_6" title="Permanent link">&para;</a></h2>
<p>.. [1] ARPACK Software, http://www.caam.rice.edu/software/ARPACK/
.. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE:
Solution of Large Scale Eigenvalue Problems by Implicitly Restarted
Arnoldi Methods. SIAM, Philadelphia, PA, 1998.</p>
<h2 id="examples_99">Examples<a class="headerlink" href="#examples_99" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import eigsh
identity = np.eye(13)
eigenvalues, eigenvectors = eigsh(identity, k=6)
eigenvalues
array([1., 1., 1., 1., 1., 1.])
eigenvectors.shape
(13, 6)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eye</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sparse matrix with ones on diagonal</p>
<p>Returns a sparse (m x n) matrix where the k-th diagonal
is all ones and everything else is zeros.</p>
<h2 id="parameters_227">Parameters<a class="headerlink" href="#parameters_227" title="Permanent link">&para;</a></h2>
<p>m : int
Number of rows in the matrix.
n : int, optional
Number of columns. Default: <code>m</code>.
k : int, optional
Diagonal to place ones on. Default: 0 (main diagonal).
dtype : dtype, optional
Data type of the matrix.
format : str, optional
Sparse format of the result, e.g. format='csr', etc.</p>
<h2 id="examples_100">Examples<a class="headerlink" href="#examples_100" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import sparse
sparse.eye(3).toarray()
array([[ 1.,  0.,  0.],
[ 0.,  1.,  0.],
[ 0.,  0.,  1.]])
sparse.eye(3, dtype=np.int8)
&lt;3x3 sparse matrix of type '<class 'numpy.int8'>'
with 3 stored elements (1 diagonals) in DIAgonal format&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_OPinv_matvec</span> <span class="o">:</span> <span class="o">?</span><span class="n">hermitian</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sigma</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_inv_matvec</span> <span class="o">:</span> <span class="o">?</span><span class="n">hermitian</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gmres</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">restart</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">restrt</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback_type</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Generalized Minimal RESidual iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_228">Parameters<a class="headerlink" href="#parameters_228" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_178">Returns<a class="headerlink" href="#returns_178" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : int
Provides convergence information:
* 0  : successful exit
* &gt;0 : convergence to tolerance not achieved, number of iterations
* &lt;0 : illegal input or breakdown</p>
<h2 id="other-parameters_1">Other parameters<a class="headerlink" href="#other-parameters_1" title="Permanent link">&para;</a></h2>
<p>x0 : {array, matrix}
Starting guess for the solution (a vector of zeros by default).
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
restart : int, optional
Number of iterations between restarts. Larger values increase
iteration cost, but may be necessary for convergence.
Default is 20.
maxiter : int, optional
Maximum number of iterations (restart cycles).  Iteration will stop
after maxiter steps even if the specified tolerance has not been
achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Inverse of the preconditioner of A.  M should approximate the
inverse of A and be easy to solve for (see Notes).  Effective
preconditioning dramatically improves the rate of convergence,
which implies that fewer iterations are needed to reach a given
error tolerance.  By default, no preconditioner is used.
callback : function
User-supplied function to call after each iteration.  It is called
as <code>callback(args)</code>, where <code>args</code> are selected by <code>callback_type</code>.
callback_type : {'x', 'pr_norm', 'legacy'}, optional
Callback function argument requested:
- <code>x</code>: current iterate (ndarray), called on every restart
- <code>pr_norm</code>: relative (preconditioned) residual norm (float),
called on every inner iteration
- <code>legacy</code> (default): same as <code>pr_norm</code>, but also changes the
meaning of 'maxiter' to count inner iterations instead of restart
cycles.
restrt : int, optional
DEPRECATED - use <code>restart</code> instead.</p>
<h2 id="see-also_78">See Also<a class="headerlink" href="#see-also_78" title="Permanent link">&para;</a></h2>
<p>LinearOperator</p>
<h2 id="notes_65">Notes<a class="headerlink" href="#notes_65" title="Permanent link">&para;</a></h2>
<p>A preconditioner, P, is chosen such that P is close to A but easy to solve
for. The preconditioner parameter required by this routine is
<code>M = P^-1</code>. The inverse should preferably not be calculated
explicitly.  Rather, use the following template to produce M::</p>
<h1 id="construct-a-linear-operator-that-computes-p-1-x">Construct a linear operator that computes P^-1 * x.<a class="headerlink" href="#construct-a-linear-operator-that-computes-p-1-x" title="Permanent link">&para;</a></h1>
<p>import scipy.sparse.linalg as spla
M_x = lambda x: spla.spsolve(P, x)
M = spla.LinearOperator((n, n), M_x)</p>
<h2 id="examples_101">Examples<a class="headerlink" href="#examples_101" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import gmres
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
b = np.array([2, 4, -1], dtype=float)
x, exitCode = gmres(A, b)
print(exitCode)            # 0 indicates successful convergence
0
np.allclose(A.dot(x), b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gmres_loose</span> <span class="o">:</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gmres with looser termination condition.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_pydata_spmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Check whether object is pydata/sparse matrix, avoiding importing the module.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isdense</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">issparse</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_229">Parameters<a class="headerlink" href="#parameters_229" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_179">Returns<a class="headerlink" href="#returns_179" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_66">Notes<a class="headerlink" href="#notes_66" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_102">Examples<a class="headerlink" href="#examples_102" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_230">Parameters<a class="headerlink" href="#parameters_230" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_180">Returns<a class="headerlink" href="#returns_180" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_67">Notes<a class="headerlink" href="#notes_67" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_103">Examples<a class="headerlink" href="#examples_103" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_csr</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of csr_matrix type?</p>
<h2 id="parameters_231">Parameters<a class="headerlink" href="#parameters_231" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a csr matrix</p>
<h2 id="returns_181">Returns<a class="headerlink" href="#returns_181" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a csr matrix, False otherwise</p>
<h2 id="examples_104">Examples<a class="headerlink" href="#examples_104" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix_csr
isspmatrix_csr(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import csc_matrix, csr_matrix, isspmatrix_csc
isspmatrix_csr(csc_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lobpcg</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">y</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">largest</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbosityLevel</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retLambdaHistory</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retResidualNormsHistory</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG)</p>
<p>LOBPCG is a preconditioned eigensolver for large symmetric positive
definite (SPD) generalized eigenproblems.</p>
<h2 id="parameters_232">Parameters<a class="headerlink" href="#parameters_232" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The symmetric linear operator of the problem, usually a
sparse matrix.  Often called the 'stiffness matrix'.
X : ndarray, float32 or float64
Initial approximation to the <code>k</code> eigenvectors (non-sparse). If <code>A</code>
has <code>shape=(n,n)</code> then <code>X</code> should have shape <code>shape=(n,k)</code>.
B : {dense matrix, sparse matrix, LinearOperator}, optional
The right hand side operator in a generalized eigenproblem.
By default, <code>B = Identity</code>.  Often called the 'mass matrix'.
M : {dense matrix, sparse matrix, LinearOperator}, optional
Preconditioner to <code>A</code>; by default <code>M = Identity</code>.
<code>M</code> should approximate the inverse of <code>A</code>.
Y : ndarray, float32 or float64, optional
n-by-sizeY matrix of constraints (non-sparse), sizeY &lt; n
The iterations will be performed in the B-orthogonal complement
of the column-space of Y. Y must be full rank.
tol : scalar, optional
Solver tolerance (stopping criterion).
The default is <code>tol=n*sqrt(eps)</code>.
maxiter : int, optional
Maximum number of iterations.  The default is <code>maxiter = 20</code>.
largest : bool, optional
When True, solve for the largest eigenvalues, otherwise the smallest.
verbosityLevel : int, optional
Controls solver output.  The default is <code>verbosityLevel=0</code>.
retLambdaHistory : bool, optional
Whether to return eigenvalue history.  Default is False.
retResidualNormsHistory : bool, optional
Whether to return history of residual norms.  Default is False.</p>
<h2 id="returns_182">Returns<a class="headerlink" href="#returns_182" title="Permanent link">&para;</a></h2>
<p>w : ndarray
Array of <code>k</code> eigenvalues
v : ndarray
An array of <code>k</code> eigenvectors.  <code>v</code> has the same shape as <code>X</code>.
lambdas : list of ndarray, optional
The eigenvalue history, if <code>retLambdaHistory</code> is True.
rnorms : list of ndarray, optional
The history of residual norms, if <code>retResidualNormsHistory</code> is True.</p>
<h2 id="notes_68">Notes<a class="headerlink" href="#notes_68" title="Permanent link">&para;</a></h2>
<p>If both <code>retLambdaHistory</code> and <code>retResidualNormsHistory</code> are True,
the return tuple has the following format
<code>(lambda, V, lambda history, residual norms history)</code>.</p>
<p>In the following <code>n</code> denotes the matrix size and <code>m</code> the number
of required eigenvalues (smallest or largest).</p>
<p>The LOBPCG code internally solves eigenproblems of the size <code>3m</code> on every
iteration by calling the 'standard' dense eigensolver, so if <code>m</code> is not
small enough compared to <code>n</code>, it does not make sense to call the LOBPCG
code, but rather one should use the 'standard' eigensolver, e.g. numpy or
scipy function in this case.
If one calls the LOBPCG algorithm for <code>5m &gt; n</code>, it will most likely break
internally, so the code tries to call the standard function instead.</p>
<p>It is not that <code>n</code> should be large for the LOBPCG to work, but rather the
ratio <code>n / m</code> should be large. It you call LOBPCG with <code>m=1</code>
and <code>n=10</code>, it works though <code>n</code> is small. The method is intended
for extremely large <code>n / m</code>, see e.g., reference [28] in
https://arxiv.org/abs/0705.2626</p>
<p>The convergence speed depends basically on two factors:</p>
<ol>
<li>
<p>How well relatively separated the seeking eigenvalues are from the rest
of the eigenvalues. One can try to vary <code>m</code> to make this better.</p>
</li>
<li>
<p>How well conditioned the problem is. This can be changed by using proper
preconditioning. For example, a rod vibration test problem (under tests
directory) is ill-conditioned for large <code>n</code>, so convergence will be
slow, unless efficient preconditioning is used. For this specific
problem, a good simple preconditioner function would be a linear solve
for <code>A</code>, which is easy to code since A is tridiagonal.</p>
</li>
</ol>
<h2 id="references_7">References<a class="headerlink" href="#references_7" title="Permanent link">&para;</a></h2>
<p>.. [1] A. V. Knyazev (2001),
Toward the Optimal Preconditioned Eigensolver: Locally Optimal
Block Preconditioned Conjugate Gradient Method.
SIAM Journal on Scientific Computing 23, no. 2,
pp. 517-541. http://dx.doi.org/10.1137/S1064827500366124</p>
<p>.. [2] A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov
(2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers
(BLOPEX) in hypre and PETSc. https://arxiv.org/abs/0705.2626</p>
<p>.. [3] A. V. Knyazev's C and MATLAB implementations:
https://bitbucket.org/joseroman/blopex</p>
<h2 id="examples_105">Examples<a class="headerlink" href="#examples_105" title="Permanent link">&para;</a></h2>
<p>Solve <code>A x = lambda x</code> with constraints and preconditioning.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import spdiags, issparse
from scipy.sparse.linalg import lobpcg, LinearOperator
n = 100
vals = np.arange(1, n + 1)
A = spdiags(vals, 0, n, n)
A.toarray()
array([[  1.,   0.,   0., ...,   0.,   0.,   0.],
[  0.,   2.,   0., ...,   0.,   0.,   0.],
[  0.,   0.,   3., ...,   0.,   0.,   0.],
...,
[  0.,   0.,   0., ...,  98.,   0.,   0.],
[  0.,   0.,   0., ...,   0.,  99.,   0.],
[  0.,   0.,   0., ...,   0.,   0., 100.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constraints:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Y = np.eye(n, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initial guess for eigenvectors, should have linearly independent
columns. Column dimension = number of requested eigenvalues.</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = np.random.rand(n, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Preconditioner in the inverse of A in this example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>invA = spdiags([1./vals], 0, n, n)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The preconditiner must be defined by a function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def precond( x ):
...     return invA @ x</p>
</blockquote>
</blockquote>
</blockquote>
<p>The argument x of the preconditioner function is a matrix inside <code>lobpcg</code>,
thus the use of matrix-matrix product <code>@</code>.</p>
<p>The preconditioner function is passed to lobpcg as a <code>LinearOperator</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>M = LinearOperator(matvec=precond, matmat=precond,
...                    shape=(n, n), dtype=float)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Let us now solve the eigenvalue problem for the matrix A:</p>
<blockquote>
<blockquote>
<blockquote>
<p>eigenvalues, _ = lobpcg(A, X, Y=Y, M=M, largest=False)
eigenvalues
array([4., 5., 6.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that the vectors passed in Y are the eigenvectors of the 3 smallest
eigenvalues. The results returned are orthogonal to those.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu_factor</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute pivoted LU decomposition of a matrix.</p>
<p>The decomposition is::</p>
<p>A = P L U</p>
<p>where P is a permutation matrix, L lower triangular with unit
diagonal elements, and U upper triangular.</p>
<h2 id="parameters_233">Parameters<a class="headerlink" href="#parameters_233" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to decompose
overwrite_a : bool, optional
Whether to overwrite data in A (may increase performance)
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_183">Returns<a class="headerlink" href="#returns_183" title="Permanent link">&para;</a></h2>
<p>lu : (N, N) ndarray
Matrix containing U in its upper triangle, and L in its lower triangle.
The unit diagonal elements of L are not stored.
piv : (N,) ndarray
Pivot indices representing the permutation matrix P:
row i of matrix was interchanged with row piv[i].</p>
<h2 id="see-also_79">See also<a class="headerlink" href="#see-also_79" title="Permanent link">&para;</a></h2>
<p>lu_solve : solve an equation system using the LU factorization of a matrix</p>
<h2 id="notes_69">Notes<a class="headerlink" href="#notes_69" title="Permanent link">&para;</a></h2>
<p>This is a wrapper to the <code>*GETRF</code> routines from LAPACK.</p>
<h2 id="examples_106">Examples<a class="headerlink" href="#examples_106" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import lu_factor
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
lu, piv = lu_factor(A)
piv
array([2, 2, 3, 3], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Convert LAPACK's <code>piv</code> array to NumPy index and test the permutation</p>
<blockquote>
<blockquote>
<blockquote>
<p>piv_py = [2, 0, 3, 1]
L, U = np.tril(lu, k=-1) + np.eye(4), np.triu(lu)
np.allclose(A[piv_py] - L @ U, np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu_solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">trans</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">lu_and_piv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve an equation system, a x = b, given the LU factorization of a</p>
<h2 id="parameters_234">Parameters<a class="headerlink" href="#parameters_234" title="Permanent link">&para;</a></h2>
<p>(lu, piv)
Factorization of the coefficient matrix a, as given by lu_factor
b : array
Right-hand side
trans : {0, 1, 2}, optional
Type of system to solve:</p>
<p>=====  =========
trans  system
=====  =========
0      a x   = b
1      a^T x = b
2      a^H x = b
=====  =========
overwrite_b : bool, optional
Whether to overwrite data in b (may increase performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_184">Returns<a class="headerlink" href="#returns_184" title="Permanent link">&para;</a></h2>
<p>x : array
Solution to the system</p>
<h2 id="see-also_80">See also<a class="headerlink" href="#see-also_80" title="Permanent link">&para;</a></h2>
<p>lu_factor : LU factorize a matrix</p>
<h2 id="examples_107">Examples<a class="headerlink" href="#examples_107" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import lu_factor, lu_solve
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
b = np.array([1, 1, 1, 1])
lu, piv = lu_factor(A)
x = lu_solve((lu, piv), b)
np.allclose(A @ x - b, np.zeros((4,)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">splu</span> <span class="o">:</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag_pivot_thresh</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">relax</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">panel_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the LU decomposition of a sparse, square matrix.</p>
<h2 id="parameters_235">Parameters<a class="headerlink" href="#parameters_235" title="Permanent link">&para;</a></h2>
<p>A : sparse matrix
Sparse matrix to factorize. Should be in CSR or CSC format.
permc_spec : str, optional
How to permute the columns of the matrix for sparsity preservation.
(default: 'COLAMD')</p>
<ul>
<li><code>NATURAL</code>: natural ordering.</li>
<li><code>MMD_ATA</code>: minimum degree ordering on the structure of A^T A.</li>
<li><code>MMD_AT_PLUS_A</code>: minimum degree ordering on the structure of A^T+A.</li>
<li><code>COLAMD</code>: approximate minimum degree column ordering</li>
</ul>
<p>diag_pivot_thresh : float, optional
Threshold used for a diagonal entry to be an acceptable pivot.
See SuperLU user's guide for details [1]<em>
relax : int, optional
Expert option for customizing the degree of relaxing supernodes.
See SuperLU user's guide for details [1]</em>
panel_size : int, optional
Expert option for customizing the panel size.
See SuperLU user's guide for details [1]<em>
options : dict, optional
Dictionary containing additional expert options to SuperLU.
See SuperLU user guide [1]</em> (section 2.4 on the 'Options' argument)
for more details. For example, you can specify
<code>options=dict(Equil=False, IterRefine='SINGLE'))</code>
to turn equilibration off and perform a single iterative refinement.</p>
<h2 id="returns_185">Returns<a class="headerlink" href="#returns_185" title="Permanent link">&para;</a></h2>
<p>invA : scipy.sparse.linalg.SuperLU
Object, which has a <code>solve</code> method.</p>
<h2 id="see-also_81">See also<a class="headerlink" href="#see-also_81" title="Permanent link">&para;</a></h2>
<p>spilu : incomplete LU decomposition</p>
<h2 id="notes_70">Notes<a class="headerlink" href="#notes_70" title="Permanent link">&para;</a></h2>
<p>This function uses the SuperLU library.</p>
<h2 id="references_8">References<a class="headerlink" href="#references_8" title="Permanent link">&para;</a></h2>
<p>.. [1] SuperLU http://crd.lbl.gov/~xiaoye/SuperLU/</p>
<h2 id="examples_108">Examples<a class="headerlink" href="#examples_108" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import splu
A = csc_matrix([[1., 0., 0.], [5., 0., 2.], [0., -1., 0.]], dtype=float)
B = splu(A)
x = np.array([1., 2., 3.], dtype=float)
B.solve(x)
array([ 1. , -3. , -1.5])
A.dot(B.solve(x))
array([ 1.,  2.,  3.])
B.solve(A.dot(x))
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svds</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ncv</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">which</span><span class="o">:[`</span><span class="nc">LM</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SM</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">v0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_singular_vectors</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">solver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the largest or smallest k singular values/vectors for a sparse matrix. The order of the singular values is not guaranteed.</p>
<h2 id="parameters_236">Parameters<a class="headerlink" href="#parameters_236" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, LinearOperator}
Array to compute the SVD on, of shape (M, N)
k : int, optional
Number of singular values and vectors to compute.
Must be 1 &lt;= k &lt; min(A.shape).
ncv : int, optional
The number of Lanczos vectors generated
ncv must be greater than k+1 and smaller than n;
it is recommended that ncv &gt; 2*k
Default: <code>min(n, max(2*k + 1, 20))</code>
tol : float, optional
Tolerance for singular values. Zero (default) means machine precision.
which : str, ['LM' | 'SM'], optional
Which <code>k</code> singular values to find:</p>
<ul>
<li>'LM' : largest singular values</li>
<li>'SM' : smallest singular values</li>
</ul>
<p>.. versionadded:: 0.12.0
v0 : ndarray, optional
Starting vector for iteration, of length min(A.shape). Should be an
(approximate) left singular vector if N &gt; M and a right singular
vector otherwise.
Default: random</p>
<p>.. versionadded:: 0.12.0
maxiter : int, optional
Maximum number of iterations.</p>
<p>.. versionadded:: 0.12.0
return_singular_vectors : bool or str, optional
- True: return singular vectors (True) in addition to singular values.</p>
<p>.. versionadded:: 0.12.0</p>
<ul>
<li>'u': only return the u matrix, without computing vh (if N &gt; M).</li>
<li>'vh': only return the vh matrix, without computing u (if N &lt;= M).</li>
</ul>
<p>.. versionadded:: 0.16.0
solver : str, optional
Eigenvalue solver to use. Should be 'arpack' or 'lobpcg'.
Default: 'arpack'</p>
<h2 id="returns_186">Returns<a class="headerlink" href="#returns_186" title="Permanent link">&para;</a></h2>
<p>u : ndarray, shape=(M, k)
Unitary matrix having left singular vectors as columns.
If <code>return_singular_vectors</code> is 'vh', this variable is not computed,
and None is returned instead.
s : ndarray, shape=(k,)
The singular values.
vt : ndarray, shape=(k, N)
Unitary matrix having right singular vectors as rows.
If <code>return_singular_vectors</code> is 'u', this variable is not computed,
and None is returned instead.</p>
<h2 id="notes_71">Notes<a class="headerlink" href="#notes_71" title="Permanent link">&para;</a></h2>
<p>This is a naive implementation using ARPACK or LOBPCG as an eigensolver
on A.H * A or A * A.H, depending on which one is more efficient.</p>
<h2 id="examples_109">Examples<a class="headerlink" href="#examples_109" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import svds, eigs
A = csc_matrix([[1, 0, 0], [5, 0, 2], [0, -1, 0], [0, 0, 3]], dtype=float)
u, s, vt = svds(A, k=2)
s
array([ 2.75193379,  5.6059665 ])
np.sqrt(eigs(A.dot(A.T), k=2)[0]).real
array([ 5.6059665 ,  2.75193379])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Dsolve</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Linsolve</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_237">Parameters<a class="headerlink" href="#parameters_237" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_187">Returns<a class="headerlink" href="#returns_187" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_82">See Also<a class="headerlink" href="#see-also_82" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_110">Examples<a class="headerlink" href="#examples_110" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">factorized</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a function for solving a sparse linear system, with A pre-factorized.</p>
<h2 id="parameters_238">Parameters<a class="headerlink" href="#parameters_238" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input.</p>
<h2 id="returns_188">Returns<a class="headerlink" href="#returns_188" title="Permanent link">&para;</a></h2>
<p>solve : callable
To solve the linear system of equations given in <code>A</code>, the <code>solve</code>
callable should be passed an ndarray of shape (N,).</p>
<h2 id="examples_111">Examples<a class="headerlink" href="#examples_111" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import factorized
A = np.array([[ 3. ,  2. , -1. ],
...               [ 2. , -2. ,  4. ],
...               [-1. ,  0.5, -1. ]])
solve = factorized(A) # Makes LU decomposition.
rhs1 = np.array([1, -2, 0])
solve(rhs1) # Uses the LU factors.
array([ 1., -2., -2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_pydata_spmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Check whether object is pydata/sparse matrix, avoiding importing the module.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_239">Parameters<a class="headerlink" href="#parameters_239" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_189">Returns<a class="headerlink" href="#returns_189" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_72">Notes<a class="headerlink" href="#notes_72" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_112">Examples<a class="headerlink" href="#examples_112" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_csc</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of csc_matrix type?</p>
<h2 id="parameters_240">Parameters<a class="headerlink" href="#parameters_240" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a csc matrix</p>
<h2 id="returns_190">Returns<a class="headerlink" href="#returns_190" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a csc matrix, False otherwise</p>
<h2 id="examples_113">Examples<a class="headerlink" href="#examples_113" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix, isspmatrix_csc
isspmatrix_csc(csc_matrix([[5]]))
True</p>
<p>from scipy.sparse import csc_matrix, csr_matrix, isspmatrix_csc
isspmatrix_csc(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_csr</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of csr_matrix type?</p>
<h2 id="parameters_241">Parameters<a class="headerlink" href="#parameters_241" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a csr matrix</p>
<h2 id="returns_191">Returns<a class="headerlink" href="#returns_191" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a csr matrix, False otherwise</p>
<h2 id="examples_114">Examples<a class="headerlink" href="#examples_114" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix_csr
isspmatrix_csr(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import csc_matrix, csr_matrix, isspmatrix_csc
isspmatrix_csr(csc_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spilu</span> <span class="o">:</span> <span class="o">?</span><span class="n">drop_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fill_factor</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">drop_rule</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag_pivot_thresh</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">relax</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">panel_size</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute an incomplete LU decomposition for a sparse, square matrix.</p>
<p>The resulting object is an approximation to the inverse of <code>A</code>.</p>
<h2 id="parameters_242">Parameters<a class="headerlink" href="#parameters_242" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Sparse matrix to factorize
drop_tol : float, optional
Drop tolerance (0 &lt;= tol &lt;= 1) for an incomplete LU decomposition.
(default: 1e-4)
fill_factor : float, optional
Specifies the fill ratio upper bound (&gt;= 1.0) for ILU. (default: 10)
drop_rule : str, optional
Comma-separated string of drop rules to use.
Available rules: <code>basic</code>, <code>prows</code>, <code>column</code>, <code>area</code>,
<code>secondary</code>, <code>dynamic</code>, <code>interp</code>. (Default: <code>basic,area</code>)</p>
<p>See SuperLU documentation for details.</p>
<p>Remaining other options
Same as for <code>splu</code></p>
<h2 id="returns_192">Returns<a class="headerlink" href="#returns_192" title="Permanent link">&para;</a></h2>
<p>invA_approx : scipy.sparse.linalg.SuperLU
Object, which has a <code>solve</code> method.</p>
<h2 id="see-also_83">See also<a class="headerlink" href="#see-also_83" title="Permanent link">&para;</a></h2>
<p>splu : complete LU decomposition</p>
<h2 id="notes_73">Notes<a class="headerlink" href="#notes_73" title="Permanent link">&para;</a></h2>
<p>To improve the better approximation to the inverse, you may need to
increase <code>fill_factor</code> AND decrease <code>drop_tol</code>.</p>
<p>This function uses the SuperLU library.</p>
<h2 id="examples_115">Examples<a class="headerlink" href="#examples_115" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import spilu
A = csc_matrix([[1., 0., 0.], [5., 0., 2.], [0., -1., 0.]], dtype=float)
B = spilu(A)
x = np.array([1., 2., 3.], dtype=float)
B.solve(x)
array([ 1. , -3. , -1.5])
A.dot(B.solve(x))
array([ 1.,  2.,  3.])
B.solve(A.dot(x))
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">splu</span> <span class="o">:</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag_pivot_thresh</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">relax</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">panel_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the LU decomposition of a sparse, square matrix.</p>
<h2 id="parameters_243">Parameters<a class="headerlink" href="#parameters_243" title="Permanent link">&para;</a></h2>
<p>A : sparse matrix
Sparse matrix to factorize. Should be in CSR or CSC format.
permc_spec : str, optional
How to permute the columns of the matrix for sparsity preservation.
(default: 'COLAMD')</p>
<ul>
<li><code>NATURAL</code>: natural ordering.</li>
<li><code>MMD_ATA</code>: minimum degree ordering on the structure of A^T A.</li>
<li><code>MMD_AT_PLUS_A</code>: minimum degree ordering on the structure of A^T+A.</li>
<li><code>COLAMD</code>: approximate minimum degree column ordering</li>
</ul>
<p>diag_pivot_thresh : float, optional
Threshold used for a diagonal entry to be an acceptable pivot.
See SuperLU user's guide for details [1]<em>
relax : int, optional
Expert option for customizing the degree of relaxing supernodes.
See SuperLU user's guide for details [1]</em>
panel_size : int, optional
Expert option for customizing the panel size.
See SuperLU user's guide for details [1]<em>
options : dict, optional
Dictionary containing additional expert options to SuperLU.
See SuperLU user guide [1]</em> (section 2.4 on the 'Options' argument)
for more details. For example, you can specify
<code>options=dict(Equil=False, IterRefine='SINGLE'))</code>
to turn equilibration off and perform a single iterative refinement.</p>
<h2 id="returns_193">Returns<a class="headerlink" href="#returns_193" title="Permanent link">&para;</a></h2>
<p>invA : scipy.sparse.linalg.SuperLU
Object, which has a <code>solve</code> method.</p>
<h2 id="see-also_84">See also<a class="headerlink" href="#see-also_84" title="Permanent link">&para;</a></h2>
<p>spilu : incomplete LU decomposition</p>
<h2 id="notes_74">Notes<a class="headerlink" href="#notes_74" title="Permanent link">&para;</a></h2>
<p>This function uses the SuperLU library.</p>
<h2 id="references_9">References<a class="headerlink" href="#references_9" title="Permanent link">&para;</a></h2>
<p>.. [1] SuperLU http://crd.lbl.gov/~xiaoye/SuperLU/</p>
<h2 id="examples_116">Examples<a class="headerlink" href="#examples_116" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import splu
A = csc_matrix([[1., 0., 0.], [5., 0., 2.], [0., -1., 0.]], dtype=float)
B = splu(A)
x = np.array([1., 2., 3.], dtype=float)
B.solve(x)
array([ 1. , -3. , -1.5])
A.dot(B.solve(x))
array([ 1.,  2.,  3.])
B.solve(A.dot(x))
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spsolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">use_umfpack</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the sparse linear system Ax=b, where b may be a vector or a matrix.</p>
<h2 id="parameters_244">Parameters<a class="headerlink" href="#parameters_244" title="Permanent link">&para;</a></h2>
<p>A : ndarray or sparse matrix
The square matrix A will be converted into CSC or CSR form
b : ndarray or sparse matrix
The matrix or vector representing the right hand side of the equation.
If a vector, b.shape must be (n,) or (n, 1).
permc_spec : str, optional
How to permute the columns of the matrix for sparsity preservation.
(default: 'COLAMD')</p>
<ul>
<li><code>NATURAL</code>: natural ordering.</li>
<li><code>MMD_ATA</code>: minimum degree ordering on the structure of A^T A.</li>
<li><code>MMD_AT_PLUS_A</code>: minimum degree ordering on the structure of A^T+A.</li>
<li><code>COLAMD</code>: approximate minimum degree column ordering
use_umfpack : bool, optional
if True (default) then use umfpack for the solution.  This is
only referenced if b is a vector and <code>scikit-umfpack</code> is installed.</li>
</ul>
<h2 id="returns_194">Returns<a class="headerlink" href="#returns_194" title="Permanent link">&para;</a></h2>
<p>x : ndarray or sparse matrix
the solution of the sparse linear equation.
If b is a vector, then x is a vector of size A.shape[1]
If b is a matrix, then x is a matrix of size (A.shape[1], b.shape[1])</p>
<h2 id="notes_75">Notes<a class="headerlink" href="#notes_75" title="Permanent link">&para;</a></h2>
<p>For solving the matrix expression AX = B, this solver assumes the resulting
matrix X is sparse, as is often the case for very sparse inputs.  If the
resulting X is dense, the construction of this sparse result will be
relatively expensive.  In that case, consider converting A to a dense
matrix and using scipy.linalg.solve or its variants.</p>
<h2 id="examples_117">Examples<a class="headerlink" href="#examples_117" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import spsolve
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
B = csc_matrix([[2, 0], [-1, 0], [2, 0]], dtype=float)
x = spsolve(A, B)
np.allclose(A.dot(x).todense(), B.todense())
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spsolve_triangular</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_A</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">unit_diagonal</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation <code>A x = b</code> for <code>x</code>, assuming A is a triangular matrix.</p>
<h2 id="parameters_245">Parameters<a class="headerlink" href="#parameters_245" title="Permanent link">&para;</a></h2>
<p>A : (M, M) sparse matrix
A sparse square triangular matrix. Should be in CSR format.
b : (M,) or (M, N) array_like
Right-hand side matrix in <code>A x = b</code>
lower : bool, optional
Whether <code>A</code> is a lower or upper triangular matrix.
Default is lower triangular matrix.
overwrite_A : bool, optional
Allow changing <code>A</code>. The indices of <code>A</code> are going to be sorted and zero
entries are going to be removed.
Enabling gives a performance gain. Default is False.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code>.
Enabling gives a performance gain. Default is False.
If <code>overwrite_b</code> is True, it should be ensured that
<code>b</code> has an appropriate dtype to be able to store the result.
unit_diagonal : bool, optional
If True, diagonal elements of <code>a</code> are assumed to be 1 and will not be
referenced.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="returns_195">Returns<a class="headerlink" href="#returns_195" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, N) ndarray
Solution to the system <code>A x = b</code>. Shape of return matches shape of <code>b</code>.</p>
<h2 id="raises_10">Raises<a class="headerlink" href="#raises_10" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If <code>A</code> is singular or not triangular.
ValueError
If shape of <code>A</code> or shape of <code>b</code> do not match the requirements.</p>
<h2 id="notes_76">Notes<a class="headerlink" href="#notes_76" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_118">Examples<a class="headerlink" href="#examples_118" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.linalg import spsolve_triangular
A = csr_matrix([[3, 0, 0], [1, -1, 0], [2, 0, 1]], dtype=float)
B = np.array([[2, 0], [-1, 0], [2, 0]], dtype=float)
x = spsolve_triangular(A, B)
np.allclose(A.dot(x), B)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">use_solver</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Select default sparse direct solver to be used.</p>
<h2 id="parameters_246">Parameters<a class="headerlink" href="#parameters_246" title="Permanent link">&para;</a></h2>
<p>useUmfpack : bool, optional
Use UMFPACK over SuperLU. Has effect only if scikits.umfpack is
installed. Default: True
assumeSortedIndices : bool, optional
Allow UMFPACK to skip the step of sorting indices for a CSR/CSC matrix.
Has effect only if useUmfpack is True and scikits.umfpack is installed.
Default: False</p>
<h2 id="notes_77">Notes<a class="headerlink" href="#notes_77" title="Permanent link">&para;</a></h2>
<p>The default sparse solver is umfpack when available
(scikits.umfpack is installed). This can be changed by passing
useUmfpack = False, which then causes the always present SuperLU
based solver to be used.</p>
<p>Umfpack requires a CSR/CSC matrix to have sorted column/row indices. If
sure that the matrix fulfills this, pass <code>assumeSortedIndices=True</code>
to gain some speed.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">warn</span> <span class="o">:</span> <span class="o">?</span><span class="n">category</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stacklevel</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">source</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">message</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Issue a warning, or maybe ignore it or raise an exception.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">factorized</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a function for solving a sparse linear system, with A pre-factorized.</p>
<h2 id="parameters_247">Parameters<a class="headerlink" href="#parameters_247" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input.</p>
<h2 id="returns_196">Returns<a class="headerlink" href="#returns_196" title="Permanent link">&para;</a></h2>
<p>solve : callable
To solve the linear system of equations given in <code>A</code>, the <code>solve</code>
callable should be passed an ndarray of shape (N,).</p>
<h2 id="examples_119">Examples<a class="headerlink" href="#examples_119" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import factorized
A = np.array([[ 3. ,  2. , -1. ],
...               [ 2. , -2. ,  4. ],
...               [-1. ,  0.5, -1. ]])
solve = factorized(A) # Makes LU decomposition.
rhs1 = np.array([1, -2, 0])
solve(rhs1) # Uses the LU factors.
array([ 1., -2., -2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spilu</span> <span class="o">:</span> <span class="o">?</span><span class="n">drop_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fill_factor</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">drop_rule</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag_pivot_thresh</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">relax</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">panel_size</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute an incomplete LU decomposition for a sparse, square matrix.</p>
<p>The resulting object is an approximation to the inverse of <code>A</code>.</p>
<h2 id="parameters_248">Parameters<a class="headerlink" href="#parameters_248" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Sparse matrix to factorize
drop_tol : float, optional
Drop tolerance (0 &lt;= tol &lt;= 1) for an incomplete LU decomposition.
(default: 1e-4)
fill_factor : float, optional
Specifies the fill ratio upper bound (&gt;= 1.0) for ILU. (default: 10)
drop_rule : str, optional
Comma-separated string of drop rules to use.
Available rules: <code>basic</code>, <code>prows</code>, <code>column</code>, <code>area</code>,
<code>secondary</code>, <code>dynamic</code>, <code>interp</code>. (Default: <code>basic,area</code>)</p>
<p>See SuperLU documentation for details.</p>
<p>Remaining other options
Same as for <code>splu</code></p>
<h2 id="returns_197">Returns<a class="headerlink" href="#returns_197" title="Permanent link">&para;</a></h2>
<p>invA_approx : scipy.sparse.linalg.SuperLU
Object, which has a <code>solve</code> method.</p>
<h2 id="see-also_85">See also<a class="headerlink" href="#see-also_85" title="Permanent link">&para;</a></h2>
<p>splu : complete LU decomposition</p>
<h2 id="notes_78">Notes<a class="headerlink" href="#notes_78" title="Permanent link">&para;</a></h2>
<p>To improve the better approximation to the inverse, you may need to
increase <code>fill_factor</code> AND decrease <code>drop_tol</code>.</p>
<p>This function uses the SuperLU library.</p>
<h2 id="examples_120">Examples<a class="headerlink" href="#examples_120" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import spilu
A = csc_matrix([[1., 0., 0.], [5., 0., 2.], [0., -1., 0.]], dtype=float)
B = spilu(A)
x = np.array([1., 2., 3.], dtype=float)
B.solve(x)
array([ 1. , -3. , -1.5])
A.dot(B.solve(x))
array([ 1.,  2.,  3.])
B.solve(A.dot(x))
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">splu</span> <span class="o">:</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag_pivot_thresh</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">relax</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">panel_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the LU decomposition of a sparse, square matrix.</p>
<h2 id="parameters_249">Parameters<a class="headerlink" href="#parameters_249" title="Permanent link">&para;</a></h2>
<p>A : sparse matrix
Sparse matrix to factorize. Should be in CSR or CSC format.
permc_spec : str, optional
How to permute the columns of the matrix for sparsity preservation.
(default: 'COLAMD')</p>
<ul>
<li><code>NATURAL</code>: natural ordering.</li>
<li><code>MMD_ATA</code>: minimum degree ordering on the structure of A^T A.</li>
<li><code>MMD_AT_PLUS_A</code>: minimum degree ordering on the structure of A^T+A.</li>
<li><code>COLAMD</code>: approximate minimum degree column ordering</li>
</ul>
<p>diag_pivot_thresh : float, optional
Threshold used for a diagonal entry to be an acceptable pivot.
See SuperLU user's guide for details [1]<em>
relax : int, optional
Expert option for customizing the degree of relaxing supernodes.
See SuperLU user's guide for details [1]</em>
panel_size : int, optional
Expert option for customizing the panel size.
See SuperLU user's guide for details [1]<em>
options : dict, optional
Dictionary containing additional expert options to SuperLU.
See SuperLU user guide [1]</em> (section 2.4 on the 'Options' argument)
for more details. For example, you can specify
<code>options=dict(Equil=False, IterRefine='SINGLE'))</code>
to turn equilibration off and perform a single iterative refinement.</p>
<h2 id="returns_198">Returns<a class="headerlink" href="#returns_198" title="Permanent link">&para;</a></h2>
<p>invA : scipy.sparse.linalg.SuperLU
Object, which has a <code>solve</code> method.</p>
<h2 id="see-also_86">See also<a class="headerlink" href="#see-also_86" title="Permanent link">&para;</a></h2>
<p>spilu : incomplete LU decomposition</p>
<h2 id="notes_79">Notes<a class="headerlink" href="#notes_79" title="Permanent link">&para;</a></h2>
<p>This function uses the SuperLU library.</p>
<h2 id="references_10">References<a class="headerlink" href="#references_10" title="Permanent link">&para;</a></h2>
<p>.. [1] SuperLU http://crd.lbl.gov/~xiaoye/SuperLU/</p>
<h2 id="examples_121">Examples<a class="headerlink" href="#examples_121" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import splu
A = csc_matrix([[1., 0., 0.], [5., 0., 2.], [0., -1., 0.]], dtype=float)
B = splu(A)
x = np.array([1., 2., 3.], dtype=float)
B.solve(x)
array([ 1. , -3. , -1.5])
A.dot(B.solve(x))
array([ 1.,  2.,  3.])
B.solve(A.dot(x))
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spsolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">use_umfpack</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the sparse linear system Ax=b, where b may be a vector or a matrix.</p>
<h2 id="parameters_250">Parameters<a class="headerlink" href="#parameters_250" title="Permanent link">&para;</a></h2>
<p>A : ndarray or sparse matrix
The square matrix A will be converted into CSC or CSR form
b : ndarray or sparse matrix
The matrix or vector representing the right hand side of the equation.
If a vector, b.shape must be (n,) or (n, 1).
permc_spec : str, optional
How to permute the columns of the matrix for sparsity preservation.
(default: 'COLAMD')</p>
<ul>
<li><code>NATURAL</code>: natural ordering.</li>
<li><code>MMD_ATA</code>: minimum degree ordering on the structure of A^T A.</li>
<li><code>MMD_AT_PLUS_A</code>: minimum degree ordering on the structure of A^T+A.</li>
<li><code>COLAMD</code>: approximate minimum degree column ordering
use_umfpack : bool, optional
if True (default) then use umfpack for the solution.  This is
only referenced if b is a vector and <code>scikit-umfpack</code> is installed.</li>
</ul>
<h2 id="returns_199">Returns<a class="headerlink" href="#returns_199" title="Permanent link">&para;</a></h2>
<p>x : ndarray or sparse matrix
the solution of the sparse linear equation.
If b is a vector, then x is a vector of size A.shape[1]
If b is a matrix, then x is a matrix of size (A.shape[1], b.shape[1])</p>
<h2 id="notes_80">Notes<a class="headerlink" href="#notes_80" title="Permanent link">&para;</a></h2>
<p>For solving the matrix expression AX = B, this solver assumes the resulting
matrix X is sparse, as is often the case for very sparse inputs.  If the
resulting X is dense, the construction of this sparse result will be
relatively expensive.  In that case, consider converting A to a dense
matrix and using scipy.linalg.solve or its variants.</p>
<h2 id="examples_122">Examples<a class="headerlink" href="#examples_122" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import spsolve
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
B = csc_matrix([[2, 0], [-1, 0], [2, 0]], dtype=float)
x = spsolve(A, B)
np.allclose(A.dot(x).todense(), B.todense())
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spsolve_triangular</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_A</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">unit_diagonal</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation <code>A x = b</code> for <code>x</code>, assuming A is a triangular matrix.</p>
<h2 id="parameters_251">Parameters<a class="headerlink" href="#parameters_251" title="Permanent link">&para;</a></h2>
<p>A : (M, M) sparse matrix
A sparse square triangular matrix. Should be in CSR format.
b : (M,) or (M, N) array_like
Right-hand side matrix in <code>A x = b</code>
lower : bool, optional
Whether <code>A</code> is a lower or upper triangular matrix.
Default is lower triangular matrix.
overwrite_A : bool, optional
Allow changing <code>A</code>. The indices of <code>A</code> are going to be sorted and zero
entries are going to be removed.
Enabling gives a performance gain. Default is False.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code>.
Enabling gives a performance gain. Default is False.
If <code>overwrite_b</code> is True, it should be ensured that
<code>b</code> has an appropriate dtype to be able to store the result.
unit_diagonal : bool, optional
If True, diagonal elements of <code>a</code> are assumed to be 1 and will not be
referenced.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="returns_200">Returns<a class="headerlink" href="#returns_200" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, N) ndarray
Solution to the system <code>A x = b</code>. Shape of return matches shape of <code>b</code>.</p>
<h2 id="raises_11">Raises<a class="headerlink" href="#raises_11" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If <code>A</code> is singular or not triangular.
ValueError
If shape of <code>A</code> or shape of <code>b</code> do not match the requirements.</p>
<h2 id="notes_81">Notes<a class="headerlink" href="#notes_81" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_123">Examples<a class="headerlink" href="#examples_123" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.linalg import spsolve_triangular
A = csr_matrix([[3, 0, 0], [1, -1, 0], [2, 0, 1]], dtype=float)
B = np.array([[2, 0], [-1, 0], [2, 0]], dtype=float)
x = spsolve_triangular(A, B)
np.allclose(A.dot(x), B)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">use_solver</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Select default sparse direct solver to be used.</p>
<h2 id="parameters_252">Parameters<a class="headerlink" href="#parameters_252" title="Permanent link">&para;</a></h2>
<p>useUmfpack : bool, optional
Use UMFPACK over SuperLU. Has effect only if scikits.umfpack is
installed. Default: True
assumeSortedIndices : bool, optional
Allow UMFPACK to skip the step of sorting indices for a CSR/CSC matrix.
Has effect only if useUmfpack is True and scikits.umfpack is installed.
Default: False</p>
<h2 id="notes_82">Notes<a class="headerlink" href="#notes_82" title="Permanent link">&para;</a></h2>
<p>The default sparse solver is umfpack when available
(scikits.umfpack is installed). This can be changed by passing
useUmfpack = False, which then causes the always present SuperLU
based solver to be used.</p>
<p>Umfpack requires a CSR/CSC matrix to have sorted column/row indices. If
sure that the matrix fulfills this, pass <code>assumeSortedIndices=True</code>
to gain some speed.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Eigen</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Arpack</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">aslinearoperator</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return A as a LinearOperator.</p>
<p>'A' may be any of the following types:
- ndarray
- matrix
- sparse matrix (e.g. csr_matrix, lil_matrix, etc.)
- LinearOperator
- An object with .shape and .matvec attributes</p>
<p>See the LinearOperator documentation for additional information.</p>
<h2 id="notes_83">Notes<a class="headerlink" href="#notes_83" title="Permanent link">&para;</a></h2>
<p>If 'A' has no .dtype attribute, the data type is determined by calling
:func:<code>LinearOperator.matvec()</code> - set the .dtype attribute to prevent this
call upon the linear operator creation.</p>
<h2 id="examples_124">Examples<a class="headerlink" href="#examples_124" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import aslinearoperator
M = np.array([[1,2,3],[4,5,6]], dtype=np.int32)
aslinearoperator(M)
&lt;2x3 MatrixLinearOperator with dtype=int32&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">choose_ncv</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Choose number of lanczos vectors based on target number
of singular/eigen values and vectors to compute, k.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eig</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">left</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">right</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">homogeneous_eigvals</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve an ordinary or generalized eigenvalue problem of a square matrix.</p>
<p>Find eigenvalues w and right or left eigenvectors of a general matrix::</p>
<p>a   vr[:,i] = w[i]        b   vr[:,i]
a.H vl[:,i] = w[i].conj() b.H vl[:,i]</p>
<p>where <code>.H</code> is the Hermitian conjugation.</p>
<h2 id="parameters_253">Parameters<a class="headerlink" href="#parameters_253" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex or real matrix whose eigenvalues and eigenvectors
will be computed.
b : (M, M) array_like, optional
Right-hand side matrix in a generalized eigenvalue problem.
Default is None, identity matrix is assumed.
left : bool, optional
Whether to calculate and return left eigenvectors.  Default is False.
right : bool, optional
Whether to calculate and return right eigenvectors.  Default is True.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.  Default is False.
overwrite_b : bool, optional
Whether to overwrite <code>b</code>; may improve performance.  Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
homogeneous_eigvals : bool, optional
If True, return the eigenvalues in homogeneous coordinates.
In this case <code>w</code> is a (2, M) array so that::</p>
<p>w[1,i] a vr[:,i] = w[0,i] b vr[:,i]</p>
<p>Default is False.</p>
<h2 id="returns_201">Returns<a class="headerlink" href="#returns_201" title="Permanent link">&para;</a></h2>
<p>w : (M,) or (2, M) double or complex ndarray
The eigenvalues, each repeated according to its
multiplicity. The shape is (M,) unless
<code>homogeneous_eigvals=True</code>.
vl : (M, M) double or complex ndarray
The normalized left eigenvector corresponding to the eigenvalue
<code>w[i]</code> is the column vl[:,i]. Only returned if <code>left=True</code>.
vr : (M, M) double or complex ndarray
The normalized right eigenvector corresponding to the eigenvalue
<code>w[i]</code> is the column <code>vr[:,i]</code>.  Only returned if <code>right=True</code>.</p>
<h2 id="raises_12">Raises<a class="headerlink" href="#raises_12" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge.</p>
<h2 id="see-also_87">See Also<a class="headerlink" href="#see-also_87" title="Permanent link">&para;</a></h2>
<p>eigvals : eigenvalues of general arrays
eigh : Eigenvalues and right eigenvectors for symmetric/Hermitian arrays.
eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian
band matrices
eigh_tridiagonal : eigenvalues and right eiegenvectors for
symmetric/Hermitian tridiagonal matrices</p>
<h2 id="examples_125">Examples<a class="headerlink" href="#examples_125" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[0., -1.], [1., 0.]])
linalg.eigvals(a)
array([0.+1.j, 0.-1.j])</p>
<p>b = np.array([[0., 1.], [1., 1.]])
linalg.eigvals(a, b)
array([ 1.+0.j, -1.+0.j])</p>
<p>a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]])
linalg.eigvals(a, homogeneous_eigvals=True)
array([[3.+0.j, 8.+0.j, 7.+0.j],
[1.+0.j, 1.+0.j, 1.+0.j]])</p>
<p>a = np.array([[0., -1.], [1., 0.]])
linalg.eigvals(a) == linalg.eig(a)[0]
array([ True,  True])
linalg.eig(a, left=True, right=False)[1] # normalized left eigenvector
array([[-0.70710678+0.j        , -0.70710678-0.j        ],
[-0.        +0.70710678j, -0.        -0.70710678j]])
linalg.eig(a, left=False, right=True)[1] # normalized right eigenvector
array([[0.70710678+0.j        , 0.70710678-0.j        ],
[0.        -0.70710678j, 0.        +0.70710678j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigh</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">turbo</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eigvals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">type_</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve an ordinary or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.</p>
<p>Find eigenvalues w and optionally eigenvectors v of matrix <code>a</code>, where
<code>b</code> is positive definite::</p>
<p>a v[:,i] = w[i] b v[:,i]
v[i,:].conj() a v[:,i] = w[i]
v[i,:].conj() b v[:,i] = 1</p>
<h2 id="parameters_254">Parameters<a class="headerlink" href="#parameters_254" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex Hermitian or real symmetric matrix whose eigenvalues and
eigenvectors will be computed.
b : (M, M) array_like, optional
A complex Hermitian or real symmetric definite positive matrix in.
If omitted, identity matrix is assumed.
lower : bool, optional
Whether the pertinent array data is taken from the lower or upper
triangle of <code>a</code>. (Default: lower)
eigvals_only : bool, optional
Whether to calculate only eigenvalues and no eigenvectors.
(Default: both are calculated)
turbo : bool, optional
Use divide and conquer algorithm (faster but expensive in memory,
only for generalized eigenvalue problem and if eigvals=None)
eigvals : tuple (lo, hi), optional
Indexes of the smallest and largest (in ascending order) eigenvalues
and corresponding eigenvectors to be returned: 0 &lt;= lo &lt;= hi &lt;= M-1.
If omitted, all eigenvalues and eigenvectors are returned.
type : int, optional
Specifies the problem type to be solved:</p>
<p>type = 1: a   v[:,i] = w[i] b v[:,i]</p>
<p>type = 2: a b v[:,i] = w[i]   v[:,i]</p>
<p>type = 3: b a v[:,i] = w[i]   v[:,i]
overwrite_a : bool, optional
Whether to overwrite data in <code>a</code> (may improve performance)
overwrite_b : bool, optional
Whether to overwrite data in <code>b</code> (may improve performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_202">Returns<a class="headerlink" href="#returns_202" title="Permanent link">&para;</a></h2>
<p>w : (N,) float ndarray
The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each
repeated according to its multiplicity.
v : (M, N) complex ndarray
(if eigvals_only == False)</p>
<p>The normalized selected eigenvector corresponding to the
eigenvalue w[i] is the column v[:,i].</p>
<p>Normalization:</p>
<p>type 1 and 3: v.conj() a      v  = w</p>
<p>type 2: inv(v).conj() a  inv(v) = w</p>
<p>type = 1 or 2: v.conj() b      v  = I</p>
<p>type = 3: v.conj() inv(b) v  = I</p>
<h2 id="raises_13">Raises<a class="headerlink" href="#raises_13" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge,
an error occurred, or b matrix is not definite positive. Note that
if input matrices are not symmetric or hermitian, no error is reported
but results will be wrong.</p>
<h2 id="see-also_88">See Also<a class="headerlink" href="#see-also_88" title="Permanent link">&para;</a></h2>
<p>eigvalsh : eigenvalues of symmetric or Hermitian arrays
eig : eigenvalues and right eigenvectors for non-symmetric arrays
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eigh_tridiagonal : eigenvalues and right eiegenvectors for
symmetric/Hermitian tridiagonal matrices</p>
<h2 id="notes_84">Notes<a class="headerlink" href="#notes_84" title="Permanent link">&para;</a></h2>
<p>This function does not check the input array for being hermitian/symmetric
in order to allow for representing arrays with only their upper/lower
triangular parts.</p>
<h2 id="examples_126">Examples<a class="headerlink" href="#examples_126" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigh
A = np.array([[6, 3, 1, 5], [3, 0, 5, 1], [1, 5, 6, 2], [5, 1, 2, 2]])
w, v = eigh(A)
np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigs</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sigma</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">which</span><span class="o">:[`</span><span class="nc">LM</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SM</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LR</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SR</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LI</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SI</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">v0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ncv</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_eigenvectors</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">minv</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">oPinv</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">oPpart</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find k eigenvalues and eigenvectors of the square matrix A.</p>
<p>Solves <code>A * x[i] = w[i] * x[i]</code>, the standard eigenvalue problem
for w[i] eigenvalues with corresponding eigenvectors x[i].</p>
<p>If M is specified, solves <code>A * x[i] = w[i] * M * x[i]</code>, the
generalized eigenvalue problem for w[i] eigenvalues
with corresponding eigenvectors x[i]</p>
<h2 id="parameters_255">Parameters<a class="headerlink" href="#parameters_255" title="Permanent link">&para;</a></h2>
<p>A : ndarray, sparse matrix or LinearOperator
An array, sparse matrix, or LinearOperator representing
the operation <code>A * x</code>, where A is a real or complex square matrix.
k : int, optional
The number of eigenvalues and eigenvectors desired.
<code>k</code> must be smaller than N-1. It is not possible to compute all
eigenvectors of a matrix.
M : ndarray, sparse matrix or LinearOperator, optional
An array, sparse matrix, or LinearOperator representing
the operation M*x for the generalized eigenvalue problem</p>
<p>A * x = w * M * x.</p>
<p>M must represent a real, symmetric matrix if A is real, and must
represent a complex, hermitian matrix if A is complex. For best
results, the data type of M should be the same as that of A.
Additionally:</p>
<p>If <code>sigma</code> is None, M is positive definite</p>
<p>If sigma is specified, M is positive semi-definite</p>
<p>If sigma is None, eigs requires an operator to compute the solution
of the linear equation <code>M * x = b</code>.  This is done internally via a
(sparse) LU decomposition for an explicit matrix M, or via an
iterative solver for a general linear operator.  Alternatively,
the user can supply the matrix or operator Minv, which gives
<code>x = Minv * b = M^-1 * b</code>.
sigma : real or complex, optional
Find eigenvalues near sigma using shift-invert mode.  This requires
an operator to compute the solution of the linear system
<code>[A - sigma * M] * x = b</code>, where M is the identity matrix if
unspecified. This is computed internally via a (sparse) LU
decomposition for explicit matrices A &amp; M, or via an iterative
solver if either A or M is a general linear operator.
Alternatively, the user can supply the matrix or operator OPinv,
which gives <code>x = OPinv * b = [A - sigma * M]^-1 * b</code>.
For a real matrix A, shift-invert can either be done in imaginary
mode or real mode, specified by the parameter OPpart ('r' or 'i').
Note that when sigma is specified, the keyword 'which' (below)
refers to the shifted eigenvalues <code>w'[i]</code> where:</p>
<p>If A is real and OPpart == 'r' (default),
<code>w'[i] = 1/2 * [1/(w[i]-sigma) + 1/(w[i]-conj(sigma))]</code>.</p>
<p>If A is real and OPpart == 'i',
<code>w'[i] = 1/2i * [1/(w[i]-sigma) - 1/(w[i]-conj(sigma))]</code>.</p>
<p>If A is complex, <code>w'[i] = 1/(w[i]-sigma)</code>.</p>
<p>v0 : ndarray, optional
Starting vector for iteration.
Default: random
ncv : int, optional
The number of Lanczos vectors generated
<code>ncv</code> must be greater than <code>k</code>; it is recommended that <code>ncv &gt; 2*k</code>.
Default: <code>min(n, max(2*k + 1, 20))</code>
which : str, ['LM' | 'SM' | 'LR' | 'SR' | 'LI' | 'SI'], optional
Which <code>k</code> eigenvectors and eigenvalues to find:</p>
<p>'LM' : largest magnitude</p>
<p>'SM' : smallest magnitude</p>
<p>'LR' : largest real part</p>
<p>'SR' : smallest real part</p>
<p>'LI' : largest imaginary part</p>
<p>'SI' : smallest imaginary part</p>
<p>When sigma != None, 'which' refers to the shifted eigenvalues w'[i]
(see discussion in 'sigma', above).  ARPACK is generally better
at finding large values than small values.  If small eigenvalues are
desired, consider using shift-invert mode for better performance.
maxiter : int, optional
Maximum number of Arnoldi update iterations allowed
Default: <code>n*10</code>
tol : float, optional
Relative accuracy for eigenvalues (stopping criterion)
The default value of 0 implies machine precision.
return_eigenvectors : bool, optional
Return eigenvectors (True) in addition to eigenvalues
Minv : ndarray, sparse matrix or LinearOperator, optional
See notes in M, above.
OPinv : ndarray, sparse matrix or LinearOperator, optional
See notes in sigma, above.
OPpart : {'r' or 'i'}, optional
See notes in sigma, above</p>
<h2 id="returns_203">Returns<a class="headerlink" href="#returns_203" title="Permanent link">&para;</a></h2>
<p>w : ndarray
Array of k eigenvalues.
v : ndarray
An array of <code>k</code> eigenvectors.
<code>v[:, i]</code> is the eigenvector corresponding to the eigenvalue w[i].</p>
<h2 id="raises_14">Raises<a class="headerlink" href="#raises_14" title="Permanent link">&para;</a></h2>
<p>ArpackNoConvergence
When the requested convergence is not obtained.
The currently converged eigenvalues and eigenvectors can be found
as <code>eigenvalues</code> and <code>eigenvectors</code> attributes of the exception
object.</p>
<h2 id="see-also_89">See Also<a class="headerlink" href="#see-also_89" title="Permanent link">&para;</a></h2>
<p>eigsh : eigenvalues and eigenvectors for symmetric matrix A
svds : singular value decomposition for a matrix A</p>
<h2 id="notes_85">Notes<a class="headerlink" href="#notes_85" title="Permanent link">&para;</a></h2>
<p>This function is a wrapper to the ARPACK [1]<em> SNEUPD, DNEUPD, CNEUPD,
ZNEUPD, functions which use the Implicitly Restarted Arnoldi Method to
find the eigenvalues and eigenvectors [2]</em>.</p>
<h2 id="references_11">References<a class="headerlink" href="#references_11" title="Permanent link">&para;</a></h2>
<p>.. [1] ARPACK Software, http://www.caam.rice.edu/software/ARPACK/
.. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE:
Solution of Large Scale Eigenvalue Problems by Implicitly Restarted
Arnoldi Methods. SIAM, Philadelphia, PA, 1998.</p>
<h2 id="examples_127">Examples<a class="headerlink" href="#examples_127" title="Permanent link">&para;</a></h2>
<p>Find 6 eigenvectors of the identity matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import eigs
id = np.eye(13)
vals, vecs = eigs(id, k=6)
vals
array([ 1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j])
vecs.shape
(13, 6)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigsh</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sigma</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">which</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">v0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ncv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_eigenvectors</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">minv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">oPinv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find k eigenvalues and eigenvectors of the real symmetric square matrix
or complex hermitian matrix A.</p>
<p>Solves <code>A * x[i] = w[i] * x[i]</code>, the standard eigenvalue problem for
w[i] eigenvalues with corresponding eigenvectors x[i].</p>
<p>If M is specified, solves <code>A * x[i] = w[i] * M * x[i]</code>, the
generalized eigenvalue problem for w[i] eigenvalues
with corresponding eigenvectors x[i].</p>
<h2 id="parameters_256">Parameters<a class="headerlink" href="#parameters_256" title="Permanent link">&para;</a></h2>
<p>A : ndarray, sparse matrix or LinearOperator
A square operator representing the operation <code>A * x</code>, where <code>A</code> is
real symmetric or complex hermitian. For buckling mode (see below)
<code>A</code> must additionally be positive-definite.
k : int, optional
The number of eigenvalues and eigenvectors desired.
<code>k</code> must be smaller than N. It is not possible to compute all
eigenvectors of a matrix.</p>
<h2 id="returns_204">Returns<a class="headerlink" href="#returns_204" title="Permanent link">&para;</a></h2>
<p>w : array
Array of k eigenvalues.
v : array
An array representing the <code>k</code> eigenvectors.  The column <code>v[:, i]</code> is
the eigenvector corresponding to the eigenvalue <code>w[i]</code>.</p>
<h2 id="other-parameters_2">Other Parameters<a class="headerlink" href="#other-parameters_2" title="Permanent link">&para;</a></h2>
<p>M : An N x N matrix, array, sparse matrix, or linear operator representing
the operation <code>M @ x</code> for the generalized eigenvalue problem</p>
<p>A @ x = w * M @ x.</p>
<p>M must represent a real, symmetric matrix if A is real, and must
represent a complex, hermitian matrix if A is complex. For best
results, the data type of M should be the same as that of A.
Additionally:</p>
<p>If sigma is None, M is symmetric positive definite.</p>
<p>If sigma is specified, M is symmetric positive semi-definite.</p>
<p>In buckling mode, M is symmetric indefinite.</p>
<p>If sigma is None, eigsh requires an operator to compute the solution
of the linear equation <code>M @ x = b</code>. This is done internally via a
(sparse) LU decomposition for an explicit matrix M, or via an
iterative solver for a general linear operator.  Alternatively,
the user can supply the matrix or operator Minv, which gives
<code>x = Minv @ b = M^-1 @ b</code>.
sigma : real
Find eigenvalues near sigma using shift-invert mode.  This requires
an operator to compute the solution of the linear system
<code>[A - sigma * M] x = b</code>, where M is the identity matrix if
unspecified.  This is computed internally via a (sparse) LU
decomposition for explicit matrices A &amp; M, or via an iterative
solver if either A or M is a general linear operator.
Alternatively, the user can supply the matrix or operator OPinv,
which gives <code>x = OPinv @ b = [A - sigma * M]^-1 @ b</code>.
Note that when sigma is specified, the keyword 'which' refers to
the shifted eigenvalues <code>w'[i]</code> where:</p>
<p>if mode == 'normal', <code>w'[i] = 1 / (w[i] - sigma)</code>.</p>
<p>if mode == 'cayley', <code>w'[i] = (w[i] + sigma) / (w[i] - sigma)</code>.</p>
<p>if mode == 'buckling', <code>w'[i] = w[i] / (w[i] - sigma)</code>.</p>
<p>(see further discussion in 'mode' below)
v0 : ndarray, optional
Starting vector for iteration.
Default: random
ncv : int, optional
The number of Lanczos vectors generated ncv must be greater than k and
smaller than n; it is recommended that <code>ncv &gt; 2*k</code>.
Default: <code>min(n, max(2*k + 1, 20))</code>
which : str ['LM' | 'SM' | 'LA' | 'SA' | 'BE']
If A is a complex hermitian matrix, 'BE' is invalid.
Which <code>k</code> eigenvectors and eigenvalues to find:</p>
<p>'LM' : Largest (in magnitude) eigenvalues.</p>
<p>'SM' : Smallest (in magnitude) eigenvalues.</p>
<p>'LA' : Largest (algebraic) eigenvalues.</p>
<p>'SA' : Smallest (algebraic) eigenvalues.</p>
<p>'BE' : Half (k/2) from each end of the spectrum.</p>
<p>When k is odd, return one more (k/2+1) from the high end.
When sigma != None, 'which' refers to the shifted eigenvalues <code>w'[i]</code>
(see discussion in 'sigma', above).  ARPACK is generally better
at finding large values than small values.  If small eigenvalues are
desired, consider using shift-invert mode for better performance.
maxiter : int, optional
Maximum number of Arnoldi update iterations allowed.
Default: <code>n*10</code>
tol : float
Relative accuracy for eigenvalues (stopping criterion).
The default value of 0 implies machine precision.
Minv : N x N matrix, array, sparse matrix, or LinearOperator
See notes in M, above.
OPinv : N x N matrix, array, sparse matrix, or LinearOperator
See notes in sigma, above.
return_eigenvectors : bool
Return eigenvectors (True) in addition to eigenvalues.
This value determines the order in which eigenvalues are sorted.
The sort order is also dependent on the <code>which</code> variable.</p>
<p>For which = 'LM' or 'SA':
If <code>return_eigenvectors</code> is True, eigenvalues are sorted by
algebraic value.</p>
<p>If <code>return_eigenvectors</code> is False, eigenvalues are sorted by
absolute value.</p>
<p>For which = 'BE' or 'LA':
eigenvalues are always sorted by algebraic value.</p>
<p>For which = 'SM':
If <code>return_eigenvectors</code> is True, eigenvalues are sorted by
algebraic value.</p>
<p>If <code>return_eigenvectors</code> is False, eigenvalues are sorted by
decreasing absolute value.</p>
<p>mode : string ['normal' | 'buckling' | 'cayley']
Specify strategy to use for shift-invert mode.  This argument applies
only for real-valued A and sigma != None.  For shift-invert mode,
ARPACK internally solves the eigenvalue problem
<code>OP * x'[i] = w'[i] * B * x'[i]</code>
and transforms the resulting Ritz vectors x'[i] and Ritz values w'[i]
into the desired eigenvectors and eigenvalues of the problem
<code>A * x[i] = w[i] * M * x[i]</code>.
The modes are as follows:</p>
<p>'normal' :
OP = [A - sigma * M]^-1 @ M,
B = M,
w'[i] = 1 / (w[i] - sigma)</p>
<p>'buckling' :
OP = [A - sigma * M]^-1 @ A,
B = A,
w'[i] = w[i] / (w[i] - sigma)</p>
<p>'cayley' :
OP = [A - sigma * M]^-1 @ [A + sigma * M],
B = M,
w'[i] = (w[i] + sigma) / (w[i] - sigma)</p>
<p>The choice of mode will affect which eigenvalues are selected by
the keyword 'which', and can also impact the stability of
convergence (see [2] for a discussion).</p>
<h2 id="raises_15">Raises<a class="headerlink" href="#raises_15" title="Permanent link">&para;</a></h2>
<p>ArpackNoConvergence
When the requested convergence is not obtained.</p>
<p>The currently converged eigenvalues and eigenvectors can be found
as <code>eigenvalues</code> and <code>eigenvectors</code> attributes of the exception
object.</p>
<h2 id="see-also_90">See Also<a class="headerlink" href="#see-also_90" title="Permanent link">&para;</a></h2>
<p>eigs : eigenvalues and eigenvectors for a general (nonsymmetric) matrix A
svds : singular value decomposition for a matrix A</p>
<h2 id="notes_86">Notes<a class="headerlink" href="#notes_86" title="Permanent link">&para;</a></h2>
<p>This function is a wrapper to the ARPACK [1]<em> SSEUPD and DSEUPD
functions which use the Implicitly Restarted Lanczos Method to
find the eigenvalues and eigenvectors [2]</em>.</p>
<h2 id="references_12">References<a class="headerlink" href="#references_12" title="Permanent link">&para;</a></h2>
<p>.. [1] ARPACK Software, http://www.caam.rice.edu/software/ARPACK/
.. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE:
Solution of Large Scale Eigenvalue Problems by Implicitly Restarted
Arnoldi Methods. SIAM, Philadelphia, PA, 1998.</p>
<h2 id="examples_128">Examples<a class="headerlink" href="#examples_128" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import eigsh
identity = np.eye(13)
eigenvalues, eigenvectors = eigsh(identity, k=6)
eigenvalues
array([1., 1., 1., 1., 1., 1.])
eigenvectors.shape
(13, 6)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eye</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sparse matrix with ones on diagonal</p>
<p>Returns a sparse (m x n) matrix where the k-th diagonal
is all ones and everything else is zeros.</p>
<h2 id="parameters_257">Parameters<a class="headerlink" href="#parameters_257" title="Permanent link">&para;</a></h2>
<p>m : int
Number of rows in the matrix.
n : int, optional
Number of columns. Default: <code>m</code>.
k : int, optional
Diagonal to place ones on. Default: 0 (main diagonal).
dtype : dtype, optional
Data type of the matrix.
format : str, optional
Sparse format of the result, e.g. format='csr', etc.</p>
<h2 id="examples_129">Examples<a class="headerlink" href="#examples_129" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import sparse
sparse.eye(3).toarray()
array([[ 1.,  0.,  0.],
[ 0.,  1.,  0.],
[ 0.,  0.,  1.]])
sparse.eye(3, dtype=np.int8)
&lt;3x3 sparse matrix of type '<class 'numpy.int8'>'
with 3 stored elements (1 diagonals) in DIAgonal format&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_OPinv_matvec</span> <span class="o">:</span> <span class="o">?</span><span class="n">hermitian</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sigma</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_inv_matvec</span> <span class="o">:</span> <span class="o">?</span><span class="n">hermitian</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gmres</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">restart</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">restrt</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback_type</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Generalized Minimal RESidual iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_258">Parameters<a class="headerlink" href="#parameters_258" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_205">Returns<a class="headerlink" href="#returns_205" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : int
Provides convergence information:
* 0  : successful exit
* &gt;0 : convergence to tolerance not achieved, number of iterations
* &lt;0 : illegal input or breakdown</p>
<h2 id="other-parameters_3">Other parameters<a class="headerlink" href="#other-parameters_3" title="Permanent link">&para;</a></h2>
<p>x0 : {array, matrix}
Starting guess for the solution (a vector of zeros by default).
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
restart : int, optional
Number of iterations between restarts. Larger values increase
iteration cost, but may be necessary for convergence.
Default is 20.
maxiter : int, optional
Maximum number of iterations (restart cycles).  Iteration will stop
after maxiter steps even if the specified tolerance has not been
achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Inverse of the preconditioner of A.  M should approximate the
inverse of A and be easy to solve for (see Notes).  Effective
preconditioning dramatically improves the rate of convergence,
which implies that fewer iterations are needed to reach a given
error tolerance.  By default, no preconditioner is used.
callback : function
User-supplied function to call after each iteration.  It is called
as <code>callback(args)</code>, where <code>args</code> are selected by <code>callback_type</code>.
callback_type : {'x', 'pr_norm', 'legacy'}, optional
Callback function argument requested:
- <code>x</code>: current iterate (ndarray), called on every restart
- <code>pr_norm</code>: relative (preconditioned) residual norm (float),
called on every inner iteration
- <code>legacy</code> (default): same as <code>pr_norm</code>, but also changes the
meaning of 'maxiter' to count inner iterations instead of restart
cycles.
restrt : int, optional
DEPRECATED - use <code>restart</code> instead.</p>
<h2 id="see-also_91">See Also<a class="headerlink" href="#see-also_91" title="Permanent link">&para;</a></h2>
<p>LinearOperator</p>
<h2 id="notes_87">Notes<a class="headerlink" href="#notes_87" title="Permanent link">&para;</a></h2>
<p>A preconditioner, P, is chosen such that P is close to A but easy to solve
for. The preconditioner parameter required by this routine is
<code>M = P^-1</code>. The inverse should preferably not be calculated
explicitly.  Rather, use the following template to produce M::</p>
<h1 id="construct-a-linear-operator-that-computes-p-1-x_1">Construct a linear operator that computes P^-1 * x.<a class="headerlink" href="#construct-a-linear-operator-that-computes-p-1-x_1" title="Permanent link">&para;</a></h1>
<p>import scipy.sparse.linalg as spla
M_x = lambda x: spla.spsolve(P, x)
M = spla.LinearOperator((n, n), M_x)</p>
<h2 id="examples_130">Examples<a class="headerlink" href="#examples_130" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import gmres
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
b = np.array([2, 4, -1], dtype=float)
x, exitCode = gmres(A, b)
print(exitCode)            # 0 indicates successful convergence
0
np.allclose(A.dot(x), b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gmres_loose</span> <span class="o">:</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gmres with looser termination condition.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_pydata_spmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Check whether object is pydata/sparse matrix, avoiding importing the module.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isdense</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">issparse</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_259">Parameters<a class="headerlink" href="#parameters_259" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_206">Returns<a class="headerlink" href="#returns_206" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_88">Notes<a class="headerlink" href="#notes_88" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_131">Examples<a class="headerlink" href="#examples_131" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_260">Parameters<a class="headerlink" href="#parameters_260" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_207">Returns<a class="headerlink" href="#returns_207" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_89">Notes<a class="headerlink" href="#notes_89" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_132">Examples<a class="headerlink" href="#examples_132" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_csr</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of csr_matrix type?</p>
<h2 id="parameters_261">Parameters<a class="headerlink" href="#parameters_261" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a csr matrix</p>
<h2 id="returns_208">Returns<a class="headerlink" href="#returns_208" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a csr matrix, False otherwise</p>
<h2 id="examples_133">Examples<a class="headerlink" href="#examples_133" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix_csr
isspmatrix_csr(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import csc_matrix, csr_matrix, isspmatrix_csc
isspmatrix_csr(csc_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lobpcg</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">y</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">largest</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbosityLevel</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retLambdaHistory</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retResidualNormsHistory</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG)</p>
<p>LOBPCG is a preconditioned eigensolver for large symmetric positive
definite (SPD) generalized eigenproblems.</p>
<h2 id="parameters_262">Parameters<a class="headerlink" href="#parameters_262" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The symmetric linear operator of the problem, usually a
sparse matrix.  Often called the 'stiffness matrix'.
X : ndarray, float32 or float64
Initial approximation to the <code>k</code> eigenvectors (non-sparse). If <code>A</code>
has <code>shape=(n,n)</code> then <code>X</code> should have shape <code>shape=(n,k)</code>.
B : {dense matrix, sparse matrix, LinearOperator}, optional
The right hand side operator in a generalized eigenproblem.
By default, <code>B = Identity</code>.  Often called the 'mass matrix'.
M : {dense matrix, sparse matrix, LinearOperator}, optional
Preconditioner to <code>A</code>; by default <code>M = Identity</code>.
<code>M</code> should approximate the inverse of <code>A</code>.
Y : ndarray, float32 or float64, optional
n-by-sizeY matrix of constraints (non-sparse), sizeY &lt; n
The iterations will be performed in the B-orthogonal complement
of the column-space of Y. Y must be full rank.
tol : scalar, optional
Solver tolerance (stopping criterion).
The default is <code>tol=n*sqrt(eps)</code>.
maxiter : int, optional
Maximum number of iterations.  The default is <code>maxiter = 20</code>.
largest : bool, optional
When True, solve for the largest eigenvalues, otherwise the smallest.
verbosityLevel : int, optional
Controls solver output.  The default is <code>verbosityLevel=0</code>.
retLambdaHistory : bool, optional
Whether to return eigenvalue history.  Default is False.
retResidualNormsHistory : bool, optional
Whether to return history of residual norms.  Default is False.</p>
<h2 id="returns_209">Returns<a class="headerlink" href="#returns_209" title="Permanent link">&para;</a></h2>
<p>w : ndarray
Array of <code>k</code> eigenvalues
v : ndarray
An array of <code>k</code> eigenvectors.  <code>v</code> has the same shape as <code>X</code>.
lambdas : list of ndarray, optional
The eigenvalue history, if <code>retLambdaHistory</code> is True.
rnorms : list of ndarray, optional
The history of residual norms, if <code>retResidualNormsHistory</code> is True.</p>
<h2 id="notes_90">Notes<a class="headerlink" href="#notes_90" title="Permanent link">&para;</a></h2>
<p>If both <code>retLambdaHistory</code> and <code>retResidualNormsHistory</code> are True,
the return tuple has the following format
<code>(lambda, V, lambda history, residual norms history)</code>.</p>
<p>In the following <code>n</code> denotes the matrix size and <code>m</code> the number
of required eigenvalues (smallest or largest).</p>
<p>The LOBPCG code internally solves eigenproblems of the size <code>3m</code> on every
iteration by calling the 'standard' dense eigensolver, so if <code>m</code> is not
small enough compared to <code>n</code>, it does not make sense to call the LOBPCG
code, but rather one should use the 'standard' eigensolver, e.g. numpy or
scipy function in this case.
If one calls the LOBPCG algorithm for <code>5m &gt; n</code>, it will most likely break
internally, so the code tries to call the standard function instead.</p>
<p>It is not that <code>n</code> should be large for the LOBPCG to work, but rather the
ratio <code>n / m</code> should be large. It you call LOBPCG with <code>m=1</code>
and <code>n=10</code>, it works though <code>n</code> is small. The method is intended
for extremely large <code>n / m</code>, see e.g., reference [28] in
https://arxiv.org/abs/0705.2626</p>
<p>The convergence speed depends basically on two factors:</p>
<ol>
<li>
<p>How well relatively separated the seeking eigenvalues are from the rest
of the eigenvalues. One can try to vary <code>m</code> to make this better.</p>
</li>
<li>
<p>How well conditioned the problem is. This can be changed by using proper
preconditioning. For example, a rod vibration test problem (under tests
directory) is ill-conditioned for large <code>n</code>, so convergence will be
slow, unless efficient preconditioning is used. For this specific
problem, a good simple preconditioner function would be a linear solve
for <code>A</code>, which is easy to code since A is tridiagonal.</p>
</li>
</ol>
<h2 id="references_13">References<a class="headerlink" href="#references_13" title="Permanent link">&para;</a></h2>
<p>.. [1] A. V. Knyazev (2001),
Toward the Optimal Preconditioned Eigensolver: Locally Optimal
Block Preconditioned Conjugate Gradient Method.
SIAM Journal on Scientific Computing 23, no. 2,
pp. 517-541. http://dx.doi.org/10.1137/S1064827500366124</p>
<p>.. [2] A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov
(2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers
(BLOPEX) in hypre and PETSc. https://arxiv.org/abs/0705.2626</p>
<p>.. [3] A. V. Knyazev's C and MATLAB implementations:
https://bitbucket.org/joseroman/blopex</p>
<h2 id="examples_134">Examples<a class="headerlink" href="#examples_134" title="Permanent link">&para;</a></h2>
<p>Solve <code>A x = lambda x</code> with constraints and preconditioning.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import spdiags, issparse
from scipy.sparse.linalg import lobpcg, LinearOperator
n = 100
vals = np.arange(1, n + 1)
A = spdiags(vals, 0, n, n)
A.toarray()
array([[  1.,   0.,   0., ...,   0.,   0.,   0.],
[  0.,   2.,   0., ...,   0.,   0.,   0.],
[  0.,   0.,   3., ...,   0.,   0.,   0.],
...,
[  0.,   0.,   0., ...,  98.,   0.,   0.],
[  0.,   0.,   0., ...,   0.,  99.,   0.],
[  0.,   0.,   0., ...,   0.,   0., 100.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constraints:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Y = np.eye(n, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initial guess for eigenvectors, should have linearly independent
columns. Column dimension = number of requested eigenvalues.</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = np.random.rand(n, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Preconditioner in the inverse of A in this example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>invA = spdiags([1./vals], 0, n, n)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The preconditiner must be defined by a function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def precond( x ):
...     return invA @ x</p>
</blockquote>
</blockquote>
</blockquote>
<p>The argument x of the preconditioner function is a matrix inside <code>lobpcg</code>,
thus the use of matrix-matrix product <code>@</code>.</p>
<p>The preconditioner function is passed to lobpcg as a <code>LinearOperator</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>M = LinearOperator(matvec=precond, matmat=precond,
...                    shape=(n, n), dtype=float)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Let us now solve the eigenvalue problem for the matrix A:</p>
<blockquote>
<blockquote>
<blockquote>
<p>eigenvalues, _ = lobpcg(A, X, Y=Y, M=M, largest=False)
eigenvalues
array([4., 5., 6.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that the vectors passed in Y are the eigenvectors of the 3 smallest
eigenvalues. The results returned are orthogonal to those.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu_factor</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute pivoted LU decomposition of a matrix.</p>
<p>The decomposition is::</p>
<p>A = P L U</p>
<p>where P is a permutation matrix, L lower triangular with unit
diagonal elements, and U upper triangular.</p>
<h2 id="parameters_263">Parameters<a class="headerlink" href="#parameters_263" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to decompose
overwrite_a : bool, optional
Whether to overwrite data in A (may increase performance)
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_210">Returns<a class="headerlink" href="#returns_210" title="Permanent link">&para;</a></h2>
<p>lu : (N, N) ndarray
Matrix containing U in its upper triangle, and L in its lower triangle.
The unit diagonal elements of L are not stored.
piv : (N,) ndarray
Pivot indices representing the permutation matrix P:
row i of matrix was interchanged with row piv[i].</p>
<h2 id="see-also_92">See also<a class="headerlink" href="#see-also_92" title="Permanent link">&para;</a></h2>
<p>lu_solve : solve an equation system using the LU factorization of a matrix</p>
<h2 id="notes_91">Notes<a class="headerlink" href="#notes_91" title="Permanent link">&para;</a></h2>
<p>This is a wrapper to the <code>*GETRF</code> routines from LAPACK.</p>
<h2 id="examples_135">Examples<a class="headerlink" href="#examples_135" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import lu_factor
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
lu, piv = lu_factor(A)
piv
array([2, 2, 3, 3], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Convert LAPACK's <code>piv</code> array to NumPy index and test the permutation</p>
<blockquote>
<blockquote>
<blockquote>
<p>piv_py = [2, 0, 3, 1]
L, U = np.tril(lu, k=-1) + np.eye(4), np.triu(lu)
np.allclose(A[piv_py] - L @ U, np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu_solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">trans</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">lu_and_piv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve an equation system, a x = b, given the LU factorization of a</p>
<h2 id="parameters_264">Parameters<a class="headerlink" href="#parameters_264" title="Permanent link">&para;</a></h2>
<p>(lu, piv)
Factorization of the coefficient matrix a, as given by lu_factor
b : array
Right-hand side
trans : {0, 1, 2}, optional
Type of system to solve:</p>
<p>=====  =========
trans  system
=====  =========
0      a x   = b
1      a^T x = b
2      a^H x = b
=====  =========
overwrite_b : bool, optional
Whether to overwrite data in b (may increase performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_211">Returns<a class="headerlink" href="#returns_211" title="Permanent link">&para;</a></h2>
<p>x : array
Solution to the system</p>
<h2 id="see-also_93">See also<a class="headerlink" href="#see-also_93" title="Permanent link">&para;</a></h2>
<p>lu_factor : LU factorize a matrix</p>
<h2 id="examples_136">Examples<a class="headerlink" href="#examples_136" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import lu_factor, lu_solve
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
b = np.array([1, 1, 1, 1])
lu, piv = lu_factor(A)
x = lu_solve((lu, piv), b)
np.allclose(A @ x - b, np.zeros((4,)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">splu</span> <span class="o">:</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag_pivot_thresh</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">relax</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">panel_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the LU decomposition of a sparse, square matrix.</p>
<h2 id="parameters_265">Parameters<a class="headerlink" href="#parameters_265" title="Permanent link">&para;</a></h2>
<p>A : sparse matrix
Sparse matrix to factorize. Should be in CSR or CSC format.
permc_spec : str, optional
How to permute the columns of the matrix for sparsity preservation.
(default: 'COLAMD')</p>
<ul>
<li><code>NATURAL</code>: natural ordering.</li>
<li><code>MMD_ATA</code>: minimum degree ordering on the structure of A^T A.</li>
<li><code>MMD_AT_PLUS_A</code>: minimum degree ordering on the structure of A^T+A.</li>
<li><code>COLAMD</code>: approximate minimum degree column ordering</li>
</ul>
<p>diag_pivot_thresh : float, optional
Threshold used for a diagonal entry to be an acceptable pivot.
See SuperLU user's guide for details [1]<em>
relax : int, optional
Expert option for customizing the degree of relaxing supernodes.
See SuperLU user's guide for details [1]</em>
panel_size : int, optional
Expert option for customizing the panel size.
See SuperLU user's guide for details [1]<em>
options : dict, optional
Dictionary containing additional expert options to SuperLU.
See SuperLU user guide [1]</em> (section 2.4 on the 'Options' argument)
for more details. For example, you can specify
<code>options=dict(Equil=False, IterRefine='SINGLE'))</code>
to turn equilibration off and perform a single iterative refinement.</p>
<h2 id="returns_212">Returns<a class="headerlink" href="#returns_212" title="Permanent link">&para;</a></h2>
<p>invA : scipy.sparse.linalg.SuperLU
Object, which has a <code>solve</code> method.</p>
<h2 id="see-also_94">See also<a class="headerlink" href="#see-also_94" title="Permanent link">&para;</a></h2>
<p>spilu : incomplete LU decomposition</p>
<h2 id="notes_92">Notes<a class="headerlink" href="#notes_92" title="Permanent link">&para;</a></h2>
<p>This function uses the SuperLU library.</p>
<h2 id="references_14">References<a class="headerlink" href="#references_14" title="Permanent link">&para;</a></h2>
<p>.. [1] SuperLU http://crd.lbl.gov/~xiaoye/SuperLU/</p>
<h2 id="examples_137">Examples<a class="headerlink" href="#examples_137" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import splu
A = csc_matrix([[1., 0., 0.], [5., 0., 2.], [0., -1., 0.]], dtype=float)
B = splu(A)
x = np.array([1., 2., 3.], dtype=float)
B.solve(x)
array([ 1. , -3. , -1.5])
A.dot(B.solve(x))
array([ 1.,  2.,  3.])
B.solve(A.dot(x))
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svds</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ncv</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">which</span><span class="o">:[`</span><span class="nc">LM</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SM</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">v0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_singular_vectors</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">solver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the largest or smallest k singular values/vectors for a sparse matrix. The order of the singular values is not guaranteed.</p>
<h2 id="parameters_266">Parameters<a class="headerlink" href="#parameters_266" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, LinearOperator}
Array to compute the SVD on, of shape (M, N)
k : int, optional
Number of singular values and vectors to compute.
Must be 1 &lt;= k &lt; min(A.shape).
ncv : int, optional
The number of Lanczos vectors generated
ncv must be greater than k+1 and smaller than n;
it is recommended that ncv &gt; 2*k
Default: <code>min(n, max(2*k + 1, 20))</code>
tol : float, optional
Tolerance for singular values. Zero (default) means machine precision.
which : str, ['LM' | 'SM'], optional
Which <code>k</code> singular values to find:</p>
<ul>
<li>'LM' : largest singular values</li>
<li>'SM' : smallest singular values</li>
</ul>
<p>.. versionadded:: 0.12.0
v0 : ndarray, optional
Starting vector for iteration, of length min(A.shape). Should be an
(approximate) left singular vector if N &gt; M and a right singular
vector otherwise.
Default: random</p>
<p>.. versionadded:: 0.12.0
maxiter : int, optional
Maximum number of iterations.</p>
<p>.. versionadded:: 0.12.0
return_singular_vectors : bool or str, optional
- True: return singular vectors (True) in addition to singular values.</p>
<p>.. versionadded:: 0.12.0</p>
<ul>
<li>'u': only return the u matrix, without computing vh (if N &gt; M).</li>
<li>'vh': only return the vh matrix, without computing u (if N &lt;= M).</li>
</ul>
<p>.. versionadded:: 0.16.0
solver : str, optional
Eigenvalue solver to use. Should be 'arpack' or 'lobpcg'.
Default: 'arpack'</p>
<h2 id="returns_213">Returns<a class="headerlink" href="#returns_213" title="Permanent link">&para;</a></h2>
<p>u : ndarray, shape=(M, k)
Unitary matrix having left singular vectors as columns.
If <code>return_singular_vectors</code> is 'vh', this variable is not computed,
and None is returned instead.
s : ndarray, shape=(k,)
The singular values.
vt : ndarray, shape=(k, N)
Unitary matrix having right singular vectors as rows.
If <code>return_singular_vectors</code> is 'u', this variable is not computed,
and None is returned instead.</p>
<h2 id="notes_93">Notes<a class="headerlink" href="#notes_93" title="Permanent link">&para;</a></h2>
<p>This is a naive implementation using ARPACK or LOBPCG as an eigensolver
on A.H * A or A * A.H, depending on which one is more efficient.</p>
<h2 id="examples_138">Examples<a class="headerlink" href="#examples_138" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import svds, eigs
A = csc_matrix([[1, 0, 0], [5, 0, 2], [0, -1, 0], [0, 0, 3]], dtype=float)
u, s, vt = svds(A, k=2)
s
array([ 2.75193379,  5.6059665 ])
np.sqrt(eigs(A.dot(A.T), k=2)[0]).real
array([ 5.6059665 ,  2.75193379])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigs</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sigma</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">which</span><span class="o">:[`</span><span class="nc">LM</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SM</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LR</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SR</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LI</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SI</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">v0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ncv</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_eigenvectors</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">minv</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">oPinv</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">oPpart</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find k eigenvalues and eigenvectors of the square matrix A.</p>
<p>Solves <code>A * x[i] = w[i] * x[i]</code>, the standard eigenvalue problem
for w[i] eigenvalues with corresponding eigenvectors x[i].</p>
<p>If M is specified, solves <code>A * x[i] = w[i] * M * x[i]</code>, the
generalized eigenvalue problem for w[i] eigenvalues
with corresponding eigenvectors x[i]</p>
<h2 id="parameters_267">Parameters<a class="headerlink" href="#parameters_267" title="Permanent link">&para;</a></h2>
<p>A : ndarray, sparse matrix or LinearOperator
An array, sparse matrix, or LinearOperator representing
the operation <code>A * x</code>, where A is a real or complex square matrix.
k : int, optional
The number of eigenvalues and eigenvectors desired.
<code>k</code> must be smaller than N-1. It is not possible to compute all
eigenvectors of a matrix.
M : ndarray, sparse matrix or LinearOperator, optional
An array, sparse matrix, or LinearOperator representing
the operation M*x for the generalized eigenvalue problem</p>
<p>A * x = w * M * x.</p>
<p>M must represent a real, symmetric matrix if A is real, and must
represent a complex, hermitian matrix if A is complex. For best
results, the data type of M should be the same as that of A.
Additionally:</p>
<p>If <code>sigma</code> is None, M is positive definite</p>
<p>If sigma is specified, M is positive semi-definite</p>
<p>If sigma is None, eigs requires an operator to compute the solution
of the linear equation <code>M * x = b</code>.  This is done internally via a
(sparse) LU decomposition for an explicit matrix M, or via an
iterative solver for a general linear operator.  Alternatively,
the user can supply the matrix or operator Minv, which gives
<code>x = Minv * b = M^-1 * b</code>.
sigma : real or complex, optional
Find eigenvalues near sigma using shift-invert mode.  This requires
an operator to compute the solution of the linear system
<code>[A - sigma * M] * x = b</code>, where M is the identity matrix if
unspecified. This is computed internally via a (sparse) LU
decomposition for explicit matrices A &amp; M, or via an iterative
solver if either A or M is a general linear operator.
Alternatively, the user can supply the matrix or operator OPinv,
which gives <code>x = OPinv * b = [A - sigma * M]^-1 * b</code>.
For a real matrix A, shift-invert can either be done in imaginary
mode or real mode, specified by the parameter OPpart ('r' or 'i').
Note that when sigma is specified, the keyword 'which' (below)
refers to the shifted eigenvalues <code>w'[i]</code> where:</p>
<p>If A is real and OPpart == 'r' (default),
<code>w'[i] = 1/2 * [1/(w[i]-sigma) + 1/(w[i]-conj(sigma))]</code>.</p>
<p>If A is real and OPpart == 'i',
<code>w'[i] = 1/2i * [1/(w[i]-sigma) - 1/(w[i]-conj(sigma))]</code>.</p>
<p>If A is complex, <code>w'[i] = 1/(w[i]-sigma)</code>.</p>
<p>v0 : ndarray, optional
Starting vector for iteration.
Default: random
ncv : int, optional
The number of Lanczos vectors generated
<code>ncv</code> must be greater than <code>k</code>; it is recommended that <code>ncv &gt; 2*k</code>.
Default: <code>min(n, max(2*k + 1, 20))</code>
which : str, ['LM' | 'SM' | 'LR' | 'SR' | 'LI' | 'SI'], optional
Which <code>k</code> eigenvectors and eigenvalues to find:</p>
<p>'LM' : largest magnitude</p>
<p>'SM' : smallest magnitude</p>
<p>'LR' : largest real part</p>
<p>'SR' : smallest real part</p>
<p>'LI' : largest imaginary part</p>
<p>'SI' : smallest imaginary part</p>
<p>When sigma != None, 'which' refers to the shifted eigenvalues w'[i]
(see discussion in 'sigma', above).  ARPACK is generally better
at finding large values than small values.  If small eigenvalues are
desired, consider using shift-invert mode for better performance.
maxiter : int, optional
Maximum number of Arnoldi update iterations allowed
Default: <code>n*10</code>
tol : float, optional
Relative accuracy for eigenvalues (stopping criterion)
The default value of 0 implies machine precision.
return_eigenvectors : bool, optional
Return eigenvectors (True) in addition to eigenvalues
Minv : ndarray, sparse matrix or LinearOperator, optional
See notes in M, above.
OPinv : ndarray, sparse matrix or LinearOperator, optional
See notes in sigma, above.
OPpart : {'r' or 'i'}, optional
See notes in sigma, above</p>
<h2 id="returns_214">Returns<a class="headerlink" href="#returns_214" title="Permanent link">&para;</a></h2>
<p>w : ndarray
Array of k eigenvalues.
v : ndarray
An array of <code>k</code> eigenvectors.
<code>v[:, i]</code> is the eigenvector corresponding to the eigenvalue w[i].</p>
<h2 id="raises_16">Raises<a class="headerlink" href="#raises_16" title="Permanent link">&para;</a></h2>
<p>ArpackNoConvergence
When the requested convergence is not obtained.
The currently converged eigenvalues and eigenvectors can be found
as <code>eigenvalues</code> and <code>eigenvectors</code> attributes of the exception
object.</p>
<h2 id="see-also_95">See Also<a class="headerlink" href="#see-also_95" title="Permanent link">&para;</a></h2>
<p>eigsh : eigenvalues and eigenvectors for symmetric matrix A
svds : singular value decomposition for a matrix A</p>
<h2 id="notes_94">Notes<a class="headerlink" href="#notes_94" title="Permanent link">&para;</a></h2>
<p>This function is a wrapper to the ARPACK [1]<em> SNEUPD, DNEUPD, CNEUPD,
ZNEUPD, functions which use the Implicitly Restarted Arnoldi Method to
find the eigenvalues and eigenvectors [2]</em>.</p>
<h2 id="references_15">References<a class="headerlink" href="#references_15" title="Permanent link">&para;</a></h2>
<p>.. [1] ARPACK Software, http://www.caam.rice.edu/software/ARPACK/
.. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE:
Solution of Large Scale Eigenvalue Problems by Implicitly Restarted
Arnoldi Methods. SIAM, Philadelphia, PA, 1998.</p>
<h2 id="examples_139">Examples<a class="headerlink" href="#examples_139" title="Permanent link">&para;</a></h2>
<p>Find 6 eigenvectors of the identity matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import eigs
id = np.eye(13)
vals, vecs = eigs(id, k=6)
vals
array([ 1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j])
vecs.shape
(13, 6)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigsh</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sigma</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">which</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">v0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ncv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_eigenvectors</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">minv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">oPinv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find k eigenvalues and eigenvectors of the real symmetric square matrix
or complex hermitian matrix A.</p>
<p>Solves <code>A * x[i] = w[i] * x[i]</code>, the standard eigenvalue problem for
w[i] eigenvalues with corresponding eigenvectors x[i].</p>
<p>If M is specified, solves <code>A * x[i] = w[i] * M * x[i]</code>, the
generalized eigenvalue problem for w[i] eigenvalues
with corresponding eigenvectors x[i].</p>
<h2 id="parameters_268">Parameters<a class="headerlink" href="#parameters_268" title="Permanent link">&para;</a></h2>
<p>A : ndarray, sparse matrix or LinearOperator
A square operator representing the operation <code>A * x</code>, where <code>A</code> is
real symmetric or complex hermitian. For buckling mode (see below)
<code>A</code> must additionally be positive-definite.
k : int, optional
The number of eigenvalues and eigenvectors desired.
<code>k</code> must be smaller than N. It is not possible to compute all
eigenvectors of a matrix.</p>
<h2 id="returns_215">Returns<a class="headerlink" href="#returns_215" title="Permanent link">&para;</a></h2>
<p>w : array
Array of k eigenvalues.
v : array
An array representing the <code>k</code> eigenvectors.  The column <code>v[:, i]</code> is
the eigenvector corresponding to the eigenvalue <code>w[i]</code>.</p>
<h2 id="other-parameters_4">Other Parameters<a class="headerlink" href="#other-parameters_4" title="Permanent link">&para;</a></h2>
<p>M : An N x N matrix, array, sparse matrix, or linear operator representing
the operation <code>M @ x</code> for the generalized eigenvalue problem</p>
<p>A @ x = w * M @ x.</p>
<p>M must represent a real, symmetric matrix if A is real, and must
represent a complex, hermitian matrix if A is complex. For best
results, the data type of M should be the same as that of A.
Additionally:</p>
<p>If sigma is None, M is symmetric positive definite.</p>
<p>If sigma is specified, M is symmetric positive semi-definite.</p>
<p>In buckling mode, M is symmetric indefinite.</p>
<p>If sigma is None, eigsh requires an operator to compute the solution
of the linear equation <code>M @ x = b</code>. This is done internally via a
(sparse) LU decomposition for an explicit matrix M, or via an
iterative solver for a general linear operator.  Alternatively,
the user can supply the matrix or operator Minv, which gives
<code>x = Minv @ b = M^-1 @ b</code>.
sigma : real
Find eigenvalues near sigma using shift-invert mode.  This requires
an operator to compute the solution of the linear system
<code>[A - sigma * M] x = b</code>, where M is the identity matrix if
unspecified.  This is computed internally via a (sparse) LU
decomposition for explicit matrices A &amp; M, or via an iterative
solver if either A or M is a general linear operator.
Alternatively, the user can supply the matrix or operator OPinv,
which gives <code>x = OPinv @ b = [A - sigma * M]^-1 @ b</code>.
Note that when sigma is specified, the keyword 'which' refers to
the shifted eigenvalues <code>w'[i]</code> where:</p>
<p>if mode == 'normal', <code>w'[i] = 1 / (w[i] - sigma)</code>.</p>
<p>if mode == 'cayley', <code>w'[i] = (w[i] + sigma) / (w[i] - sigma)</code>.</p>
<p>if mode == 'buckling', <code>w'[i] = w[i] / (w[i] - sigma)</code>.</p>
<p>(see further discussion in 'mode' below)
v0 : ndarray, optional
Starting vector for iteration.
Default: random
ncv : int, optional
The number of Lanczos vectors generated ncv must be greater than k and
smaller than n; it is recommended that <code>ncv &gt; 2*k</code>.
Default: <code>min(n, max(2*k + 1, 20))</code>
which : str ['LM' | 'SM' | 'LA' | 'SA' | 'BE']
If A is a complex hermitian matrix, 'BE' is invalid.
Which <code>k</code> eigenvectors and eigenvalues to find:</p>
<p>'LM' : Largest (in magnitude) eigenvalues.</p>
<p>'SM' : Smallest (in magnitude) eigenvalues.</p>
<p>'LA' : Largest (algebraic) eigenvalues.</p>
<p>'SA' : Smallest (algebraic) eigenvalues.</p>
<p>'BE' : Half (k/2) from each end of the spectrum.</p>
<p>When k is odd, return one more (k/2+1) from the high end.
When sigma != None, 'which' refers to the shifted eigenvalues <code>w'[i]</code>
(see discussion in 'sigma', above).  ARPACK is generally better
at finding large values than small values.  If small eigenvalues are
desired, consider using shift-invert mode for better performance.
maxiter : int, optional
Maximum number of Arnoldi update iterations allowed.
Default: <code>n*10</code>
tol : float
Relative accuracy for eigenvalues (stopping criterion).
The default value of 0 implies machine precision.
Minv : N x N matrix, array, sparse matrix, or LinearOperator
See notes in M, above.
OPinv : N x N matrix, array, sparse matrix, or LinearOperator
See notes in sigma, above.
return_eigenvectors : bool
Return eigenvectors (True) in addition to eigenvalues.
This value determines the order in which eigenvalues are sorted.
The sort order is also dependent on the <code>which</code> variable.</p>
<p>For which = 'LM' or 'SA':
If <code>return_eigenvectors</code> is True, eigenvalues are sorted by
algebraic value.</p>
<p>If <code>return_eigenvectors</code> is False, eigenvalues are sorted by
absolute value.</p>
<p>For which = 'BE' or 'LA':
eigenvalues are always sorted by algebraic value.</p>
<p>For which = 'SM':
If <code>return_eigenvectors</code> is True, eigenvalues are sorted by
algebraic value.</p>
<p>If <code>return_eigenvectors</code> is False, eigenvalues are sorted by
decreasing absolute value.</p>
<p>mode : string ['normal' | 'buckling' | 'cayley']
Specify strategy to use for shift-invert mode.  This argument applies
only for real-valued A and sigma != None.  For shift-invert mode,
ARPACK internally solves the eigenvalue problem
<code>OP * x'[i] = w'[i] * B * x'[i]</code>
and transforms the resulting Ritz vectors x'[i] and Ritz values w'[i]
into the desired eigenvectors and eigenvalues of the problem
<code>A * x[i] = w[i] * M * x[i]</code>.
The modes are as follows:</p>
<p>'normal' :
OP = [A - sigma * M]^-1 @ M,
B = M,
w'[i] = 1 / (w[i] - sigma)</p>
<p>'buckling' :
OP = [A - sigma * M]^-1 @ A,
B = A,
w'[i] = w[i] / (w[i] - sigma)</p>
<p>'cayley' :
OP = [A - sigma * M]^-1 @ [A + sigma * M],
B = M,
w'[i] = (w[i] + sigma) / (w[i] - sigma)</p>
<p>The choice of mode will affect which eigenvalues are selected by
the keyword 'which', and can also impact the stability of
convergence (see [2] for a discussion).</p>
<h2 id="raises_17">Raises<a class="headerlink" href="#raises_17" title="Permanent link">&para;</a></h2>
<p>ArpackNoConvergence
When the requested convergence is not obtained.</p>
<p>The currently converged eigenvalues and eigenvectors can be found
as <code>eigenvalues</code> and <code>eigenvectors</code> attributes of the exception
object.</p>
<h2 id="see-also_96">See Also<a class="headerlink" href="#see-also_96" title="Permanent link">&para;</a></h2>
<p>eigs : eigenvalues and eigenvectors for a general (nonsymmetric) matrix A
svds : singular value decomposition for a matrix A</p>
<h2 id="notes_95">Notes<a class="headerlink" href="#notes_95" title="Permanent link">&para;</a></h2>
<p>This function is a wrapper to the ARPACK [1]<em> SSEUPD and DSEUPD
functions which use the Implicitly Restarted Lanczos Method to
find the eigenvalues and eigenvectors [2]</em>.</p>
<h2 id="references_16">References<a class="headerlink" href="#references_16" title="Permanent link">&para;</a></h2>
<p>.. [1] ARPACK Software, http://www.caam.rice.edu/software/ARPACK/
.. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE:
Solution of Large Scale Eigenvalue Problems by Implicitly Restarted
Arnoldi Methods. SIAM, Philadelphia, PA, 1998.</p>
<h2 id="examples_140">Examples<a class="headerlink" href="#examples_140" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import eigsh
identity = np.eye(13)
eigenvalues, eigenvectors = eigsh(identity, k=6)
eigenvalues
array([1., 1., 1., 1., 1., 1.])
eigenvectors.shape
(13, 6)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lobpcg</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">y</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">largest</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbosityLevel</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retLambdaHistory</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retResidualNormsHistory</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG)</p>
<p>LOBPCG is a preconditioned eigensolver for large symmetric positive
definite (SPD) generalized eigenproblems.</p>
<h2 id="parameters_269">Parameters<a class="headerlink" href="#parameters_269" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The symmetric linear operator of the problem, usually a
sparse matrix.  Often called the 'stiffness matrix'.
X : ndarray, float32 or float64
Initial approximation to the <code>k</code> eigenvectors (non-sparse). If <code>A</code>
has <code>shape=(n,n)</code> then <code>X</code> should have shape <code>shape=(n,k)</code>.
B : {dense matrix, sparse matrix, LinearOperator}, optional
The right hand side operator in a generalized eigenproblem.
By default, <code>B = Identity</code>.  Often called the 'mass matrix'.
M : {dense matrix, sparse matrix, LinearOperator}, optional
Preconditioner to <code>A</code>; by default <code>M = Identity</code>.
<code>M</code> should approximate the inverse of <code>A</code>.
Y : ndarray, float32 or float64, optional
n-by-sizeY matrix of constraints (non-sparse), sizeY &lt; n
The iterations will be performed in the B-orthogonal complement
of the column-space of Y. Y must be full rank.
tol : scalar, optional
Solver tolerance (stopping criterion).
The default is <code>tol=n*sqrt(eps)</code>.
maxiter : int, optional
Maximum number of iterations.  The default is <code>maxiter = 20</code>.
largest : bool, optional
When True, solve for the largest eigenvalues, otherwise the smallest.
verbosityLevel : int, optional
Controls solver output.  The default is <code>verbosityLevel=0</code>.
retLambdaHistory : bool, optional
Whether to return eigenvalue history.  Default is False.
retResidualNormsHistory : bool, optional
Whether to return history of residual norms.  Default is False.</p>
<h2 id="returns_216">Returns<a class="headerlink" href="#returns_216" title="Permanent link">&para;</a></h2>
<p>w : ndarray
Array of <code>k</code> eigenvalues
v : ndarray
An array of <code>k</code> eigenvectors.  <code>v</code> has the same shape as <code>X</code>.
lambdas : list of ndarray, optional
The eigenvalue history, if <code>retLambdaHistory</code> is True.
rnorms : list of ndarray, optional
The history of residual norms, if <code>retResidualNormsHistory</code> is True.</p>
<h2 id="notes_96">Notes<a class="headerlink" href="#notes_96" title="Permanent link">&para;</a></h2>
<p>If both <code>retLambdaHistory</code> and <code>retResidualNormsHistory</code> are True,
the return tuple has the following format
<code>(lambda, V, lambda history, residual norms history)</code>.</p>
<p>In the following <code>n</code> denotes the matrix size and <code>m</code> the number
of required eigenvalues (smallest or largest).</p>
<p>The LOBPCG code internally solves eigenproblems of the size <code>3m</code> on every
iteration by calling the 'standard' dense eigensolver, so if <code>m</code> is not
small enough compared to <code>n</code>, it does not make sense to call the LOBPCG
code, but rather one should use the 'standard' eigensolver, e.g. numpy or
scipy function in this case.
If one calls the LOBPCG algorithm for <code>5m &gt; n</code>, it will most likely break
internally, so the code tries to call the standard function instead.</p>
<p>It is not that <code>n</code> should be large for the LOBPCG to work, but rather the
ratio <code>n / m</code> should be large. It you call LOBPCG with <code>m=1</code>
and <code>n=10</code>, it works though <code>n</code> is small. The method is intended
for extremely large <code>n / m</code>, see e.g., reference [28] in
https://arxiv.org/abs/0705.2626</p>
<p>The convergence speed depends basically on two factors:</p>
<ol>
<li>
<p>How well relatively separated the seeking eigenvalues are from the rest
of the eigenvalues. One can try to vary <code>m</code> to make this better.</p>
</li>
<li>
<p>How well conditioned the problem is. This can be changed by using proper
preconditioning. For example, a rod vibration test problem (under tests
directory) is ill-conditioned for large <code>n</code>, so convergence will be
slow, unless efficient preconditioning is used. For this specific
problem, a good simple preconditioner function would be a linear solve
for <code>A</code>, which is easy to code since A is tridiagonal.</p>
</li>
</ol>
<h2 id="references_17">References<a class="headerlink" href="#references_17" title="Permanent link">&para;</a></h2>
<p>.. [1] A. V. Knyazev (2001),
Toward the Optimal Preconditioned Eigensolver: Locally Optimal
Block Preconditioned Conjugate Gradient Method.
SIAM Journal on Scientific Computing 23, no. 2,
pp. 517-541. http://dx.doi.org/10.1137/S1064827500366124</p>
<p>.. [2] A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov
(2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers
(BLOPEX) in hypre and PETSc. https://arxiv.org/abs/0705.2626</p>
<p>.. [3] A. V. Knyazev's C and MATLAB implementations:
https://bitbucket.org/joseroman/blopex</p>
<h2 id="examples_141">Examples<a class="headerlink" href="#examples_141" title="Permanent link">&para;</a></h2>
<p>Solve <code>A x = lambda x</code> with constraints and preconditioning.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import spdiags, issparse
from scipy.sparse.linalg import lobpcg, LinearOperator
n = 100
vals = np.arange(1, n + 1)
A = spdiags(vals, 0, n, n)
A.toarray()
array([[  1.,   0.,   0., ...,   0.,   0.,   0.],
[  0.,   2.,   0., ...,   0.,   0.,   0.],
[  0.,   0.,   3., ...,   0.,   0.,   0.],
...,
[  0.,   0.,   0., ...,  98.,   0.,   0.],
[  0.,   0.,   0., ...,   0.,  99.,   0.],
[  0.,   0.,   0., ...,   0.,   0., 100.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constraints:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Y = np.eye(n, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initial guess for eigenvectors, should have linearly independent
columns. Column dimension = number of requested eigenvalues.</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = np.random.rand(n, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Preconditioner in the inverse of A in this example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>invA = spdiags([1./vals], 0, n, n)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The preconditiner must be defined by a function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def precond( x ):
...     return invA @ x</p>
</blockquote>
</blockquote>
</blockquote>
<p>The argument x of the preconditioner function is a matrix inside <code>lobpcg</code>,
thus the use of matrix-matrix product <code>@</code>.</p>
<p>The preconditioner function is passed to lobpcg as a <code>LinearOperator</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>M = LinearOperator(matvec=precond, matmat=precond,
...                    shape=(n, n), dtype=float)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Let us now solve the eigenvalue problem for the matrix A:</p>
<blockquote>
<blockquote>
<blockquote>
<p>eigenvalues, _ = lobpcg(A, X, Y=Y, M=M, largest=False)
eigenvalues
array([4., 5., 6.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that the vectors passed in Y are the eigenvectors of the 3 smallest
eigenvalues. The results returned are orthogonal to those.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svds</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ncv</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">which</span><span class="o">:[`</span><span class="nc">LM</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SM</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">v0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_singular_vectors</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">solver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the largest or smallest k singular values/vectors for a sparse matrix. The order of the singular values is not guaranteed.</p>
<h2 id="parameters_270">Parameters<a class="headerlink" href="#parameters_270" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, LinearOperator}
Array to compute the SVD on, of shape (M, N)
k : int, optional
Number of singular values and vectors to compute.
Must be 1 &lt;= k &lt; min(A.shape).
ncv : int, optional
The number of Lanczos vectors generated
ncv must be greater than k+1 and smaller than n;
it is recommended that ncv &gt; 2*k
Default: <code>min(n, max(2*k + 1, 20))</code>
tol : float, optional
Tolerance for singular values. Zero (default) means machine precision.
which : str, ['LM' | 'SM'], optional
Which <code>k</code> singular values to find:</p>
<ul>
<li>'LM' : largest singular values</li>
<li>'SM' : smallest singular values</li>
</ul>
<p>.. versionadded:: 0.12.0
v0 : ndarray, optional
Starting vector for iteration, of length min(A.shape). Should be an
(approximate) left singular vector if N &gt; M and a right singular
vector otherwise.
Default: random</p>
<p>.. versionadded:: 0.12.0
maxiter : int, optional
Maximum number of iterations.</p>
<p>.. versionadded:: 0.12.0
return_singular_vectors : bool or str, optional
- True: return singular vectors (True) in addition to singular values.</p>
<p>.. versionadded:: 0.12.0</p>
<ul>
<li>'u': only return the u matrix, without computing vh (if N &gt; M).</li>
<li>'vh': only return the vh matrix, without computing u (if N &lt;= M).</li>
</ul>
<p>.. versionadded:: 0.16.0
solver : str, optional
Eigenvalue solver to use. Should be 'arpack' or 'lobpcg'.
Default: 'arpack'</p>
<h2 id="returns_217">Returns<a class="headerlink" href="#returns_217" title="Permanent link">&para;</a></h2>
<p>u : ndarray, shape=(M, k)
Unitary matrix having left singular vectors as columns.
If <code>return_singular_vectors</code> is 'vh', this variable is not computed,
and None is returned instead.
s : ndarray, shape=(k,)
The singular values.
vt : ndarray, shape=(k, N)
Unitary matrix having right singular vectors as rows.
If <code>return_singular_vectors</code> is 'u', this variable is not computed,
and None is returned instead.</p>
<h2 id="notes_97">Notes<a class="headerlink" href="#notes_97" title="Permanent link">&para;</a></h2>
<p>This is a naive implementation using ARPACK or LOBPCG as an eigensolver
on A.H * A or A * A.H, depending on which one is more efficient.</p>
<h2 id="examples_142">Examples<a class="headerlink" href="#examples_142" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import svds, eigs
A = csc_matrix([[1, 0, 0], [5, 0, 2], [0, -1, 0], [0, 0, 3]], dtype=float)
u, s, vt = svds(A, k=2)
s
array([ 2.75193379,  5.6059665 ])
np.sqrt(eigs(A.dot(A.T), k=2)[0]).real
array([ 5.6059665 ,  2.75193379])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Interface</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">IdentityOperator</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IdentityOperator</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IdentityOperator</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Common interface for performing matrix vector products</p>
<p>Many iterative methods (e.g. cg, gmres) do not need to know the
individual entries of a matrix to solve a linear system A<em>x=b.
Such solvers only require the computation of matrix vector
products, A</em>v where v is a dense vector.  This class serves as
an abstract interface between iterative solvers and matrix-like
objects.</p>
<p>To construct a concrete LinearOperator, either pass appropriate
callables to the constructor of this class, or subclass it.</p>
<p>A subclass must implement either one of the methods <code>_matvec</code>
and <code>_matmat</code>, and the attributes/properties <code>shape</code> (pair of
integers) and <code>dtype</code> (may be None). It may call the <code>__init__</code>
on this class to have these attributes validated. Implementing
<code>_matvec</code> automatically implements <code>_matmat</code> (using a naive
algorithm) and vice-versa.</p>
<p>Optionally, a subclass may implement <code>_rmatvec</code> or <code>_adjoint</code>
to implement the Hermitian adjoint (conjugate transpose). As with
<code>_matvec</code> and <code>_matmat</code>, implementing either <code>_rmatvec</code> or
<code>_adjoint</code> implements the other automatically. Implementing
<code>_adjoint</code> is preferable; <code>_rmatvec</code> is mostly there for
backwards compatibility.</p>
<h2 id="parameters_271">Parameters<a class="headerlink" href="#parameters_271" title="Permanent link">&para;</a></h2>
<p>shape : tuple
Matrix dimensions (M, N).
matvec : callable f(v)
Returns returns A * v.
rmatvec : callable f(v)
Returns A^H * v, where A^H is the conjugate transpose of A.
matmat : callable f(V)
Returns A * V, where V is a dense matrix with dimensions (N, K).
dtype : dtype
Data type of the matrix.
rmatmat : callable f(V)
Returns A^H * V, where V is a dense matrix with dimensions (M, K).</p>
<h2 id="attributes_10">Attributes<a class="headerlink" href="#attributes_10" title="Permanent link">&para;</a></h2>
<p>args : tuple
For linear operators describing products etc. of other linear
operators, the operands of the binary operation.</p>
<h2 id="see-also_97">See Also<a class="headerlink" href="#see-also_97" title="Permanent link">&para;</a></h2>
<p>aslinearoperator : Construct LinearOperators</p>
<h2 id="notes_98">Notes<a class="headerlink" href="#notes_98" title="Permanent link">&para;</a></h2>
<p>The user-defined matvec() function must properly handle the case
where v has shape (N,) as well as the (N,1) case.  The shape of
the return type is handled internally by LinearOperator.</p>
<p>LinearOperator instances can also be multiplied, added with each
other and exponentiated, all lazily: the result of these operations
is always a new, composite LinearOperator, that defers linear
operations to the original operators and combines the results.</p>
<p>More details regarding how to subclass a LinearOperator and several
examples of concrete LinearOperator instances can be found in the
external project <code>PyLops &lt;https://pylops.readthedocs.io&gt;</code>_.</p>
<h2 id="examples_143">Examples<a class="headerlink" href="#examples_143" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse.linalg import LinearOperator
def mv(v):
...     return np.array([2<em>v[0], 3</em>v[1]])
...
A = LinearOperator((2,2), matvec=mv)
A
&lt;2x2 _CustomLinearOperator with dtype=float64&gt;
A.matvec(np.ones(2))
array([ 2.,  3.])
A * np.ones(2)
array([ 2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">adjoint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Hermitian adjoint.</p>
<p>Returns the Hermitian adjoint of self, aka the Hermitian
conjugate or Hermitian transpose. For a complex matrix, the
Hermitian adjoint is equal to the conjugate transpose.</p>
<p>Can be abbreviated self.H instead of self.adjoint().</p>
<h2 id="returns_218">Returns<a class="headerlink" href="#returns_218" title="Permanent link">&para;</a></h2>
<p>A_H : LinearOperator
Hermitian adjoint of self.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix or matrix-vector multiplication.</p>
<h2 id="parameters_272">Parameters<a class="headerlink" href="#parameters_272" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-d or 2-d array, representing a vector or matrix.</p>
<h2 id="returns_219">Returns<a class="headerlink" href="#returns_219" title="Permanent link">&para;</a></h2>
<p>Ax : array
1-d or 2-d array (depending on the shape of x) that represents
the result of applying this linear operator on x.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix multiplication.</p>
<p>Performs the operation y=A<em>X where A is an MxN linear
operator and X dense N</em>K matrix or ndarray.</p>
<h2 id="parameters_273">Parameters<a class="headerlink" href="#parameters_273" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
An array with shape (N,K).</p>
<h2 id="returns_220">Returns<a class="headerlink" href="#returns_220" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or ndarray with shape (M,K) depending on
the type of the X argument.</p>
<h2 id="notes_99">Notes<a class="headerlink" href="#notes_99" title="Permanent link">&para;</a></h2>
<p>This matmat wraps any user-specified matmat routine or overridden
_matmat method to ensure that y has the correct type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-vector multiplication.</p>
<p>Performs the operation y=A*x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_274">Parameters<a class="headerlink" href="#parameters_274" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (N,) or (N,1).</p>
<h2 id="returns_221">Returns<a class="headerlink" href="#returns_221" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (M,) or (M,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_100">Notes<a class="headerlink" href="#notes_100" title="Permanent link">&para;</a></h2>
<p>This matvec wraps the user-specified matvec routine or overridden
_matvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-matrix multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array, or 2-d array.
The default implementation defers to the adjoint.</p>
<h2 id="parameters_275">Parameters<a class="headerlink" href="#parameters_275" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
A matrix or 2D array.</p>
<h2 id="returns_222">Returns<a class="headerlink" href="#returns_222" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or 2D array depending on the type of the input.</p>
<h2 id="notes_101">Notes<a class="headerlink" href="#notes_101" title="Permanent link">&para;</a></h2>
<p>This rmatmat wraps the user-specified rmatmat routine.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-vector multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_276">Parameters<a class="headerlink" href="#parameters_276" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (M,) or (M,1).</p>
<h2 id="returns_223">Returns<a class="headerlink" href="#returns_223" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (N,) or (N,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_102">Notes<a class="headerlink" href="#notes_102" title="Permanent link">&para;</a></h2>
<p>This rmatvec wraps the user-specified rmatvec routine or overridden
_rmatvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transpose this linear operator.</p>
<p>Returns a LinearOperator that represents the transpose of this one.
Can be abbreviated self.T instead of self.transpose().</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">MatrixLinearOperator</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">MatrixLinearOperator</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">MatrixLinearOperator</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Common interface for performing matrix vector products</p>
<p>Many iterative methods (e.g. cg, gmres) do not need to know the
individual entries of a matrix to solve a linear system A<em>x=b.
Such solvers only require the computation of matrix vector
products, A</em>v where v is a dense vector.  This class serves as
an abstract interface between iterative solvers and matrix-like
objects.</p>
<p>To construct a concrete LinearOperator, either pass appropriate
callables to the constructor of this class, or subclass it.</p>
<p>A subclass must implement either one of the methods <code>_matvec</code>
and <code>_matmat</code>, and the attributes/properties <code>shape</code> (pair of
integers) and <code>dtype</code> (may be None). It may call the <code>__init__</code>
on this class to have these attributes validated. Implementing
<code>_matvec</code> automatically implements <code>_matmat</code> (using a naive
algorithm) and vice-versa.</p>
<p>Optionally, a subclass may implement <code>_rmatvec</code> or <code>_adjoint</code>
to implement the Hermitian adjoint (conjugate transpose). As with
<code>_matvec</code> and <code>_matmat</code>, implementing either <code>_rmatvec</code> or
<code>_adjoint</code> implements the other automatically. Implementing
<code>_adjoint</code> is preferable; <code>_rmatvec</code> is mostly there for
backwards compatibility.</p>
<h2 id="parameters_277">Parameters<a class="headerlink" href="#parameters_277" title="Permanent link">&para;</a></h2>
<p>shape : tuple
Matrix dimensions (M, N).
matvec : callable f(v)
Returns returns A * v.
rmatvec : callable f(v)
Returns A^H * v, where A^H is the conjugate transpose of A.
matmat : callable f(V)
Returns A * V, where V is a dense matrix with dimensions (N, K).
dtype : dtype
Data type of the matrix.
rmatmat : callable f(V)
Returns A^H * V, where V is a dense matrix with dimensions (M, K).</p>
<h2 id="attributes_11">Attributes<a class="headerlink" href="#attributes_11" title="Permanent link">&para;</a></h2>
<p>args : tuple
For linear operators describing products etc. of other linear
operators, the operands of the binary operation.</p>
<h2 id="see-also_98">See Also<a class="headerlink" href="#see-also_98" title="Permanent link">&para;</a></h2>
<p>aslinearoperator : Construct LinearOperators</p>
<h2 id="notes_103">Notes<a class="headerlink" href="#notes_103" title="Permanent link">&para;</a></h2>
<p>The user-defined matvec() function must properly handle the case
where v has shape (N,) as well as the (N,1) case.  The shape of
the return type is handled internally by LinearOperator.</p>
<p>LinearOperator instances can also be multiplied, added with each
other and exponentiated, all lazily: the result of these operations
is always a new, composite LinearOperator, that defers linear
operations to the original operators and combines the results.</p>
<p>More details regarding how to subclass a LinearOperator and several
examples of concrete LinearOperator instances can be found in the
external project <code>PyLops &lt;https://pylops.readthedocs.io&gt;</code>_.</p>
<h2 id="examples_144">Examples<a class="headerlink" href="#examples_144" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse.linalg import LinearOperator
def mv(v):
...     return np.array([2<em>v[0], 3</em>v[1]])
...
A = LinearOperator((2,2), matvec=mv)
A
&lt;2x2 _CustomLinearOperator with dtype=float64&gt;
A.matvec(np.ones(2))
array([ 2.,  3.])
A * np.ones(2)
array([ 2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">adjoint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Hermitian adjoint.</p>
<p>Returns the Hermitian adjoint of self, aka the Hermitian
conjugate or Hermitian transpose. For a complex matrix, the
Hermitian adjoint is equal to the conjugate transpose.</p>
<p>Can be abbreviated self.H instead of self.adjoint().</p>
<h2 id="returns_224">Returns<a class="headerlink" href="#returns_224" title="Permanent link">&para;</a></h2>
<p>A_H : LinearOperator
Hermitian adjoint of self.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix or matrix-vector multiplication.</p>
<h2 id="parameters_278">Parameters<a class="headerlink" href="#parameters_278" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-d or 2-d array, representing a vector or matrix.</p>
<h2 id="returns_225">Returns<a class="headerlink" href="#returns_225" title="Permanent link">&para;</a></h2>
<p>Ax : array
1-d or 2-d array (depending on the shape of x) that represents
the result of applying this linear operator on x.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix multiplication.</p>
<p>Performs the operation y=A<em>X where A is an MxN linear
operator and X dense N</em>K matrix or ndarray.</p>
<h2 id="parameters_279">Parameters<a class="headerlink" href="#parameters_279" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
An array with shape (N,K).</p>
<h2 id="returns_226">Returns<a class="headerlink" href="#returns_226" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or ndarray with shape (M,K) depending on
the type of the X argument.</p>
<h2 id="notes_104">Notes<a class="headerlink" href="#notes_104" title="Permanent link">&para;</a></h2>
<p>This matmat wraps any user-specified matmat routine or overridden
_matmat method to ensure that y has the correct type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-vector multiplication.</p>
<p>Performs the operation y=A*x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_280">Parameters<a class="headerlink" href="#parameters_280" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (N,) or (N,1).</p>
<h2 id="returns_227">Returns<a class="headerlink" href="#returns_227" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (M,) or (M,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_105">Notes<a class="headerlink" href="#notes_105" title="Permanent link">&para;</a></h2>
<p>This matvec wraps the user-specified matvec routine or overridden
_matvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-matrix multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array, or 2-d array.
The default implementation defers to the adjoint.</p>
<h2 id="parameters_281">Parameters<a class="headerlink" href="#parameters_281" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
A matrix or 2D array.</p>
<h2 id="returns_228">Returns<a class="headerlink" href="#returns_228" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or 2D array depending on the type of the input.</p>
<h2 id="notes_106">Notes<a class="headerlink" href="#notes_106" title="Permanent link">&para;</a></h2>
<p>This rmatmat wraps the user-specified rmatmat routine.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-vector multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_282">Parameters<a class="headerlink" href="#parameters_282" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (M,) or (M,1).</p>
<h2 id="returns_229">Returns<a class="headerlink" href="#returns_229" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (N,) or (N,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_107">Notes<a class="headerlink" href="#notes_107" title="Permanent link">&para;</a></h2>
<p>This rmatvec wraps the user-specified rmatvec routine or overridden
_rmatvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transpose this linear operator.</p>
<p>Returns a LinearOperator that represents the transpose of this one.
Can be abbreviated self.T instead of self.transpose().</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">aslinearoperator</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return A as a LinearOperator.</p>
<p>'A' may be any of the following types:
- ndarray
- matrix
- sparse matrix (e.g. csr_matrix, lil_matrix, etc.)
- LinearOperator
- An object with .shape and .matvec attributes</p>
<p>See the LinearOperator documentation for additional information.</p>
<h2 id="notes_108">Notes<a class="headerlink" href="#notes_108" title="Permanent link">&para;</a></h2>
<p>If 'A' has no .dtype attribute, the data type is determined by calling
:func:<code>LinearOperator.matvec()</code> - set the .dtype attribute to prevent this
call upon the linear operator creation.</p>
<h2 id="examples_145">Examples<a class="headerlink" href="#examples_145" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import aslinearoperator
M = np.array([[1,2,3],[4,5,6]], dtype=np.int32)
aslinearoperator(M)
&lt;2x3 MatrixLinearOperator with dtype=int32&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asmatrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_pydata_spmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Check whether object is pydata/sparse matrix, avoiding importing the module.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isintlike</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x appropriate as an index into a sparse matrix? Returns True
if it can be cast safely to a machine int.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">nonneg</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x a valid 2-tuple of dimensions?</p>
<p>If nonneg, also checks that the dimensions are non-negative.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_283">Parameters<a class="headerlink" href="#parameters_283" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_230">Returns<a class="headerlink" href="#returns_230" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_109">Notes<a class="headerlink" href="#notes_109" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_146">Examples<a class="headerlink" href="#examples_146" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Isolve</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Iterative</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">bicg</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use BIConjugate Gradient iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_284">Parameters<a class="headerlink" href="#parameters_284" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> and <code>A^T x</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_231">Returns<a class="headerlink" href="#returns_231" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_5">Other Parameters<a class="headerlink" href="#other-parameters_5" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bicgstab</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use BIConjugate Gradient STABilized iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_285">Parameters<a class="headerlink" href="#parameters_285" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_232">Returns<a class="headerlink" href="#returns_232" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_6">Other Parameters<a class="headerlink" href="#other-parameters_6" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cg</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Conjugate Gradient iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_286">Parameters<a class="headerlink" href="#parameters_286" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
<code>A</code> must represent a hermitian, positive definite matrix.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_233">Returns<a class="headerlink" href="#returns_233" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_7">Other Parameters<a class="headerlink" href="#other-parameters_7" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cgs</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Conjugate Gradient Squared iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_287">Parameters<a class="headerlink" href="#parameters_287" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real-valued N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_234">Returns<a class="headerlink" href="#returns_234" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_8">Other Parameters<a class="headerlink" href="#other-parameters_8" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gmres</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">restart</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">restrt</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback_type</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Generalized Minimal RESidual iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_288">Parameters<a class="headerlink" href="#parameters_288" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_235">Returns<a class="headerlink" href="#returns_235" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : int
Provides convergence information:
* 0  : successful exit
* &gt;0 : convergence to tolerance not achieved, number of iterations
* &lt;0 : illegal input or breakdown</p>
<h2 id="other-parameters_9">Other parameters<a class="headerlink" href="#other-parameters_9" title="Permanent link">&para;</a></h2>
<p>x0 : {array, matrix}
Starting guess for the solution (a vector of zeros by default).
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
restart : int, optional
Number of iterations between restarts. Larger values increase
iteration cost, but may be necessary for convergence.
Default is 20.
maxiter : int, optional
Maximum number of iterations (restart cycles).  Iteration will stop
after maxiter steps even if the specified tolerance has not been
achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Inverse of the preconditioner of A.  M should approximate the
inverse of A and be easy to solve for (see Notes).  Effective
preconditioning dramatically improves the rate of convergence,
which implies that fewer iterations are needed to reach a given
error tolerance.  By default, no preconditioner is used.
callback : function
User-supplied function to call after each iteration.  It is called
as <code>callback(args)</code>, where <code>args</code> are selected by <code>callback_type</code>.
callback_type : {'x', 'pr_norm', 'legacy'}, optional
Callback function argument requested:
- <code>x</code>: current iterate (ndarray), called on every restart
- <code>pr_norm</code>: relative (preconditioned) residual norm (float),
called on every inner iteration
- <code>legacy</code> (default): same as <code>pr_norm</code>, but also changes the
meaning of 'maxiter' to count inner iterations instead of restart
cycles.
restrt : int, optional
DEPRECATED - use <code>restart</code> instead.</p>
<h2 id="see-also_99">See Also<a class="headerlink" href="#see-also_99" title="Permanent link">&para;</a></h2>
<p>LinearOperator</p>
<h2 id="notes_110">Notes<a class="headerlink" href="#notes_110" title="Permanent link">&para;</a></h2>
<p>A preconditioner, P, is chosen such that P is close to A but easy to solve
for. The preconditioner parameter required by this routine is
<code>M = P^-1</code>. The inverse should preferably not be calculated
explicitly.  Rather, use the following template to produce M::</p>
<h1 id="construct-a-linear-operator-that-computes-p-1-x_2">Construct a linear operator that computes P^-1 * x.<a class="headerlink" href="#construct-a-linear-operator-that-computes-p-1-x_2" title="Permanent link">&para;</a></h1>
<p>import scipy.sparse.linalg as spla
M_x = lambda x: spla.spsolve(P, x)
M = spla.LinearOperator((n, n), M_x)</p>
<h2 id="examples_147">Examples<a class="headerlink" href="#examples_147" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import gmres
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
b = np.array([2, 4, -1], dtype=float)
x, exitCode = gmres(A, b)
print(exitCode)            # 0 indicates successful convergence
0
np.allclose(A.dot(x), b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">make_system</span> <span class="o">:</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Make a linear system Ax=b</p>
<h2 id="parameters_289">Parameters<a class="headerlink" href="#parameters_289" title="Permanent link">&para;</a></h2>
<p>A : LinearOperator
sparse or dense matrix (or any valid input to aslinearoperator)
M : {LinearOperator, Nones}
preconditioner
sparse or dense matrix (or any valid input to aslinearoperator)
x0 : {array_like, None}
initial guess to iterative method
b : array_like
right hand side</p>
<h2 id="returns_236">Returns<a class="headerlink" href="#returns_236" title="Permanent link">&para;</a></h2>
<p>(A, M, x, b, postprocess)
A : LinearOperator
matrix of the linear system
M : LinearOperator
preconditioner
x : rank 1 ndarray
initial guess
b : rank 1 ndarray
right hand side
postprocess : function
converts the solution vector to the appropriate
type and dimensions (e.g. (N,1) matrix)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">non_reentrant</span> <span class="o">:</span> <span class="o">?</span><span class="n">err_msg</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Decorate a function with a threading lock and prevent reentrant calls.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qmr</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Quasi-Minimal Residual iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_290">Parameters<a class="headerlink" href="#parameters_290" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real-valued N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> and <code>A^T x</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_237">Returns<a class="headerlink" href="#returns_237" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_10">Other Parameters<a class="headerlink" href="#other-parameters_10" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M1 : {sparse matrix, dense matrix, LinearOperator}
Left preconditioner for A.
M2 : {sparse matrix, dense matrix, LinearOperator}
Right preconditioner for A. Used together with the left
preconditioner M1.  The matrix M1<em>A</em>M2 should have better
conditioned than A alone.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<h2 id="see-also_100">See Also<a class="headerlink" href="#see-also_100" title="Permanent link">&para;</a></h2>
<p>LinearOperator</p>
<h2 id="examples_148">Examples<a class="headerlink" href="#examples_148" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import qmr
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
b = np.array([2, 4, -1], dtype=float)
x, exitCode = qmr(A, b)
print(exitCode)            # 0 indicates successful convergence
0
np.allclose(A.dot(x), b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_docstring</span> <span class="o">:</span> <span class="o">?</span><span class="n">footer</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol_default</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">header</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ainfo</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Utils</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Matrix</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Matrix</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArrayLike</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Matrix</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>matrix(data, dtype=None, copy=True)</p>
<p>.. note:: It is no longer recommended to use this class, even for linear
algebra. Instead use regular arrays. The class may be removed
in the future.</p>
<p>Returns a matrix from an array-like object, or from a string of data.
A matrix is a specialized 2-D array that retains its 2-D nature
through operations.  It has certain special operators, such as <code>*</code>
(matrix multiplication) and <code>**</code> (matrix power).</p>
<h2 id="parameters_291">Parameters<a class="headerlink" href="#parameters_291" title="Permanent link">&para;</a></h2>
<p>data : array_like or string
If <code>data</code> is a string, it is interpreted as a matrix with commas
or spaces separating columns, and semicolons separating rows.
dtype : data-type
Data-type of the output matrix.
copy : bool
If <code>data</code> is already an <code>ndarray</code>, then this flag determines
whether the data is copied (the default), or whether a view is
constructed.</p>
<h2 id="see-also_101">See Also<a class="headerlink" href="#see-also_101" title="Permanent link">&para;</a></h2>
<p>array</p>
<h2 id="examples_149">Examples<a class="headerlink" href="#examples_149" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.matrix('1 2; 3 4')
a
matrix([[1, 2],
[3, 4]])</p>
<p>np.matrix([[1, 2], [3, 4]])
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">index</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">setitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Set self[key] to value.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">all</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Test whether all matrix elements along a given axis evaluate to True.</p>
<h2 id="parameters_292">Parameters<a class="headerlink" href="#parameters_292" title="Permanent link">&para;</a></h2>
<p>See <code>numpy.all</code> for complete descriptions</p>
<h2 id="see-also_102">See Also<a class="headerlink" href="#see-also_102" title="Permanent link">&para;</a></h2>
<p>numpy.all</p>
<h2 id="notes_111">Notes<a class="headerlink" href="#notes_111" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.all</code>, but it returns a <code>matrix</code> object.</p>
<h2 id="examples_150">Examples<a class="headerlink" href="#examples_150" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
y = x[0]; y
matrix([[0, 1, 2, 3]])
(x == y)
matrix([[ True,  True,  True,  True],
[False, False, False, False],
[False, False, False, False]])
(x == y).all()
False
(x == y).all(0)
matrix([[False, False, False, False]])
(x == y).all(1)
matrix([[ True],
[False],
[False]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">any</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Test whether any array element along a given axis evaluates to True.</p>
<p>Refer to <code>numpy.any</code> for full documentation.</p>
<h2 id="parameters_293">Parameters<a class="headerlink" href="#parameters_293" title="Permanent link">&para;</a></h2>
<p>axis : int, optional
Axis along which logical OR is performed
out : ndarray, optional
Output to existing array instead of creating new one, must have
same shape as expected output</p>
<h2 id="returns_238">Returns<a class="headerlink" href="#returns_238" title="Permanent link">&para;</a></h2>
<p>any : bool, ndarray
Returns a single bool if <code>axis</code> is <code>None</code>; otherwise,
returns <code>ndarray</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argmax</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Indexes of the maximum values along an axis.</p>
<p>Return the indexes of the first occurrences of the maximum values
along the specified axis.  If axis is None, the index is for the
flattened matrix.</p>
<h2 id="parameters_294">Parameters<a class="headerlink" href="#parameters_294" title="Permanent link">&para;</a></h2>
<p>See <code>numpy.argmax</code> for complete descriptions</p>
<h2 id="see-also_103">See Also<a class="headerlink" href="#see-also_103" title="Permanent link">&para;</a></h2>
<p>numpy.argmax</p>
<h2 id="notes_112">Notes<a class="headerlink" href="#notes_112" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.argmax</code>, but returns a <code>matrix</code> object
where <code>ndarray.argmax</code> would return an <code>ndarray</code>.</p>
<h2 id="examples_151">Examples<a class="headerlink" href="#examples_151" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.argmax()
11
x.argmax(0)
matrix([[2, 2, 2, 2]])
x.argmax(1)
matrix([[3],
[3],
[3]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argmin</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Indexes of the minimum values along an axis.</p>
<p>Return the indexes of the first occurrences of the minimum values
along the specified axis.  If axis is None, the index is for the
flattened matrix.</p>
<h2 id="parameters_295">Parameters<a class="headerlink" href="#parameters_295" title="Permanent link">&para;</a></h2>
<p>See <code>numpy.argmin</code> for complete descriptions.</p>
<h2 id="see-also_104">See Also<a class="headerlink" href="#see-also_104" title="Permanent link">&para;</a></h2>
<p>numpy.argmin</p>
<h2 id="notes_113">Notes<a class="headerlink" href="#notes_113" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.argmin</code>, but returns a <code>matrix</code> object
where <code>ndarray.argmin</code> would return an <code>ndarray</code>.</p>
<h2 id="examples_152">Examples<a class="headerlink" href="#examples_152" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = -np.matrix(np.arange(12).reshape((3,4))); x
matrix([[  0,  -1,  -2,  -3],
[ -4,  -5,  -6,  -7],
[ -8,  -9, -10, -11]])
x.argmin()
11
x.argmin(0)
matrix([[2, 2, 2, 2]])
x.argmin(1)
matrix([[3],
[3],
[3]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argpartition</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kind</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">kth</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.argpartition(kth, axis=-1, kind='introselect', order=None)</p>
<p>Returns the indices that would partition this array.</p>
<p>Refer to <code>numpy.argpartition</code> for full documentation.</p>
<p>.. versionadded:: 1.8.0</p>
<h2 id="see-also_105">See Also<a class="headerlink" href="#see-also_105" title="Permanent link">&para;</a></h2>
<p>numpy.argpartition : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argsort</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kind</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.argsort(axis=-1, kind=None, order=None)</p>
<p>Returns the indices that would sort this array.</p>
<p>Refer to <code>numpy.argsort</code> for full documentation.</p>
<h2 id="see-also_106">See Also<a class="headerlink" href="#see-also_106" title="Permanent link">&para;</a></h2>
<p>numpy.argsort : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">astype</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">casting</span><span class="o">:[`</span><span class="nc">No</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Equiv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Safe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same_kind</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Unsafe</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</p>
<p>Copy of the array, cast to a specified type.</p>
<h2 id="parameters_296">Parameters<a class="headerlink" href="#parameters_296" title="Permanent link">&para;</a></h2>
<p>dtype : str or dtype
Typecode or data-type to which the array is cast.
order : {'C', 'F', 'A', 'K'}, optional
Controls the memory layout order of the result.
'C' means C order, 'F' means Fortran order, 'A'
means 'F' order if all the arrays are Fortran contiguous,
'C' order otherwise, and 'K' means as close to the
order the array elements appear in memory as possible.
Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
Controls what kind of data casting may occur. Defaults to 'unsafe'
for backwards compatibility.</p>
<ul>
<li>'no' means the data types should not be cast at all.</li>
<li>'equiv' means only byte-order changes are allowed.</li>
<li>'safe' means only casts which can preserve values are allowed.</li>
<li>'same_kind' means only safe casts or casts within a kind,
like float64 to float32, are allowed.</li>
<li>'unsafe' means any data conversions may be done.
subok : bool, optional
If True, then sub-classes will be passed-through (default), otherwise
the returned array will be forced to be a base-class array.
copy : bool, optional
By default, astype always returns a newly allocated array. If this
is set to false, and the <code>dtype</code>, <code>order</code>, and <code>subok</code>
requirements are satisfied, the input array is returned instead
of a copy.</li>
</ul>
<h2 id="returns_239">Returns<a class="headerlink" href="#returns_239" title="Permanent link">&para;</a></h2>
<p>arr_t : ndarray
Unless <code>copy</code> is False and the other conditions for returning the input
array are satisfied (see description for <code>copy</code> input parameter), <code>arr_t</code>
is a new array of the same shape as the input array, with dtype, order
given by <code>dtype</code>, <code>order</code>.</p>
<h2 id="notes_114">Notes<a class="headerlink" href="#notes_114" title="Permanent link">&para;</a></h2>
<p>.. versionchanged:: 1.17.0
Casting between a simple data type and a structured one is possible only
for 'unsafe' casting.  Casting to multiple fields is allowed, but
casting from multiple fields is not.</p>
<p>.. versionchanged:: 1.9.0
Casting from numeric to string types in 'safe' casting mode requires
that the string dtype length is long enough to store the max
integer/float value converted.</p>
<h2 id="raises_18">Raises<a class="headerlink" href="#raises_18" title="Permanent link">&para;</a></h2>
<p>ComplexWarning
When casting from complex to float or int. To avoid this,
one should use <code>a.real.astype(t)</code>.</p>
<h2 id="examples_153">Examples<a class="headerlink" href="#examples_153" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 2.5])
x
array([1. ,  2. ,  2.5])</p>
<p>x.astype(int)
array([1, 2, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">byteswap</span> <span class="o">:</span> <span class="o">?</span><span class="n">inplace</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.byteswap(inplace=False)</p>
<p>Swap the bytes of the array elements</p>
<p>Toggle between low-endian and big-endian data representation by
returning a byteswapped array, optionally swapped in-place.
Arrays of byte-strings are not swapped. The real and imaginary
parts of a complex number are swapped individually.</p>
<h2 id="parameters_297">Parameters<a class="headerlink" href="#parameters_297" title="Permanent link">&para;</a></h2>
<p>inplace : bool, optional
If <code>True</code>, swap bytes in-place, default is <code>False</code>.</p>
<h2 id="returns_240">Returns<a class="headerlink" href="#returns_240" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The byteswapped array. If <code>inplace</code> is <code>True</code>, this is
a view to self.</p>
<h2 id="examples_154">Examples<a class="headerlink" href="#examples_154" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>A = np.array([1, 256, 8755], dtype=np.int16)
list(map(hex, A))
['0x1', '0x100', '0x2233']
A.byteswap(inplace=True)
array([  256,     1, 13090], dtype=int16)
list(map(hex, A))
['0x100', '0x1', '0x3322']</p>
</blockquote>
</blockquote>
</blockquote>
<p>Arrays of byte-strings are not swapped</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = np.array([b'ceg', b'fac'])
A.byteswap()
array([b'ceg', b'fac'], dtype='|S3')</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>A.newbyteorder().byteswap()</code> produces an array with the same values
but different representation in memory</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = np.array([1, 2, 3])
A.view(np.uint8)
array([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
0, 0], dtype=uint8)
A.newbyteorder().byteswap(inplace=True)
array([1, 2, 3])
A.view(np.uint8)
array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
0, 3], dtype=uint8)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">choose</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">choices</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.choose(choices, out=None, mode='raise')</p>
<p>Use an index array to construct a new array from a set of choices.</p>
<p>Refer to <code>numpy.choose</code> for full documentation.</p>
<h2 id="see-also_107">See Also<a class="headerlink" href="#see-also_107" title="Permanent link">&para;</a></h2>
<p>numpy.choose : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">clip</span> <span class="o">:</span> <span class="o">?</span><span class="n">min</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.clip(min=None, max=None, out=None, **kwargs)</p>
<p>Return an array whose values are limited to <code>[min, max]</code>.
One of max or min must be given.</p>
<p>Refer to <code>numpy.clip</code> for full documentation.</p>
<h2 id="see-also_108">See Also<a class="headerlink" href="#see-also_108" title="Permanent link">&para;</a></h2>
<p>numpy.clip : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">compress</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">condition</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.compress(condition, axis=None, out=None)</p>
<p>Return selected slices of this array along given axis.</p>
<p>Refer to <code>numpy.compress</code> for full documentation.</p>
<h2 id="see-also_109">See Also<a class="headerlink" href="#see-also_109" title="Permanent link">&para;</a></h2>
<p>numpy.compress : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conj</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.conj()</p>
<p>Complex-conjugate all elements.</p>
<p>Refer to <code>numpy.conjugate</code> for full documentation.</p>
<h2 id="see-also_110">See Also<a class="headerlink" href="#see-also_110" title="Permanent link">&para;</a></h2>
<p>numpy.conjugate : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjugate</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.conjugate()</p>
<p>Return the complex conjugate, element-wise.</p>
<p>Refer to <code>numpy.conjugate</code> for full documentation.</p>
<h2 id="see-also_111">See Also<a class="headerlink" href="#see-also_111" title="Permanent link">&para;</a></h2>
<p>numpy.conjugate : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">copy</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.copy(order='C')</p>
<p>Return a copy of the array.</p>
<h2 id="parameters_298">Parameters<a class="headerlink" href="#parameters_298" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F', 'A', 'K'}, optional
Controls the memory layout of the copy. 'C' means C-order,
'F' means F-order, 'A' means 'F' if <code>a</code> is Fortran contiguous,
'C' otherwise. 'K' means match the layout of <code>a</code> as closely
as possible. (Note that this function and :func:<code>numpy.copy</code> are very
similar, but have different default values for their order=
arguments.)</p>
<h2 id="see-also_112">See also<a class="headerlink" href="#see-also_112" title="Permanent link">&para;</a></h2>
<p>numpy.copy
numpy.copyto</p>
<h2 id="examples_155">Examples<a class="headerlink" href="#examples_155" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([[1,2,3],[4,5,6]], order='F')</p>
<p>y = x.copy()</p>
<p>x.fill(0)</p>
<p>x
array([[0, 0, 0],
[0, 0, 0]])</p>
<p>y
array([[1, 2, 3],
[4, 5, 6]])</p>
<p>y.flags['C_CONTIGUOUS']
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cumprod</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.cumprod(axis=None, dtype=None, out=None)</p>
<p>Return the cumulative product of the elements along the given axis.</p>
<p>Refer to <code>numpy.cumprod</code> for full documentation.</p>
<h2 id="see-also_113">See Also<a class="headerlink" href="#see-also_113" title="Permanent link">&para;</a></h2>
<p>numpy.cumprod : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cumsum</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.cumsum(axis=None, dtype=None, out=None)</p>
<p>Return the cumulative sum of the elements along the given axis.</p>
<p>Refer to <code>numpy.cumsum</code> for full documentation.</p>
<h2 id="see-also_114">See Also<a class="headerlink" href="#see-also_114" title="Permanent link">&para;</a></h2>
<p>numpy.cumsum : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">offset</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.diagonal(offset=0, axis1=0, axis2=1)</p>
<p>Return specified diagonals. In NumPy 1.9 the returned array is a
read-only view instead of a copy as in previous NumPy versions.  In
a future version the read-only restriction will be removed.</p>
<p>Refer to :func:<code>numpy.diagonal</code> for full documentation.</p>
<h2 id="see-also_115">See Also<a class="headerlink" href="#see-also_115" title="Permanent link">&para;</a></h2>
<p>numpy.diagonal : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.dot(b, out=None)</p>
<p>Dot product of two arrays.</p>
<p>Refer to <code>numpy.dot</code> for full documentation.</p>
<h2 id="see-also_116">See Also<a class="headerlink" href="#see-also_116" title="Permanent link">&para;</a></h2>
<p>numpy.dot : equivalent function</p>
<h2 id="examples_156">Examples<a class="headerlink" href="#examples_156" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.eye(2)
b = np.ones((2, 2)) * 2
a.dot(b)
array([[2.,  2.],
[2.,  2.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>This array method can be conveniently chained:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a.dot(b).dot(b)
array([[8.,  8.],
[8.,  8.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dump</span> <span class="o">:</span> <span class="n">file</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Path</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.dump(file)</p>
<p>Dump a pickle of the array to the specified file.
The array can be read back with pickle.load or numpy.load.</p>
<h2 id="parameters_299">Parameters<a class="headerlink" href="#parameters_299" title="Permanent link">&para;</a></h2>
<p>file : str or Path
A string naming the dump file.</p>
<p>.. versionchanged:: 1.17.0
<code>pathlib.Path</code> objects are now accepted.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dumps</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.dumps()</p>
<p>Returns the pickle of the array as a string.
pickle.loads or numpy.loads will convert the string back to an array.</p>
<h2 id="parameters_300">Parameters<a class="headerlink" href="#parameters_300" title="Permanent link">&para;</a></h2>
<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fill</span> <span class="o">:</span> <span class="k">value</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.fill(value)</p>
<p>Fill the array with a scalar value.</p>
<h2 id="parameters_301">Parameters<a class="headerlink" href="#parameters_301" title="Permanent link">&para;</a></h2>
<p>value : scalar
All elements of <code>a</code> will be assigned this value.</p>
<h2 id="examples_157">Examples<a class="headerlink" href="#examples_157" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
a.fill(0)
a
array([0, 0])
a = np.empty(2)
a.fill(1)
a
array([1.,  1.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">flatten</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a flattened copy of the matrix.</p>
<p>All <code>N</code> elements of the matrix are placed into a single row.</p>
<h2 id="parameters_302">Parameters<a class="headerlink" href="#parameters_302" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F', 'A', 'K'}, optional
'C' means to flatten in row-major (C-style) order. 'F' means to
flatten in column-major (Fortran-style) order. 'A' means to
flatten in column-major order if <code>m</code> is Fortran <em>contiguous</em> in
memory, row-major order otherwise. 'K' means to flatten <code>m</code> in
the order the elements occur in memory. The default is 'C'.</p>
<h2 id="returns_241">Returns<a class="headerlink" href="#returns_241" title="Permanent link">&para;</a></h2>
<p>y : matrix
A copy of the matrix, flattened to a <code>(1, N)</code> matrix where <code>N</code>
is the number of elements in the original matrix.</p>
<h2 id="see-also_117">See Also<a class="headerlink" href="#see-also_117" title="Permanent link">&para;</a></h2>
<p>ravel : Return a flattened array.
flat : A 1-D flat iterator over the matrix.</p>
<h2 id="examples_158">Examples<a class="headerlink" href="#examples_158" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>m = np.matrix([[1,2], [3,4]])
m.flatten()
matrix([[1, 2, 3, 4]])
m.flatten('F')
matrix([[1, 3, 2, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getA</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return <code>self</code> as an <code>ndarray</code> object.</p>
<p>Equivalent to <code>np.asarray(self)</code>.</p>
<h2 id="parameters_303">Parameters<a class="headerlink" href="#parameters_303" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="returns_242">Returns<a class="headerlink" href="#returns_242" title="Permanent link">&para;</a></h2>
<p>ret : ndarray
<code>self</code> as an <code>ndarray</code></p>
<h2 id="examples_159">Examples<a class="headerlink" href="#examples_159" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.getA()
array([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getA1</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return <code>self</code> as a flattened <code>ndarray</code>.</p>
<p>Equivalent to <code>np.asarray(x).ravel()</code></p>
<h2 id="parameters_304">Parameters<a class="headerlink" href="#parameters_304" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="returns_243">Returns<a class="headerlink" href="#returns_243" title="Permanent link">&para;</a></h2>
<p>ret : ndarray
<code>self</code>, 1-D, as an <code>ndarray</code></p>
<h2 id="examples_160">Examples<a class="headerlink" href="#examples_160" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.getA1()
array([ 0,  1,  2, ...,  9, 10, 11])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getH</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the (complex) conjugate transpose of <code>self</code>.</p>
<p>Equivalent to <code>np.transpose(self)</code> if <code>self</code> is real-valued.</p>
<h2 id="parameters_305">Parameters<a class="headerlink" href="#parameters_305" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="returns_244">Returns<a class="headerlink" href="#returns_244" title="Permanent link">&para;</a></h2>
<p>ret : matrix object
complex conjugate transpose of <code>self</code></p>
<h2 id="examples_161">Examples<a class="headerlink" href="#examples_161" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4)))
z = x - 1j*x; z
matrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],
[  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],
[  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])
z.getH()
matrix([[ 0. -0.j,  4. +4.j,  8. +8.j],
[ 1. +1.j,  5. +5.j,  9. +9.j],
[ 2. +2.j,  6. +6.j, 10.+10.j],
[ 3. +3.j,  7. +7.j, 11.+11.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getI</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the (multiplicative) inverse of invertible <code>self</code>.</p>
<h2 id="parameters_306">Parameters<a class="headerlink" href="#parameters_306" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="returns_245">Returns<a class="headerlink" href="#returns_245" title="Permanent link">&para;</a></h2>
<p>ret : matrix object
If <code>self</code> is non-singular, <code>ret</code> is such that <code>ret * self</code> ==
<code>self * ret</code> == <code>np.matrix(np.eye(self[0,:].size)</code> all return
<code>True</code>.</p>
<h2 id="raises_19">Raises<a class="headerlink" href="#raises_19" title="Permanent link">&para;</a></h2>
<p>numpy.linalg.LinAlgError: Singular matrix
If <code>self</code> is singular.</p>
<h2 id="see-also_118">See Also<a class="headerlink" href="#see-also_118" title="Permanent link">&para;</a></h2>
<p>linalg.inv</p>
<h2 id="examples_162">Examples<a class="headerlink" href="#examples_162" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>m = np.matrix('[1, 2; 3, 4]'); m
matrix([[1, 2],
[3, 4]])
m.getI()
matrix([[-2. ,  1. ],
[ 1.5, -0.5]])
m.getI() * m
matrix([[ 1.,  0.], # may vary
[ 0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getT</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the transpose of the matrix.</p>
<p>Does <em>not</em> conjugate!  For the complex conjugate transpose, use <code>.H</code>.</p>
<h2 id="parameters_307">Parameters<a class="headerlink" href="#parameters_307" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="returns_246">Returns<a class="headerlink" href="#returns_246" title="Permanent link">&para;</a></h2>
<p>ret : matrix object
The (non-conjugated) transpose of the matrix.</p>
<h2 id="see-also_119">See Also<a class="headerlink" href="#see-also_119" title="Permanent link">&para;</a></h2>
<p>transpose, getH</p>
<h2 id="examples_163">Examples<a class="headerlink" href="#examples_163" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>m = np.matrix('[1, 2; 3, 4]')
m
matrix([[1, 2],
[3, 4]])
m.getT()
matrix([[1, 3],
[2, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getfield</span> <span class="o">:</span> <span class="o">?</span><span class="n">offset</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.getfield(dtype, offset=0)</p>
<p>Returns a field of the given array as a certain type.</p>
<p>A field is a view of the array data with a given data-type. The values in
the view are determined by the given type and the offset into the current
array in bytes. The offset needs to be such that the view dtype fits in the
array dtype; for example an array of dtype complex128 has 16-byte elements.
If taking a view with a 32-bit integer (4 bytes), the offset needs to be
between 0 and 12 bytes.</p>
<h2 id="parameters_308">Parameters<a class="headerlink" href="#parameters_308" title="Permanent link">&para;</a></h2>
<p>dtype : str or dtype
The data type of the view. The dtype size of the view can not be larger
than that of the array itself.
offset : int
Number of bytes to skip before beginning the element view.</p>
<h2 id="examples_164">Examples<a class="headerlink" href="#examples_164" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.diag([1.+1.j]*2)
x[1, 1] = 2 + 4.j
x
array([[1.+1.j,  0.+0.j],
[0.+0.j,  2.+4.j]])
x.getfield(np.float64)
array([[1.,  0.],
[0.,  2.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>By choosing an offset of 8 bytes we can select the complex part of the
array for our view:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x.getfield(np.float64, offset=8)
array([[1.,  0.],
[0.,  4.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">item</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.item( *args)</p>
<p>Copy an element of an array to a standard Python scalar and return it.</p>
<h2 id="parameters_309">Parameters<a class="headerlink" href="#parameters_309" title="Permanent link">&para;</a></h2>
<p>*args : Arguments (variable number and type)</p>
<ul>
<li>
<p>none: in this case, the method only works for arrays
with one element (<code>a.size == 1</code>), which element is
copied into a standard Python scalar object and returned.</p>
</li>
<li>
<p>int_type: this argument is interpreted as a flat index into
the array, specifying which element to copy and return.</p>
</li>
<li>
<p>tuple of int_types: functions as does a single int_type argument,
except that the argument is interpreted as an nd-index into the
array.</p>
</li>
</ul>
<h2 id="returns_247">Returns<a class="headerlink" href="#returns_247" title="Permanent link">&para;</a></h2>
<p>z : Standard Python scalar object
A copy of the specified element of the array as a suitable
Python scalar</p>
<h2 id="notes_115">Notes<a class="headerlink" href="#notes_115" title="Permanent link">&para;</a></h2>
<p>When the data type of <code>a</code> is longdouble or clongdouble, item() returns
a scalar array object because there is no available Python scalar that
would not lose information. Void arrays return a buffer object for item(),
unless fields are defined, in which case a tuple is returned.</p>
<p><code>item</code> is very similar to a[args], except, instead of an array scalar,
a standard Python scalar is returned. This can be useful for speeding up
access to elements of the array and doing arithmetic on elements of the
array using Python's optimized math.</p>
<h2 id="examples_165">Examples<a class="headerlink" href="#examples_165" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.random.seed(123)
x = np.random.randint(9, size=(3, 3))
x
array([[2, 2, 6],
[1, 3, 6],
[1, 0, 1]])
x.item(3)
1
x.item(7)
0
x.item((0, 1))
2
x.item((2, 2))
1</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itemset</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.itemset( *args)</p>
<p>Insert scalar into an array (scalar is cast to array's dtype, if possible)</p>
<p>There must be at least 1 argument, and define the last argument
as <em>item</em>.  Then, <code>a.itemset( *args)</code> is equivalent to but faster
than <code>a[args] = item</code>.  The item should be a scalar value and <code>args</code>
must select a single item in the array <code>a</code>.</p>
<h2 id="parameters_310">Parameters<a class="headerlink" href="#parameters_310" title="Permanent link">&para;</a></h2>
<p>*args : Arguments
If one argument: a scalar, only used in case <code>a</code> is of size 1.
If two arguments: the last argument is the value to be set
and must be a scalar, the first argument specifies a single array
element location. It is either an int or a tuple.</p>
<h2 id="notes_116">Notes<a class="headerlink" href="#notes_116" title="Permanent link">&para;</a></h2>
<p>Compared to indexing syntax, <code>itemset</code> provides some speed increase
for placing a scalar into a particular location in an <code>ndarray</code>,
if you must do this.  However, generally this is discouraged:
among other problems, it complicates the appearance of the code.
Also, when using <code>itemset</code> (and <code>item</code>) inside a loop, be sure
to assign the methods to a local variable to avoid the attribute
look-up at each loop iteration.</p>
<h2 id="examples_166">Examples<a class="headerlink" href="#examples_166" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.random.seed(123)
x = np.random.randint(9, size=(3, 3))
x
array([[2, 2, 6],
[1, 3, 6],
[1, 0, 1]])
x.itemset(4, 0)
x.itemset((2, 2), 9)
x
array([[2, 2, 6],
[1, 0, 6],
[1, 0, 9]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">max</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the maximum value along an axis.</p>
<h2 id="parameters_311">Parameters<a class="headerlink" href="#parameters_311" title="Permanent link">&para;</a></h2>
<p>See <code>amax</code> for complete descriptions</p>
<h2 id="see-also_120">See Also<a class="headerlink" href="#see-also_120" title="Permanent link">&para;</a></h2>
<p>amax, ndarray.max</p>
<h2 id="notes_117">Notes<a class="headerlink" href="#notes_117" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.max</code>, but returns a <code>matrix</code> object
where <code>ndarray.max</code> would return an ndarray.</p>
<h2 id="examples_167">Examples<a class="headerlink" href="#examples_167" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.max()
11
x.max(0)
matrix([[ 8,  9, 10, 11]])
x.max(1)
matrix([[ 3],
[ 7],
[11]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the average of the matrix elements along the given axis.</p>
<p>Refer to <code>numpy.mean</code> for full documentation.</p>
<h2 id="see-also_121">See Also<a class="headerlink" href="#see-also_121" title="Permanent link">&para;</a></h2>
<p>numpy.mean</p>
<h2 id="notes_118">Notes<a class="headerlink" href="#notes_118" title="Permanent link">&para;</a></h2>
<p>Same as <code>ndarray.mean</code> except that, where that returns an <code>ndarray</code>,
this returns a <code>matrix</code> object.</p>
<h2 id="examples_168">Examples<a class="headerlink" href="#examples_168" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3, 4)))
x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.mean()
5.5
x.mean(0)
matrix([[4., 5., 6., 7.]])
x.mean(1)
matrix([[ 1.5],
[ 5.5],
[ 9.5]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">min</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the minimum value along an axis.</p>
<h2 id="parameters_312">Parameters<a class="headerlink" href="#parameters_312" title="Permanent link">&para;</a></h2>
<p>See <code>amin</code> for complete descriptions.</p>
<h2 id="see-also_122">See Also<a class="headerlink" href="#see-also_122" title="Permanent link">&para;</a></h2>
<p>amin, ndarray.min</p>
<h2 id="notes_119">Notes<a class="headerlink" href="#notes_119" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.min</code>, but returns a <code>matrix</code> object
where <code>ndarray.min</code> would return an ndarray.</p>
<h2 id="examples_169">Examples<a class="headerlink" href="#examples_169" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = -np.matrix(np.arange(12).reshape((3,4))); x
matrix([[  0,  -1,  -2,  -3],
[ -4,  -5,  -6,  -7],
[ -8,  -9, -10, -11]])
x.min()
-11
x.min(0)
matrix([[ -8,  -9, -10, -11]])
x.min(1)
matrix([[ -3],
[ -7],
[-11]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">newbyteorder</span> <span class="o">:</span> <span class="o">?</span><span class="n">new_order</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>arr.newbyteorder(new_order='S')</p>
<p>Return the array with the same data viewed with a different byte order.</p>
<p>Equivalent to::</p>
<p>arr.view(arr.dtype.newbytorder(new_order))</p>
<p>Changes are also made in all fields and sub-arrays of the array data
type.</p>
<h2 id="parameters_313">Parameters<a class="headerlink" href="#parameters_313" title="Permanent link">&para;</a></h2>
<p>new_order : string, optional
Byte order to force; a value from the byte order specifications
below. <code>new_order</code> codes can be any of:</p>
<ul>
<li>'S' - swap dtype from current to opposite endian</li>
<li>{'&lt;', 'L'} - little endian</li>
<li>{'&gt;', 'B'} - big endian</li>
<li>{'=', 'N'} - native order</li>
<li>{'|', 'I'} - ignore (no change to byte order)</li>
</ul>
<p>The default value ('S') results in swapping the current
byte order. The code does a case-insensitive check on the first
letter of <code>new_order</code> for the alternatives above.  For example,
any of 'B' or 'b' or 'biggish' are valid to specify big-endian.</p>
<h2 id="returns_248">Returns<a class="headerlink" href="#returns_248" title="Permanent link">&para;</a></h2>
<p>new_arr : array
New array object with the dtype reflecting given change to the
byte order.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.nonzero()</p>
<p>Return the indices of the elements that are non-zero.</p>
<p>Refer to <code>numpy.nonzero</code> for full documentation.</p>
<h2 id="see-also_123">See Also<a class="headerlink" href="#see-also_123" title="Permanent link">&para;</a></h2>
<p>numpy.nonzero : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">partition</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kind</span><span class="o">:[`</span><span class="nc">Introselect</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">StringList</span> <span class="k">of</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">kth</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.partition(kth, axis=-1, kind='introselect', order=None)</p>
<p>Rearranges the elements in the array in such a way that the value of the
element in kth position is in the position it would be in a sorted array.
All elements smaller than the kth element are moved before this element and
all equal or greater are moved behind it. The ordering of the elements in
the two partitions is undefined.</p>
<p>.. versionadded:: 1.8.0</p>
<h2 id="parameters_314">Parameters<a class="headerlink" href="#parameters_314" title="Permanent link">&para;</a></h2>
<p>kth : int or sequence of ints
Element index to partition by. The kth element value will be in its
final sorted position and all smaller elements will be moved before it
and all equal or greater elements behind it.
The order of all elements in the partitions is undefined.
If provided with a sequence of kth it will partition all elements
indexed by kth of them into their sorted position at once.
axis : int, optional
Axis along which to sort. Default is -1, which means sort along the
last axis.
kind : {'introselect'}, optional
Selection algorithm. Default is 'introselect'.
order : str or list of str, optional
When <code>a</code> is an array with fields defined, this argument specifies
which fields to compare first, second, etc. A single field can
be specified as a string, and not all fields need to be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</p>
<h2 id="see-also_124">See Also<a class="headerlink" href="#see-also_124" title="Permanent link">&para;</a></h2>
<p>numpy.partition : Return a parititioned copy of an array.
argpartition : Indirect partition.
sort : Full sort.</p>
<h2 id="notes_120">Notes<a class="headerlink" href="#notes_120" title="Permanent link">&para;</a></h2>
<p>See <code>np.partition</code> for notes on the different algorithms.</p>
<h2 id="examples_170">Examples<a class="headerlink" href="#examples_170" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([3, 4, 2, 1])
a.partition(3)
a
array([2, 1, 3, 4])</p>
<p>a.partition((1, 3))
a
array([1, 2, 3, 4])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">prod</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the product of the array elements over the given axis.</p>
<p>Refer to <code>prod</code> for full documentation.</p>
<h2 id="see-also_125">See Also<a class="headerlink" href="#see-also_125" title="Permanent link">&para;</a></h2>
<p>prod, ndarray.prod</p>
<h2 id="notes_121">Notes<a class="headerlink" href="#notes_121" title="Permanent link">&para;</a></h2>
<p>Same as <code>ndarray.prod</code>, except, where that returns an <code>ndarray</code>, this
returns a <code>matrix</code> object instead.</p>
<h2 id="examples_171">Examples<a class="headerlink" href="#examples_171" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.prod()
0
x.prod(0)
matrix([[  0,  45, 120, 231]])
x.prod(1)
matrix([[   0],
[ 840],
[7920]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ptp</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Peak-to-peak (maximum - minimum) value along the given axis.</p>
<p>Refer to <code>numpy.ptp</code> for full documentation.</p>
<h2 id="see-also_126">See Also<a class="headerlink" href="#see-also_126" title="Permanent link">&para;</a></h2>
<p>numpy.ptp</p>
<h2 id="notes_122">Notes<a class="headerlink" href="#notes_122" title="Permanent link">&para;</a></h2>
<p>Same as <code>ndarray.ptp</code>, except, where that would return an <code>ndarray</code> object,
this returns a <code>matrix</code> object.</p>
<h2 id="examples_172">Examples<a class="headerlink" href="#examples_172" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.ptp()
11
x.ptp(0)
matrix([[8, 8, 8, 8]])
x.ptp(1)
matrix([[3],
[3],
[3]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">put</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">indices</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">values</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.put(indices, values, mode='raise')</p>
<p>Set <code>a.flat[n] = values[n]</code> for all <code>n</code> in indices.</p>
<p>Refer to <code>numpy.put</code> for full documentation.</p>
<h2 id="see-also_127">See Also<a class="headerlink" href="#see-also_127" title="Permanent link">&para;</a></h2>
<p>numpy.put : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ravel</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a flattened matrix.</p>
<p>Refer to <code>numpy.ravel</code> for more documentation.</p>
<h2 id="parameters_315">Parameters<a class="headerlink" href="#parameters_315" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F', 'A', 'K'}, optional
The elements of <code>m</code> are read using this index order. 'C' means to
index the elements in C-like order, with the last axis index
changing fastest, back to the first axis index changing slowest.
'F' means to index the elements in Fortran-like index order, with
the first index changing fastest, and the last index changing
slowest. Note that the 'C' and 'F' options take no account of the
memory layout of the underlying array, and only refer to the order
of axis indexing.  'A' means to read the elements in Fortran-like
index order if <code>m</code> is Fortran <em>contiguous</em> in memory, C-like order
otherwise.  'K' means to read the elements in the order they occur
in memory, except for reversing the data when strides are negative.
By default, 'C' index order is used.</p>
<h2 id="returns_249">Returns<a class="headerlink" href="#returns_249" title="Permanent link">&para;</a></h2>
<p>ret : matrix
Return the matrix flattened to shape <code>(1, N)</code> where <code>N</code>
is the number of elements in the original matrix.
A copy is made only if necessary.</p>
<h2 id="see-also_128">See Also<a class="headerlink" href="#see-also_128" title="Permanent link">&para;</a></h2>
<p>matrix.flatten : returns a similar output matrix but always a copy
matrix.flat : a flat iterator on the array.
numpy.ravel : related function which returns an ndarray</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">repeat</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">repeats</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.repeat(repeats, axis=None)</p>
<p>Repeat elements of an array.</p>
<p>Refer to <code>numpy.repeat</code> for full documentation.</p>
<h2 id="see-also_129">See Also<a class="headerlink" href="#see-also_129" title="Permanent link">&para;</a></h2>
<p>numpy.repeat : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.reshape(shape, order='C')</p>
<p>Returns an array containing the same data with a new shape.</p>
<p>Refer to <code>numpy.reshape</code> for full documentation.</p>
<h2 id="see-also_130">See Also<a class="headerlink" href="#see-also_130" title="Permanent link">&para;</a></h2>
<p>numpy.reshape : equivalent function</p>
<h2 id="notes_123">Notes<a class="headerlink" href="#notes_123" title="Permanent link">&para;</a></h2>
<p>Unlike the free function <code>numpy.reshape</code>, this method on <code>ndarray</code> allows
the elements of the shape parameter to be passed in as separate arguments.
For example, <code>a.reshape(10, 11)</code> is equivalent to
<code>a.reshape((10, 11))</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resize</span> <span class="o">:</span> <span class="o">?</span><span class="n">refcheck</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">new_shape</span><span class="o">:[`</span><span class="nc">TupleOfInts</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_n_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.resize(new_shape, refcheck=True)</p>
<p>Change shape and size of array in-place.</p>
<h2 id="parameters_316">Parameters<a class="headerlink" href="#parameters_316" title="Permanent link">&para;</a></h2>
<p>new_shape : tuple of ints, or <code>n</code> ints
Shape of resized array.
refcheck : bool, optional
If False, reference count will not be checked. Default is True.</p>
<h2 id="returns_250">Returns<a class="headerlink" href="#returns_250" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="raises_20">Raises<a class="headerlink" href="#raises_20" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>a</code> does not own its own data or references or views to it exist,
and the data memory must be changed.
PyPy only: will always raise if the data memory must be changed, since
there is no reliable way to determine if references or views to it
exist.</p>
<p>SystemError
If the <code>order</code> keyword argument is specified. This behaviour is a
bug in NumPy.</p>
<h2 id="see-also_131">See Also<a class="headerlink" href="#see-also_131" title="Permanent link">&para;</a></h2>
<p>resize : Return a new array with the specified shape.</p>
<h2 id="notes_124">Notes<a class="headerlink" href="#notes_124" title="Permanent link">&para;</a></h2>
<p>This reallocates space for the data area if necessary.</p>
<p>Only contiguous arrays (data elements consecutive in memory) can be
resized.</p>
<p>The purpose of the reference count check is to make sure you
do not use this array as a buffer for another Python object and then
reallocate the memory. However, reference counts can increase in
other ways so if you are sure that you have not shared the memory
for this array with another Python object, then you may safely set
<code>refcheck</code> to False.</p>
<h2 id="examples_173">Examples<a class="headerlink" href="#examples_173" title="Permanent link">&para;</a></h2>
<p>Shrinking an array: array is flattened (in the order that the data are
stored in memory), resized, and reshaped:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[0, 1], [2, 3]], order='C')
a.resize((2, 1))
a
array([[0],
[1]])</p>
<p>a = np.array([[0, 1], [2, 3]], order='F')
a.resize((2, 1))
a
array([[0],
[2]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Enlarging an array: as above, but missing entries are filled with zeros:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([[0, 1], [2, 3]])
b.resize(2, 3) # new_shape parameter doesn't have to be a tuple
b
array([[0, 1, 2],
[3, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Referencing an array prevents resizing...</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = a
a.resize((1, 1))
Traceback (most recent call last):
...
ValueError: cannot resize an array that references or is referenced ...</p>
</blockquote>
</blockquote>
</blockquote>
<p>Unless <code>refcheck</code> is False:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a.resize((1, 1), refcheck=False)
a
array([[0]])
c
array([[0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">round</span> <span class="o">:</span> <span class="o">?</span><span class="n">decimals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.round(decimals=0, out=None)</p>
<p>Return <code>a</code> with each element rounded to the given number of decimals.</p>
<p>Refer to <code>numpy.around</code> for full documentation.</p>
<h2 id="see-also_132">See Also<a class="headerlink" href="#see-also_132" title="Permanent link">&para;</a></h2>
<p>numpy.around : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">searchsorted</span> <span class="o">:</span> <span class="o">?</span><span class="n">side</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sorter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.searchsorted(v, side='left', sorter=None)</p>
<p>Find indices where elements of v should be inserted in a to maintain order.</p>
<p>For full documentation, see <code>numpy.searchsorted</code></p>
<h2 id="see-also_133">See Also<a class="headerlink" href="#see-also_133" title="Permanent link">&para;</a></h2>
<p>numpy.searchsorted : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setfield</span> <span class="o">:</span> <span class="o">?</span><span class="n">offset</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">val_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.setfield(val, dtype, offset=0)</p>
<p>Put a value into a specified place in a field defined by a data-type.</p>
<p>Place <code>val</code> into <code>a</code>'s field defined by <code>dtype</code> and beginning <code>offset</code>
bytes into the field.</p>
<h2 id="parameters_317">Parameters<a class="headerlink" href="#parameters_317" title="Permanent link">&para;</a></h2>
<p>val : object
Value to be placed in field.
dtype : dtype object
Data-type of the field in which to place <code>val</code>.
offset : int, optional
The number of bytes into the field at which to place <code>val</code>.</p>
<h2 id="returns_251">Returns<a class="headerlink" href="#returns_251" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="see-also_134">See Also<a class="headerlink" href="#see-also_134" title="Permanent link">&para;</a></h2>
<p>getfield</p>
<h2 id="examples_174">Examples<a class="headerlink" href="#examples_174" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.eye(3)
x.getfield(np.float64)
array([[1.,  0.,  0.],
[0.,  1.,  0.],
[0.,  0.,  1.]])
x.setfield(3, np.int32)
x.getfield(np.int32)
array([[3, 3, 3],
[3, 3, 3],
[3, 3, 3]], dtype=int32)
x
array([[1.0e+000, 1.5e-323, 1.5e-323],
[1.5e-323, 1.0e+000, 1.5e-323],
[1.5e-323, 1.5e-323, 1.0e+000]])
x.setfield(np.eye(3), np.int32)
x
array([[1.,  0.,  0.],
[0.,  1.,  0.],
[0.,  0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setflags</span> <span class="o">:</span> <span class="o">?</span><span class="n">write</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">align</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">uic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.setflags(write=None, align=None, uic=None)</p>
<p>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
respectively.</p>
<p>These Boolean-valued flags affect how numpy interprets the memory
area used by <code>a</code> (see Notes below). The ALIGNED flag can only
be set to True if the data is actually aligned according to the type.
The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
to True. The flag WRITEABLE can only be set to True if the array owns its
own memory, or the ultimate owner of the memory exposes a writeable buffer
interface, or is a string. (The exception for string is made so that
unpickling can be done without copying memory.)</p>
<h2 id="parameters_318">Parameters<a class="headerlink" href="#parameters_318" title="Permanent link">&para;</a></h2>
<p>write : bool, optional
Describes whether or not <code>a</code> can be written to.
align : bool, optional
Describes whether or not <code>a</code> is aligned properly for its type.
uic : bool, optional
Describes whether or not <code>a</code> is a copy of another 'base' array.</p>
<h2 id="notes_125">Notes<a class="headerlink" href="#notes_125" title="Permanent link">&para;</a></h2>
<p>Array flags provide information about how the memory area used
for the array is to be interpreted. There are 7 Boolean flags
in use, only four of which can be changed by the user:
WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.</p>
<p>WRITEABLE (W) the data area can be written to;</p>
<p>ALIGNED (A) the data and strides are aligned appropriately for the hardware
(as determined by the compiler);</p>
<p>UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;</p>
<p>WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
called, the base array will be updated with the contents of this array.</p>
<p>All flags can be accessed using the single (upper case) letter as well
as the full name.</p>
<h2 id="examples_175">Examples<a class="headerlink" href="#examples_175" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>y = np.array([[3, 1, 7],
...               [2, 0, 0],
...               [8, 5, 9]])
y
array([[3, 1, 7],
[2, 0, 0],
[8, 5, 9]])
y.flags
C_CONTIGUOUS : True
F_CONTIGUOUS : False
OWNDATA : True
WRITEABLE : True
ALIGNED : True
WRITEBACKIFCOPY : False
UPDATEIFCOPY : False
y.setflags(write=0, align=0)
y.flags
C_CONTIGUOUS : True
F_CONTIGUOUS : False
OWNDATA : True
WRITEABLE : False
ALIGNED : False
WRITEBACKIFCOPY : False
UPDATEIFCOPY : False
y.setflags(uic=1)
Traceback (most recent call last):
File '<stdin>', line 1, in <module>
ValueError: cannot set WRITEBACKIFCOPY flag to True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sort</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kind</span><span class="o">:[`</span><span class="nc">Stable</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Quicksort</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Heapsort</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mergesort</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">StringList</span> <span class="k">of</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.sort(axis=-1, kind=None, order=None)</p>
<p>Sort an array in-place. Refer to <code>numpy.sort</code> for full documentation.</p>
<h2 id="parameters_319">Parameters<a class="headerlink" href="#parameters_319" title="Permanent link">&para;</a></h2>
<p>axis : int, optional
Axis along which to sort. Default is -1, which means sort along the
last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
and 'mergesort' use timsort under the covers and, in general, the
actual implementation will vary with datatype. The 'mergesort' option
is retained for backwards compatibility.</p>
<p>.. versionchanged:: 1.15.0.
The 'stable' option was added.</p>
<p>order : str or list of str, optional
When <code>a</code> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</p>
<h2 id="see-also_135">See Also<a class="headerlink" href="#see-also_135" title="Permanent link">&para;</a></h2>
<p>numpy.sort : Return a sorted copy of an array.
numpy.argsort : Indirect sort.
numpy.lexsort : Indirect stable sort on multiple keys.
numpy.searchsorted : Find elements in sorted array.
numpy.partition: Partial sort.</p>
<h2 id="notes_126">Notes<a class="headerlink" href="#notes_126" title="Permanent link">&para;</a></h2>
<p>See <code>numpy.sort</code> for notes on the different sorting algorithms.</p>
<h2 id="examples_176">Examples<a class="headerlink" href="#examples_176" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1,4], [3,1]])
a.sort(axis=1)
a
array([[1, 4],
[1, 3]])
a.sort(axis=0)
a
array([[1, 3],
[1, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Use the <code>order</code> keyword to specify a field to use when sorting a
structured array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])
a.sort(order='y')
a
array([(b'c', 1), (b'a', 2)],
dtype=[('x', 'S1'), ('y', '&lt;i8')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">squeeze</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a possibly reshaped matrix.</p>
<p>Refer to <code>numpy.squeeze</code> for more documentation.</p>
<h2 id="parameters_320">Parameters<a class="headerlink" href="#parameters_320" title="Permanent link">&para;</a></h2>
<p>axis : None or int or tuple of ints, optional
Selects a subset of the single-dimensional entries in the shape.
If an axis is selected with shape entry greater than one,
an error is raised.</p>
<h2 id="returns_252">Returns<a class="headerlink" href="#returns_252" title="Permanent link">&para;</a></h2>
<p>squeezed : matrix
The matrix, but as a (1, N) matrix if it had shape (N, 1).</p>
<h2 id="see-also_136">See Also<a class="headerlink" href="#see-also_136" title="Permanent link">&para;</a></h2>
<p>numpy.squeeze : related function</p>
<h2 id="notes_127">Notes<a class="headerlink" href="#notes_127" title="Permanent link">&para;</a></h2>
<p>If <code>m</code> has a single column then that column is returned
as the single row of a matrix.  Otherwise <code>m</code> is returned.
The returned matrix is always either <code>m</code> itself or a view into <code>m</code>.
Supplying an axis keyword argument will not affect the returned matrix
but it may cause an error to be raised.</p>
<h2 id="examples_177">Examples<a class="headerlink" href="#examples_177" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>c = np.matrix([[1], [2]])
c
matrix([[1],
[2]])
c.squeeze()
matrix([[1, 2]])
r = c.T
r
matrix([[1, 2]])
r.squeeze()
matrix([[1, 2]])
m = np.matrix([[1, 2], [3, 4]])
m.squeeze()
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">std</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ddof</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the standard deviation of the array elements along the given axis.</p>
<p>Refer to <code>numpy.std</code> for full documentation.</p>
<h2 id="see-also_137">See Also<a class="headerlink" href="#see-also_137" title="Permanent link">&para;</a></h2>
<p>numpy.std</p>
<h2 id="notes_128">Notes<a class="headerlink" href="#notes_128" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.std</code>, except that where an <code>ndarray</code> would
be returned, a <code>matrix</code> object is returned instead.</p>
<h2 id="examples_178">Examples<a class="headerlink" href="#examples_178" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3, 4)))
x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.std()
3.4520525295346629 # may vary
x.std(0)
matrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]]) # may vary
x.std(1)
matrix([[ 1.11803399],
[ 1.11803399],
[ 1.11803399]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the sum of the matrix elements, along the given axis.</p>
<p>Refer to <code>numpy.sum</code> for full documentation.</p>
<h2 id="see-also_138">See Also<a class="headerlink" href="#see-also_138" title="Permanent link">&para;</a></h2>
<p>numpy.sum</p>
<h2 id="notes_129">Notes<a class="headerlink" href="#notes_129" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.sum</code>, except that where an <code>ndarray</code> would
be returned, a <code>matrix</code> object is returned instead.</p>
<h2 id="examples_179">Examples<a class="headerlink" href="#examples_179" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix([[1, 2], [4, 3]])
x.sum()
10
x.sum(axis=1)
matrix([[3],
[7]])
x.sum(axis=1, dtype='float')
matrix([[3.],
[7.]])
out = np.zeros((2, 1), dtype='float')
x.sum(axis=1, dtype='float', out=np.asmatrix(out))
matrix([[3.],
[7.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">swapaxes</span> <span class="o">:</span> <span class="n">axis1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">axis2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.swapaxes(axis1, axis2)</p>
<p>Return a view of the array with <code>axis1</code> and <code>axis2</code> interchanged.</p>
<p>Refer to <code>numpy.swapaxes</code> for full documentation.</p>
<h2 id="see-also_139">See Also<a class="headerlink" href="#see-also_139" title="Permanent link">&para;</a></h2>
<p>numpy.swapaxes : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">take</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">indices</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.take(indices, axis=None, out=None, mode='raise')</p>
<p>Return an array formed from the elements of <code>a</code> at the given indices.</p>
<p>Refer to <code>numpy.take</code> for full documentation.</p>
<h2 id="see-also_140">See Also<a class="headerlink" href="#see-also_140" title="Permanent link">&para;</a></h2>
<p>numpy.take : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tobytes</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.tobytes(order='C')</p>
<p>Construct Python bytes containing the raw data bytes in the array.</p>
<p>Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either 'C' or 'Fortran',
or 'Any' order (the default is 'C'-order). 'Any' order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means 'Fortran' order.</p>
<p>.. versionadded:: 1.9.0</p>
<h2 id="parameters_321">Parameters<a class="headerlink" href="#parameters_321" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F', None}, optional
Order of the data for multidimensional arrays:
C, Fortran, or the same as for the original array.</p>
<h2 id="returns_253">Returns<a class="headerlink" href="#returns_253" title="Permanent link">&para;</a></h2>
<p>s : bytes
Python bytes exhibiting a copy of <code>a</code>'s raw data.</p>
<h2 id="examples_180">Examples<a class="headerlink" href="#examples_180" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')
x.tobytes()
b'\x00\x00\x01\x00\x02\x00\x03\x00'
x.tobytes('C') == x.tobytes()
True
x.tobytes('F')
b'\x00\x00\x02\x00\x01\x00\x03\x00'</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tofile</span> <span class="o">:</span> <span class="o">?</span><span class="n">sep</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">fid</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.tofile(fid, sep='', format='%s')</p>
<p>Write array to a file as text or binary (default).</p>
<p>Data is always written in 'C' order, independent of the order of <code>a</code>.
The data produced by this method can be recovered using the function
fromfile().</p>
<h2 id="parameters_322">Parameters<a class="headerlink" href="#parameters_322" title="Permanent link">&para;</a></h2>
<p>fid : file or str or Path
An open file object, or a string containing a filename.</p>
<p>.. versionchanged:: 1.17.0
<code>pathlib.Path</code> objects are now accepted.</p>
<p>sep : str
Separator between array items for text output.
If '' (empty), a binary file is written, equivalent to
<code>file.write(a.tobytes())</code>.
format : str
Format string for text file output.
Each entry in the array is formatted to text by first converting
it to the closest Python type, and then using 'format' % item.</p>
<h2 id="notes_130">Notes<a class="headerlink" href="#notes_130" title="Permanent link">&para;</a></h2>
<p>This is a convenience function for quick storage of array data.
Information on endianness and precision is lost, so this method is not a
good choice for files intended to archive data or transport data between
machines with different endianness. Some of these problems can be overcome
by outputting the data as text files, at the expense of speed and file
size.</p>
<p>When fid is a file object, array contents are directly written to the
file, bypassing the file object's <code>write</code> method. As a result, tofile
cannot be used with files objects supporting compression (e.g., GzipFile)
or file-like objects that do not support <code>fileno()</code> (e.g., BytesIO).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tolist</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the matrix as a (possibly nested) list.</p>
<p>See <code>ndarray.tolist</code> for full documentation.</p>
<h2 id="see-also_141">See Also<a class="headerlink" href="#see-also_141" title="Permanent link">&para;</a></h2>
<p>ndarray.tolist</p>
<h2 id="examples_181">Examples<a class="headerlink" href="#examples_181" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.tolist()
[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tostring</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.tostring(order='C')</p>
<p>Construct Python bytes containing the raw data bytes in the array.</p>
<p>Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either 'C' or 'Fortran',
or 'Any' order (the default is 'C'-order). 'Any' order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means 'Fortran' order.</p>
<p>This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.</p>
<h2 id="parameters_323">Parameters<a class="headerlink" href="#parameters_323" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F', None}, optional
Order of the data for multidimensional arrays:
C, Fortran, or the same as for the original array.</p>
<h2 id="returns_254">Returns<a class="headerlink" href="#returns_254" title="Permanent link">&para;</a></h2>
<p>s : bytes
Python bytes exhibiting a copy of <code>a</code>'s raw data.</p>
<h2 id="examples_182">Examples<a class="headerlink" href="#examples_182" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')
x.tobytes()
b'\x00\x00\x01\x00\x02\x00\x03\x00'
x.tobytes('C') == x.tobytes()
True
x.tobytes('F')
b'\x00\x00\x02\x00\x01\x00\x03\x00'</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">trace</span> <span class="o">:</span> <span class="o">?</span><span class="n">offset</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</p>
<p>Return the sum along diagonals of the array.</p>
<p>Refer to <code>numpy.trace</code> for full documentation.</p>
<h2 id="see-also_142">See Also<a class="headerlink" href="#see-also_142" title="Permanent link">&para;</a></h2>
<p>numpy.trace : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.transpose( *axes)</p>
<p>Returns a view of the array with axes transposed.</p>
<p>For a 1-D array this has no effect, as a transposed vector is simply the
same vector. To convert a 1-D array into a 2D column vector, an additional
dimension must be added. <code>np.atleast2d(a).T</code> achieves this, as does
<code>a[:, np.newaxis]</code>.
For a 2-D array, this is a standard matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
<code>a.shape = (i[0], i[1], ... i[n-2], i[n-1])</code>, then
<code>a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])</code>.</p>
<h2 id="parameters_324">Parameters<a class="headerlink" href="#parameters_324" title="Permanent link">&para;</a></h2>
<p>axes : None, tuple of ints, or <code>n</code> ints</p>
<ul>
<li>
<p>None or no argument: reverses the order of the axes.</p>
</li>
<li>
<p>tuple of ints: <code>i</code> in the <code>j</code>-th place in the tuple means <code>a</code>'s
<code>i</code>-th axis becomes <code>a.transpose()</code>'s <code>j</code>-th axis.</p>
</li>
<li>
<p><code>n</code> ints: same as an n-tuple of the same ints (this form is
intended simply as a 'convenience' alternative to the tuple form)</p>
</li>
</ul>
<h2 id="returns_255">Returns<a class="headerlink" href="#returns_255" title="Permanent link">&para;</a></h2>
<p>out : ndarray
View of <code>a</code>, with axes suitably permuted.</p>
<h2 id="see-also_143">See Also<a class="headerlink" href="#see-also_143" title="Permanent link">&para;</a></h2>
<p>ndarray.T : Array property returning the array transposed.
ndarray.reshape : Give a new shape to an array without changing its data.</p>
<h2 id="examples_183">Examples<a class="headerlink" href="#examples_183" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2], [3, 4]])
a
array([[1, 2],
[3, 4]])
a.transpose()
array([[1, 3],
[2, 4]])
a.transpose((1, 0))
array([[1, 3],
[2, 4]])
a.transpose(1, 0)
array([[1, 3],
[2, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">var</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ddof</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the variance of the matrix elements, along the given axis.</p>
<p>Refer to <code>numpy.var</code> for full documentation.</p>
<h2 id="see-also_144">See Also<a class="headerlink" href="#see-also_144" title="Permanent link">&para;</a></h2>
<p>numpy.var</p>
<h2 id="notes_131">Notes<a class="headerlink" href="#notes_131" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.var</code>, except that where an <code>ndarray</code> would
be returned, a <code>matrix</code> object is returned instead.</p>
<h2 id="examples_184">Examples<a class="headerlink" href="#examples_184" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3, 4)))
x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.var()
11.916666666666666
x.var(0)
matrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]]) # may vary
x.var(1)
matrix([[1.25],
[1.25],
[1.25]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">view</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">Ndarray_sub_class</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">type_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.view(dtype=None, type=None)</p>
<p>New view of array with the same data.</p>
<h2 id="parameters_325">Parameters<a class="headerlink" href="#parameters_325" title="Permanent link">&para;</a></h2>
<p>dtype : data-type or ndarray sub-class, optional
Data-type descriptor of the returned view, e.g., float32 or int16. The
default, None, results in the view having the same data-type as <code>a</code>.
This argument can also be specified as an ndarray sub-class, which
then specifies the type of the returned object (this is equivalent to
setting the <code>type</code> parameter).
type : Python type, optional
Type of the returned view, e.g., ndarray or matrix.  Again, the
default None results in type preservation.</p>
<h2 id="notes_132">Notes<a class="headerlink" href="#notes_132" title="Permanent link">&para;</a></h2>
<p><code>a.view()</code> is used two different ways:</p>
<p><code>a.view(some_dtype)</code> or <code>a.view(dtype=some_dtype)</code> constructs a view
of the array's memory with a different data-type.  This can cause a
reinterpretation of the bytes of memory.</p>
<p><code>a.view(ndarray_subclass)</code> or <code>a.view(type=ndarray_subclass)</code> just
returns an instance of <code>ndarray_subclass</code> that looks at the same array
(same shape, dtype, etc.)  This does not cause a reinterpretation of the
memory.</p>
<p>For <code>a.view(some_dtype)</code>, if <code>some_dtype</code> has a different number of
bytes per entry than the previous dtype (for example, converting a
regular array to a structured array), then the behavior of the view
cannot be predicted just from the superficial appearance of <code>a</code> (shown
by <code>print(a)</code>). It also depends on exactly how <code>a</code> is stored in
memory. Therefore if <code>a</code> is C-ordered versus fortran-ordered, versus
defined as a slice or transpose, etc., the view may give different
results.</p>
<h2 id="examples_185">Examples<a class="headerlink" href="#examples_185" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Viewing array data using a different type and dtype:</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = x.view(dtype=np.int16, type=np.matrix)
y
matrix([[513]], dtype=int16)
print(type(y))
<class 'numpy.matrix'></p>
</blockquote>
</blockquote>
</blockquote>
<p>Creating a view on a structured array so it can be used in calculations</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])
xv = x.view(dtype=np.int8).reshape(-1,2)
xv
array([[1, 2],
[3, 4]], dtype=int8)
xv.mean(0)
array([2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Making changes to the view changes the underlying array</p>
<blockquote>
<blockquote>
<blockquote>
<p>xv[0,1] = 20
x
array([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using a view to convert an array to a recarray:</p>
<blockquote>
<blockquote>
<blockquote>
<p>z = x.view(np.recarray)
z.a
array([1, 3], dtype=int8)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Views share data:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x[0] = (9, 10)
z[0]
(9, 10)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Views that change the dtype size (bytes per entry) should normally be
avoided on arrays defined by slices, transposes, fortran-ordering, etc.:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)
y = x[:, 0:2]
y
array([[1, 2],
[4, 5]], dtype=int16)
y.view(dtype=[('width', np.int16), ('length', np.int16)])
Traceback (most recent call last):
...
ValueError: To change to a dtype of a different size, the array must be C-contiguous
z = y.copy()
z.view(dtype=[('width', np.int16), ('length', np.int16)])
array([[(1, 2)],
[(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="kt">array</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">K</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ndmin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">object_</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h2 id="parameters_326">Parameters<a class="headerlink" href="#parameters_326" title="Permanent link">&para;</a></h2>
<p>object : array_like
An array, any object exposing the array interface, an object whose
<strong>array</strong> method returns an array, or any (nested) sequence.
dtype : data-type, optional
The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.
copy : bool, optional
If true (default), then the object is copied.  Otherwise, a copy will
only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<code>dtype</code>, <code>order</code>, etc.).
order : {'K', 'A', 'C', 'F'}, optional
Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless 'F' is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<p>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================</p>
<p>When <code>copy=False</code> and a copy is made for other reasons, the result is
the same as if <code>copy=True</code>, with some exceptions for <code>A</code>, see the
Notes section. The default order is 'K'.
subok : bool, optional
If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).
ndmin : int, optional
Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
<h2 id="returns_256">Returns<a class="headerlink" href="#returns_256" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array object satisfying the specified requirements.</p>
<h2 id="see-also_145">See Also<a class="headerlink" href="#see-also_145" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="notes_133">Notes<a class="headerlink" href="#notes_133" title="Permanent link">&para;</a></h2>
<p>When order is 'A' and <code>object</code> is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.</p>
<h2 id="examples_186">Examples<a class="headerlink" href="#examples_186" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3])
array([1, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Upcasting:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>More than one dimension:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([[1, 2], [3, 4]])
array([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Minimum dimensions 2:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Type provided:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Data-type consisting of more than one element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
x['a']
array([1, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Creating an array from sub-classes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array(np.mat('1 2; 3 4'))
array([[1, 2],
[3, 4]])</p>
<p>np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asanyarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an ndarray, but pass ndarray subclasses through.</p>
<h2 id="parameters_327">Parameters<a class="headerlink" href="#parameters_327" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes scalars, lists, lists of tuples, tuples, tuples of tuples,
tuples of lists, and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or column-major
(Fortran-style) memory representation.  Defaults to 'C'.</p>
<h2 id="returns_257">Returns<a class="headerlink" href="#returns_257" title="Permanent link">&para;</a></h2>
<p>out : ndarray or an ndarray subclass
Array interpretation of <code>a</code>.  If <code>a</code> is an ndarray or a subclass
of ndarray, it is returned as-is and no copy is performed.</p>
<h2 id="see-also_146">See Also<a class="headerlink" href="#see-also_146" title="Permanent link">&para;</a></h2>
<p>asarray : Similar function which always returns ndarrays.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and
Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_187">Examples<a class="headerlink" href="#examples_187" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asanyarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Instances of <code>ndarray</code> subclasses are passed through as-is:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_328">Parameters<a class="headerlink" href="#parameters_328" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_258">Returns<a class="headerlink" href="#returns_258" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_147">See Also<a class="headerlink" href="#see-also_147" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_188">Examples<a class="headerlink" href="#examples_188" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">aslinearoperator</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return A as a LinearOperator.</p>
<p>'A' may be any of the following types:
- ndarray
- matrix
- sparse matrix (e.g. csr_matrix, lil_matrix, etc.)
- LinearOperator
- An object with .shape and .matvec attributes</p>
<p>See the LinearOperator documentation for additional information.</p>
<h2 id="notes_134">Notes<a class="headerlink" href="#notes_134" title="Permanent link">&para;</a></h2>
<p>If 'A' has no .dtype attribute, the data type is determined by calling
:func:<code>LinearOperator.matvec()</code> - set the .dtype attribute to prevent this
call upon the linear operator creation.</p>
<h2 id="examples_189">Examples<a class="headerlink" href="#examples_189" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import aslinearoperator
M = np.array([[1,2,3],[4,5,6]], dtype=np.int32)
aslinearoperator(M)
&lt;2x3 MatrixLinearOperator with dtype=int32&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asmatrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">coerce</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">id</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">make_system</span> <span class="o">:</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Make a linear system Ax=b</p>
<h2 id="parameters_329">Parameters<a class="headerlink" href="#parameters_329" title="Permanent link">&para;</a></h2>
<p>A : LinearOperator
sparse or dense matrix (or any valid input to aslinearoperator)
M : {LinearOperator, Nones}
preconditioner
sparse or dense matrix (or any valid input to aslinearoperator)
x0 : {array_like, None}
initial guess to iterative method
b : array_like
right hand side</p>
<h2 id="returns_259">Returns<a class="headerlink" href="#returns_259" title="Permanent link">&para;</a></h2>
<p>(A, M, x, b, postprocess)
A : LinearOperator
matrix of the linear system
M : LinearOperator
preconditioner
x : rank 1 ndarray
initial guess
b : rank 1 ndarray
right hand side
postprocess : function
converts the solution vector to the appropriate
type and dimensions (e.g. (N,1) matrix)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_330">Parameters<a class="headerlink" href="#parameters_330" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_260">Returns<a class="headerlink" href="#returns_260" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_148">See Also<a class="headerlink" href="#see-also_148" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_190">Examples<a class="headerlink" href="#examples_190" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bicg</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use BIConjugate Gradient iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_331">Parameters<a class="headerlink" href="#parameters_331" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> and <code>A^T x</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_261">Returns<a class="headerlink" href="#returns_261" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_11">Other Parameters<a class="headerlink" href="#other-parameters_11" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bicgstab</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use BIConjugate Gradient STABilized iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_332">Parameters<a class="headerlink" href="#parameters_332" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_262">Returns<a class="headerlink" href="#returns_262" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_12">Other Parameters<a class="headerlink" href="#other-parameters_12" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cg</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Conjugate Gradient iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_333">Parameters<a class="headerlink" href="#parameters_333" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
<code>A</code> must represent a hermitian, positive definite matrix.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_263">Returns<a class="headerlink" href="#returns_263" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_13">Other Parameters<a class="headerlink" href="#other-parameters_13" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cgs</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Conjugate Gradient Squared iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_334">Parameters<a class="headerlink" href="#parameters_334" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real-valued N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_264">Returns<a class="headerlink" href="#returns_264" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_14">Other Parameters<a class="headerlink" href="#other-parameters_14" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gcrotmk</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m&#39;</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cu</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">discard_C</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">truncate</span><span class="o">:[`</span><span class="nc">Oldest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Smallest</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Solve a matrix equation using flexible GCROT(m,k) algorithm.</p>
<h2 id="parameters_335">Parameters<a class="headerlink" href="#parameters_335" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).
x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>tol</code>.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : int, optional
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}, optional
Preconditioner for A.  The preconditioner should approximate the
inverse of A. gcrotmk is a 'flexible' algorithm and the preconditioner
can vary from iteration to iteration. Effective preconditioning
dramatically improves the rate of convergence, which implies that
fewer iterations are needed to reach a given error tolerance.
callback : function, optional
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.
m : int, optional
Number of inner FGMRES iterations per each outer iteration.
Default: 20
k : int, optional
Number of vectors to carry between inner FGMRES iterations.
According to [2]<em>, good values are around m.
Default: m
CU : list of tuples, optional
List of tuples <code>(c, u)</code> which contain the columns of the matrices
C and U in the GCROT(m,k) algorithm. For details, see [2]</em>.
The list given and vectors contained in it are modified in-place.
If not given, start from empty matrices. The <code>c</code> elements in the
tuples can be <code>None</code>, in which case the vectors are recomputed
via <code>c = A u</code> on start and orthogonalized as described in [3]<em>.
discard_C : bool, optional
Discard the C-vectors at the end. Useful if recycling Krylov subspaces
for different linear systems.
truncate : {'oldest', 'smallest'}, optional
Truncation scheme to use. Drop: oldest vectors, or vectors with
smallest singular values using the scheme discussed in [1,2].
See [2]</em> for detailed comparison.
Default: 'oldest'</p>
<h2 id="returns_265">Returns<a class="headerlink" href="#returns_265" title="Permanent link">&para;</a></h2>
<p>x : array or matrix
The solution found.
info : int
Provides convergence information:</p>
<ul>
<li>0  : successful exit</li>
<li>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations</p>
</blockquote>
</li>
</ul>
<h2 id="references_18">References<a class="headerlink" href="#references_18" title="Permanent link">&para;</a></h2>
<p>.. [1] E. de Sturler, ''Truncation strategies for optimal Krylov subspace
methods'', SIAM J. Numer. Anal. 36, 864 (1999).
.. [2] J.E. Hicken and D.W. Zingg, ''A simplified and flexible variant
of GCROT for solving nonsymmetric linear systems'',
SIAM J. Sci. Comput. 32, 172 (2010).
.. [3] M.L. Parks, E. de Sturler, G. Mackey, D.D. Johnson, S. Maiti,
''Recycling Krylov subspaces for sequences of linear systems'',
SIAM J. Sci. Comput. 28, 1651 (2006).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gmres</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">restart</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">restrt</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback_type</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Generalized Minimal RESidual iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_336">Parameters<a class="headerlink" href="#parameters_336" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_266">Returns<a class="headerlink" href="#returns_266" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : int
Provides convergence information:
* 0  : successful exit
* &gt;0 : convergence to tolerance not achieved, number of iterations
* &lt;0 : illegal input or breakdown</p>
<h2 id="other-parameters_15">Other parameters<a class="headerlink" href="#other-parameters_15" title="Permanent link">&para;</a></h2>
<p>x0 : {array, matrix}
Starting guess for the solution (a vector of zeros by default).
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
restart : int, optional
Number of iterations between restarts. Larger values increase
iteration cost, but may be necessary for convergence.
Default is 20.
maxiter : int, optional
Maximum number of iterations (restart cycles).  Iteration will stop
after maxiter steps even if the specified tolerance has not been
achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Inverse of the preconditioner of A.  M should approximate the
inverse of A and be easy to solve for (see Notes).  Effective
preconditioning dramatically improves the rate of convergence,
which implies that fewer iterations are needed to reach a given
error tolerance.  By default, no preconditioner is used.
callback : function
User-supplied function to call after each iteration.  It is called
as <code>callback(args)</code>, where <code>args</code> are selected by <code>callback_type</code>.
callback_type : {'x', 'pr_norm', 'legacy'}, optional
Callback function argument requested:
- <code>x</code>: current iterate (ndarray), called on every restart
- <code>pr_norm</code>: relative (preconditioned) residual norm (float),
called on every inner iteration
- <code>legacy</code> (default): same as <code>pr_norm</code>, but also changes the
meaning of 'maxiter' to count inner iterations instead of restart
cycles.
restrt : int, optional
DEPRECATED - use <code>restart</code> instead.</p>
<h2 id="see-also_149">See Also<a class="headerlink" href="#see-also_149" title="Permanent link">&para;</a></h2>
<p>LinearOperator</p>
<h2 id="notes_135">Notes<a class="headerlink" href="#notes_135" title="Permanent link">&para;</a></h2>
<p>A preconditioner, P, is chosen such that P is close to A but easy to solve
for. The preconditioner parameter required by this routine is
<code>M = P^-1</code>. The inverse should preferably not be calculated
explicitly.  Rather, use the following template to produce M::</p>
<h1 id="construct-a-linear-operator-that-computes-p-1-x_3">Construct a linear operator that computes P^-1 * x.<a class="headerlink" href="#construct-a-linear-operator-that-computes-p-1-x_3" title="Permanent link">&para;</a></h1>
<p>import scipy.sparse.linalg as spla
M_x = lambda x: spla.spsolve(P, x)
M = spla.LinearOperator((n, n), M_x)</p>
<h2 id="examples_191">Examples<a class="headerlink" href="#examples_191" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import gmres
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
b = np.array([2, 4, -1], dtype=float)
x, exitCode = gmres(A, b)
print(exitCode)            # 0 indicates successful convergence
0
np.allclose(A.dot(x), b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lgmres</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">inner_m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">outer_k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">outer_v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">store_outer_Av</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prepend_outer_v</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Solve a matrix equation using the LGMRES algorithm.</p>
<p>The LGMRES algorithm [1]<em> [2]</em> is designed to avoid some problems
in the convergence in restarted GMRES, and often converges in fewer
iterations.</p>
<h2 id="parameters_337">Parameters<a class="headerlink" href="#parameters_337" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).
x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>tol</code>.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : int, optional
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}, optional
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function, optional
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.
inner_m : int, optional
Number of inner GMRES iterations per each outer iteration.
outer_k : int, optional
Number of vectors to carry between inner GMRES iterations.
According to [1]_, good values are in the range of 1...3.
However, note that if you want to use the additional vectors to
accelerate solving multiple similar problems, larger values may
be beneficial.
outer_v : list of tuples, optional
List containing tuples <code>(v, Av)</code> of vectors and corresponding
matrix-vector products, used to augment the Krylov subspace, and
carried between inner GMRES iterations. The element <code>Av</code> can
be <code>None</code> if the matrix-vector product should be re-evaluated.
This parameter is modified in-place by <code>lgmres</code>, and can be used
to pass 'guess' vectors in and out of the algorithm when solving
similar problems.
store_outer_Av : bool, optional
Whether LGMRES should store also A*v in addition to vectors <code>v</code>
in the <code>outer_v</code> list. Default is True.
prepend_outer_v : bool, optional
Whether to put outer_v augmentation vectors before Krylov iterates.
In standard LGMRES, prepend_outer_v=False.</p>
<h2 id="returns_267">Returns<a class="headerlink" href="#returns_267" title="Permanent link">&para;</a></h2>
<p>x : array or matrix
The converged solution.
info : int
Provides convergence information:</p>
<ul>
<li>0  : successful exit</li>
<li>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations</p>
</blockquote>
</li>
<li>&lt;0 : illegal input or breakdown</li>
</ul>
<h2 id="notes_136">Notes<a class="headerlink" href="#notes_136" title="Permanent link">&para;</a></h2>
<p>The LGMRES algorithm [1]<em> [2]</em> is designed to avoid the
slowing of convergence in restarted GMRES, due to alternating
residual vectors. Typically, it often outperforms GMRES(m) of
comparable memory requirements by some measure, or at least is not
much worse.</p>
<p>Another advantage in this algorithm is that you can supply it with
'guess' vectors in the <code>outer_v</code> argument that augment the Krylov
subspace. If the solution lies close to the span of these vectors,
the algorithm converges faster. This can be useful if several very
similar matrices need to be inverted one after another, such as in
Newton-Krylov iteration where the Jacobian matrix often changes
little in the nonlinear steps.</p>
<h2 id="references_19">References<a class="headerlink" href="#references_19" title="Permanent link">&para;</a></h2>
<p>.. [1] A.H. Baker and E.R. Jessup and T. Manteuffel, 'A Technique for
Accelerating the Convergence of Restarted GMRES', SIAM J. Matrix
Anal. Appl. 26, 962 (2005).
.. [2] A.H. Baker, 'On Improving the Performance of the Linear Solver
restarted GMRES', PhD thesis, University of Colorado (2003).</p>
<h2 id="examples_192">Examples<a class="headerlink" href="#examples_192" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import lgmres
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
b = np.array([2, 4, -1], dtype=float)
x, exitCode = lgmres(A, b)
print(exitCode)            # 0 indicates successful convergence
0
np.allclose(A.dot(x), b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lsmr</span> <span class="o">:</span> <span class="o">?</span><span class="n">damp</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">btol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">conlim</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">show</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Iterative solver for least-squares problems.</p>
<p>lsmr solves the system of linear equations <code>Ax = b</code>. If the system
is inconsistent, it solves the least-squares problem <code>min ||b - Ax||_2</code>.
A is a rectangular matrix of dimension m-by-n, where all cases are
allowed: m = n, m &gt; n, or m &lt; n. B is a vector of length m.
The matrix A may be dense or sparse (usually sparse).</p>
<h2 id="parameters_338">Parameters<a class="headerlink" href="#parameters_338" title="Permanent link">&para;</a></h2>
<p>A : {matrix, sparse matrix, ndarray, LinearOperator}
Matrix A in the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> and <code>A^H x</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : array_like, shape (m,)
Vector b in the linear system.
damp : float
Damping factor for regularized least-squares. <code>lsmr</code> solves
the regularized least-squares problem::</p>
<p>min ||(b) - (  A   )x||
||(0)   (damp*I) ||_2</p>
<p>where damp is a scalar.  If damp is None or 0, the system
is solved without regularization.
atol, btol : float, optional
Stopping tolerances. <code>lsmr</code> continues iterations until a
certain backward error estimate is smaller than some quantity
depending on atol and btol.  Let <code>r = b - Ax</code> be the
residual vector for the current approximate solution <code>x</code>.
If <code>Ax = b</code> seems to be consistent, <code>lsmr</code> terminates
when <code>norm(r) &lt;= atol * norm(A) * norm(x) + btol * norm(b)</code>.
Otherwise, lsmr terminates when <code>norm(A^H r) &lt;=
atol * norm(A) * norm(r)</code>.  If both tolerances are 1.0e-6 (say),
the final <code>norm(r)</code> should be accurate to about 6
digits. (The final x will usually have fewer correct digits,
depending on <code>cond(A)</code> and the size of LAMBDA.)  If <code>atol</code>
or <code>btol</code> is None, a default value of 1.0e-6 will be used.
Ideally, they should be estimates of the relative error in the
entries of A and B respectively.  For example, if the entries
of <code>A</code> have 7 correct digits, set atol = 1e-7. This prevents
the algorithm from doing unnecessary work beyond the
uncertainty of the input data.
conlim : float, optional
<code>lsmr</code> terminates if an estimate of <code>cond(A)</code> exceeds
<code>conlim</code>.  For compatible systems <code>Ax = b</code>, conlim could be
as large as 1.0e+12 (say).  For least-squares problems,
<code>conlim</code> should be less than 1.0e+8. If <code>conlim</code> is None, the
default value is 1e+8.  Maximum precision can be obtained by
setting <code>atol = btol = conlim = 0</code>, but the number of
iterations may then be excessive.
maxiter : int, optional
<code>lsmr</code> terminates if the number of iterations reaches
<code>maxiter</code>.  The default is <code>maxiter = min(m, n)</code>.  For
ill-conditioned systems, a larger value of <code>maxiter</code> may be
needed.
show : bool, optional
Print iterations logs if <code>show=True</code>.
x0 : array_like, shape (n,), optional
Initial guess of x, if None zeros are used.</p>
<p>.. versionadded:: 1.0.0
Returns</p>
<hr />
<p>x : ndarray of float
Least-square solution returned.
istop : int
istop gives the reason for stopping::</p>
<p>istop   = 0 means x=0 is a solution.  If x0 was given, then x=x0 is a
solution.
= 1 means x is an approximate solution to A*x = B,
according to atol and btol.
= 2 means x approximately solves the least-squares problem
according to atol.
= 3 means COND(A) seems to be greater than CONLIM.
= 4 is the same as 1 with atol = btol = eps (machine
precision)
= 5 is the same as 2 with atol = eps.
= 6 is the same as 3 with CONLIM = 1/eps.
= 7 means ITN reached maxiter before the other stopping
conditions were satisfied.</p>
<p>itn : int
Number of iterations used.
normr : float
<code>norm(b-Ax)</code>
normar : float
<code>norm(A^H (b - Ax))</code>
norma : float
<code>norm(A)</code>
conda : float
Condition number of A.
normx : float
<code>norm(x)</code></p>
<h2 id="notes_137">Notes<a class="headerlink" href="#notes_137" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.11.0</p>
<h2 id="references_20">References<a class="headerlink" href="#references_20" title="Permanent link">&para;</a></h2>
<p>.. [1] D. C.-L. Fong and M. A. Saunders,
'LSMR: An iterative algorithm for sparse least-squares problems',
SIAM J. Sci. Comput., vol. 33, pp. 2950-2971, 2011.
https://arxiv.org/abs/1006.0758
.. [2] LSMR Software, https://web.stanford.edu/group/SOL/software/lsmr/</p>
<h2 id="examples_193">Examples<a class="headerlink" href="#examples_193" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import lsmr
A = csc_matrix([[1., 0.], [1., 1.], [0., 1.]], dtype=float)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The first example has the trivial solution <code>[0, 0]</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([0., 0., 0.], dtype=float)
x, istop, itn, normr = lsmr(A, b)[:4]
istop
0
x
array([ 0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The stopping code <code>istop=0</code> returned indicates that a vector of zeros was
found as a solution. The returned solution <code>x</code> indeed contains <code>[0., 0.]</code>.
The next example has a non-trivial solution:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([1., 0., -1.], dtype=float)
x, istop, itn, normr = lsmr(A, b)[:4]
istop
1
x
array([ 1., -1.])
itn
1
normr
4.440892098500627e-16</p>
</blockquote>
</blockquote>
</blockquote>
<p>As indicated by <code>istop=1</code>, <code>lsmr</code> found a solution obeying the tolerance
limits. The given solution <code>[1., -1.]</code> obviously solves the equation. The
remaining return values include information about the number of iterations
(<code>itn=1</code>) and the remaining difference of left and right side of the solved
equation.
The final example demonstrates the behavior in the case where there is no
solution for the equation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([1., 0.01, -1.], dtype=float)
x, istop, itn, normr = lsmr(A, b)[:4]
istop
2
x
array([ 1.00333333, -0.99666667])
A.dot(x)-b
array([ 0.00333333, -0.00333333,  0.00333333])
normr
0.005773502691896255</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>istop</code> indicates that the system is inconsistent and thus <code>x</code> is rather an
approximate solution to the corresponding least-squares problem. <code>normr</code>
contains the minimal distance that was found.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lsqr</span> <span class="o">:</span> <span class="o">?</span><span class="n">damp</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">btol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">conlim</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iter_lim</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">show</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">calc_var</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find the least-squares solution to a large, sparse, linear system
of equations.</p>
<p>The function solves <code>Ax = b</code>  or  <code>min ||b - Ax||^2</code> or
<code>min ||Ax - b||^2 + d^2 ||x||^2</code>.</p>
<p>The matrix A may be square or rectangular (over-determined or
under-determined), and may have any rank.</p>
<p>::</p>
<ol>
<li>
<p>Unsymmetric equations --    solve  A*x = b</p>
</li>
<li>
<p>Linear least squares  --    solve  A*x = b
in the least-squares sense</p>
</li>
<li>
<p>Damped least squares  --    solve  (   A    )<em>x = ( b )
( damp</em>I )     ( 0 )
in the least-squares sense</p>
</li>
</ol>
<h2 id="parameters_339">Parameters<a class="headerlink" href="#parameters_339" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, ndarray, LinearOperator}
Representation of an m-by-n matrix.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> and <code>A^T x</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : array_like, shape (m,)
Right-hand side vector <code>b</code>.
damp : float
Damping coefficient.
atol, btol : float, optional
Stopping tolerances. If both are 1.0e-9 (say), the final
residual norm should be accurate to about 9 digits.  (The
final x will usually have fewer correct digits, depending on
cond(A) and the size of damp.)
conlim : float, optional
Another stopping tolerance.  lsqr terminates if an estimate of
<code>cond(A)</code> exceeds <code>conlim</code>.  For compatible systems <code>Ax =
b</code>, <code>conlim</code> could be as large as 1.0e+12 (say).  For
least-squares problems, conlim should be less than 1.0e+8.
Maximum precision can be obtained by setting <code>atol = btol =
conlim = zero</code>, but the number of iterations may then be
excessive.
iter_lim : int, optional
Explicit limitation on number of iterations (for safety).
show : bool, optional
Display an iteration log.
calc_var : bool, optional
Whether to estimate diagonals of <code>(A'A + damp^2*I)^{-1}</code>.
x0 : array_like, shape (n,), optional
Initial guess of x, if None zeros are used.</p>
<p>.. versionadded:: 1.0.0</p>
<h2 id="returns_268">Returns<a class="headerlink" href="#returns_268" title="Permanent link">&para;</a></h2>
<p>x : ndarray of float
The final solution.
istop : int
Gives the reason for termination.
1 means x is an approximate solution to Ax = b.
2 means x approximately solves the least-squares problem.
itn : int
Iteration number upon termination.
r1norm : float
<code>norm(r)</code>, where <code>r = b - Ax</code>.
r2norm : float
<code>sqrt( norm(r)^2  +  damp^2 * norm(x)^2 )</code>.  Equal to <code>r1norm</code> if
<code>damp == 0</code>.
anorm : float
Estimate of Frobenius norm of <code>Abar = [[A]; [damp*I]]</code>.
acond : float
Estimate of <code>cond(Abar)</code>.
arnorm : float
Estimate of <code>norm(A'*r - damp^2*x)</code>.
xnorm : float
<code>norm(x)</code>
var : ndarray of float
If <code>calc_var</code> is True, estimates all diagonals of
<code>(A'A)^{-1}</code> (if <code>damp == 0</code>) or more generally <code>(A'A +
damp^2*I)^{-1}</code>.  This is well defined if A has full column
rank or <code>damp &gt; 0</code>.  (Not sure what var means if <code>rank(A)
&lt; n</code> and <code>damp = 0.</code>)</p>
<h2 id="notes_138">Notes<a class="headerlink" href="#notes_138" title="Permanent link">&para;</a></h2>
<p>LSQR uses an iterative method to approximate the solution.  The
number of iterations required to reach a certain accuracy depends
strongly on the scaling of the problem.  Poor scaling of the rows
or columns of A should therefore be avoided where possible.</p>
<p>For example, in problem 1 the solution is unaltered by
row-scaling.  If a row of A is very small or large compared to
the other rows of A, the corresponding row of ( A  b ) should be
scaled up or down.</p>
<p>In problems 1 and 2, the solution x is easily recovered
following column-scaling.  Unless better information is known,
the nonzero columns of A should be scaled so that they all have
the same Euclidean norm (e.g., 1.0).</p>
<p>In problem 3, there is no freedom to re-scale if damp is
nonzero.  However, the value of damp should be assigned only
after attention has been paid to the scaling of A.</p>
<p>The parameter damp is intended to help regularize
ill-conditioned systems, by preventing the true solution from
being very large.  Another aid to regularization is provided by
the parameter acond, which may be used to terminate iterations
before the computed solution becomes very large.</p>
<p>If some initial estimate <code>x0</code> is known and if <code>damp == 0</code>,
one could proceed as follows:</p>
<ol>
<li>Compute a residual vector <code>r0 = b - A*x0</code>.</li>
<li>Use LSQR to solve the system  <code>A*dx = r0</code>.</li>
<li>Add the correction dx to obtain a final solution <code>x = x0 + dx</code>.</li>
</ol>
<p>This requires that <code>x0</code> be available before and after the call
to LSQR.  To judge the benefits, suppose LSQR takes k1 iterations
to solve A<em>x = b and k2 iterations to solve A</em>dx = r0.
If x0 is 'good', norm(r0) will be smaller than norm(b).
If the same stopping tolerances atol and btol are used for each
system, k1 and k2 will be similar, but the final solution x0 + dx
should be more accurate.  The only way to reduce the total work
is to use a larger stopping tolerance for the second system.
If some value btol is suitable for A<em>x = b, the larger value
btol</em>norm(b)/norm(r0)  should be suitable for A*dx = r0.</p>
<p>Preconditioning is another way to reduce the number of iterations.
If it is possible to solve a related system <code>M*x = b</code>
efficiently, where M approximates A in some helpful way (e.g. M -
A has low rank or its elements are small relative to those of A),
LSQR may converge more rapidly on the system <code>A*M(inverse)*z =
b</code>, after which x can be recovered by solving M*x = z.</p>
<p>If A is symmetric, LSQR should not be used!</p>
<p>Alternatives are the symmetric conjugate-gradient method (cg)
and/or SYMMLQ.  SYMMLQ is an implementation of symmetric cg that
applies to any symmetric A and will converge more rapidly than
LSQR.  If A is positive definite, there are other implementations
of symmetric cg that require slightly less work per iteration than
SYMMLQ (but will take the same number of iterations).</p>
<h2 id="references_21">References<a class="headerlink" href="#references_21" title="Permanent link">&para;</a></h2>
<p>.. [1] C. C. Paige and M. A. Saunders (1982a).
'LSQR: An algorithm for sparse linear equations and
sparse least squares', ACM TOMS 8(1), 43-71.
.. [2] C. C. Paige and M. A. Saunders (1982b).
'Algorithm 583.  LSQR: Sparse linear equations and least
squares problems', ACM TOMS 8(2), 195-209.
.. [3] M. A. Saunders (1995).  'Solution of sparse rectangular
systems using LSQR and CRAIG', BIT 35, 588-604.</p>
<h2 id="examples_194">Examples<a class="headerlink" href="#examples_194" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import lsqr
A = csc_matrix([[1., 0.], [1., 1.], [0., 1.]], dtype=float)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The first example has the trivial solution <code>[0, 0]</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([0., 0., 0.], dtype=float)
x, istop, itn, normr = lsqr(A, b)[:4]
The exact solution is  x = 0
istop
0
x
array([ 0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The stopping code <code>istop=0</code> returned indicates that a vector of zeros was
found as a solution. The returned solution <code>x</code> indeed contains <code>[0., 0.]</code>.
The next example has a non-trivial solution:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([1., 0., -1.], dtype=float)
x, istop, itn, r1norm = lsqr(A, b)[:4]
istop
1
x
array([ 1., -1.])
itn
1
r1norm
4.440892098500627e-16</p>
</blockquote>
</blockquote>
</blockquote>
<p>As indicated by <code>istop=1</code>, <code>lsqr</code> found a solution obeying the tolerance
limits. The given solution <code>[1., -1.]</code> obviously solves the equation. The
remaining return values include information about the number of iterations
(<code>itn=1</code>) and the remaining difference of left and right side of the solved
equation.
The final example demonstrates the behavior in the case where there is no
solution for the equation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([1., 0.01, -1.], dtype=float)
x, istop, itn, r1norm = lsqr(A, b)[:4]
istop
2
x
array([ 1.00333333, -0.99666667])
A.dot(x)-b
array([ 0.00333333, -0.00333333,  0.00333333])
r1norm
0.005773502691896255</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>istop</code> indicates that the system is inconsistent and thus <code>x</code> is rather an
approximate solution to the corresponding least-squares problem. <code>r1norm</code>
contains the norm of the minimal residual that was found.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minres</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shift</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">show</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use MINimum RESidual iteration to solve Ax=b</p>
<p>MINRES minimizes norm(A*x - b) for a real symmetric matrix A.  Unlike
the Conjugate Gradient method, A can be indefinite or singular.</p>
<p>If shift != 0 then the method solves (A - shift*I)x = b</p>
<h2 id="parameters_340">Parameters<a class="headerlink" href="#parameters_340" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real symmetric N-by-N matrix of the linear system
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_269">Returns<a class="headerlink" href="#returns_269" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_16">Other Parameters<a class="headerlink" href="#other-parameters_16" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol : float
Tolerance to achieve. The algorithm terminates when the relative
residual is below <code>tol</code>.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<h2 id="references_22">References<a class="headerlink" href="#references_22" title="Permanent link">&para;</a></h2>
<p>Solution of sparse indefinite systems of linear equations,
C. C. Paige and M. A. Saunders (1975),
SIAM J. Numer. Anal. 12(4), pp. 617-629.
https://web.stanford.edu/group/SOL/software/minres/</p>
<p>This file is a translation of the following MATLAB implementation:
https://web.stanford.edu/group/SOL/software/minres/minres-matlab.zip</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qmr</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Quasi-Minimal Residual iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_341">Parameters<a class="headerlink" href="#parameters_341" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real-valued N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> and <code>A^T x</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_270">Returns<a class="headerlink" href="#returns_270" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_17">Other Parameters<a class="headerlink" href="#other-parameters_17" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M1 : {sparse matrix, dense matrix, LinearOperator}
Left preconditioner for A.
M2 : {sparse matrix, dense matrix, LinearOperator}
Right preconditioner for A. Used together with the left
preconditioner M1.  The matrix M1<em>A</em>M2 should have better
conditioned than A alone.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<h2 id="see-also_150">See Also<a class="headerlink" href="#see-also_150" title="Permanent link">&para;</a></h2>
<p>LinearOperator</p>
<h2 id="examples_195">Examples<a class="headerlink" href="#examples_195" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import qmr
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
b = np.array([2, 4, -1], dtype=float)
x, exitCode = qmr(A, b)
print(exitCode)            # 0 indicates successful convergence
0
np.allclose(A.dot(x), b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Iterative</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">bicg</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use BIConjugate Gradient iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_342">Parameters<a class="headerlink" href="#parameters_342" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> and <code>A^T x</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_271">Returns<a class="headerlink" href="#returns_271" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_18">Other Parameters<a class="headerlink" href="#other-parameters_18" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bicgstab</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use BIConjugate Gradient STABilized iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_343">Parameters<a class="headerlink" href="#parameters_343" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_272">Returns<a class="headerlink" href="#returns_272" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_19">Other Parameters<a class="headerlink" href="#other-parameters_19" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cg</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Conjugate Gradient iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_344">Parameters<a class="headerlink" href="#parameters_344" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
<code>A</code> must represent a hermitian, positive definite matrix.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_273">Returns<a class="headerlink" href="#returns_273" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_20">Other Parameters<a class="headerlink" href="#other-parameters_20" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cgs</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Conjugate Gradient Squared iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_345">Parameters<a class="headerlink" href="#parameters_345" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real-valued N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_274">Returns<a class="headerlink" href="#returns_274" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_21">Other Parameters<a class="headerlink" href="#other-parameters_21" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gmres</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">restart</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">restrt</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback_type</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Generalized Minimal RESidual iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_346">Parameters<a class="headerlink" href="#parameters_346" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_275">Returns<a class="headerlink" href="#returns_275" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : int
Provides convergence information:
* 0  : successful exit
* &gt;0 : convergence to tolerance not achieved, number of iterations
* &lt;0 : illegal input or breakdown</p>
<h2 id="other-parameters_22">Other parameters<a class="headerlink" href="#other-parameters_22" title="Permanent link">&para;</a></h2>
<p>x0 : {array, matrix}
Starting guess for the solution (a vector of zeros by default).
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
restart : int, optional
Number of iterations between restarts. Larger values increase
iteration cost, but may be necessary for convergence.
Default is 20.
maxiter : int, optional
Maximum number of iterations (restart cycles).  Iteration will stop
after maxiter steps even if the specified tolerance has not been
achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Inverse of the preconditioner of A.  M should approximate the
inverse of A and be easy to solve for (see Notes).  Effective
preconditioning dramatically improves the rate of convergence,
which implies that fewer iterations are needed to reach a given
error tolerance.  By default, no preconditioner is used.
callback : function
User-supplied function to call after each iteration.  It is called
as <code>callback(args)</code>, where <code>args</code> are selected by <code>callback_type</code>.
callback_type : {'x', 'pr_norm', 'legacy'}, optional
Callback function argument requested:
- <code>x</code>: current iterate (ndarray), called on every restart
- <code>pr_norm</code>: relative (preconditioned) residual norm (float),
called on every inner iteration
- <code>legacy</code> (default): same as <code>pr_norm</code>, but also changes the
meaning of 'maxiter' to count inner iterations instead of restart
cycles.
restrt : int, optional
DEPRECATED - use <code>restart</code> instead.</p>
<h2 id="see-also_151">See Also<a class="headerlink" href="#see-also_151" title="Permanent link">&para;</a></h2>
<p>LinearOperator</p>
<h2 id="notes_139">Notes<a class="headerlink" href="#notes_139" title="Permanent link">&para;</a></h2>
<p>A preconditioner, P, is chosen such that P is close to A but easy to solve
for. The preconditioner parameter required by this routine is
<code>M = P^-1</code>. The inverse should preferably not be calculated
explicitly.  Rather, use the following template to produce M::</p>
<h1 id="construct-a-linear-operator-that-computes-p-1-x_4">Construct a linear operator that computes P^-1 * x.<a class="headerlink" href="#construct-a-linear-operator-that-computes-p-1-x_4" title="Permanent link">&para;</a></h1>
<p>import scipy.sparse.linalg as spla
M_x = lambda x: spla.spsolve(P, x)
M = spla.LinearOperator((n, n), M_x)</p>
<h2 id="examples_196">Examples<a class="headerlink" href="#examples_196" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import gmres
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
b = np.array([2, 4, -1], dtype=float)
x, exitCode = gmres(A, b)
print(exitCode)            # 0 indicates successful convergence
0
np.allclose(A.dot(x), b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">make_system</span> <span class="o">:</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Make a linear system Ax=b</p>
<h2 id="parameters_347">Parameters<a class="headerlink" href="#parameters_347" title="Permanent link">&para;</a></h2>
<p>A : LinearOperator
sparse or dense matrix (or any valid input to aslinearoperator)
M : {LinearOperator, Nones}
preconditioner
sparse or dense matrix (or any valid input to aslinearoperator)
x0 : {array_like, None}
initial guess to iterative method
b : array_like
right hand side</p>
<h2 id="returns_276">Returns<a class="headerlink" href="#returns_276" title="Permanent link">&para;</a></h2>
<p>(A, M, x, b, postprocess)
A : LinearOperator
matrix of the linear system
M : LinearOperator
preconditioner
x : rank 1 ndarray
initial guess
b : rank 1 ndarray
right hand side
postprocess : function
converts the solution vector to the appropriate
type and dimensions (e.g. (N,1) matrix)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">non_reentrant</span> <span class="o">:</span> <span class="o">?</span><span class="n">err_msg</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Decorate a function with a threading lock and prevent reentrant calls.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qmr</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Quasi-Minimal Residual iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_348">Parameters<a class="headerlink" href="#parameters_348" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real-valued N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> and <code>A^T x</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_277">Returns<a class="headerlink" href="#returns_277" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_23">Other Parameters<a class="headerlink" href="#other-parameters_23" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M1 : {sparse matrix, dense matrix, LinearOperator}
Left preconditioner for A.
M2 : {sparse matrix, dense matrix, LinearOperator}
Right preconditioner for A. Used together with the left
preconditioner M1.  The matrix M1<em>A</em>M2 should have better
conditioned than A alone.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<h2 id="see-also_152">See Also<a class="headerlink" href="#see-also_152" title="Permanent link">&para;</a></h2>
<p>LinearOperator</p>
<h2 id="examples_197">Examples<a class="headerlink" href="#examples_197" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import qmr
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
b = np.array([2, 4, -1], dtype=float)
x, exitCode = qmr(A, b)
print(exitCode)            # 0 indicates successful convergence
0
np.allclose(A.dot(x), b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_docstring</span> <span class="o">:</span> <span class="o">?</span><span class="n">footer</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol_default</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">header</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ainfo</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Linsolve</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_349">Parameters<a class="headerlink" href="#parameters_349" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_278">Returns<a class="headerlink" href="#returns_278" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_153">See Also<a class="headerlink" href="#see-also_153" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_198">Examples<a class="headerlink" href="#examples_198" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">factorized</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a function for solving a sparse linear system, with A pre-factorized.</p>
<h2 id="parameters_350">Parameters<a class="headerlink" href="#parameters_350" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input.</p>
<h2 id="returns_279">Returns<a class="headerlink" href="#returns_279" title="Permanent link">&para;</a></h2>
<p>solve : callable
To solve the linear system of equations given in <code>A</code>, the <code>solve</code>
callable should be passed an ndarray of shape (N,).</p>
<h2 id="examples_199">Examples<a class="headerlink" href="#examples_199" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import factorized
A = np.array([[ 3. ,  2. , -1. ],
...               [ 2. , -2. ,  4. ],
...               [-1. ,  0.5, -1. ]])
solve = factorized(A) # Makes LU decomposition.
rhs1 = np.array([1, -2, 0])
solve(rhs1) # Uses the LU factors.
array([ 1., -2., -2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_pydata_spmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Check whether object is pydata/sparse matrix, avoiding importing the module.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_351">Parameters<a class="headerlink" href="#parameters_351" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_280">Returns<a class="headerlink" href="#returns_280" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_140">Notes<a class="headerlink" href="#notes_140" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_200">Examples<a class="headerlink" href="#examples_200" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_csc</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of csc_matrix type?</p>
<h2 id="parameters_352">Parameters<a class="headerlink" href="#parameters_352" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a csc matrix</p>
<h2 id="returns_281">Returns<a class="headerlink" href="#returns_281" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a csc matrix, False otherwise</p>
<h2 id="examples_201">Examples<a class="headerlink" href="#examples_201" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix, isspmatrix_csc
isspmatrix_csc(csc_matrix([[5]]))
True</p>
<p>from scipy.sparse import csc_matrix, csr_matrix, isspmatrix_csc
isspmatrix_csc(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_csr</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of csr_matrix type?</p>
<h2 id="parameters_353">Parameters<a class="headerlink" href="#parameters_353" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a csr matrix</p>
<h2 id="returns_282">Returns<a class="headerlink" href="#returns_282" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a csr matrix, False otherwise</p>
<h2 id="examples_202">Examples<a class="headerlink" href="#examples_202" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix_csr
isspmatrix_csr(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import csc_matrix, csr_matrix, isspmatrix_csc
isspmatrix_csr(csc_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spilu</span> <span class="o">:</span> <span class="o">?</span><span class="n">drop_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fill_factor</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">drop_rule</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag_pivot_thresh</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">relax</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">panel_size</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute an incomplete LU decomposition for a sparse, square matrix.</p>
<p>The resulting object is an approximation to the inverse of <code>A</code>.</p>
<h2 id="parameters_354">Parameters<a class="headerlink" href="#parameters_354" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Sparse matrix to factorize
drop_tol : float, optional
Drop tolerance (0 &lt;= tol &lt;= 1) for an incomplete LU decomposition.
(default: 1e-4)
fill_factor : float, optional
Specifies the fill ratio upper bound (&gt;= 1.0) for ILU. (default: 10)
drop_rule : str, optional
Comma-separated string of drop rules to use.
Available rules: <code>basic</code>, <code>prows</code>, <code>column</code>, <code>area</code>,
<code>secondary</code>, <code>dynamic</code>, <code>interp</code>. (Default: <code>basic,area</code>)</p>
<p>See SuperLU documentation for details.</p>
<p>Remaining other options
Same as for <code>splu</code></p>
<h2 id="returns_283">Returns<a class="headerlink" href="#returns_283" title="Permanent link">&para;</a></h2>
<p>invA_approx : scipy.sparse.linalg.SuperLU
Object, which has a <code>solve</code> method.</p>
<h2 id="see-also_154">See also<a class="headerlink" href="#see-also_154" title="Permanent link">&para;</a></h2>
<p>splu : complete LU decomposition</p>
<h2 id="notes_141">Notes<a class="headerlink" href="#notes_141" title="Permanent link">&para;</a></h2>
<p>To improve the better approximation to the inverse, you may need to
increase <code>fill_factor</code> AND decrease <code>drop_tol</code>.</p>
<p>This function uses the SuperLU library.</p>
<h2 id="examples_203">Examples<a class="headerlink" href="#examples_203" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import spilu
A = csc_matrix([[1., 0., 0.], [5., 0., 2.], [0., -1., 0.]], dtype=float)
B = spilu(A)
x = np.array([1., 2., 3.], dtype=float)
B.solve(x)
array([ 1. , -3. , -1.5])
A.dot(B.solve(x))
array([ 1.,  2.,  3.])
B.solve(A.dot(x))
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">splu</span> <span class="o">:</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag_pivot_thresh</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">relax</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">panel_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the LU decomposition of a sparse, square matrix.</p>
<h2 id="parameters_355">Parameters<a class="headerlink" href="#parameters_355" title="Permanent link">&para;</a></h2>
<p>A : sparse matrix
Sparse matrix to factorize. Should be in CSR or CSC format.
permc_spec : str, optional
How to permute the columns of the matrix for sparsity preservation.
(default: 'COLAMD')</p>
<ul>
<li><code>NATURAL</code>: natural ordering.</li>
<li><code>MMD_ATA</code>: minimum degree ordering on the structure of A^T A.</li>
<li><code>MMD_AT_PLUS_A</code>: minimum degree ordering on the structure of A^T+A.</li>
<li><code>COLAMD</code>: approximate minimum degree column ordering</li>
</ul>
<p>diag_pivot_thresh : float, optional
Threshold used for a diagonal entry to be an acceptable pivot.
See SuperLU user's guide for details [1]<em>
relax : int, optional
Expert option for customizing the degree of relaxing supernodes.
See SuperLU user's guide for details [1]</em>
panel_size : int, optional
Expert option for customizing the panel size.
See SuperLU user's guide for details [1]<em>
options : dict, optional
Dictionary containing additional expert options to SuperLU.
See SuperLU user guide [1]</em> (section 2.4 on the 'Options' argument)
for more details. For example, you can specify
<code>options=dict(Equil=False, IterRefine='SINGLE'))</code>
to turn equilibration off and perform a single iterative refinement.</p>
<h2 id="returns_284">Returns<a class="headerlink" href="#returns_284" title="Permanent link">&para;</a></h2>
<p>invA : scipy.sparse.linalg.SuperLU
Object, which has a <code>solve</code> method.</p>
<h2 id="see-also_155">See also<a class="headerlink" href="#see-also_155" title="Permanent link">&para;</a></h2>
<p>spilu : incomplete LU decomposition</p>
<h2 id="notes_142">Notes<a class="headerlink" href="#notes_142" title="Permanent link">&para;</a></h2>
<p>This function uses the SuperLU library.</p>
<h2 id="references_23">References<a class="headerlink" href="#references_23" title="Permanent link">&para;</a></h2>
<p>.. [1] SuperLU http://crd.lbl.gov/~xiaoye/SuperLU/</p>
<h2 id="examples_204">Examples<a class="headerlink" href="#examples_204" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import splu
A = csc_matrix([[1., 0., 0.], [5., 0., 2.], [0., -1., 0.]], dtype=float)
B = splu(A)
x = np.array([1., 2., 3.], dtype=float)
B.solve(x)
array([ 1. , -3. , -1.5])
A.dot(B.solve(x))
array([ 1.,  2.,  3.])
B.solve(A.dot(x))
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spsolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">use_umfpack</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the sparse linear system Ax=b, where b may be a vector or a matrix.</p>
<h2 id="parameters_356">Parameters<a class="headerlink" href="#parameters_356" title="Permanent link">&para;</a></h2>
<p>A : ndarray or sparse matrix
The square matrix A will be converted into CSC or CSR form
b : ndarray or sparse matrix
The matrix or vector representing the right hand side of the equation.
If a vector, b.shape must be (n,) or (n, 1).
permc_spec : str, optional
How to permute the columns of the matrix for sparsity preservation.
(default: 'COLAMD')</p>
<ul>
<li><code>NATURAL</code>: natural ordering.</li>
<li><code>MMD_ATA</code>: minimum degree ordering on the structure of A^T A.</li>
<li><code>MMD_AT_PLUS_A</code>: minimum degree ordering on the structure of A^T+A.</li>
<li><code>COLAMD</code>: approximate minimum degree column ordering
use_umfpack : bool, optional
if True (default) then use umfpack for the solution.  This is
only referenced if b is a vector and <code>scikit-umfpack</code> is installed.</li>
</ul>
<h2 id="returns_285">Returns<a class="headerlink" href="#returns_285" title="Permanent link">&para;</a></h2>
<p>x : ndarray or sparse matrix
the solution of the sparse linear equation.
If b is a vector, then x is a vector of size A.shape[1]
If b is a matrix, then x is a matrix of size (A.shape[1], b.shape[1])</p>
<h2 id="notes_143">Notes<a class="headerlink" href="#notes_143" title="Permanent link">&para;</a></h2>
<p>For solving the matrix expression AX = B, this solver assumes the resulting
matrix X is sparse, as is often the case for very sparse inputs.  If the
resulting X is dense, the construction of this sparse result will be
relatively expensive.  In that case, consider converting A to a dense
matrix and using scipy.linalg.solve or its variants.</p>
<h2 id="examples_205">Examples<a class="headerlink" href="#examples_205" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import spsolve
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
B = csc_matrix([[2, 0], [-1, 0], [2, 0]], dtype=float)
x = spsolve(A, B)
np.allclose(A.dot(x).todense(), B.todense())
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spsolve_triangular</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_A</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">unit_diagonal</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation <code>A x = b</code> for <code>x</code>, assuming A is a triangular matrix.</p>
<h2 id="parameters_357">Parameters<a class="headerlink" href="#parameters_357" title="Permanent link">&para;</a></h2>
<p>A : (M, M) sparse matrix
A sparse square triangular matrix. Should be in CSR format.
b : (M,) or (M, N) array_like
Right-hand side matrix in <code>A x = b</code>
lower : bool, optional
Whether <code>A</code> is a lower or upper triangular matrix.
Default is lower triangular matrix.
overwrite_A : bool, optional
Allow changing <code>A</code>. The indices of <code>A</code> are going to be sorted and zero
entries are going to be removed.
Enabling gives a performance gain. Default is False.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code>.
Enabling gives a performance gain. Default is False.
If <code>overwrite_b</code> is True, it should be ensured that
<code>b</code> has an appropriate dtype to be able to store the result.
unit_diagonal : bool, optional
If True, diagonal elements of <code>a</code> are assumed to be 1 and will not be
referenced.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="returns_286">Returns<a class="headerlink" href="#returns_286" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, N) ndarray
Solution to the system <code>A x = b</code>. Shape of return matches shape of <code>b</code>.</p>
<h2 id="raises_21">Raises<a class="headerlink" href="#raises_21" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If <code>A</code> is singular or not triangular.
ValueError
If shape of <code>A</code> or shape of <code>b</code> do not match the requirements.</p>
<h2 id="notes_144">Notes<a class="headerlink" href="#notes_144" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_206">Examples<a class="headerlink" href="#examples_206" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.linalg import spsolve_triangular
A = csr_matrix([[3, 0, 0], [1, -1, 0], [2, 0, 1]], dtype=float)
B = np.array([[2, 0], [-1, 0], [2, 0]], dtype=float)
x = spsolve_triangular(A, B)
np.allclose(A.dot(x), B)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">use_solver</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Select default sparse direct solver to be used.</p>
<h2 id="parameters_358">Parameters<a class="headerlink" href="#parameters_358" title="Permanent link">&para;</a></h2>
<p>useUmfpack : bool, optional
Use UMFPACK over SuperLU. Has effect only if scikits.umfpack is
installed. Default: True
assumeSortedIndices : bool, optional
Allow UMFPACK to skip the step of sorting indices for a CSR/CSC matrix.
Has effect only if useUmfpack is True and scikits.umfpack is installed.
Default: False</p>
<h2 id="notes_145">Notes<a class="headerlink" href="#notes_145" title="Permanent link">&para;</a></h2>
<p>The default sparse solver is umfpack when available
(scikits.umfpack is installed). This can be changed by passing
useUmfpack = False, which then causes the always present SuperLU
based solver to be used.</p>
<p>Umfpack requires a CSR/CSC matrix to have sorted column/row indices. If
sure that the matrix fulfills this, pass <code>assumeSortedIndices=True</code>
to gain some speed.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">warn</span> <span class="o">:</span> <span class="o">?</span><span class="n">category</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stacklevel</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">source</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">message</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Issue a warning, or maybe ignore it or raise an exception.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Matfuncs</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">MatrixPowerOperator</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">MatrixPowerOperator</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">MatrixPowerOperator</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Common interface for performing matrix vector products</p>
<p>Many iterative methods (e.g. cg, gmres) do not need to know the
individual entries of a matrix to solve a linear system A<em>x=b.
Such solvers only require the computation of matrix vector
products, A</em>v where v is a dense vector.  This class serves as
an abstract interface between iterative solvers and matrix-like
objects.</p>
<p>To construct a concrete LinearOperator, either pass appropriate
callables to the constructor of this class, or subclass it.</p>
<p>A subclass must implement either one of the methods <code>_matvec</code>
and <code>_matmat</code>, and the attributes/properties <code>shape</code> (pair of
integers) and <code>dtype</code> (may be None). It may call the <code>__init__</code>
on this class to have these attributes validated. Implementing
<code>_matvec</code> automatically implements <code>_matmat</code> (using a naive
algorithm) and vice-versa.</p>
<p>Optionally, a subclass may implement <code>_rmatvec</code> or <code>_adjoint</code>
to implement the Hermitian adjoint (conjugate transpose). As with
<code>_matvec</code> and <code>_matmat</code>, implementing either <code>_rmatvec</code> or
<code>_adjoint</code> implements the other automatically. Implementing
<code>_adjoint</code> is preferable; <code>_rmatvec</code> is mostly there for
backwards compatibility.</p>
<h2 id="parameters_359">Parameters<a class="headerlink" href="#parameters_359" title="Permanent link">&para;</a></h2>
<p>shape : tuple
Matrix dimensions (M, N).
matvec : callable f(v)
Returns returns A * v.
rmatvec : callable f(v)
Returns A^H * v, where A^H is the conjugate transpose of A.
matmat : callable f(V)
Returns A * V, where V is a dense matrix with dimensions (N, K).
dtype : dtype
Data type of the matrix.
rmatmat : callable f(V)
Returns A^H * V, where V is a dense matrix with dimensions (M, K).</p>
<h2 id="attributes_12">Attributes<a class="headerlink" href="#attributes_12" title="Permanent link">&para;</a></h2>
<p>args : tuple
For linear operators describing products etc. of other linear
operators, the operands of the binary operation.</p>
<h2 id="see-also_156">See Also<a class="headerlink" href="#see-also_156" title="Permanent link">&para;</a></h2>
<p>aslinearoperator : Construct LinearOperators</p>
<h2 id="notes_146">Notes<a class="headerlink" href="#notes_146" title="Permanent link">&para;</a></h2>
<p>The user-defined matvec() function must properly handle the case
where v has shape (N,) as well as the (N,1) case.  The shape of
the return type is handled internally by LinearOperator.</p>
<p>LinearOperator instances can also be multiplied, added with each
other and exponentiated, all lazily: the result of these operations
is always a new, composite LinearOperator, that defers linear
operations to the original operators and combines the results.</p>
<p>More details regarding how to subclass a LinearOperator and several
examples of concrete LinearOperator instances can be found in the
external project <code>PyLops &lt;https://pylops.readthedocs.io&gt;</code>_.</p>
<h2 id="examples_207">Examples<a class="headerlink" href="#examples_207" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse.linalg import LinearOperator
def mv(v):
...     return np.array([2<em>v[0], 3</em>v[1]])
...
A = LinearOperator((2,2), matvec=mv)
A
&lt;2x2 _CustomLinearOperator with dtype=float64&gt;
A.matvec(np.ones(2))
array([ 2.,  3.])
A * np.ones(2)
array([ 2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">adjoint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Hermitian adjoint.</p>
<p>Returns the Hermitian adjoint of self, aka the Hermitian
conjugate or Hermitian transpose. For a complex matrix, the
Hermitian adjoint is equal to the conjugate transpose.</p>
<p>Can be abbreviated self.H instead of self.adjoint().</p>
<h2 id="returns_287">Returns<a class="headerlink" href="#returns_287" title="Permanent link">&para;</a></h2>
<p>A_H : LinearOperator
Hermitian adjoint of self.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix or matrix-vector multiplication.</p>
<h2 id="parameters_360">Parameters<a class="headerlink" href="#parameters_360" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-d or 2-d array, representing a vector or matrix.</p>
<h2 id="returns_288">Returns<a class="headerlink" href="#returns_288" title="Permanent link">&para;</a></h2>
<p>Ax : array
1-d or 2-d array (depending on the shape of x) that represents
the result of applying this linear operator on x.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix multiplication.</p>
<p>Performs the operation y=A<em>X where A is an MxN linear
operator and X dense N</em>K matrix or ndarray.</p>
<h2 id="parameters_361">Parameters<a class="headerlink" href="#parameters_361" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
An array with shape (N,K).</p>
<h2 id="returns_289">Returns<a class="headerlink" href="#returns_289" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or ndarray with shape (M,K) depending on
the type of the X argument.</p>
<h2 id="notes_147">Notes<a class="headerlink" href="#notes_147" title="Permanent link">&para;</a></h2>
<p>This matmat wraps any user-specified matmat routine or overridden
_matmat method to ensure that y has the correct type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-vector multiplication.</p>
<p>Performs the operation y=A*x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_362">Parameters<a class="headerlink" href="#parameters_362" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (N,) or (N,1).</p>
<h2 id="returns_290">Returns<a class="headerlink" href="#returns_290" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (M,) or (M,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_148">Notes<a class="headerlink" href="#notes_148" title="Permanent link">&para;</a></h2>
<p>This matvec wraps the user-specified matvec routine or overridden
_matvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-matrix multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array, or 2-d array.
The default implementation defers to the adjoint.</p>
<h2 id="parameters_363">Parameters<a class="headerlink" href="#parameters_363" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
A matrix or 2D array.</p>
<h2 id="returns_291">Returns<a class="headerlink" href="#returns_291" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or 2D array depending on the type of the input.</p>
<h2 id="notes_149">Notes<a class="headerlink" href="#notes_149" title="Permanent link">&para;</a></h2>
<p>This rmatmat wraps the user-specified rmatmat routine.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-vector multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_364">Parameters<a class="headerlink" href="#parameters_364" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (M,) or (M,1).</p>
<h2 id="returns_292">Returns<a class="headerlink" href="#returns_292" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (N,) or (N,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_150">Notes<a class="headerlink" href="#notes_150" title="Permanent link">&para;</a></h2>
<p>This rmatvec wraps the user-specified rmatvec routine or overridden
_rmatvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transpose this linear operator.</p>
<p>Returns a LinearOperator that represents the transpose of this one.
Can be abbreviated self.T instead of self.transpose().</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">ProductOperator</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ProductOperator</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">ProductOperator</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>For now, this is limited to products of multiple square matrices.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">adjoint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Hermitian adjoint.</p>
<p>Returns the Hermitian adjoint of self, aka the Hermitian
conjugate or Hermitian transpose. For a complex matrix, the
Hermitian adjoint is equal to the conjugate transpose.</p>
<p>Can be abbreviated self.H instead of self.adjoint().</p>
<h2 id="returns_293">Returns<a class="headerlink" href="#returns_293" title="Permanent link">&para;</a></h2>
<p>A_H : LinearOperator
Hermitian adjoint of self.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix or matrix-vector multiplication.</p>
<h2 id="parameters_365">Parameters<a class="headerlink" href="#parameters_365" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-d or 2-d array, representing a vector or matrix.</p>
<h2 id="returns_294">Returns<a class="headerlink" href="#returns_294" title="Permanent link">&para;</a></h2>
<p>Ax : array
1-d or 2-d array (depending on the shape of x) that represents
the result of applying this linear operator on x.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix multiplication.</p>
<p>Performs the operation y=A<em>X where A is an MxN linear
operator and X dense N</em>K matrix or ndarray.</p>
<h2 id="parameters_366">Parameters<a class="headerlink" href="#parameters_366" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
An array with shape (N,K).</p>
<h2 id="returns_295">Returns<a class="headerlink" href="#returns_295" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or ndarray with shape (M,K) depending on
the type of the X argument.</p>
<h2 id="notes_151">Notes<a class="headerlink" href="#notes_151" title="Permanent link">&para;</a></h2>
<p>This matmat wraps any user-specified matmat routine or overridden
_matmat method to ensure that y has the correct type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-vector multiplication.</p>
<p>Performs the operation y=A*x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_367">Parameters<a class="headerlink" href="#parameters_367" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (N,) or (N,1).</p>
<h2 id="returns_296">Returns<a class="headerlink" href="#returns_296" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (M,) or (M,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_152">Notes<a class="headerlink" href="#notes_152" title="Permanent link">&para;</a></h2>
<p>This matvec wraps the user-specified matvec routine or overridden
_matvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-matrix multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array, or 2-d array.
The default implementation defers to the adjoint.</p>
<h2 id="parameters_368">Parameters<a class="headerlink" href="#parameters_368" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
A matrix or 2D array.</p>
<h2 id="returns_297">Returns<a class="headerlink" href="#returns_297" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or 2D array depending on the type of the input.</p>
<h2 id="notes_153">Notes<a class="headerlink" href="#notes_153" title="Permanent link">&para;</a></h2>
<p>This rmatmat wraps the user-specified rmatmat routine.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-vector multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_369">Parameters<a class="headerlink" href="#parameters_369" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (M,) or (M,1).</p>
<h2 id="returns_298">Returns<a class="headerlink" href="#returns_298" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (N,) or (N,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_154">Notes<a class="headerlink" href="#notes_154" title="Permanent link">&para;</a></h2>
<p>This rmatvec wraps the user-specified rmatvec routine or overridden
_rmatvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transpose this linear operator.</p>
<p>Returns a LinearOperator that represents the transpose of this one.
Can be abbreviated self.T instead of self.transpose().</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">expm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix exponential using Pade approximation.</p>
<h2 id="parameters_370">Parameters<a class="headerlink" href="#parameters_370" title="Permanent link">&para;</a></h2>
<p>A : (M,M) array_like or sparse matrix
2D Array or Matrix (sparse or dense) to be exponentiated</p>
<h2 id="returns_299">Returns<a class="headerlink" href="#returns_299" title="Permanent link">&para;</a></h2>
<p>expA : (M,M) ndarray
Matrix exponential of <code>A</code></p>
<h2 id="notes_155">Notes<a class="headerlink" href="#notes_155" title="Permanent link">&para;</a></h2>
<p>This is algorithm (6.1) which is a simplification of algorithm (5.1).</p>
<p>.. versionadded:: 0.12.0</p>
<h2 id="references_24">References<a class="headerlink" href="#references_24" title="Permanent link">&para;</a></h2>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
'A New Scaling and Squaring Algorithm for the Matrix Exponential.'
SIAM Journal on Matrix Analysis and Applications.
31 (3). pp. 970-989. ISSN 1095-7162</p>
<h2 id="examples_208">Examples<a class="headerlink" href="#examples_208" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import expm
A = csc_matrix([[1, 0, 0], [0, 2, 0], [0, 0, 3]])
A.todense()
matrix([[1, 0, 0],
[0, 2, 0],
[0, 0, 3]], dtype=int64)
Aexp = expm(A)
Aexp
&lt;3x3 sparse matrix of type '<class 'numpy.float64'>'
with 3 stored elements in Compressed Sparse Column format&gt;
Aexp.todense()
matrix([[  2.71828183,   0.        ,   0.        ],
[  0.        ,   7.3890561 ,   0.        ],
[  0.        ,   0.        ,  20.08553692]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of a sparse matrix</p>
<h2 id="parameters_371">Parameters<a class="headerlink" href="#parameters_371" title="Permanent link">&para;</a></h2>
<p>A : (M,M) ndarray or sparse matrix
square matrix to be inverted</p>
<h2 id="returns_300">Returns<a class="headerlink" href="#returns_300" title="Permanent link">&para;</a></h2>
<p>Ainv : (M,M) ndarray or sparse matrix
inverse of <code>A</code></p>
<h2 id="notes_156">Notes<a class="headerlink" href="#notes_156" title="Permanent link">&para;</a></h2>
<p>This computes the sparse inverse of <code>A</code>.  If the inverse of <code>A</code> is expected
to be non-sparse, it will likely be faster to convert <code>A</code> to dense and use
scipy.linalg.inv.</p>
<h2 id="examples_209">Examples<a class="headerlink" href="#examples_209" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import inv
A = csc_matrix([[1., 0.], [1., 2.]])
Ainv = inv(A)
Ainv
&lt;2x2 sparse matrix of type '<class 'numpy.float64'>'
with 3 stored elements in Compressed Sparse Column format&gt;
A.dot(Ainv)
&lt;2x2 sparse matrix of type '<class 'numpy.float64'>'
with 2 stored elements in Compressed Sparse Column format&gt;
A.dot(Ainv).todense()
matrix([[ 1.,  0.],
[ 0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>.. versionadded:: 0.12.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_pydata_spmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Check whether object is pydata/sparse matrix, avoiding importing the module.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_372">Parameters<a class="headerlink" href="#parameters_372" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_301">Returns<a class="headerlink" href="#returns_301" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_157">Notes<a class="headerlink" href="#notes_157" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_210">Examples<a class="headerlink" href="#examples_210" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym_pos</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">assume_a</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">transposed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the linear equation set <code>a * x = b</code> for the unknown <code>x</code>
for square <code>a</code> matrix.</p>
<p>If the data matrix is known to be a particular type then supplying the
corresponding string to <code>assume_a</code> key chooses the dedicated solver.
The available options are</p>
<p>===================  ========
generic matrix       'gen'
symmetric            'sym'
hermitian            'her'
positive definite    'pos'
===================  ========</p>
<p>If omitted, <code>'gen'</code> is the default structure.</p>
<p>The datatype of the arrays define which solver is called regardless
of the values. In other words, even when the complex array entries have
precisely zero imaginary parts, the complex solver will be called based
on the data type of the array.</p>
<h2 id="parameters_373">Parameters<a class="headerlink" href="#parameters_373" title="Permanent link">&para;</a></h2>
<p>a : (N, N) array_like
Square input data
b : (N, NRHS) array_like
Input data for the right hand side.
sym_pos : bool, optional
Assume <code>a</code> is symmetric and positive definite. This key is deprecated
and assume_a = 'pos' keyword is recommended instead. The functionality
is the same. It will be removed in the future.
lower : bool, optional
If True, only the data contained in the lower triangle of <code>a</code>. Default
is to use upper triangle. (ignored for <code>'gen'</code>)
overwrite_a : bool, optional
Allow overwriting data in <code>a</code> (may enhance performance).
Default is False.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code> (may enhance performance).
Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
assume_a : str, optional
Valid entries are explained above.
transposed: bool, optional
If True, <code>a^T x = b</code> for real matrices, raises <code>NotImplementedError</code>
for complex matrices (only for True).</p>
<h2 id="returns_302">Returns<a class="headerlink" href="#returns_302" title="Permanent link">&para;</a></h2>
<p>x : (N, NRHS) ndarray
The solution array.</p>
<h2 id="raises_22">Raises<a class="headerlink" href="#raises_22" title="Permanent link">&para;</a></h2>
<p>ValueError
If size mismatches detected or input a is not square.
LinAlgError
If the matrix is singular.
LinAlgWarning
If an ill-conditioned input a is detected.
NotImplementedError
If transposed is True and input a is a complex matrix.</p>
<h2 id="examples_211">Examples<a class="headerlink" href="#examples_211" title="Permanent link">&para;</a></h2>
<p>Given <code>a</code> and <code>b</code>, solve for <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])
b = np.array([2, 4, -1])
from scipy import linalg
x = linalg.solve(a, b)
x
array([ 2., -2.,  9.])
np.dot(a, x) == b
array([ True,  True,  True], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="notes_158">Notes<a class="headerlink" href="#notes_158" title="Permanent link">&para;</a></h2>
<p>If the input b matrix is a 1D array with N elements, when supplied
together with an NxN input a, it is assumed as a valid column vector
despite the apparent size mismatch. This is compatible with the
numpy.dot() behavior and the returned result is still 1D array.</p>
<p>The generic, symmetric, hermitian and positive definite solutions are
obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of
LAPACK respectively.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_triangular</span> <span class="o">:</span> <span class="o">?</span><span class="n">trans</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">N</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">unit_diagonal</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation <code>a x = b</code> for <code>x</code>, assuming a is a triangular matrix.</p>
<h2 id="parameters_374">Parameters<a class="headerlink" href="#parameters_374" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A triangular matrix
b : (M,) or (M, N) array_like
Right-hand side matrix in <code>a x = b</code>
lower : bool, optional
Use only data contained in the lower triangle of <code>a</code>.
Default is to use upper triangle.
trans : {0, 1, 2, 'N', 'T', 'C'}, optional
Type of system to solve:</p>
<p>========  =========
trans     system
========  =========
0 or 'N'  a x  = b
1 or 'T'  a^T x = b
2 or 'C'  a^H x = b
========  =========
unit_diagonal : bool, optional
If True, diagonal elements of <code>a</code> are assumed to be 1 and
will not be referenced.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code> (may enhance performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_303">Returns<a class="headerlink" href="#returns_303" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, N) ndarray
Solution to the system <code>a x = b</code>.  Shape of return matches <code>b</code>.</p>
<h2 id="raises_23">Raises<a class="headerlink" href="#raises_23" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If <code>a</code> is singular</p>
<h2 id="notes_159">Notes<a class="headerlink" href="#notes_159" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.9.0</p>
<h2 id="examples_212">Examples<a class="headerlink" href="#examples_212" title="Permanent link">&para;</a></h2>
<p>Solve the lower triangular system a x = b, where::</p>
<p>[3  0  0  0]       [4]
a =  [2  1  0  0]   b = [2]
[1  0  1  0]       [4]
[1  1  1  1]       [2]</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import solve_triangular
a = np.array([[3, 0, 0, 0], [2, 1, 0, 0], [1, 0, 1, 0], [1, 1, 1, 1]])
b = np.array([4, 2, 4, 2])
x = solve_triangular(a, b, lower=True)
x
array([ 1.33333333, -0.66666667,  2.66666667, -1.33333333])
a.dot(x)  # Check the result
array([ 4.,  2.,  4.,  2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">speye</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sparse matrix with ones on diagonal</p>
<p>Returns a sparse (m x n) matrix where the k-th diagonal
is all ones and everything else is zeros.</p>
<h2 id="parameters_375">Parameters<a class="headerlink" href="#parameters_375" title="Permanent link">&para;</a></h2>
<p>m : int
Number of rows in the matrix.
n : int, optional
Number of columns. Default: <code>m</code>.
k : int, optional
Diagonal to place ones on. Default: 0 (main diagonal).
dtype : dtype, optional
Data type of the matrix.
format : str, optional
Sparse format of the result, e.g. format='csr', etc.</p>
<h2 id="examples_213">Examples<a class="headerlink" href="#examples_213" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import sparse
sparse.eye(3).toarray()
array([[ 1.,  0.,  0.],
[ 0.,  1.,  0.],
[ 0.,  0.,  1.]])
sparse.eye(3, dtype=np.int8)
&lt;3x3 sparse matrix of type '<class 'numpy.int8'>'
with 3 stored elements (1 diagonals) in DIAgonal format&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spsolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">use_umfpack</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the sparse linear system Ax=b, where b may be a vector or a matrix.</p>
<h2 id="parameters_376">Parameters<a class="headerlink" href="#parameters_376" title="Permanent link">&para;</a></h2>
<p>A : ndarray or sparse matrix
The square matrix A will be converted into CSC or CSR form
b : ndarray or sparse matrix
The matrix or vector representing the right hand side of the equation.
If a vector, b.shape must be (n,) or (n, 1).
permc_spec : str, optional
How to permute the columns of the matrix for sparsity preservation.
(default: 'COLAMD')</p>
<ul>
<li><code>NATURAL</code>: natural ordering.</li>
<li><code>MMD_ATA</code>: minimum degree ordering on the structure of A^T A.</li>
<li><code>MMD_AT_PLUS_A</code>: minimum degree ordering on the structure of A^T+A.</li>
<li><code>COLAMD</code>: approximate minimum degree column ordering
use_umfpack : bool, optional
if True (default) then use umfpack for the solution.  This is
only referenced if b is a vector and <code>scikit-umfpack</code> is installed.</li>
</ul>
<h2 id="returns_304">Returns<a class="headerlink" href="#returns_304" title="Permanent link">&para;</a></h2>
<p>x : ndarray or sparse matrix
the solution of the sparse linear equation.
If b is a vector, then x is a vector of size A.shape[1]
If b is a matrix, then x is a matrix of size (A.shape[1], b.shape[1])</p>
<h2 id="notes_160">Notes<a class="headerlink" href="#notes_160" title="Permanent link">&para;</a></h2>
<p>For solving the matrix expression AX = B, this solver assumes the resulting
matrix X is sparse, as is often the case for very sparse inputs.  If the
resulting X is dense, the construction of this sparse result will be
relatively expensive.  In that case, consider converting A to a dense
matrix and using scipy.linalg.solve or its variants.</p>
<h2 id="examples_214">Examples<a class="headerlink" href="#examples_214" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import spsolve
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
B = csc_matrix([[2, 0], [-1, 0], [2, 0]], dtype=float)
x = spsolve(A, B)
np.allclose(A.dot(x).todense(), B.todense())
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Utils</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">IdentityOperator</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IdentityOperator</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">IdentityOperator</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Common interface for performing matrix vector products</p>
<p>Many iterative methods (e.g. cg, gmres) do not need to know the
individual entries of a matrix to solve a linear system A<em>x=b.
Such solvers only require the computation of matrix vector
products, A</em>v where v is a dense vector.  This class serves as
an abstract interface between iterative solvers and matrix-like
objects.</p>
<p>To construct a concrete LinearOperator, either pass appropriate
callables to the constructor of this class, or subclass it.</p>
<p>A subclass must implement either one of the methods <code>_matvec</code>
and <code>_matmat</code>, and the attributes/properties <code>shape</code> (pair of
integers) and <code>dtype</code> (may be None). It may call the <code>__init__</code>
on this class to have these attributes validated. Implementing
<code>_matvec</code> automatically implements <code>_matmat</code> (using a naive
algorithm) and vice-versa.</p>
<p>Optionally, a subclass may implement <code>_rmatvec</code> or <code>_adjoint</code>
to implement the Hermitian adjoint (conjugate transpose). As with
<code>_matvec</code> and <code>_matmat</code>, implementing either <code>_rmatvec</code> or
<code>_adjoint</code> implements the other automatically. Implementing
<code>_adjoint</code> is preferable; <code>_rmatvec</code> is mostly there for
backwards compatibility.</p>
<h2 id="parameters_377">Parameters<a class="headerlink" href="#parameters_377" title="Permanent link">&para;</a></h2>
<p>shape : tuple
Matrix dimensions (M, N).
matvec : callable f(v)
Returns returns A * v.
rmatvec : callable f(v)
Returns A^H * v, where A^H is the conjugate transpose of A.
matmat : callable f(V)
Returns A * V, where V is a dense matrix with dimensions (N, K).
dtype : dtype
Data type of the matrix.
rmatmat : callable f(V)
Returns A^H * V, where V is a dense matrix with dimensions (M, K).</p>
<h2 id="attributes_13">Attributes<a class="headerlink" href="#attributes_13" title="Permanent link">&para;</a></h2>
<p>args : tuple
For linear operators describing products etc. of other linear
operators, the operands of the binary operation.</p>
<h2 id="see-also_157">See Also<a class="headerlink" href="#see-also_157" title="Permanent link">&para;</a></h2>
<p>aslinearoperator : Construct LinearOperators</p>
<h2 id="notes_161">Notes<a class="headerlink" href="#notes_161" title="Permanent link">&para;</a></h2>
<p>The user-defined matvec() function must properly handle the case
where v has shape (N,) as well as the (N,1) case.  The shape of
the return type is handled internally by LinearOperator.</p>
<p>LinearOperator instances can also be multiplied, added with each
other and exponentiated, all lazily: the result of these operations
is always a new, composite LinearOperator, that defers linear
operations to the original operators and combines the results.</p>
<p>More details regarding how to subclass a LinearOperator and several
examples of concrete LinearOperator instances can be found in the
external project <code>PyLops &lt;https://pylops.readthedocs.io&gt;</code>_.</p>
<h2 id="examples_215">Examples<a class="headerlink" href="#examples_215" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse.linalg import LinearOperator
def mv(v):
...     return np.array([2<em>v[0], 3</em>v[1]])
...
A = LinearOperator((2,2), matvec=mv)
A
&lt;2x2 _CustomLinearOperator with dtype=float64&gt;
A.matvec(np.ones(2))
array([ 2.,  3.])
A * np.ones(2)
array([ 2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">adjoint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Hermitian adjoint.</p>
<p>Returns the Hermitian adjoint of self, aka the Hermitian
conjugate or Hermitian transpose. For a complex matrix, the
Hermitian adjoint is equal to the conjugate transpose.</p>
<p>Can be abbreviated self.H instead of self.adjoint().</p>
<h2 id="returns_305">Returns<a class="headerlink" href="#returns_305" title="Permanent link">&para;</a></h2>
<p>A_H : LinearOperator
Hermitian adjoint of self.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix or matrix-vector multiplication.</p>
<h2 id="parameters_378">Parameters<a class="headerlink" href="#parameters_378" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-d or 2-d array, representing a vector or matrix.</p>
<h2 id="returns_306">Returns<a class="headerlink" href="#returns_306" title="Permanent link">&para;</a></h2>
<p>Ax : array
1-d or 2-d array (depending on the shape of x) that represents
the result of applying this linear operator on x.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix multiplication.</p>
<p>Performs the operation y=A<em>X where A is an MxN linear
operator and X dense N</em>K matrix or ndarray.</p>
<h2 id="parameters_379">Parameters<a class="headerlink" href="#parameters_379" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
An array with shape (N,K).</p>
<h2 id="returns_307">Returns<a class="headerlink" href="#returns_307" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or ndarray with shape (M,K) depending on
the type of the X argument.</p>
<h2 id="notes_162">Notes<a class="headerlink" href="#notes_162" title="Permanent link">&para;</a></h2>
<p>This matmat wraps any user-specified matmat routine or overridden
_matmat method to ensure that y has the correct type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-vector multiplication.</p>
<p>Performs the operation y=A*x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_380">Parameters<a class="headerlink" href="#parameters_380" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (N,) or (N,1).</p>
<h2 id="returns_308">Returns<a class="headerlink" href="#returns_308" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (M,) or (M,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_163">Notes<a class="headerlink" href="#notes_163" title="Permanent link">&para;</a></h2>
<p>This matvec wraps the user-specified matvec routine or overridden
_matvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-matrix multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array, or 2-d array.
The default implementation defers to the adjoint.</p>
<h2 id="parameters_381">Parameters<a class="headerlink" href="#parameters_381" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
A matrix or 2D array.</p>
<h2 id="returns_309">Returns<a class="headerlink" href="#returns_309" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or 2D array depending on the type of the input.</p>
<h2 id="notes_164">Notes<a class="headerlink" href="#notes_164" title="Permanent link">&para;</a></h2>
<p>This rmatmat wraps the user-specified rmatmat routine.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-vector multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_382">Parameters<a class="headerlink" href="#parameters_382" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (M,) or (M,1).</p>
<h2 id="returns_310">Returns<a class="headerlink" href="#returns_310" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (N,) or (N,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_165">Notes<a class="headerlink" href="#notes_165" title="Permanent link">&para;</a></h2>
<p>This rmatvec wraps the user-specified rmatvec routine or overridden
_rmatvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transpose this linear operator.</p>
<p>Returns a LinearOperator that represents the transpose of this one.
Can be abbreviated self.T instead of self.transpose().</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Matrix</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Matrix</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ArrayLike</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Matrix</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>matrix(data, dtype=None, copy=True)</p>
<p>.. note:: It is no longer recommended to use this class, even for linear
algebra. Instead use regular arrays. The class may be removed
in the future.</p>
<p>Returns a matrix from an array-like object, or from a string of data.
A matrix is a specialized 2-D array that retains its 2-D nature
through operations.  It has certain special operators, such as <code>*</code>
(matrix multiplication) and <code>**</code> (matrix power).</p>
<h2 id="parameters_383">Parameters<a class="headerlink" href="#parameters_383" title="Permanent link">&para;</a></h2>
<p>data : array_like or string
If <code>data</code> is a string, it is interpreted as a matrix with commas
or spaces separating columns, and semicolons separating rows.
dtype : data-type
Data-type of the output matrix.
copy : bool
If <code>data</code> is already an <code>ndarray</code>, then this flag determines
whether the data is copied (the default), or whether a view is
constructed.</p>
<h2 id="see-also_158">See Also<a class="headerlink" href="#see-also_158" title="Permanent link">&para;</a></h2>
<p>array</p>
<h2 id="examples_216">Examples<a class="headerlink" href="#examples_216" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.matrix('1 2; 3 4')
a
matrix([[1, 2],
[3, 4]])</p>
<p>np.matrix([[1, 2], [3, 4]])
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">index</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">setitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Set self[key] to value.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">all</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Test whether all matrix elements along a given axis evaluate to True.</p>
<h2 id="parameters_384">Parameters<a class="headerlink" href="#parameters_384" title="Permanent link">&para;</a></h2>
<p>See <code>numpy.all</code> for complete descriptions</p>
<h2 id="see-also_159">See Also<a class="headerlink" href="#see-also_159" title="Permanent link">&para;</a></h2>
<p>numpy.all</p>
<h2 id="notes_166">Notes<a class="headerlink" href="#notes_166" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.all</code>, but it returns a <code>matrix</code> object.</p>
<h2 id="examples_217">Examples<a class="headerlink" href="#examples_217" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
y = x[0]; y
matrix([[0, 1, 2, 3]])
(x == y)
matrix([[ True,  True,  True,  True],
[False, False, False, False],
[False, False, False, False]])
(x == y).all()
False
(x == y).all(0)
matrix([[False, False, False, False]])
(x == y).all(1)
matrix([[ True],
[False],
[False]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">any</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Test whether any array element along a given axis evaluates to True.</p>
<p>Refer to <code>numpy.any</code> for full documentation.</p>
<h2 id="parameters_385">Parameters<a class="headerlink" href="#parameters_385" title="Permanent link">&para;</a></h2>
<p>axis : int, optional
Axis along which logical OR is performed
out : ndarray, optional
Output to existing array instead of creating new one, must have
same shape as expected output</p>
<h2 id="returns_311">Returns<a class="headerlink" href="#returns_311" title="Permanent link">&para;</a></h2>
<p>any : bool, ndarray
Returns a single bool if <code>axis</code> is <code>None</code>; otherwise,
returns <code>ndarray</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argmax</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Indexes of the maximum values along an axis.</p>
<p>Return the indexes of the first occurrences of the maximum values
along the specified axis.  If axis is None, the index is for the
flattened matrix.</p>
<h2 id="parameters_386">Parameters<a class="headerlink" href="#parameters_386" title="Permanent link">&para;</a></h2>
<p>See <code>numpy.argmax</code> for complete descriptions</p>
<h2 id="see-also_160">See Also<a class="headerlink" href="#see-also_160" title="Permanent link">&para;</a></h2>
<p>numpy.argmax</p>
<h2 id="notes_167">Notes<a class="headerlink" href="#notes_167" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.argmax</code>, but returns a <code>matrix</code> object
where <code>ndarray.argmax</code> would return an <code>ndarray</code>.</p>
<h2 id="examples_218">Examples<a class="headerlink" href="#examples_218" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.argmax()
11
x.argmax(0)
matrix([[2, 2, 2, 2]])
x.argmax(1)
matrix([[3],
[3],
[3]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argmin</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Indexes of the minimum values along an axis.</p>
<p>Return the indexes of the first occurrences of the minimum values
along the specified axis.  If axis is None, the index is for the
flattened matrix.</p>
<h2 id="parameters_387">Parameters<a class="headerlink" href="#parameters_387" title="Permanent link">&para;</a></h2>
<p>See <code>numpy.argmin</code> for complete descriptions.</p>
<h2 id="see-also_161">See Also<a class="headerlink" href="#see-also_161" title="Permanent link">&para;</a></h2>
<p>numpy.argmin</p>
<h2 id="notes_168">Notes<a class="headerlink" href="#notes_168" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.argmin</code>, but returns a <code>matrix</code> object
where <code>ndarray.argmin</code> would return an <code>ndarray</code>.</p>
<h2 id="examples_219">Examples<a class="headerlink" href="#examples_219" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = -np.matrix(np.arange(12).reshape((3,4))); x
matrix([[  0,  -1,  -2,  -3],
[ -4,  -5,  -6,  -7],
[ -8,  -9, -10, -11]])
x.argmin()
11
x.argmin(0)
matrix([[2, 2, 2, 2]])
x.argmin(1)
matrix([[3],
[3],
[3]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argpartition</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kind</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">kth</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.argpartition(kth, axis=-1, kind='introselect', order=None)</p>
<p>Returns the indices that would partition this array.</p>
<p>Refer to <code>numpy.argpartition</code> for full documentation.</p>
<p>.. versionadded:: 1.8.0</p>
<h2 id="see-also_162">See Also<a class="headerlink" href="#see-also_162" title="Permanent link">&para;</a></h2>
<p>numpy.argpartition : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argsort</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kind</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.argsort(axis=-1, kind=None, order=None)</p>
<p>Returns the indices that would sort this array.</p>
<p>Refer to <code>numpy.argsort</code> for full documentation.</p>
<h2 id="see-also_163">See Also<a class="headerlink" href="#see-also_163" title="Permanent link">&para;</a></h2>
<p>numpy.argsort : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">astype</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">casting</span><span class="o">:[`</span><span class="nc">No</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Equiv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Safe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same_kind</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Unsafe</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)</p>
<p>Copy of the array, cast to a specified type.</p>
<h2 id="parameters_388">Parameters<a class="headerlink" href="#parameters_388" title="Permanent link">&para;</a></h2>
<p>dtype : str or dtype
Typecode or data-type to which the array is cast.
order : {'C', 'F', 'A', 'K'}, optional
Controls the memory layout order of the result.
'C' means C order, 'F' means Fortran order, 'A'
means 'F' order if all the arrays are Fortran contiguous,
'C' order otherwise, and 'K' means as close to the
order the array elements appear in memory as possible.
Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
Controls what kind of data casting may occur. Defaults to 'unsafe'
for backwards compatibility.</p>
<ul>
<li>'no' means the data types should not be cast at all.</li>
<li>'equiv' means only byte-order changes are allowed.</li>
<li>'safe' means only casts which can preserve values are allowed.</li>
<li>'same_kind' means only safe casts or casts within a kind,
like float64 to float32, are allowed.</li>
<li>'unsafe' means any data conversions may be done.
subok : bool, optional
If True, then sub-classes will be passed-through (default), otherwise
the returned array will be forced to be a base-class array.
copy : bool, optional
By default, astype always returns a newly allocated array. If this
is set to false, and the <code>dtype</code>, <code>order</code>, and <code>subok</code>
requirements are satisfied, the input array is returned instead
of a copy.</li>
</ul>
<h2 id="returns_312">Returns<a class="headerlink" href="#returns_312" title="Permanent link">&para;</a></h2>
<p>arr_t : ndarray
Unless <code>copy</code> is False and the other conditions for returning the input
array are satisfied (see description for <code>copy</code> input parameter), <code>arr_t</code>
is a new array of the same shape as the input array, with dtype, order
given by <code>dtype</code>, <code>order</code>.</p>
<h2 id="notes_169">Notes<a class="headerlink" href="#notes_169" title="Permanent link">&para;</a></h2>
<p>.. versionchanged:: 1.17.0
Casting between a simple data type and a structured one is possible only
for 'unsafe' casting.  Casting to multiple fields is allowed, but
casting from multiple fields is not.</p>
<p>.. versionchanged:: 1.9.0
Casting from numeric to string types in 'safe' casting mode requires
that the string dtype length is long enough to store the max
integer/float value converted.</p>
<h2 id="raises_24">Raises<a class="headerlink" href="#raises_24" title="Permanent link">&para;</a></h2>
<p>ComplexWarning
When casting from complex to float or int. To avoid this,
one should use <code>a.real.astype(t)</code>.</p>
<h2 id="examples_220">Examples<a class="headerlink" href="#examples_220" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 2.5])
x
array([1. ,  2. ,  2.5])</p>
<p>x.astype(int)
array([1, 2, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">byteswap</span> <span class="o">:</span> <span class="o">?</span><span class="n">inplace</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.byteswap(inplace=False)</p>
<p>Swap the bytes of the array elements</p>
<p>Toggle between low-endian and big-endian data representation by
returning a byteswapped array, optionally swapped in-place.
Arrays of byte-strings are not swapped. The real and imaginary
parts of a complex number are swapped individually.</p>
<h2 id="parameters_389">Parameters<a class="headerlink" href="#parameters_389" title="Permanent link">&para;</a></h2>
<p>inplace : bool, optional
If <code>True</code>, swap bytes in-place, default is <code>False</code>.</p>
<h2 id="returns_313">Returns<a class="headerlink" href="#returns_313" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The byteswapped array. If <code>inplace</code> is <code>True</code>, this is
a view to self.</p>
<h2 id="examples_221">Examples<a class="headerlink" href="#examples_221" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>A = np.array([1, 256, 8755], dtype=np.int16)
list(map(hex, A))
['0x1', '0x100', '0x2233']
A.byteswap(inplace=True)
array([  256,     1, 13090], dtype=int16)
list(map(hex, A))
['0x100', '0x1', '0x3322']</p>
</blockquote>
</blockquote>
</blockquote>
<p>Arrays of byte-strings are not swapped</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = np.array([b'ceg', b'fac'])
A.byteswap()
array([b'ceg', b'fac'], dtype='|S3')</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>A.newbyteorder().byteswap()</code> produces an array with the same values
but different representation in memory</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = np.array([1, 2, 3])
A.view(np.uint8)
array([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
0, 0], dtype=uint8)
A.newbyteorder().byteswap(inplace=True)
array([1, 2, 3])
A.view(np.uint8)
array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
0, 3], dtype=uint8)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">choose</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">choices</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.choose(choices, out=None, mode='raise')</p>
<p>Use an index array to construct a new array from a set of choices.</p>
<p>Refer to <code>numpy.choose</code> for full documentation.</p>
<h2 id="see-also_164">See Also<a class="headerlink" href="#see-also_164" title="Permanent link">&para;</a></h2>
<p>numpy.choose : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">clip</span> <span class="o">:</span> <span class="o">?</span><span class="n">min</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.clip(min=None, max=None, out=None, **kwargs)</p>
<p>Return an array whose values are limited to <code>[min, max]</code>.
One of max or min must be given.</p>
<p>Refer to <code>numpy.clip</code> for full documentation.</p>
<h2 id="see-also_165">See Also<a class="headerlink" href="#see-also_165" title="Permanent link">&para;</a></h2>
<p>numpy.clip : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">compress</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">condition</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.compress(condition, axis=None, out=None)</p>
<p>Return selected slices of this array along given axis.</p>
<p>Refer to <code>numpy.compress</code> for full documentation.</p>
<h2 id="see-also_166">See Also<a class="headerlink" href="#see-also_166" title="Permanent link">&para;</a></h2>
<p>numpy.compress : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conj</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.conj()</p>
<p>Complex-conjugate all elements.</p>
<p>Refer to <code>numpy.conjugate</code> for full documentation.</p>
<h2 id="see-also_167">See Also<a class="headerlink" href="#see-also_167" title="Permanent link">&para;</a></h2>
<p>numpy.conjugate : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjugate</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.conjugate()</p>
<p>Return the complex conjugate, element-wise.</p>
<p>Refer to <code>numpy.conjugate</code> for full documentation.</p>
<h2 id="see-also_168">See Also<a class="headerlink" href="#see-also_168" title="Permanent link">&para;</a></h2>
<p>numpy.conjugate : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">copy</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.copy(order='C')</p>
<p>Return a copy of the array.</p>
<h2 id="parameters_390">Parameters<a class="headerlink" href="#parameters_390" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F', 'A', 'K'}, optional
Controls the memory layout of the copy. 'C' means C-order,
'F' means F-order, 'A' means 'F' if <code>a</code> is Fortran contiguous,
'C' otherwise. 'K' means match the layout of <code>a</code> as closely
as possible. (Note that this function and :func:<code>numpy.copy</code> are very
similar, but have different default values for their order=
arguments.)</p>
<h2 id="see-also_169">See also<a class="headerlink" href="#see-also_169" title="Permanent link">&para;</a></h2>
<p>numpy.copy
numpy.copyto</p>
<h2 id="examples_222">Examples<a class="headerlink" href="#examples_222" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([[1,2,3],[4,5,6]], order='F')</p>
<p>y = x.copy()</p>
<p>x.fill(0)</p>
<p>x
array([[0, 0, 0],
[0, 0, 0]])</p>
<p>y
array([[1, 2, 3],
[4, 5, 6]])</p>
<p>y.flags['C_CONTIGUOUS']
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cumprod</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.cumprod(axis=None, dtype=None, out=None)</p>
<p>Return the cumulative product of the elements along the given axis.</p>
<p>Refer to <code>numpy.cumprod</code> for full documentation.</p>
<h2 id="see-also_170">See Also<a class="headerlink" href="#see-also_170" title="Permanent link">&para;</a></h2>
<p>numpy.cumprod : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cumsum</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.cumsum(axis=None, dtype=None, out=None)</p>
<p>Return the cumulative sum of the elements along the given axis.</p>
<p>Refer to <code>numpy.cumsum</code> for full documentation.</p>
<h2 id="see-also_171">See Also<a class="headerlink" href="#see-also_171" title="Permanent link">&para;</a></h2>
<p>numpy.cumsum : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">offset</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.diagonal(offset=0, axis1=0, axis2=1)</p>
<p>Return specified diagonals. In NumPy 1.9 the returned array is a
read-only view instead of a copy as in previous NumPy versions.  In
a future version the read-only restriction will be removed.</p>
<p>Refer to :func:<code>numpy.diagonal</code> for full documentation.</p>
<h2 id="see-also_172">See Also<a class="headerlink" href="#see-also_172" title="Permanent link">&para;</a></h2>
<p>numpy.diagonal : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.dot(b, out=None)</p>
<p>Dot product of two arrays.</p>
<p>Refer to <code>numpy.dot</code> for full documentation.</p>
<h2 id="see-also_173">See Also<a class="headerlink" href="#see-also_173" title="Permanent link">&para;</a></h2>
<p>numpy.dot : equivalent function</p>
<h2 id="examples_223">Examples<a class="headerlink" href="#examples_223" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.eye(2)
b = np.ones((2, 2)) * 2
a.dot(b)
array([[2.,  2.],
[2.,  2.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>This array method can be conveniently chained:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a.dot(b).dot(b)
array([[8.,  8.],
[8.,  8.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dump</span> <span class="o">:</span> <span class="n">file</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Path</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.dump(file)</p>
<p>Dump a pickle of the array to the specified file.
The array can be read back with pickle.load or numpy.load.</p>
<h2 id="parameters_391">Parameters<a class="headerlink" href="#parameters_391" title="Permanent link">&para;</a></h2>
<p>file : str or Path
A string naming the dump file.</p>
<p>.. versionchanged:: 1.17.0
<code>pathlib.Path</code> objects are now accepted.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dumps</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.dumps()</p>
<p>Returns the pickle of the array as a string.
pickle.loads or numpy.loads will convert the string back to an array.</p>
<h2 id="parameters_392">Parameters<a class="headerlink" href="#parameters_392" title="Permanent link">&para;</a></h2>
<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fill</span> <span class="o">:</span> <span class="k">value</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.fill(value)</p>
<p>Fill the array with a scalar value.</p>
<h2 id="parameters_393">Parameters<a class="headerlink" href="#parameters_393" title="Permanent link">&para;</a></h2>
<p>value : scalar
All elements of <code>a</code> will be assigned this value.</p>
<h2 id="examples_224">Examples<a class="headerlink" href="#examples_224" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
a.fill(0)
a
array([0, 0])
a = np.empty(2)
a.fill(1)
a
array([1.,  1.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">flatten</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a flattened copy of the matrix.</p>
<p>All <code>N</code> elements of the matrix are placed into a single row.</p>
<h2 id="parameters_394">Parameters<a class="headerlink" href="#parameters_394" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F', 'A', 'K'}, optional
'C' means to flatten in row-major (C-style) order. 'F' means to
flatten in column-major (Fortran-style) order. 'A' means to
flatten in column-major order if <code>m</code> is Fortran <em>contiguous</em> in
memory, row-major order otherwise. 'K' means to flatten <code>m</code> in
the order the elements occur in memory. The default is 'C'.</p>
<h2 id="returns_314">Returns<a class="headerlink" href="#returns_314" title="Permanent link">&para;</a></h2>
<p>y : matrix
A copy of the matrix, flattened to a <code>(1, N)</code> matrix where <code>N</code>
is the number of elements in the original matrix.</p>
<h2 id="see-also_174">See Also<a class="headerlink" href="#see-also_174" title="Permanent link">&para;</a></h2>
<p>ravel : Return a flattened array.
flat : A 1-D flat iterator over the matrix.</p>
<h2 id="examples_225">Examples<a class="headerlink" href="#examples_225" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>m = np.matrix([[1,2], [3,4]])
m.flatten()
matrix([[1, 2, 3, 4]])
m.flatten('F')
matrix([[1, 3, 2, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getA</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return <code>self</code> as an <code>ndarray</code> object.</p>
<p>Equivalent to <code>np.asarray(self)</code>.</p>
<h2 id="parameters_395">Parameters<a class="headerlink" href="#parameters_395" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="returns_315">Returns<a class="headerlink" href="#returns_315" title="Permanent link">&para;</a></h2>
<p>ret : ndarray
<code>self</code> as an <code>ndarray</code></p>
<h2 id="examples_226">Examples<a class="headerlink" href="#examples_226" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.getA()
array([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getA1</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return <code>self</code> as a flattened <code>ndarray</code>.</p>
<p>Equivalent to <code>np.asarray(x).ravel()</code></p>
<h2 id="parameters_396">Parameters<a class="headerlink" href="#parameters_396" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="returns_316">Returns<a class="headerlink" href="#returns_316" title="Permanent link">&para;</a></h2>
<p>ret : ndarray
<code>self</code>, 1-D, as an <code>ndarray</code></p>
<h2 id="examples_227">Examples<a class="headerlink" href="#examples_227" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.getA1()
array([ 0,  1,  2, ...,  9, 10, 11])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getH</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the (complex) conjugate transpose of <code>self</code>.</p>
<p>Equivalent to <code>np.transpose(self)</code> if <code>self</code> is real-valued.</p>
<h2 id="parameters_397">Parameters<a class="headerlink" href="#parameters_397" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="returns_317">Returns<a class="headerlink" href="#returns_317" title="Permanent link">&para;</a></h2>
<p>ret : matrix object
complex conjugate transpose of <code>self</code></p>
<h2 id="examples_228">Examples<a class="headerlink" href="#examples_228" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4)))
z = x - 1j*x; z
matrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],
[  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],
[  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])
z.getH()
matrix([[ 0. -0.j,  4. +4.j,  8. +8.j],
[ 1. +1.j,  5. +5.j,  9. +9.j],
[ 2. +2.j,  6. +6.j, 10.+10.j],
[ 3. +3.j,  7. +7.j, 11.+11.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getI</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the (multiplicative) inverse of invertible <code>self</code>.</p>
<h2 id="parameters_398">Parameters<a class="headerlink" href="#parameters_398" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="returns_318">Returns<a class="headerlink" href="#returns_318" title="Permanent link">&para;</a></h2>
<p>ret : matrix object
If <code>self</code> is non-singular, <code>ret</code> is such that <code>ret * self</code> ==
<code>self * ret</code> == <code>np.matrix(np.eye(self[0,:].size)</code> all return
<code>True</code>.</p>
<h2 id="raises_25">Raises<a class="headerlink" href="#raises_25" title="Permanent link">&para;</a></h2>
<p>numpy.linalg.LinAlgError: Singular matrix
If <code>self</code> is singular.</p>
<h2 id="see-also_175">See Also<a class="headerlink" href="#see-also_175" title="Permanent link">&para;</a></h2>
<p>linalg.inv</p>
<h2 id="examples_229">Examples<a class="headerlink" href="#examples_229" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>m = np.matrix('[1, 2; 3, 4]'); m
matrix([[1, 2],
[3, 4]])
m.getI()
matrix([[-2. ,  1. ],
[ 1.5, -0.5]])
m.getI() * m
matrix([[ 1.,  0.], # may vary
[ 0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getT</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the transpose of the matrix.</p>
<p>Does <em>not</em> conjugate!  For the complex conjugate transpose, use <code>.H</code>.</p>
<h2 id="parameters_399">Parameters<a class="headerlink" href="#parameters_399" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="returns_319">Returns<a class="headerlink" href="#returns_319" title="Permanent link">&para;</a></h2>
<p>ret : matrix object
The (non-conjugated) transpose of the matrix.</p>
<h2 id="see-also_176">See Also<a class="headerlink" href="#see-also_176" title="Permanent link">&para;</a></h2>
<p>transpose, getH</p>
<h2 id="examples_230">Examples<a class="headerlink" href="#examples_230" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>m = np.matrix('[1, 2; 3, 4]')
m
matrix([[1, 2],
[3, 4]])
m.getT()
matrix([[1, 3],
[2, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getfield</span> <span class="o">:</span> <span class="o">?</span><span class="n">offset</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.getfield(dtype, offset=0)</p>
<p>Returns a field of the given array as a certain type.</p>
<p>A field is a view of the array data with a given data-type. The values in
the view are determined by the given type and the offset into the current
array in bytes. The offset needs to be such that the view dtype fits in the
array dtype; for example an array of dtype complex128 has 16-byte elements.
If taking a view with a 32-bit integer (4 bytes), the offset needs to be
between 0 and 12 bytes.</p>
<h2 id="parameters_400">Parameters<a class="headerlink" href="#parameters_400" title="Permanent link">&para;</a></h2>
<p>dtype : str or dtype
The data type of the view. The dtype size of the view can not be larger
than that of the array itself.
offset : int
Number of bytes to skip before beginning the element view.</p>
<h2 id="examples_231">Examples<a class="headerlink" href="#examples_231" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.diag([1.+1.j]*2)
x[1, 1] = 2 + 4.j
x
array([[1.+1.j,  0.+0.j],
[0.+0.j,  2.+4.j]])
x.getfield(np.float64)
array([[1.,  0.],
[0.,  2.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>By choosing an offset of 8 bytes we can select the complex part of the
array for our view:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x.getfield(np.float64, offset=8)
array([[1.,  0.],
[0.,  4.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">item</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.item( *args)</p>
<p>Copy an element of an array to a standard Python scalar and return it.</p>
<h2 id="parameters_401">Parameters<a class="headerlink" href="#parameters_401" title="Permanent link">&para;</a></h2>
<p>*args : Arguments (variable number and type)</p>
<ul>
<li>
<p>none: in this case, the method only works for arrays
with one element (<code>a.size == 1</code>), which element is
copied into a standard Python scalar object and returned.</p>
</li>
<li>
<p>int_type: this argument is interpreted as a flat index into
the array, specifying which element to copy and return.</p>
</li>
<li>
<p>tuple of int_types: functions as does a single int_type argument,
except that the argument is interpreted as an nd-index into the
array.</p>
</li>
</ul>
<h2 id="returns_320">Returns<a class="headerlink" href="#returns_320" title="Permanent link">&para;</a></h2>
<p>z : Standard Python scalar object
A copy of the specified element of the array as a suitable
Python scalar</p>
<h2 id="notes_170">Notes<a class="headerlink" href="#notes_170" title="Permanent link">&para;</a></h2>
<p>When the data type of <code>a</code> is longdouble or clongdouble, item() returns
a scalar array object because there is no available Python scalar that
would not lose information. Void arrays return a buffer object for item(),
unless fields are defined, in which case a tuple is returned.</p>
<p><code>item</code> is very similar to a[args], except, instead of an array scalar,
a standard Python scalar is returned. This can be useful for speeding up
access to elements of the array and doing arithmetic on elements of the
array using Python's optimized math.</p>
<h2 id="examples_232">Examples<a class="headerlink" href="#examples_232" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.random.seed(123)
x = np.random.randint(9, size=(3, 3))
x
array([[2, 2, 6],
[1, 3, 6],
[1, 0, 1]])
x.item(3)
1
x.item(7)
0
x.item((0, 1))
2
x.item((2, 2))
1</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itemset</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.itemset( *args)</p>
<p>Insert scalar into an array (scalar is cast to array's dtype, if possible)</p>
<p>There must be at least 1 argument, and define the last argument
as <em>item</em>.  Then, <code>a.itemset( *args)</code> is equivalent to but faster
than <code>a[args] = item</code>.  The item should be a scalar value and <code>args</code>
must select a single item in the array <code>a</code>.</p>
<h2 id="parameters_402">Parameters<a class="headerlink" href="#parameters_402" title="Permanent link">&para;</a></h2>
<p>*args : Arguments
If one argument: a scalar, only used in case <code>a</code> is of size 1.
If two arguments: the last argument is the value to be set
and must be a scalar, the first argument specifies a single array
element location. It is either an int or a tuple.</p>
<h2 id="notes_171">Notes<a class="headerlink" href="#notes_171" title="Permanent link">&para;</a></h2>
<p>Compared to indexing syntax, <code>itemset</code> provides some speed increase
for placing a scalar into a particular location in an <code>ndarray</code>,
if you must do this.  However, generally this is discouraged:
among other problems, it complicates the appearance of the code.
Also, when using <code>itemset</code> (and <code>item</code>) inside a loop, be sure
to assign the methods to a local variable to avoid the attribute
look-up at each loop iteration.</p>
<h2 id="examples_233">Examples<a class="headerlink" href="#examples_233" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.random.seed(123)
x = np.random.randint(9, size=(3, 3))
x
array([[2, 2, 6],
[1, 3, 6],
[1, 0, 1]])
x.itemset(4, 0)
x.itemset((2, 2), 9)
x
array([[2, 2, 6],
[1, 0, 6],
[1, 0, 9]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">max</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the maximum value along an axis.</p>
<h2 id="parameters_403">Parameters<a class="headerlink" href="#parameters_403" title="Permanent link">&para;</a></h2>
<p>See <code>amax</code> for complete descriptions</p>
<h2 id="see-also_177">See Also<a class="headerlink" href="#see-also_177" title="Permanent link">&para;</a></h2>
<p>amax, ndarray.max</p>
<h2 id="notes_172">Notes<a class="headerlink" href="#notes_172" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.max</code>, but returns a <code>matrix</code> object
where <code>ndarray.max</code> would return an ndarray.</p>
<h2 id="examples_234">Examples<a class="headerlink" href="#examples_234" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.max()
11
x.max(0)
matrix([[ 8,  9, 10, 11]])
x.max(1)
matrix([[ 3],
[ 7],
[11]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the average of the matrix elements along the given axis.</p>
<p>Refer to <code>numpy.mean</code> for full documentation.</p>
<h2 id="see-also_178">See Also<a class="headerlink" href="#see-also_178" title="Permanent link">&para;</a></h2>
<p>numpy.mean</p>
<h2 id="notes_173">Notes<a class="headerlink" href="#notes_173" title="Permanent link">&para;</a></h2>
<p>Same as <code>ndarray.mean</code> except that, where that returns an <code>ndarray</code>,
this returns a <code>matrix</code> object.</p>
<h2 id="examples_235">Examples<a class="headerlink" href="#examples_235" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3, 4)))
x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.mean()
5.5
x.mean(0)
matrix([[4., 5., 6., 7.]])
x.mean(1)
matrix([[ 1.5],
[ 5.5],
[ 9.5]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">min</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the minimum value along an axis.</p>
<h2 id="parameters_404">Parameters<a class="headerlink" href="#parameters_404" title="Permanent link">&para;</a></h2>
<p>See <code>amin</code> for complete descriptions.</p>
<h2 id="see-also_179">See Also<a class="headerlink" href="#see-also_179" title="Permanent link">&para;</a></h2>
<p>amin, ndarray.min</p>
<h2 id="notes_174">Notes<a class="headerlink" href="#notes_174" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.min</code>, but returns a <code>matrix</code> object
where <code>ndarray.min</code> would return an ndarray.</p>
<h2 id="examples_236">Examples<a class="headerlink" href="#examples_236" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = -np.matrix(np.arange(12).reshape((3,4))); x
matrix([[  0,  -1,  -2,  -3],
[ -4,  -5,  -6,  -7],
[ -8,  -9, -10, -11]])
x.min()
-11
x.min(0)
matrix([[ -8,  -9, -10, -11]])
x.min(1)
matrix([[ -3],
[ -7],
[-11]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">newbyteorder</span> <span class="o">:</span> <span class="o">?</span><span class="n">new_order</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>arr.newbyteorder(new_order='S')</p>
<p>Return the array with the same data viewed with a different byte order.</p>
<p>Equivalent to::</p>
<p>arr.view(arr.dtype.newbytorder(new_order))</p>
<p>Changes are also made in all fields and sub-arrays of the array data
type.</p>
<h2 id="parameters_405">Parameters<a class="headerlink" href="#parameters_405" title="Permanent link">&para;</a></h2>
<p>new_order : string, optional
Byte order to force; a value from the byte order specifications
below. <code>new_order</code> codes can be any of:</p>
<ul>
<li>'S' - swap dtype from current to opposite endian</li>
<li>{'&lt;', 'L'} - little endian</li>
<li>{'&gt;', 'B'} - big endian</li>
<li>{'=', 'N'} - native order</li>
<li>{'|', 'I'} - ignore (no change to byte order)</li>
</ul>
<p>The default value ('S') results in swapping the current
byte order. The code does a case-insensitive check on the first
letter of <code>new_order</code> for the alternatives above.  For example,
any of 'B' or 'b' or 'biggish' are valid to specify big-endian.</p>
<h2 id="returns_321">Returns<a class="headerlink" href="#returns_321" title="Permanent link">&para;</a></h2>
<p>new_arr : array
New array object with the dtype reflecting given change to the
byte order.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nonzero</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.nonzero()</p>
<p>Return the indices of the elements that are non-zero.</p>
<p>Refer to <code>numpy.nonzero</code> for full documentation.</p>
<h2 id="see-also_180">See Also<a class="headerlink" href="#see-also_180" title="Permanent link">&para;</a></h2>
<p>numpy.nonzero : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">partition</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kind</span><span class="o">:[`</span><span class="nc">Introselect</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">StringList</span> <span class="k">of</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">kth</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.partition(kth, axis=-1, kind='introselect', order=None)</p>
<p>Rearranges the elements in the array in such a way that the value of the
element in kth position is in the position it would be in a sorted array.
All elements smaller than the kth element are moved before this element and
all equal or greater are moved behind it. The ordering of the elements in
the two partitions is undefined.</p>
<p>.. versionadded:: 1.8.0</p>
<h2 id="parameters_406">Parameters<a class="headerlink" href="#parameters_406" title="Permanent link">&para;</a></h2>
<p>kth : int or sequence of ints
Element index to partition by. The kth element value will be in its
final sorted position and all smaller elements will be moved before it
and all equal or greater elements behind it.
The order of all elements in the partitions is undefined.
If provided with a sequence of kth it will partition all elements
indexed by kth of them into their sorted position at once.
axis : int, optional
Axis along which to sort. Default is -1, which means sort along the
last axis.
kind : {'introselect'}, optional
Selection algorithm. Default is 'introselect'.
order : str or list of str, optional
When <code>a</code> is an array with fields defined, this argument specifies
which fields to compare first, second, etc. A single field can
be specified as a string, and not all fields need to be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</p>
<h2 id="see-also_181">See Also<a class="headerlink" href="#see-also_181" title="Permanent link">&para;</a></h2>
<p>numpy.partition : Return a parititioned copy of an array.
argpartition : Indirect partition.
sort : Full sort.</p>
<h2 id="notes_175">Notes<a class="headerlink" href="#notes_175" title="Permanent link">&para;</a></h2>
<p>See <code>np.partition</code> for notes on the different algorithms.</p>
<h2 id="examples_237">Examples<a class="headerlink" href="#examples_237" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([3, 4, 2, 1])
a.partition(3)
a
array([2, 1, 3, 4])</p>
<p>a.partition((1, 3))
a
array([1, 2, 3, 4])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">prod</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the product of the array elements over the given axis.</p>
<p>Refer to <code>prod</code> for full documentation.</p>
<h2 id="see-also_182">See Also<a class="headerlink" href="#see-also_182" title="Permanent link">&para;</a></h2>
<p>prod, ndarray.prod</p>
<h2 id="notes_176">Notes<a class="headerlink" href="#notes_176" title="Permanent link">&para;</a></h2>
<p>Same as <code>ndarray.prod</code>, except, where that returns an <code>ndarray</code>, this
returns a <code>matrix</code> object instead.</p>
<h2 id="examples_238">Examples<a class="headerlink" href="#examples_238" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.prod()
0
x.prod(0)
matrix([[  0,  45, 120, 231]])
x.prod(1)
matrix([[   0],
[ 840],
[7920]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ptp</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Peak-to-peak (maximum - minimum) value along the given axis.</p>
<p>Refer to <code>numpy.ptp</code> for full documentation.</p>
<h2 id="see-also_183">See Also<a class="headerlink" href="#see-also_183" title="Permanent link">&para;</a></h2>
<p>numpy.ptp</p>
<h2 id="notes_177">Notes<a class="headerlink" href="#notes_177" title="Permanent link">&para;</a></h2>
<p>Same as <code>ndarray.ptp</code>, except, where that would return an <code>ndarray</code> object,
this returns a <code>matrix</code> object.</p>
<h2 id="examples_239">Examples<a class="headerlink" href="#examples_239" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.ptp()
11
x.ptp(0)
matrix([[8, 8, 8, 8]])
x.ptp(1)
matrix([[3],
[3],
[3]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">put</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">indices</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">values</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.put(indices, values, mode='raise')</p>
<p>Set <code>a.flat[n] = values[n]</code> for all <code>n</code> in indices.</p>
<p>Refer to <code>numpy.put</code> for full documentation.</p>
<h2 id="see-also_184">See Also<a class="headerlink" href="#see-also_184" title="Permanent link">&para;</a></h2>
<p>numpy.put : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ravel</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a flattened matrix.</p>
<p>Refer to <code>numpy.ravel</code> for more documentation.</p>
<h2 id="parameters_407">Parameters<a class="headerlink" href="#parameters_407" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F', 'A', 'K'}, optional
The elements of <code>m</code> are read using this index order. 'C' means to
index the elements in C-like order, with the last axis index
changing fastest, back to the first axis index changing slowest.
'F' means to index the elements in Fortran-like index order, with
the first index changing fastest, and the last index changing
slowest. Note that the 'C' and 'F' options take no account of the
memory layout of the underlying array, and only refer to the order
of axis indexing.  'A' means to read the elements in Fortran-like
index order if <code>m</code> is Fortran <em>contiguous</em> in memory, C-like order
otherwise.  'K' means to read the elements in the order they occur
in memory, except for reversing the data when strides are negative.
By default, 'C' index order is used.</p>
<h2 id="returns_322">Returns<a class="headerlink" href="#returns_322" title="Permanent link">&para;</a></h2>
<p>ret : matrix
Return the matrix flattened to shape <code>(1, N)</code> where <code>N</code>
is the number of elements in the original matrix.
A copy is made only if necessary.</p>
<h2 id="see-also_185">See Also<a class="headerlink" href="#see-also_185" title="Permanent link">&para;</a></h2>
<p>matrix.flatten : returns a similar output matrix but always a copy
matrix.flat : a flat iterator on the array.
numpy.ravel : related function which returns an ndarray</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">repeat</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">repeats</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.repeat(repeats, axis=None)</p>
<p>Repeat elements of an array.</p>
<p>Refer to <code>numpy.repeat</code> for full documentation.</p>
<h2 id="see-also_186">See Also<a class="headerlink" href="#see-also_186" title="Permanent link">&para;</a></h2>
<p>numpy.repeat : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.reshape(shape, order='C')</p>
<p>Returns an array containing the same data with a new shape.</p>
<p>Refer to <code>numpy.reshape</code> for full documentation.</p>
<h2 id="see-also_187">See Also<a class="headerlink" href="#see-also_187" title="Permanent link">&para;</a></h2>
<p>numpy.reshape : equivalent function</p>
<h2 id="notes_178">Notes<a class="headerlink" href="#notes_178" title="Permanent link">&para;</a></h2>
<p>Unlike the free function <code>numpy.reshape</code>, this method on <code>ndarray</code> allows
the elements of the shape parameter to be passed in as separate arguments.
For example, <code>a.reshape(10, 11)</code> is equivalent to
<code>a.reshape((10, 11))</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resize</span> <span class="o">:</span> <span class="o">?</span><span class="n">refcheck</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">new_shape</span><span class="o">:[`</span><span class="nc">TupleOfInts</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_n_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.resize(new_shape, refcheck=True)</p>
<p>Change shape and size of array in-place.</p>
<h2 id="parameters_408">Parameters<a class="headerlink" href="#parameters_408" title="Permanent link">&para;</a></h2>
<p>new_shape : tuple of ints, or <code>n</code> ints
Shape of resized array.
refcheck : bool, optional
If False, reference count will not be checked. Default is True.</p>
<h2 id="returns_323">Returns<a class="headerlink" href="#returns_323" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="raises_26">Raises<a class="headerlink" href="#raises_26" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>a</code> does not own its own data or references or views to it exist,
and the data memory must be changed.
PyPy only: will always raise if the data memory must be changed, since
there is no reliable way to determine if references or views to it
exist.</p>
<p>SystemError
If the <code>order</code> keyword argument is specified. This behaviour is a
bug in NumPy.</p>
<h2 id="see-also_188">See Also<a class="headerlink" href="#see-also_188" title="Permanent link">&para;</a></h2>
<p>resize : Return a new array with the specified shape.</p>
<h2 id="notes_179">Notes<a class="headerlink" href="#notes_179" title="Permanent link">&para;</a></h2>
<p>This reallocates space for the data area if necessary.</p>
<p>Only contiguous arrays (data elements consecutive in memory) can be
resized.</p>
<p>The purpose of the reference count check is to make sure you
do not use this array as a buffer for another Python object and then
reallocate the memory. However, reference counts can increase in
other ways so if you are sure that you have not shared the memory
for this array with another Python object, then you may safely set
<code>refcheck</code> to False.</p>
<h2 id="examples_240">Examples<a class="headerlink" href="#examples_240" title="Permanent link">&para;</a></h2>
<p>Shrinking an array: array is flattened (in the order that the data are
stored in memory), resized, and reshaped:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[0, 1], [2, 3]], order='C')
a.resize((2, 1))
a
array([[0],
[1]])</p>
<p>a = np.array([[0, 1], [2, 3]], order='F')
a.resize((2, 1))
a
array([[0],
[2]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Enlarging an array: as above, but missing entries are filled with zeros:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([[0, 1], [2, 3]])
b.resize(2, 3) # new_shape parameter doesn't have to be a tuple
b
array([[0, 1, 2],
[3, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Referencing an array prevents resizing...</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = a
a.resize((1, 1))
Traceback (most recent call last):
...
ValueError: cannot resize an array that references or is referenced ...</p>
</blockquote>
</blockquote>
</blockquote>
<p>Unless <code>refcheck</code> is False:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a.resize((1, 1), refcheck=False)
a
array([[0]])
c
array([[0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">round</span> <span class="o">:</span> <span class="o">?</span><span class="n">decimals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.round(decimals=0, out=None)</p>
<p>Return <code>a</code> with each element rounded to the given number of decimals.</p>
<p>Refer to <code>numpy.around</code> for full documentation.</p>
<h2 id="see-also_189">See Also<a class="headerlink" href="#see-also_189" title="Permanent link">&para;</a></h2>
<p>numpy.around : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">searchsorted</span> <span class="o">:</span> <span class="o">?</span><span class="n">side</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sorter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.searchsorted(v, side='left', sorter=None)</p>
<p>Find indices where elements of v should be inserted in a to maintain order.</p>
<p>For full documentation, see <code>numpy.searchsorted</code></p>
<h2 id="see-also_190">See Also<a class="headerlink" href="#see-also_190" title="Permanent link">&para;</a></h2>
<p>numpy.searchsorted : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setfield</span> <span class="o">:</span> <span class="o">?</span><span class="n">offset</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">val_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.setfield(val, dtype, offset=0)</p>
<p>Put a value into a specified place in a field defined by a data-type.</p>
<p>Place <code>val</code> into <code>a</code>'s field defined by <code>dtype</code> and beginning <code>offset</code>
bytes into the field.</p>
<h2 id="parameters_409">Parameters<a class="headerlink" href="#parameters_409" title="Permanent link">&para;</a></h2>
<p>val : object
Value to be placed in field.
dtype : dtype object
Data-type of the field in which to place <code>val</code>.
offset : int, optional
The number of bytes into the field at which to place <code>val</code>.</p>
<h2 id="returns_324">Returns<a class="headerlink" href="#returns_324" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="see-also_191">See Also<a class="headerlink" href="#see-also_191" title="Permanent link">&para;</a></h2>
<p>getfield</p>
<h2 id="examples_241">Examples<a class="headerlink" href="#examples_241" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.eye(3)
x.getfield(np.float64)
array([[1.,  0.,  0.],
[0.,  1.,  0.],
[0.,  0.,  1.]])
x.setfield(3, np.int32)
x.getfield(np.int32)
array([[3, 3, 3],
[3, 3, 3],
[3, 3, 3]], dtype=int32)
x
array([[1.0e+000, 1.5e-323, 1.5e-323],
[1.5e-323, 1.0e+000, 1.5e-323],
[1.5e-323, 1.5e-323, 1.0e+000]])
x.setfield(np.eye(3), np.int32)
x
array([[1.,  0.,  0.],
[0.,  1.,  0.],
[0.,  0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setflags</span> <span class="o">:</span> <span class="o">?</span><span class="n">write</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">align</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">uic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.setflags(write=None, align=None, uic=None)</p>
<p>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
respectively.</p>
<p>These Boolean-valued flags affect how numpy interprets the memory
area used by <code>a</code> (see Notes below). The ALIGNED flag can only
be set to True if the data is actually aligned according to the type.
The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
to True. The flag WRITEABLE can only be set to True if the array owns its
own memory, or the ultimate owner of the memory exposes a writeable buffer
interface, or is a string. (The exception for string is made so that
unpickling can be done without copying memory.)</p>
<h2 id="parameters_410">Parameters<a class="headerlink" href="#parameters_410" title="Permanent link">&para;</a></h2>
<p>write : bool, optional
Describes whether or not <code>a</code> can be written to.
align : bool, optional
Describes whether or not <code>a</code> is aligned properly for its type.
uic : bool, optional
Describes whether or not <code>a</code> is a copy of another 'base' array.</p>
<h2 id="notes_180">Notes<a class="headerlink" href="#notes_180" title="Permanent link">&para;</a></h2>
<p>Array flags provide information about how the memory area used
for the array is to be interpreted. There are 7 Boolean flags
in use, only four of which can be changed by the user:
WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.</p>
<p>WRITEABLE (W) the data area can be written to;</p>
<p>ALIGNED (A) the data and strides are aligned appropriately for the hardware
(as determined by the compiler);</p>
<p>UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;</p>
<p>WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
called, the base array will be updated with the contents of this array.</p>
<p>All flags can be accessed using the single (upper case) letter as well
as the full name.</p>
<h2 id="examples_242">Examples<a class="headerlink" href="#examples_242" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>y = np.array([[3, 1, 7],
...               [2, 0, 0],
...               [8, 5, 9]])
y
array([[3, 1, 7],
[2, 0, 0],
[8, 5, 9]])
y.flags
C_CONTIGUOUS : True
F_CONTIGUOUS : False
OWNDATA : True
WRITEABLE : True
ALIGNED : True
WRITEBACKIFCOPY : False
UPDATEIFCOPY : False
y.setflags(write=0, align=0)
y.flags
C_CONTIGUOUS : True
F_CONTIGUOUS : False
OWNDATA : True
WRITEABLE : False
ALIGNED : False
WRITEBACKIFCOPY : False
UPDATEIFCOPY : False
y.setflags(uic=1)
Traceback (most recent call last):
File '<stdin>', line 1, in <module>
ValueError: cannot set WRITEBACKIFCOPY flag to True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sort</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kind</span><span class="o">:[`</span><span class="nc">Stable</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Quicksort</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Heapsort</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mergesort</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">StringList</span> <span class="k">of</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.sort(axis=-1, kind=None, order=None)</p>
<p>Sort an array in-place. Refer to <code>numpy.sort</code> for full documentation.</p>
<h2 id="parameters_411">Parameters<a class="headerlink" href="#parameters_411" title="Permanent link">&para;</a></h2>
<p>axis : int, optional
Axis along which to sort. Default is -1, which means sort along the
last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
and 'mergesort' use timsort under the covers and, in general, the
actual implementation will vary with datatype. The 'mergesort' option
is retained for backwards compatibility.</p>
<p>.. versionchanged:: 1.15.0.
The 'stable' option was added.</p>
<p>order : str or list of str, optional
When <code>a</code> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</p>
<h2 id="see-also_192">See Also<a class="headerlink" href="#see-also_192" title="Permanent link">&para;</a></h2>
<p>numpy.sort : Return a sorted copy of an array.
numpy.argsort : Indirect sort.
numpy.lexsort : Indirect stable sort on multiple keys.
numpy.searchsorted : Find elements in sorted array.
numpy.partition: Partial sort.</p>
<h2 id="notes_181">Notes<a class="headerlink" href="#notes_181" title="Permanent link">&para;</a></h2>
<p>See <code>numpy.sort</code> for notes on the different sorting algorithms.</p>
<h2 id="examples_243">Examples<a class="headerlink" href="#examples_243" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1,4], [3,1]])
a.sort(axis=1)
a
array([[1, 4],
[1, 3]])
a.sort(axis=0)
a
array([[1, 3],
[1, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Use the <code>order</code> keyword to specify a field to use when sorting a
structured array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])
a.sort(order='y')
a
array([(b'c', 1), (b'a', 2)],
dtype=[('x', 'S1'), ('y', '&lt;i8')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">squeeze</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a possibly reshaped matrix.</p>
<p>Refer to <code>numpy.squeeze</code> for more documentation.</p>
<h2 id="parameters_412">Parameters<a class="headerlink" href="#parameters_412" title="Permanent link">&para;</a></h2>
<p>axis : None or int or tuple of ints, optional
Selects a subset of the single-dimensional entries in the shape.
If an axis is selected with shape entry greater than one,
an error is raised.</p>
<h2 id="returns_325">Returns<a class="headerlink" href="#returns_325" title="Permanent link">&para;</a></h2>
<p>squeezed : matrix
The matrix, but as a (1, N) matrix if it had shape (N, 1).</p>
<h2 id="see-also_193">See Also<a class="headerlink" href="#see-also_193" title="Permanent link">&para;</a></h2>
<p>numpy.squeeze : related function</p>
<h2 id="notes_182">Notes<a class="headerlink" href="#notes_182" title="Permanent link">&para;</a></h2>
<p>If <code>m</code> has a single column then that column is returned
as the single row of a matrix.  Otherwise <code>m</code> is returned.
The returned matrix is always either <code>m</code> itself or a view into <code>m</code>.
Supplying an axis keyword argument will not affect the returned matrix
but it may cause an error to be raised.</p>
<h2 id="examples_244">Examples<a class="headerlink" href="#examples_244" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>c = np.matrix([[1], [2]])
c
matrix([[1],
[2]])
c.squeeze()
matrix([[1, 2]])
r = c.T
r
matrix([[1, 2]])
r.squeeze()
matrix([[1, 2]])
m = np.matrix([[1, 2], [3, 4]])
m.squeeze()
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">std</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ddof</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the standard deviation of the array elements along the given axis.</p>
<p>Refer to <code>numpy.std</code> for full documentation.</p>
<h2 id="see-also_194">See Also<a class="headerlink" href="#see-also_194" title="Permanent link">&para;</a></h2>
<p>numpy.std</p>
<h2 id="notes_183">Notes<a class="headerlink" href="#notes_183" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.std</code>, except that where an <code>ndarray</code> would
be returned, a <code>matrix</code> object is returned instead.</p>
<h2 id="examples_245">Examples<a class="headerlink" href="#examples_245" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3, 4)))
x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.std()
3.4520525295346629 # may vary
x.std(0)
matrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]]) # may vary
x.std(1)
matrix([[ 1.11803399],
[ 1.11803399],
[ 1.11803399]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the sum of the matrix elements, along the given axis.</p>
<p>Refer to <code>numpy.sum</code> for full documentation.</p>
<h2 id="see-also_195">See Also<a class="headerlink" href="#see-also_195" title="Permanent link">&para;</a></h2>
<p>numpy.sum</p>
<h2 id="notes_184">Notes<a class="headerlink" href="#notes_184" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.sum</code>, except that where an <code>ndarray</code> would
be returned, a <code>matrix</code> object is returned instead.</p>
<h2 id="examples_246">Examples<a class="headerlink" href="#examples_246" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix([[1, 2], [4, 3]])
x.sum()
10
x.sum(axis=1)
matrix([[3],
[7]])
x.sum(axis=1, dtype='float')
matrix([[3.],
[7.]])
out = np.zeros((2, 1), dtype='float')
x.sum(axis=1, dtype='float', out=np.asmatrix(out))
matrix([[3.],
[7.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">swapaxes</span> <span class="o">:</span> <span class="n">axis1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">axis2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.swapaxes(axis1, axis2)</p>
<p>Return a view of the array with <code>axis1</code> and <code>axis2</code> interchanged.</p>
<p>Refer to <code>numpy.swapaxes</code> for full documentation.</p>
<h2 id="see-also_196">See Also<a class="headerlink" href="#see-also_196" title="Permanent link">&para;</a></h2>
<p>numpy.swapaxes : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">take</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">indices</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.take(indices, axis=None, out=None, mode='raise')</p>
<p>Return an array formed from the elements of <code>a</code> at the given indices.</p>
<p>Refer to <code>numpy.take</code> for full documentation.</p>
<h2 id="see-also_197">See Also<a class="headerlink" href="#see-also_197" title="Permanent link">&para;</a></h2>
<p>numpy.take : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tobytes</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.tobytes(order='C')</p>
<p>Construct Python bytes containing the raw data bytes in the array.</p>
<p>Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either 'C' or 'Fortran',
or 'Any' order (the default is 'C'-order). 'Any' order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means 'Fortran' order.</p>
<p>.. versionadded:: 1.9.0</p>
<h2 id="parameters_413">Parameters<a class="headerlink" href="#parameters_413" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F', None}, optional
Order of the data for multidimensional arrays:
C, Fortran, or the same as for the original array.</p>
<h2 id="returns_326">Returns<a class="headerlink" href="#returns_326" title="Permanent link">&para;</a></h2>
<p>s : bytes
Python bytes exhibiting a copy of <code>a</code>'s raw data.</p>
<h2 id="examples_247">Examples<a class="headerlink" href="#examples_247" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')
x.tobytes()
b'\x00\x00\x01\x00\x02\x00\x03\x00'
x.tobytes('C') == x.tobytes()
True
x.tobytes('F')
b'\x00\x00\x02\x00\x01\x00\x03\x00'</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tofile</span> <span class="o">:</span> <span class="o">?</span><span class="n">sep</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">fid</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.tofile(fid, sep='', format='%s')</p>
<p>Write array to a file as text or binary (default).</p>
<p>Data is always written in 'C' order, independent of the order of <code>a</code>.
The data produced by this method can be recovered using the function
fromfile().</p>
<h2 id="parameters_414">Parameters<a class="headerlink" href="#parameters_414" title="Permanent link">&para;</a></h2>
<p>fid : file or str or Path
An open file object, or a string containing a filename.</p>
<p>.. versionchanged:: 1.17.0
<code>pathlib.Path</code> objects are now accepted.</p>
<p>sep : str
Separator between array items for text output.
If '' (empty), a binary file is written, equivalent to
<code>file.write(a.tobytes())</code>.
format : str
Format string for text file output.
Each entry in the array is formatted to text by first converting
it to the closest Python type, and then using 'format' % item.</p>
<h2 id="notes_185">Notes<a class="headerlink" href="#notes_185" title="Permanent link">&para;</a></h2>
<p>This is a convenience function for quick storage of array data.
Information on endianness and precision is lost, so this method is not a
good choice for files intended to archive data or transport data between
machines with different endianness. Some of these problems can be overcome
by outputting the data as text files, at the expense of speed and file
size.</p>
<p>When fid is a file object, array contents are directly written to the
file, bypassing the file object's <code>write</code> method. As a result, tofile
cannot be used with files objects supporting compression (e.g., GzipFile)
or file-like objects that do not support <code>fileno()</code> (e.g., BytesIO).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tolist</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the matrix as a (possibly nested) list.</p>
<p>See <code>ndarray.tolist</code> for full documentation.</p>
<h2 id="see-also_198">See Also<a class="headerlink" href="#see-also_198" title="Permanent link">&para;</a></h2>
<p>ndarray.tolist</p>
<h2 id="examples_248">Examples<a class="headerlink" href="#examples_248" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.tolist()
[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tostring</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.tostring(order='C')</p>
<p>Construct Python bytes containing the raw data bytes in the array.</p>
<p>Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either 'C' or 'Fortran',
or 'Any' order (the default is 'C'-order). 'Any' order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means 'Fortran' order.</p>
<p>This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.</p>
<h2 id="parameters_415">Parameters<a class="headerlink" href="#parameters_415" title="Permanent link">&para;</a></h2>
<p>order : {'C', 'F', None}, optional
Order of the data for multidimensional arrays:
C, Fortran, or the same as for the original array.</p>
<h2 id="returns_327">Returns<a class="headerlink" href="#returns_327" title="Permanent link">&para;</a></h2>
<p>s : bytes
Python bytes exhibiting a copy of <code>a</code>'s raw data.</p>
<h2 id="examples_249">Examples<a class="headerlink" href="#examples_249" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')
x.tobytes()
b'\x00\x00\x01\x00\x02\x00\x03\x00'
x.tobytes('C') == x.tobytes()
True
x.tobytes('F')
b'\x00\x00\x02\x00\x01\x00\x03\x00'</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">trace</span> <span class="o">:</span> <span class="o">?</span><span class="n">offset</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)</p>
<p>Return the sum along diagonals of the array.</p>
<p>Refer to <code>numpy.trace</code> for full documentation.</p>
<h2 id="see-also_199">See Also<a class="headerlink" href="#see-also_199" title="Permanent link">&para;</a></h2>
<p>numpy.trace : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.transpose( *axes)</p>
<p>Returns a view of the array with axes transposed.</p>
<p>For a 1-D array this has no effect, as a transposed vector is simply the
same vector. To convert a 1-D array into a 2D column vector, an additional
dimension must be added. <code>np.atleast2d(a).T</code> achieves this, as does
<code>a[:, np.newaxis]</code>.
For a 2-D array, this is a standard matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
<code>a.shape = (i[0], i[1], ... i[n-2], i[n-1])</code>, then
<code>a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])</code>.</p>
<h2 id="parameters_416">Parameters<a class="headerlink" href="#parameters_416" title="Permanent link">&para;</a></h2>
<p>axes : None, tuple of ints, or <code>n</code> ints</p>
<ul>
<li>
<p>None or no argument: reverses the order of the axes.</p>
</li>
<li>
<p>tuple of ints: <code>i</code> in the <code>j</code>-th place in the tuple means <code>a</code>'s
<code>i</code>-th axis becomes <code>a.transpose()</code>'s <code>j</code>-th axis.</p>
</li>
<li>
<p><code>n</code> ints: same as an n-tuple of the same ints (this form is
intended simply as a 'convenience' alternative to the tuple form)</p>
</li>
</ul>
<h2 id="returns_328">Returns<a class="headerlink" href="#returns_328" title="Permanent link">&para;</a></h2>
<p>out : ndarray
View of <code>a</code>, with axes suitably permuted.</p>
<h2 id="see-also_200">See Also<a class="headerlink" href="#see-also_200" title="Permanent link">&para;</a></h2>
<p>ndarray.T : Array property returning the array transposed.
ndarray.reshape : Give a new shape to an array without changing its data.</p>
<h2 id="examples_250">Examples<a class="headerlink" href="#examples_250" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2], [3, 4]])
a
array([[1, 2],
[3, 4]])
a.transpose()
array([[1, 3],
[2, 4]])
a.transpose((1, 0))
array([[1, 3],
[2, 4]])
a.transpose(1, 0)
array([[1, 3],
[2, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">var</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ddof</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the variance of the matrix elements, along the given axis.</p>
<p>Refer to <code>numpy.var</code> for full documentation.</p>
<h2 id="see-also_201">See Also<a class="headerlink" href="#see-also_201" title="Permanent link">&para;</a></h2>
<p>numpy.var</p>
<h2 id="notes_186">Notes<a class="headerlink" href="#notes_186" title="Permanent link">&para;</a></h2>
<p>This is the same as <code>ndarray.var</code>, except that where an <code>ndarray</code> would
be returned, a <code>matrix</code> object is returned instead.</p>
<h2 id="examples_251">Examples<a class="headerlink" href="#examples_251" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.matrix(np.arange(12).reshape((3, 4)))
x
matrix([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
x.var()
11.916666666666666
x.var(0)
matrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]]) # may vary
x.var(1)
matrix([[1.25],
[1.25],
[1.25]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">view</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">Ndarray_sub_class</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">type_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>a.view(dtype=None, type=None)</p>
<p>New view of array with the same data.</p>
<h2 id="parameters_417">Parameters<a class="headerlink" href="#parameters_417" title="Permanent link">&para;</a></h2>
<p>dtype : data-type or ndarray sub-class, optional
Data-type descriptor of the returned view, e.g., float32 or int16. The
default, None, results in the view having the same data-type as <code>a</code>.
This argument can also be specified as an ndarray sub-class, which
then specifies the type of the returned object (this is equivalent to
setting the <code>type</code> parameter).
type : Python type, optional
Type of the returned view, e.g., ndarray or matrix.  Again, the
default None results in type preservation.</p>
<h2 id="notes_187">Notes<a class="headerlink" href="#notes_187" title="Permanent link">&para;</a></h2>
<p><code>a.view()</code> is used two different ways:</p>
<p><code>a.view(some_dtype)</code> or <code>a.view(dtype=some_dtype)</code> constructs a view
of the array's memory with a different data-type.  This can cause a
reinterpretation of the bytes of memory.</p>
<p><code>a.view(ndarray_subclass)</code> or <code>a.view(type=ndarray_subclass)</code> just
returns an instance of <code>ndarray_subclass</code> that looks at the same array
(same shape, dtype, etc.)  This does not cause a reinterpretation of the
memory.</p>
<p>For <code>a.view(some_dtype)</code>, if <code>some_dtype</code> has a different number of
bytes per entry than the previous dtype (for example, converting a
regular array to a structured array), then the behavior of the view
cannot be predicted just from the superficial appearance of <code>a</code> (shown
by <code>print(a)</code>). It also depends on exactly how <code>a</code> is stored in
memory. Therefore if <code>a</code> is C-ordered versus fortran-ordered, versus
defined as a slice or transpose, etc., the view may give different
results.</p>
<h2 id="examples_252">Examples<a class="headerlink" href="#examples_252" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Viewing array data using a different type and dtype:</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = x.view(dtype=np.int16, type=np.matrix)
y
matrix([[513]], dtype=int16)
print(type(y))
<class 'numpy.matrix'></p>
</blockquote>
</blockquote>
</blockquote>
<p>Creating a view on a structured array so it can be used in calculations</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])
xv = x.view(dtype=np.int8).reshape(-1,2)
xv
array([[1, 2],
[3, 4]], dtype=int8)
xv.mean(0)
array([2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Making changes to the view changes the underlying array</p>
<blockquote>
<blockquote>
<blockquote>
<p>xv[0,1] = 20
x
array([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using a view to convert an array to a recarray:</p>
<blockquote>
<blockquote>
<blockquote>
<p>z = x.view(np.recarray)
z.a
array([1, 3], dtype=int8)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Views share data:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x[0] = (9, 10)
z[0]
(9, 10)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Views that change the dtype size (bytes per entry) should normally be
avoided on arrays defined by slices, transposes, fortran-ordering, etc.:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)
y = x[:, 0:2]
y
array([[1, 2],
[4, 5]], dtype=int16)
y.view(dtype=[('width', np.int16), ('length', np.int16)])
Traceback (most recent call last):
...
ValueError: To change to a dtype of a different size, the array must be C-contiguous
z = y.copy()
z.view(dtype=[('width', np.int16), ('length', np.int16)])
array([[(1, 2)],
[(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="kt">array</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">K</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ndmin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">object_</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h2 id="parameters_418">Parameters<a class="headerlink" href="#parameters_418" title="Permanent link">&para;</a></h2>
<p>object : array_like
An array, any object exposing the array interface, an object whose
<strong>array</strong> method returns an array, or any (nested) sequence.
dtype : data-type, optional
The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.
copy : bool, optional
If true (default), then the object is copied.  Otherwise, a copy will
only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<code>dtype</code>, <code>order</code>, etc.).
order : {'K', 'A', 'C', 'F'}, optional
Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless 'F' is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<p>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================</p>
<p>When <code>copy=False</code> and a copy is made for other reasons, the result is
the same as if <code>copy=True</code>, with some exceptions for <code>A</code>, see the
Notes section. The default order is 'K'.
subok : bool, optional
If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).
ndmin : int, optional
Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
<h2 id="returns_329">Returns<a class="headerlink" href="#returns_329" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array object satisfying the specified requirements.</p>
<h2 id="see-also_202">See Also<a class="headerlink" href="#see-also_202" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="notes_188">Notes<a class="headerlink" href="#notes_188" title="Permanent link">&para;</a></h2>
<p>When order is 'A' and <code>object</code> is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.</p>
<h2 id="examples_253">Examples<a class="headerlink" href="#examples_253" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3])
array([1, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Upcasting:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>More than one dimension:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([[1, 2], [3, 4]])
array([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Minimum dimensions 2:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Type provided:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Data-type consisting of more than one element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
x['a']
array([1, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Creating an array from sub-classes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array(np.mat('1 2; 3 4'))
array([[1, 2],
[3, 4]])</p>
<p>np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asanyarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an ndarray, but pass ndarray subclasses through.</p>
<h2 id="parameters_419">Parameters<a class="headerlink" href="#parameters_419" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes scalars, lists, lists of tuples, tuples, tuples of tuples,
tuples of lists, and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or column-major
(Fortran-style) memory representation.  Defaults to 'C'.</p>
<h2 id="returns_330">Returns<a class="headerlink" href="#returns_330" title="Permanent link">&para;</a></h2>
<p>out : ndarray or an ndarray subclass
Array interpretation of <code>a</code>.  If <code>a</code> is an ndarray or a subclass
of ndarray, it is returned as-is and no copy is performed.</p>
<h2 id="see-also_203">See Also<a class="headerlink" href="#see-also_203" title="Permanent link">&para;</a></h2>
<p>asarray : Similar function which always returns ndarrays.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and
Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_254">Examples<a class="headerlink" href="#examples_254" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asanyarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Instances of <code>ndarray</code> subclasses are passed through as-is:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_420">Parameters<a class="headerlink" href="#parameters_420" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_331">Returns<a class="headerlink" href="#returns_331" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_204">See Also<a class="headerlink" href="#see-also_204" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_255">Examples<a class="headerlink" href="#examples_255" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">aslinearoperator</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return A as a LinearOperator.</p>
<p>'A' may be any of the following types:
- ndarray
- matrix
- sparse matrix (e.g. csr_matrix, lil_matrix, etc.)
- LinearOperator
- An object with .shape and .matvec attributes</p>
<p>See the LinearOperator documentation for additional information.</p>
<h2 id="notes_189">Notes<a class="headerlink" href="#notes_189" title="Permanent link">&para;</a></h2>
<p>If 'A' has no .dtype attribute, the data type is determined by calling
:func:<code>LinearOperator.matvec()</code> - set the .dtype attribute to prevent this
call upon the linear operator creation.</p>
<h2 id="examples_256">Examples<a class="headerlink" href="#examples_256" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import aslinearoperator
M = np.array([[1,2,3],[4,5,6]], dtype=np.int32)
aslinearoperator(M)
&lt;2x3 MatrixLinearOperator with dtype=int32&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asmatrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">coerce</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">id</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">make_system</span> <span class="o">:</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Make a linear system Ax=b</p>
<h2 id="parameters_421">Parameters<a class="headerlink" href="#parameters_421" title="Permanent link">&para;</a></h2>
<p>A : LinearOperator
sparse or dense matrix (or any valid input to aslinearoperator)
M : {LinearOperator, Nones}
preconditioner
sparse or dense matrix (or any valid input to aslinearoperator)
x0 : {array_like, None}
initial guess to iterative method
b : array_like
right hand side</p>
<h2 id="returns_332">Returns<a class="headerlink" href="#returns_332" title="Permanent link">&para;</a></h2>
<p>(A, M, x, b, postprocess)
A : LinearOperator
matrix of the linear system
M : LinearOperator
preconditioner
x : rank 1 ndarray
initial guess
b : rank 1 ndarray
right hand side
postprocess : function
converts the solution vector to the appropriate
type and dimensions (e.g. (N,1) matrix)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_422">Parameters<a class="headerlink" href="#parameters_422" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_333">Returns<a class="headerlink" href="#returns_333" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_205">See Also<a class="headerlink" href="#see-also_205" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_257">Examples<a class="headerlink" href="#examples_257" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">aslinearoperator</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return A as a LinearOperator.</p>
<p>'A' may be any of the following types:
- ndarray
- matrix
- sparse matrix (e.g. csr_matrix, lil_matrix, etc.)
- LinearOperator
- An object with .shape and .matvec attributes</p>
<p>See the LinearOperator documentation for additional information.</p>
<h2 id="notes_190">Notes<a class="headerlink" href="#notes_190" title="Permanent link">&para;</a></h2>
<p>If 'A' has no .dtype attribute, the data type is determined by calling
:func:<code>LinearOperator.matvec()</code> - set the .dtype attribute to prevent this
call upon the linear operator creation.</p>
<h2 id="examples_258">Examples<a class="headerlink" href="#examples_258" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import aslinearoperator
M = np.array([[1,2,3],[4,5,6]], dtype=np.int32)
aslinearoperator(M)
&lt;2x3 MatrixLinearOperator with dtype=int32&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bicg</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use BIConjugate Gradient iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_423">Parameters<a class="headerlink" href="#parameters_423" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> and <code>A^T x</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_334">Returns<a class="headerlink" href="#returns_334" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_24">Other Parameters<a class="headerlink" href="#other-parameters_24" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bicgstab</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use BIConjugate Gradient STABilized iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_424">Parameters<a class="headerlink" href="#parameters_424" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_335">Returns<a class="headerlink" href="#returns_335" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_25">Other Parameters<a class="headerlink" href="#other-parameters_25" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cg</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Conjugate Gradient iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_425">Parameters<a class="headerlink" href="#parameters_425" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
<code>A</code> must represent a hermitian, positive definite matrix.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_336">Returns<a class="headerlink" href="#returns_336" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_26">Other Parameters<a class="headerlink" href="#other-parameters_26" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cgs</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Conjugate Gradient Squared iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_426">Parameters<a class="headerlink" href="#parameters_426" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real-valued N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_337">Returns<a class="headerlink" href="#returns_337" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_27">Other Parameters<a class="headerlink" href="#other-parameters_27" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigs</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sigma</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">which</span><span class="o">:[`</span><span class="nc">LM</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SM</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LR</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SR</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LI</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SI</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">v0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ncv</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_eigenvectors</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">minv</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">oPinv</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">oPpart</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find k eigenvalues and eigenvectors of the square matrix A.</p>
<p>Solves <code>A * x[i] = w[i] * x[i]</code>, the standard eigenvalue problem
for w[i] eigenvalues with corresponding eigenvectors x[i].</p>
<p>If M is specified, solves <code>A * x[i] = w[i] * M * x[i]</code>, the
generalized eigenvalue problem for w[i] eigenvalues
with corresponding eigenvectors x[i]</p>
<h2 id="parameters_427">Parameters<a class="headerlink" href="#parameters_427" title="Permanent link">&para;</a></h2>
<p>A : ndarray, sparse matrix or LinearOperator
An array, sparse matrix, or LinearOperator representing
the operation <code>A * x</code>, where A is a real or complex square matrix.
k : int, optional
The number of eigenvalues and eigenvectors desired.
<code>k</code> must be smaller than N-1. It is not possible to compute all
eigenvectors of a matrix.
M : ndarray, sparse matrix or LinearOperator, optional
An array, sparse matrix, or LinearOperator representing
the operation M*x for the generalized eigenvalue problem</p>
<p>A * x = w * M * x.</p>
<p>M must represent a real, symmetric matrix if A is real, and must
represent a complex, hermitian matrix if A is complex. For best
results, the data type of M should be the same as that of A.
Additionally:</p>
<p>If <code>sigma</code> is None, M is positive definite</p>
<p>If sigma is specified, M is positive semi-definite</p>
<p>If sigma is None, eigs requires an operator to compute the solution
of the linear equation <code>M * x = b</code>.  This is done internally via a
(sparse) LU decomposition for an explicit matrix M, or via an
iterative solver for a general linear operator.  Alternatively,
the user can supply the matrix or operator Minv, which gives
<code>x = Minv * b = M^-1 * b</code>.
sigma : real or complex, optional
Find eigenvalues near sigma using shift-invert mode.  This requires
an operator to compute the solution of the linear system
<code>[A - sigma * M] * x = b</code>, where M is the identity matrix if
unspecified. This is computed internally via a (sparse) LU
decomposition for explicit matrices A &amp; M, or via an iterative
solver if either A or M is a general linear operator.
Alternatively, the user can supply the matrix or operator OPinv,
which gives <code>x = OPinv * b = [A - sigma * M]^-1 * b</code>.
For a real matrix A, shift-invert can either be done in imaginary
mode or real mode, specified by the parameter OPpart ('r' or 'i').
Note that when sigma is specified, the keyword 'which' (below)
refers to the shifted eigenvalues <code>w'[i]</code> where:</p>
<p>If A is real and OPpart == 'r' (default),
<code>w'[i] = 1/2 * [1/(w[i]-sigma) + 1/(w[i]-conj(sigma))]</code>.</p>
<p>If A is real and OPpart == 'i',
<code>w'[i] = 1/2i * [1/(w[i]-sigma) - 1/(w[i]-conj(sigma))]</code>.</p>
<p>If A is complex, <code>w'[i] = 1/(w[i]-sigma)</code>.</p>
<p>v0 : ndarray, optional
Starting vector for iteration.
Default: random
ncv : int, optional
The number of Lanczos vectors generated
<code>ncv</code> must be greater than <code>k</code>; it is recommended that <code>ncv &gt; 2*k</code>.
Default: <code>min(n, max(2*k + 1, 20))</code>
which : str, ['LM' | 'SM' | 'LR' | 'SR' | 'LI' | 'SI'], optional
Which <code>k</code> eigenvectors and eigenvalues to find:</p>
<p>'LM' : largest magnitude</p>
<p>'SM' : smallest magnitude</p>
<p>'LR' : largest real part</p>
<p>'SR' : smallest real part</p>
<p>'LI' : largest imaginary part</p>
<p>'SI' : smallest imaginary part</p>
<p>When sigma != None, 'which' refers to the shifted eigenvalues w'[i]
(see discussion in 'sigma', above).  ARPACK is generally better
at finding large values than small values.  If small eigenvalues are
desired, consider using shift-invert mode for better performance.
maxiter : int, optional
Maximum number of Arnoldi update iterations allowed
Default: <code>n*10</code>
tol : float, optional
Relative accuracy for eigenvalues (stopping criterion)
The default value of 0 implies machine precision.
return_eigenvectors : bool, optional
Return eigenvectors (True) in addition to eigenvalues
Minv : ndarray, sparse matrix or LinearOperator, optional
See notes in M, above.
OPinv : ndarray, sparse matrix or LinearOperator, optional
See notes in sigma, above.
OPpart : {'r' or 'i'}, optional
See notes in sigma, above</p>
<h2 id="returns_338">Returns<a class="headerlink" href="#returns_338" title="Permanent link">&para;</a></h2>
<p>w : ndarray
Array of k eigenvalues.
v : ndarray
An array of <code>k</code> eigenvectors.
<code>v[:, i]</code> is the eigenvector corresponding to the eigenvalue w[i].</p>
<h2 id="raises_27">Raises<a class="headerlink" href="#raises_27" title="Permanent link">&para;</a></h2>
<p>ArpackNoConvergence
When the requested convergence is not obtained.
The currently converged eigenvalues and eigenvectors can be found
as <code>eigenvalues</code> and <code>eigenvectors</code> attributes of the exception
object.</p>
<h2 id="see-also_206">See Also<a class="headerlink" href="#see-also_206" title="Permanent link">&para;</a></h2>
<p>eigsh : eigenvalues and eigenvectors for symmetric matrix A
svds : singular value decomposition for a matrix A</p>
<h2 id="notes_191">Notes<a class="headerlink" href="#notes_191" title="Permanent link">&para;</a></h2>
<p>This function is a wrapper to the ARPACK [1]<em> SNEUPD, DNEUPD, CNEUPD,
ZNEUPD, functions which use the Implicitly Restarted Arnoldi Method to
find the eigenvalues and eigenvectors [2]</em>.</p>
<h2 id="references_25">References<a class="headerlink" href="#references_25" title="Permanent link">&para;</a></h2>
<p>.. [1] ARPACK Software, http://www.caam.rice.edu/software/ARPACK/
.. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE:
Solution of Large Scale Eigenvalue Problems by Implicitly Restarted
Arnoldi Methods. SIAM, Philadelphia, PA, 1998.</p>
<h2 id="examples_259">Examples<a class="headerlink" href="#examples_259" title="Permanent link">&para;</a></h2>
<p>Find 6 eigenvectors of the identity matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import eigs
id = np.eye(13)
vals, vecs = eigs(id, k=6)
vals
array([ 1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j])
vecs.shape
(13, 6)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigsh</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sigma</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">which</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">v0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ncv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_eigenvectors</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">minv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">oPinv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find k eigenvalues and eigenvectors of the real symmetric square matrix
or complex hermitian matrix A.</p>
<p>Solves <code>A * x[i] = w[i] * x[i]</code>, the standard eigenvalue problem for
w[i] eigenvalues with corresponding eigenvectors x[i].</p>
<p>If M is specified, solves <code>A * x[i] = w[i] * M * x[i]</code>, the
generalized eigenvalue problem for w[i] eigenvalues
with corresponding eigenvectors x[i].</p>
<h2 id="parameters_428">Parameters<a class="headerlink" href="#parameters_428" title="Permanent link">&para;</a></h2>
<p>A : ndarray, sparse matrix or LinearOperator
A square operator representing the operation <code>A * x</code>, where <code>A</code> is
real symmetric or complex hermitian. For buckling mode (see below)
<code>A</code> must additionally be positive-definite.
k : int, optional
The number of eigenvalues and eigenvectors desired.
<code>k</code> must be smaller than N. It is not possible to compute all
eigenvectors of a matrix.</p>
<h2 id="returns_339">Returns<a class="headerlink" href="#returns_339" title="Permanent link">&para;</a></h2>
<p>w : array
Array of k eigenvalues.
v : array
An array representing the <code>k</code> eigenvectors.  The column <code>v[:, i]</code> is
the eigenvector corresponding to the eigenvalue <code>w[i]</code>.</p>
<h2 id="other-parameters_28">Other Parameters<a class="headerlink" href="#other-parameters_28" title="Permanent link">&para;</a></h2>
<p>M : An N x N matrix, array, sparse matrix, or linear operator representing
the operation <code>M @ x</code> for the generalized eigenvalue problem</p>
<p>A @ x = w * M @ x.</p>
<p>M must represent a real, symmetric matrix if A is real, and must
represent a complex, hermitian matrix if A is complex. For best
results, the data type of M should be the same as that of A.
Additionally:</p>
<p>If sigma is None, M is symmetric positive definite.</p>
<p>If sigma is specified, M is symmetric positive semi-definite.</p>
<p>In buckling mode, M is symmetric indefinite.</p>
<p>If sigma is None, eigsh requires an operator to compute the solution
of the linear equation <code>M @ x = b</code>. This is done internally via a
(sparse) LU decomposition for an explicit matrix M, or via an
iterative solver for a general linear operator.  Alternatively,
the user can supply the matrix or operator Minv, which gives
<code>x = Minv @ b = M^-1 @ b</code>.
sigma : real
Find eigenvalues near sigma using shift-invert mode.  This requires
an operator to compute the solution of the linear system
<code>[A - sigma * M] x = b</code>, where M is the identity matrix if
unspecified.  This is computed internally via a (sparse) LU
decomposition for explicit matrices A &amp; M, or via an iterative
solver if either A or M is a general linear operator.
Alternatively, the user can supply the matrix or operator OPinv,
which gives <code>x = OPinv @ b = [A - sigma * M]^-1 @ b</code>.
Note that when sigma is specified, the keyword 'which' refers to
the shifted eigenvalues <code>w'[i]</code> where:</p>
<p>if mode == 'normal', <code>w'[i] = 1 / (w[i] - sigma)</code>.</p>
<p>if mode == 'cayley', <code>w'[i] = (w[i] + sigma) / (w[i] - sigma)</code>.</p>
<p>if mode == 'buckling', <code>w'[i] = w[i] / (w[i] - sigma)</code>.</p>
<p>(see further discussion in 'mode' below)
v0 : ndarray, optional
Starting vector for iteration.
Default: random
ncv : int, optional
The number of Lanczos vectors generated ncv must be greater than k and
smaller than n; it is recommended that <code>ncv &gt; 2*k</code>.
Default: <code>min(n, max(2*k + 1, 20))</code>
which : str ['LM' | 'SM' | 'LA' | 'SA' | 'BE']
If A is a complex hermitian matrix, 'BE' is invalid.
Which <code>k</code> eigenvectors and eigenvalues to find:</p>
<p>'LM' : Largest (in magnitude) eigenvalues.</p>
<p>'SM' : Smallest (in magnitude) eigenvalues.</p>
<p>'LA' : Largest (algebraic) eigenvalues.</p>
<p>'SA' : Smallest (algebraic) eigenvalues.</p>
<p>'BE' : Half (k/2) from each end of the spectrum.</p>
<p>When k is odd, return one more (k/2+1) from the high end.
When sigma != None, 'which' refers to the shifted eigenvalues <code>w'[i]</code>
(see discussion in 'sigma', above).  ARPACK is generally better
at finding large values than small values.  If small eigenvalues are
desired, consider using shift-invert mode for better performance.
maxiter : int, optional
Maximum number of Arnoldi update iterations allowed.
Default: <code>n*10</code>
tol : float
Relative accuracy for eigenvalues (stopping criterion).
The default value of 0 implies machine precision.
Minv : N x N matrix, array, sparse matrix, or LinearOperator
See notes in M, above.
OPinv : N x N matrix, array, sparse matrix, or LinearOperator
See notes in sigma, above.
return_eigenvectors : bool
Return eigenvectors (True) in addition to eigenvalues.
This value determines the order in which eigenvalues are sorted.
The sort order is also dependent on the <code>which</code> variable.</p>
<p>For which = 'LM' or 'SA':
If <code>return_eigenvectors</code> is True, eigenvalues are sorted by
algebraic value.</p>
<p>If <code>return_eigenvectors</code> is False, eigenvalues are sorted by
absolute value.</p>
<p>For which = 'BE' or 'LA':
eigenvalues are always sorted by algebraic value.</p>
<p>For which = 'SM':
If <code>return_eigenvectors</code> is True, eigenvalues are sorted by
algebraic value.</p>
<p>If <code>return_eigenvectors</code> is False, eigenvalues are sorted by
decreasing absolute value.</p>
<p>mode : string ['normal' | 'buckling' | 'cayley']
Specify strategy to use for shift-invert mode.  This argument applies
only for real-valued A and sigma != None.  For shift-invert mode,
ARPACK internally solves the eigenvalue problem
<code>OP * x'[i] = w'[i] * B * x'[i]</code>
and transforms the resulting Ritz vectors x'[i] and Ritz values w'[i]
into the desired eigenvectors and eigenvalues of the problem
<code>A * x[i] = w[i] * M * x[i]</code>.
The modes are as follows:</p>
<p>'normal' :
OP = [A - sigma * M]^-1 @ M,
B = M,
w'[i] = 1 / (w[i] - sigma)</p>
<p>'buckling' :
OP = [A - sigma * M]^-1 @ A,
B = A,
w'[i] = w[i] / (w[i] - sigma)</p>
<p>'cayley' :
OP = [A - sigma * M]^-1 @ [A + sigma * M],
B = M,
w'[i] = (w[i] + sigma) / (w[i] - sigma)</p>
<p>The choice of mode will affect which eigenvalues are selected by
the keyword 'which', and can also impact the stability of
convergence (see [2] for a discussion).</p>
<h2 id="raises_28">Raises<a class="headerlink" href="#raises_28" title="Permanent link">&para;</a></h2>
<p>ArpackNoConvergence
When the requested convergence is not obtained.</p>
<p>The currently converged eigenvalues and eigenvectors can be found
as <code>eigenvalues</code> and <code>eigenvectors</code> attributes of the exception
object.</p>
<h2 id="see-also_207">See Also<a class="headerlink" href="#see-also_207" title="Permanent link">&para;</a></h2>
<p>eigs : eigenvalues and eigenvectors for a general (nonsymmetric) matrix A
svds : singular value decomposition for a matrix A</p>
<h2 id="notes_192">Notes<a class="headerlink" href="#notes_192" title="Permanent link">&para;</a></h2>
<p>This function is a wrapper to the ARPACK [1]<em> SSEUPD and DSEUPD
functions which use the Implicitly Restarted Lanczos Method to
find the eigenvalues and eigenvectors [2]</em>.</p>
<h2 id="references_26">References<a class="headerlink" href="#references_26" title="Permanent link">&para;</a></h2>
<p>.. [1] ARPACK Software, http://www.caam.rice.edu/software/ARPACK/
.. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE:
Solution of Large Scale Eigenvalue Problems by Implicitly Restarted
Arnoldi Methods. SIAM, Philadelphia, PA, 1998.</p>
<h2 id="examples_260">Examples<a class="headerlink" href="#examples_260" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import eigsh
identity = np.eye(13)
eigenvalues, eigenvectors = eigsh(identity, k=6)
eigenvalues
array([1., 1., 1., 1., 1., 1.])
eigenvectors.shape
(13, 6)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix exponential using Pade approximation.</p>
<h2 id="parameters_429">Parameters<a class="headerlink" href="#parameters_429" title="Permanent link">&para;</a></h2>
<p>A : (M,M) array_like or sparse matrix
2D Array or Matrix (sparse or dense) to be exponentiated</p>
<h2 id="returns_340">Returns<a class="headerlink" href="#returns_340" title="Permanent link">&para;</a></h2>
<p>expA : (M,M) ndarray
Matrix exponential of <code>A</code></p>
<h2 id="notes_193">Notes<a class="headerlink" href="#notes_193" title="Permanent link">&para;</a></h2>
<p>This is algorithm (6.1) which is a simplification of algorithm (5.1).</p>
<p>.. versionadded:: 0.12.0</p>
<h2 id="references_27">References<a class="headerlink" href="#references_27" title="Permanent link">&para;</a></h2>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
'A New Scaling and Squaring Algorithm for the Matrix Exponential.'
SIAM Journal on Matrix Analysis and Applications.
31 (3). pp. 970-989. ISSN 1095-7162</p>
<h2 id="examples_261">Examples<a class="headerlink" href="#examples_261" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import expm
A = csc_matrix([[1, 0, 0], [0, 2, 0], [0, 0, 3]])
A.todense()
matrix([[1, 0, 0],
[0, 2, 0],
[0, 0, 3]], dtype=int64)
Aexp = expm(A)
Aexp
&lt;3x3 sparse matrix of type '<class 'numpy.float64'>'
with 3 stored elements in Compressed Sparse Column format&gt;
Aexp.todense()
matrix([[  2.71828183,   0.        ,   0.        ],
[  0.        ,   7.3890561 ,   0.        ],
[  0.        ,   0.        ,  20.08553692]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm_multiply</span> <span class="o">:</span> <span class="o">?</span><span class="n">start</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stop</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">num</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">endpoint</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the action of the matrix exponential of A on B.</p>
<h2 id="parameters_430">Parameters<a class="headerlink" href="#parameters_430" title="Permanent link">&para;</a></h2>
<p>A : transposable linear operator
The operator whose exponential is of interest.
B : ndarray
The matrix or vector to be multiplied by the matrix exponential of A.
start : scalar, optional
The starting time point of the sequence.
stop : scalar, optional
The end time point of the sequence, unless <code>endpoint</code> is set to False.
In that case, the sequence consists of all but the last of <code>num + 1</code>
evenly spaced time points, so that <code>stop</code> is excluded.
Note that the step size changes when <code>endpoint</code> is False.
num : int, optional
Number of time points to use.
endpoint : bool, optional
If True, <code>stop</code> is the last time point.  Otherwise, it is not included.</p>
<h2 id="returns_341">Returns<a class="headerlink" href="#returns_341" title="Permanent link">&para;</a></h2>
<p>expm_A_B : ndarray
The result of the action :math:<code>e^{t_k A} B</code>.</p>
<h2 id="notes_194">Notes<a class="headerlink" href="#notes_194" title="Permanent link">&para;</a></h2>
<p>The optional arguments defining the sequence of evenly spaced time points
are compatible with the arguments of <code>numpy.linspace</code>.</p>
<p>The output ndarray shape is somewhat complicated so I explain it here.
The ndim of the output could be either 1, 2, or 3.
It would be 1 if you are computing the expm action on a single vector
at a single time point.
It would be 2 if you are computing the expm action on a vector
at multiple time points, or if you are computing the expm action
on a matrix at a single time point.
It would be 3 if you want the action on a matrix with multiple
columns at multiple time points.
If multiple time points are requested, expm_A_B[0] will always
be the action of the expm at the first time point,
regardless of whether the action is on a vector or a matrix.</p>
<h2 id="references_28">References<a class="headerlink" href="#references_28" title="Permanent link">&para;</a></h2>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2011)
'Computing the Action of the Matrix Exponential,
with an Application to Exponential Integrators.'
SIAM Journal on Scientific Computing,
33 (2). pp. 488-511. ISSN 1064-8275
http://eprints.ma.man.ac.uk/1591/</p>
<p>.. [2] Nicholas J. Higham and Awad H. Al-Mohy (2010)
'Computing Matrix Functions.'
Acta Numerica,
19. 159-208. ISSN 0962-4929
http://eprints.ma.man.ac.uk/1451/</p>
<h2 id="examples_262">Examples<a class="headerlink" href="#examples_262" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import expm, expm_multiply
A = csc_matrix([[1, 0], [0, 1]])
A.todense()
matrix([[1, 0],
[0, 1]], dtype=int64)
B = np.array([np.exp(-1.), np.exp(-2.)])
B
array([ 0.36787944,  0.13533528])
expm_multiply(A, B, start=1, stop=2, num=3, endpoint=True)
array([[ 1.        ,  0.36787944],
[ 1.64872127,  0.60653066],
[ 2.71828183,  1.        ]])
expm(A).dot(B)                  # Verify 1st timestep
array([ 1.        ,  0.36787944])
expm(1.5<em>A).dot(B)              # Verify 2nd timestep
array([ 1.64872127,  0.60653066])
expm(2</em>A).dot(B)                # Verify 3rd timestep
array([ 2.71828183,  1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">factorized</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a function for solving a sparse linear system, with A pre-factorized.</p>
<h2 id="parameters_431">Parameters<a class="headerlink" href="#parameters_431" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input.</p>
<h2 id="returns_342">Returns<a class="headerlink" href="#returns_342" title="Permanent link">&para;</a></h2>
<p>solve : callable
To solve the linear system of equations given in <code>A</code>, the <code>solve</code>
callable should be passed an ndarray of shape (N,).</p>
<h2 id="examples_263">Examples<a class="headerlink" href="#examples_263" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse.linalg import factorized
A = np.array([[ 3. ,  2. , -1. ],
...               [ 2. , -2. ,  4. ],
...               [-1. ,  0.5, -1. ]])
solve = factorized(A) # Makes LU decomposition.
rhs1 = np.array([1, -2, 0])
solve(rhs1) # Uses the LU factors.
array([ 1., -2., -2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gcrotmk</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m&#39;</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cu</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">discard_C</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">truncate</span><span class="o">:[`</span><span class="nc">Oldest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Smallest</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Solve a matrix equation using flexible GCROT(m,k) algorithm.</p>
<h2 id="parameters_432">Parameters<a class="headerlink" href="#parameters_432" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).
x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>tol</code>.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : int, optional
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}, optional
Preconditioner for A.  The preconditioner should approximate the
inverse of A. gcrotmk is a 'flexible' algorithm and the preconditioner
can vary from iteration to iteration. Effective preconditioning
dramatically improves the rate of convergence, which implies that
fewer iterations are needed to reach a given error tolerance.
callback : function, optional
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.
m : int, optional
Number of inner FGMRES iterations per each outer iteration.
Default: 20
k : int, optional
Number of vectors to carry between inner FGMRES iterations.
According to [2]<em>, good values are around m.
Default: m
CU : list of tuples, optional
List of tuples <code>(c, u)</code> which contain the columns of the matrices
C and U in the GCROT(m,k) algorithm. For details, see [2]</em>.
The list given and vectors contained in it are modified in-place.
If not given, start from empty matrices. The <code>c</code> elements in the
tuples can be <code>None</code>, in which case the vectors are recomputed
via <code>c = A u</code> on start and orthogonalized as described in [3]<em>.
discard_C : bool, optional
Discard the C-vectors at the end. Useful if recycling Krylov subspaces
for different linear systems.
truncate : {'oldest', 'smallest'}, optional
Truncation scheme to use. Drop: oldest vectors, or vectors with
smallest singular values using the scheme discussed in [1,2].
See [2]</em> for detailed comparison.
Default: 'oldest'</p>
<h2 id="returns_343">Returns<a class="headerlink" href="#returns_343" title="Permanent link">&para;</a></h2>
<p>x : array or matrix
The solution found.
info : int
Provides convergence information:</p>
<ul>
<li>0  : successful exit</li>
<li>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations</p>
</blockquote>
</li>
</ul>
<h2 id="references_29">References<a class="headerlink" href="#references_29" title="Permanent link">&para;</a></h2>
<p>.. [1] E. de Sturler, ''Truncation strategies for optimal Krylov subspace
methods'', SIAM J. Numer. Anal. 36, 864 (1999).
.. [2] J.E. Hicken and D.W. Zingg, ''A simplified and flexible variant
of GCROT for solving nonsymmetric linear systems'',
SIAM J. Sci. Comput. 32, 172 (2010).
.. [3] M.L. Parks, E. de Sturler, G. Mackey, D.D. Johnson, S. Maiti,
''Recycling Krylov subspaces for sequences of linear systems'',
SIAM J. Sci. Comput. 28, 1651 (2006).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gmres</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">restart</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">restrt</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback_type</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Generalized Minimal RESidual iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_433">Parameters<a class="headerlink" href="#parameters_433" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_344">Returns<a class="headerlink" href="#returns_344" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : int
Provides convergence information:
* 0  : successful exit
* &gt;0 : convergence to tolerance not achieved, number of iterations
* &lt;0 : illegal input or breakdown</p>
<h2 id="other-parameters_29">Other parameters<a class="headerlink" href="#other-parameters_29" title="Permanent link">&para;</a></h2>
<p>x0 : {array, matrix}
Starting guess for the solution (a vector of zeros by default).
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
restart : int, optional
Number of iterations between restarts. Larger values increase
iteration cost, but may be necessary for convergence.
Default is 20.
maxiter : int, optional
Maximum number of iterations (restart cycles).  Iteration will stop
after maxiter steps even if the specified tolerance has not been
achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Inverse of the preconditioner of A.  M should approximate the
inverse of A and be easy to solve for (see Notes).  Effective
preconditioning dramatically improves the rate of convergence,
which implies that fewer iterations are needed to reach a given
error tolerance.  By default, no preconditioner is used.
callback : function
User-supplied function to call after each iteration.  It is called
as <code>callback(args)</code>, where <code>args</code> are selected by <code>callback_type</code>.
callback_type : {'x', 'pr_norm', 'legacy'}, optional
Callback function argument requested:
- <code>x</code>: current iterate (ndarray), called on every restart
- <code>pr_norm</code>: relative (preconditioned) residual norm (float),
called on every inner iteration
- <code>legacy</code> (default): same as <code>pr_norm</code>, but also changes the
meaning of 'maxiter' to count inner iterations instead of restart
cycles.
restrt : int, optional
DEPRECATED - use <code>restart</code> instead.</p>
<h2 id="see-also_208">See Also<a class="headerlink" href="#see-also_208" title="Permanent link">&para;</a></h2>
<p>LinearOperator</p>
<h2 id="notes_195">Notes<a class="headerlink" href="#notes_195" title="Permanent link">&para;</a></h2>
<p>A preconditioner, P, is chosen such that P is close to A but easy to solve
for. The preconditioner parameter required by this routine is
<code>M = P^-1</code>. The inverse should preferably not be calculated
explicitly.  Rather, use the following template to produce M::</p>
<h1 id="construct-a-linear-operator-that-computes-p-1-x_5">Construct a linear operator that computes P^-1 * x.<a class="headerlink" href="#construct-a-linear-operator-that-computes-p-1-x_5" title="Permanent link">&para;</a></h1>
<p>import scipy.sparse.linalg as spla
M_x = lambda x: spla.spsolve(P, x)
M = spla.LinearOperator((n, n), M_x)</p>
<h2 id="examples_264">Examples<a class="headerlink" href="#examples_264" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import gmres
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
b = np.array([2, 4, -1], dtype=float)
x, exitCode = gmres(A, b)
print(exitCode)            # 0 indicates successful convergence
0
np.allclose(A.dot(x), b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of a sparse matrix</p>
<h2 id="parameters_434">Parameters<a class="headerlink" href="#parameters_434" title="Permanent link">&para;</a></h2>
<p>A : (M,M) ndarray or sparse matrix
square matrix to be inverted</p>
<h2 id="returns_345">Returns<a class="headerlink" href="#returns_345" title="Permanent link">&para;</a></h2>
<p>Ainv : (M,M) ndarray or sparse matrix
inverse of <code>A</code></p>
<h2 id="notes_196">Notes<a class="headerlink" href="#notes_196" title="Permanent link">&para;</a></h2>
<p>This computes the sparse inverse of <code>A</code>.  If the inverse of <code>A</code> is expected
to be non-sparse, it will likely be faster to convert <code>A</code> to dense and use
scipy.linalg.inv.</p>
<h2 id="examples_265">Examples<a class="headerlink" href="#examples_265" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import inv
A = csc_matrix([[1., 0.], [1., 2.]])
Ainv = inv(A)
Ainv
&lt;2x2 sparse matrix of type '<class 'numpy.float64'>'
with 3 stored elements in Compressed Sparse Column format&gt;
A.dot(Ainv)
&lt;2x2 sparse matrix of type '<class 'numpy.float64'>'
with 2 stored elements in Compressed Sparse Column format&gt;
A.dot(Ainv).todense()
matrix([[ 1.,  0.],
[ 0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>.. versionadded:: 0.12.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lgmres</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">inner_m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">outer_k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">outer_v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">store_outer_Av</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prepend_outer_v</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Solve a matrix equation using the LGMRES algorithm.</p>
<p>The LGMRES algorithm [1]<em> [2]</em> is designed to avoid some problems
in the convergence in restarted GMRES, and often converges in fewer
iterations.</p>
<h2 id="parameters_435">Parameters<a class="headerlink" href="#parameters_435" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real or complex N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).
x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>tol</code>.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : int, optional
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}, optional
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function, optional
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.
inner_m : int, optional
Number of inner GMRES iterations per each outer iteration.
outer_k : int, optional
Number of vectors to carry between inner GMRES iterations.
According to [1]_, good values are in the range of 1...3.
However, note that if you want to use the additional vectors to
accelerate solving multiple similar problems, larger values may
be beneficial.
outer_v : list of tuples, optional
List containing tuples <code>(v, Av)</code> of vectors and corresponding
matrix-vector products, used to augment the Krylov subspace, and
carried between inner GMRES iterations. The element <code>Av</code> can
be <code>None</code> if the matrix-vector product should be re-evaluated.
This parameter is modified in-place by <code>lgmres</code>, and can be used
to pass 'guess' vectors in and out of the algorithm when solving
similar problems.
store_outer_Av : bool, optional
Whether LGMRES should store also A*v in addition to vectors <code>v</code>
in the <code>outer_v</code> list. Default is True.
prepend_outer_v : bool, optional
Whether to put outer_v augmentation vectors before Krylov iterates.
In standard LGMRES, prepend_outer_v=False.</p>
<h2 id="returns_346">Returns<a class="headerlink" href="#returns_346" title="Permanent link">&para;</a></h2>
<p>x : array or matrix
The converged solution.
info : int
Provides convergence information:</p>
<ul>
<li>0  : successful exit</li>
<li>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations</p>
</blockquote>
</li>
<li>&lt;0 : illegal input or breakdown</li>
</ul>
<h2 id="notes_197">Notes<a class="headerlink" href="#notes_197" title="Permanent link">&para;</a></h2>
<p>The LGMRES algorithm [1]<em> [2]</em> is designed to avoid the
slowing of convergence in restarted GMRES, due to alternating
residual vectors. Typically, it often outperforms GMRES(m) of
comparable memory requirements by some measure, or at least is not
much worse.</p>
<p>Another advantage in this algorithm is that you can supply it with
'guess' vectors in the <code>outer_v</code> argument that augment the Krylov
subspace. If the solution lies close to the span of these vectors,
the algorithm converges faster. This can be useful if several very
similar matrices need to be inverted one after another, such as in
Newton-Krylov iteration where the Jacobian matrix often changes
little in the nonlinear steps.</p>
<h2 id="references_30">References<a class="headerlink" href="#references_30" title="Permanent link">&para;</a></h2>
<p>.. [1] A.H. Baker and E.R. Jessup and T. Manteuffel, 'A Technique for
Accelerating the Convergence of Restarted GMRES', SIAM J. Matrix
Anal. Appl. 26, 962 (2005).
.. [2] A.H. Baker, 'On Improving the Performance of the Linear Solver
restarted GMRES', PhD thesis, University of Colorado (2003).</p>
<h2 id="examples_266">Examples<a class="headerlink" href="#examples_266" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import lgmres
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
b = np.array([2, 4, -1], dtype=float)
x, exitCode = lgmres(A, b)
print(exitCode)            # 0 indicates successful convergence
0
np.allclose(A.dot(x), b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lobpcg</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">y</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">largest</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbosityLevel</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retLambdaHistory</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retResidualNormsHistory</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG)</p>
<p>LOBPCG is a preconditioned eigensolver for large symmetric positive
definite (SPD) generalized eigenproblems.</p>
<h2 id="parameters_436">Parameters<a class="headerlink" href="#parameters_436" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The symmetric linear operator of the problem, usually a
sparse matrix.  Often called the 'stiffness matrix'.
X : ndarray, float32 or float64
Initial approximation to the <code>k</code> eigenvectors (non-sparse). If <code>A</code>
has <code>shape=(n,n)</code> then <code>X</code> should have shape <code>shape=(n,k)</code>.
B : {dense matrix, sparse matrix, LinearOperator}, optional
The right hand side operator in a generalized eigenproblem.
By default, <code>B = Identity</code>.  Often called the 'mass matrix'.
M : {dense matrix, sparse matrix, LinearOperator}, optional
Preconditioner to <code>A</code>; by default <code>M = Identity</code>.
<code>M</code> should approximate the inverse of <code>A</code>.
Y : ndarray, float32 or float64, optional
n-by-sizeY matrix of constraints (non-sparse), sizeY &lt; n
The iterations will be performed in the B-orthogonal complement
of the column-space of Y. Y must be full rank.
tol : scalar, optional
Solver tolerance (stopping criterion).
The default is <code>tol=n*sqrt(eps)</code>.
maxiter : int, optional
Maximum number of iterations.  The default is <code>maxiter = 20</code>.
largest : bool, optional
When True, solve for the largest eigenvalues, otherwise the smallest.
verbosityLevel : int, optional
Controls solver output.  The default is <code>verbosityLevel=0</code>.
retLambdaHistory : bool, optional
Whether to return eigenvalue history.  Default is False.
retResidualNormsHistory : bool, optional
Whether to return history of residual norms.  Default is False.</p>
<h2 id="returns_347">Returns<a class="headerlink" href="#returns_347" title="Permanent link">&para;</a></h2>
<p>w : ndarray
Array of <code>k</code> eigenvalues
v : ndarray
An array of <code>k</code> eigenvectors.  <code>v</code> has the same shape as <code>X</code>.
lambdas : list of ndarray, optional
The eigenvalue history, if <code>retLambdaHistory</code> is True.
rnorms : list of ndarray, optional
The history of residual norms, if <code>retResidualNormsHistory</code> is True.</p>
<h2 id="notes_198">Notes<a class="headerlink" href="#notes_198" title="Permanent link">&para;</a></h2>
<p>If both <code>retLambdaHistory</code> and <code>retResidualNormsHistory</code> are True,
the return tuple has the following format
<code>(lambda, V, lambda history, residual norms history)</code>.</p>
<p>In the following <code>n</code> denotes the matrix size and <code>m</code> the number
of required eigenvalues (smallest or largest).</p>
<p>The LOBPCG code internally solves eigenproblems of the size <code>3m</code> on every
iteration by calling the 'standard' dense eigensolver, so if <code>m</code> is not
small enough compared to <code>n</code>, it does not make sense to call the LOBPCG
code, but rather one should use the 'standard' eigensolver, e.g. numpy or
scipy function in this case.
If one calls the LOBPCG algorithm for <code>5m &gt; n</code>, it will most likely break
internally, so the code tries to call the standard function instead.</p>
<p>It is not that <code>n</code> should be large for the LOBPCG to work, but rather the
ratio <code>n / m</code> should be large. It you call LOBPCG with <code>m=1</code>
and <code>n=10</code>, it works though <code>n</code> is small. The method is intended
for extremely large <code>n / m</code>, see e.g., reference [28] in
https://arxiv.org/abs/0705.2626</p>
<p>The convergence speed depends basically on two factors:</p>
<ol>
<li>
<p>How well relatively separated the seeking eigenvalues are from the rest
of the eigenvalues. One can try to vary <code>m</code> to make this better.</p>
</li>
<li>
<p>How well conditioned the problem is. This can be changed by using proper
preconditioning. For example, a rod vibration test problem (under tests
directory) is ill-conditioned for large <code>n</code>, so convergence will be
slow, unless efficient preconditioning is used. For this specific
problem, a good simple preconditioner function would be a linear solve
for <code>A</code>, which is easy to code since A is tridiagonal.</p>
</li>
</ol>
<h2 id="references_31">References<a class="headerlink" href="#references_31" title="Permanent link">&para;</a></h2>
<p>.. [1] A. V. Knyazev (2001),
Toward the Optimal Preconditioned Eigensolver: Locally Optimal
Block Preconditioned Conjugate Gradient Method.
SIAM Journal on Scientific Computing 23, no. 2,
pp. 517-541. http://dx.doi.org/10.1137/S1064827500366124</p>
<p>.. [2] A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov
(2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers
(BLOPEX) in hypre and PETSc. https://arxiv.org/abs/0705.2626</p>
<p>.. [3] A. V. Knyazev's C and MATLAB implementations:
https://bitbucket.org/joseroman/blopex</p>
<h2 id="examples_267">Examples<a class="headerlink" href="#examples_267" title="Permanent link">&para;</a></h2>
<p>Solve <code>A x = lambda x</code> with constraints and preconditioning.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse import spdiags, issparse
from scipy.sparse.linalg import lobpcg, LinearOperator
n = 100
vals = np.arange(1, n + 1)
A = spdiags(vals, 0, n, n)
A.toarray()
array([[  1.,   0.,   0., ...,   0.,   0.,   0.],
[  0.,   2.,   0., ...,   0.,   0.,   0.],
[  0.,   0.,   3., ...,   0.,   0.,   0.],
...,
[  0.,   0.,   0., ...,  98.,   0.,   0.],
[  0.,   0.,   0., ...,   0.,  99.,   0.],
[  0.,   0.,   0., ...,   0.,   0., 100.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constraints:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Y = np.eye(n, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initial guess for eigenvectors, should have linearly independent
columns. Column dimension = number of requested eigenvalues.</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = np.random.rand(n, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Preconditioner in the inverse of A in this example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>invA = spdiags([1./vals], 0, n, n)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The preconditiner must be defined by a function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def precond( x ):
...     return invA @ x</p>
</blockquote>
</blockquote>
</blockquote>
<p>The argument x of the preconditioner function is a matrix inside <code>lobpcg</code>,
thus the use of matrix-matrix product <code>@</code>.</p>
<p>The preconditioner function is passed to lobpcg as a <code>LinearOperator</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>M = LinearOperator(matvec=precond, matmat=precond,
...                    shape=(n, n), dtype=float)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Let us now solve the eigenvalue problem for the matrix A:</p>
<blockquote>
<blockquote>
<blockquote>
<p>eigenvalues, _ = lobpcg(A, X, Y=Y, M=M, largest=False)
eigenvalues
array([4., 5., 6.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that the vectors passed in Y are the eigenvectors of the 3 smallest
eigenvalues. The results returned are orthogonal to those.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lsmr</span> <span class="o">:</span> <span class="o">?</span><span class="n">damp</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">btol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">conlim</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">show</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Iterative solver for least-squares problems.</p>
<p>lsmr solves the system of linear equations <code>Ax = b</code>. If the system
is inconsistent, it solves the least-squares problem <code>min ||b - Ax||_2</code>.
A is a rectangular matrix of dimension m-by-n, where all cases are
allowed: m = n, m &gt; n, or m &lt; n. B is a vector of length m.
The matrix A may be dense or sparse (usually sparse).</p>
<h2 id="parameters_437">Parameters<a class="headerlink" href="#parameters_437" title="Permanent link">&para;</a></h2>
<p>A : {matrix, sparse matrix, ndarray, LinearOperator}
Matrix A in the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> and <code>A^H x</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : array_like, shape (m,)
Vector b in the linear system.
damp : float
Damping factor for regularized least-squares. <code>lsmr</code> solves
the regularized least-squares problem::</p>
<p>min ||(b) - (  A   )x||
||(0)   (damp*I) ||_2</p>
<p>where damp is a scalar.  If damp is None or 0, the system
is solved without regularization.
atol, btol : float, optional
Stopping tolerances. <code>lsmr</code> continues iterations until a
certain backward error estimate is smaller than some quantity
depending on atol and btol.  Let <code>r = b - Ax</code> be the
residual vector for the current approximate solution <code>x</code>.
If <code>Ax = b</code> seems to be consistent, <code>lsmr</code> terminates
when <code>norm(r) &lt;= atol * norm(A) * norm(x) + btol * norm(b)</code>.
Otherwise, lsmr terminates when <code>norm(A^H r) &lt;=
atol * norm(A) * norm(r)</code>.  If both tolerances are 1.0e-6 (say),
the final <code>norm(r)</code> should be accurate to about 6
digits. (The final x will usually have fewer correct digits,
depending on <code>cond(A)</code> and the size of LAMBDA.)  If <code>atol</code>
or <code>btol</code> is None, a default value of 1.0e-6 will be used.
Ideally, they should be estimates of the relative error in the
entries of A and B respectively.  For example, if the entries
of <code>A</code> have 7 correct digits, set atol = 1e-7. This prevents
the algorithm from doing unnecessary work beyond the
uncertainty of the input data.
conlim : float, optional
<code>lsmr</code> terminates if an estimate of <code>cond(A)</code> exceeds
<code>conlim</code>.  For compatible systems <code>Ax = b</code>, conlim could be
as large as 1.0e+12 (say).  For least-squares problems,
<code>conlim</code> should be less than 1.0e+8. If <code>conlim</code> is None, the
default value is 1e+8.  Maximum precision can be obtained by
setting <code>atol = btol = conlim = 0</code>, but the number of
iterations may then be excessive.
maxiter : int, optional
<code>lsmr</code> terminates if the number of iterations reaches
<code>maxiter</code>.  The default is <code>maxiter = min(m, n)</code>.  For
ill-conditioned systems, a larger value of <code>maxiter</code> may be
needed.
show : bool, optional
Print iterations logs if <code>show=True</code>.
x0 : array_like, shape (n,), optional
Initial guess of x, if None zeros are used.</p>
<p>.. versionadded:: 1.0.0
Returns</p>
<hr />
<p>x : ndarray of float
Least-square solution returned.
istop : int
istop gives the reason for stopping::</p>
<p>istop   = 0 means x=0 is a solution.  If x0 was given, then x=x0 is a
solution.
= 1 means x is an approximate solution to A*x = B,
according to atol and btol.
= 2 means x approximately solves the least-squares problem
according to atol.
= 3 means COND(A) seems to be greater than CONLIM.
= 4 is the same as 1 with atol = btol = eps (machine
precision)
= 5 is the same as 2 with atol = eps.
= 6 is the same as 3 with CONLIM = 1/eps.
= 7 means ITN reached maxiter before the other stopping
conditions were satisfied.</p>
<p>itn : int
Number of iterations used.
normr : float
<code>norm(b-Ax)</code>
normar : float
<code>norm(A^H (b - Ax))</code>
norma : float
<code>norm(A)</code>
conda : float
Condition number of A.
normx : float
<code>norm(x)</code></p>
<h2 id="notes_199">Notes<a class="headerlink" href="#notes_199" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.11.0</p>
<h2 id="references_32">References<a class="headerlink" href="#references_32" title="Permanent link">&para;</a></h2>
<p>.. [1] D. C.-L. Fong and M. A. Saunders,
'LSMR: An iterative algorithm for sparse least-squares problems',
SIAM J. Sci. Comput., vol. 33, pp. 2950-2971, 2011.
https://arxiv.org/abs/1006.0758
.. [2] LSMR Software, https://web.stanford.edu/group/SOL/software/lsmr/</p>
<h2 id="examples_268">Examples<a class="headerlink" href="#examples_268" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import lsmr
A = csc_matrix([[1., 0.], [1., 1.], [0., 1.]], dtype=float)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The first example has the trivial solution <code>[0, 0]</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([0., 0., 0.], dtype=float)
x, istop, itn, normr = lsmr(A, b)[:4]
istop
0
x
array([ 0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The stopping code <code>istop=0</code> returned indicates that a vector of zeros was
found as a solution. The returned solution <code>x</code> indeed contains <code>[0., 0.]</code>.
The next example has a non-trivial solution:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([1., 0., -1.], dtype=float)
x, istop, itn, normr = lsmr(A, b)[:4]
istop
1
x
array([ 1., -1.])
itn
1
normr
4.440892098500627e-16</p>
</blockquote>
</blockquote>
</blockquote>
<p>As indicated by <code>istop=1</code>, <code>lsmr</code> found a solution obeying the tolerance
limits. The given solution <code>[1., -1.]</code> obviously solves the equation. The
remaining return values include information about the number of iterations
(<code>itn=1</code>) and the remaining difference of left and right side of the solved
equation.
The final example demonstrates the behavior in the case where there is no
solution for the equation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([1., 0.01, -1.], dtype=float)
x, istop, itn, normr = lsmr(A, b)[:4]
istop
2
x
array([ 1.00333333, -0.99666667])
A.dot(x)-b
array([ 0.00333333, -0.00333333,  0.00333333])
normr
0.005773502691896255</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>istop</code> indicates that the system is inconsistent and thus <code>x</code> is rather an
approximate solution to the corresponding least-squares problem. <code>normr</code>
contains the minimal distance that was found.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lsqr</span> <span class="o">:</span> <span class="o">?</span><span class="n">damp</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">btol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">conlim</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iter_lim</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">show</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">calc_var</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find the least-squares solution to a large, sparse, linear system
of equations.</p>
<p>The function solves <code>Ax = b</code>  or  <code>min ||b - Ax||^2</code> or
<code>min ||Ax - b||^2 + d^2 ||x||^2</code>.</p>
<p>The matrix A may be square or rectangular (over-determined or
under-determined), and may have any rank.</p>
<p>::</p>
<ol>
<li>
<p>Unsymmetric equations --    solve  A*x = b</p>
</li>
<li>
<p>Linear least squares  --    solve  A*x = b
in the least-squares sense</p>
</li>
<li>
<p>Damped least squares  --    solve  (   A    )<em>x = ( b )
( damp</em>I )     ( 0 )
in the least-squares sense</p>
</li>
</ol>
<h2 id="parameters_438">Parameters<a class="headerlink" href="#parameters_438" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, ndarray, LinearOperator}
Representation of an m-by-n matrix.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> and <code>A^T x</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : array_like, shape (m,)
Right-hand side vector <code>b</code>.
damp : float
Damping coefficient.
atol, btol : float, optional
Stopping tolerances. If both are 1.0e-9 (say), the final
residual norm should be accurate to about 9 digits.  (The
final x will usually have fewer correct digits, depending on
cond(A) and the size of damp.)
conlim : float, optional
Another stopping tolerance.  lsqr terminates if an estimate of
<code>cond(A)</code> exceeds <code>conlim</code>.  For compatible systems <code>Ax =
b</code>, <code>conlim</code> could be as large as 1.0e+12 (say).  For
least-squares problems, conlim should be less than 1.0e+8.
Maximum precision can be obtained by setting <code>atol = btol =
conlim = zero</code>, but the number of iterations may then be
excessive.
iter_lim : int, optional
Explicit limitation on number of iterations (for safety).
show : bool, optional
Display an iteration log.
calc_var : bool, optional
Whether to estimate diagonals of <code>(A'A + damp^2*I)^{-1}</code>.
x0 : array_like, shape (n,), optional
Initial guess of x, if None zeros are used.</p>
<p>.. versionadded:: 1.0.0</p>
<h2 id="returns_348">Returns<a class="headerlink" href="#returns_348" title="Permanent link">&para;</a></h2>
<p>x : ndarray of float
The final solution.
istop : int
Gives the reason for termination.
1 means x is an approximate solution to Ax = b.
2 means x approximately solves the least-squares problem.
itn : int
Iteration number upon termination.
r1norm : float
<code>norm(r)</code>, where <code>r = b - Ax</code>.
r2norm : float
<code>sqrt( norm(r)^2  +  damp^2 * norm(x)^2 )</code>.  Equal to <code>r1norm</code> if
<code>damp == 0</code>.
anorm : float
Estimate of Frobenius norm of <code>Abar = [[A]; [damp*I]]</code>.
acond : float
Estimate of <code>cond(Abar)</code>.
arnorm : float
Estimate of <code>norm(A'*r - damp^2*x)</code>.
xnorm : float
<code>norm(x)</code>
var : ndarray of float
If <code>calc_var</code> is True, estimates all diagonals of
<code>(A'A)^{-1}</code> (if <code>damp == 0</code>) or more generally <code>(A'A +
damp^2*I)^{-1}</code>.  This is well defined if A has full column
rank or <code>damp &gt; 0</code>.  (Not sure what var means if <code>rank(A)
&lt; n</code> and <code>damp = 0.</code>)</p>
<h2 id="notes_200">Notes<a class="headerlink" href="#notes_200" title="Permanent link">&para;</a></h2>
<p>LSQR uses an iterative method to approximate the solution.  The
number of iterations required to reach a certain accuracy depends
strongly on the scaling of the problem.  Poor scaling of the rows
or columns of A should therefore be avoided where possible.</p>
<p>For example, in problem 1 the solution is unaltered by
row-scaling.  If a row of A is very small or large compared to
the other rows of A, the corresponding row of ( A  b ) should be
scaled up or down.</p>
<p>In problems 1 and 2, the solution x is easily recovered
following column-scaling.  Unless better information is known,
the nonzero columns of A should be scaled so that they all have
the same Euclidean norm (e.g., 1.0).</p>
<p>In problem 3, there is no freedom to re-scale if damp is
nonzero.  However, the value of damp should be assigned only
after attention has been paid to the scaling of A.</p>
<p>The parameter damp is intended to help regularize
ill-conditioned systems, by preventing the true solution from
being very large.  Another aid to regularization is provided by
the parameter acond, which may be used to terminate iterations
before the computed solution becomes very large.</p>
<p>If some initial estimate <code>x0</code> is known and if <code>damp == 0</code>,
one could proceed as follows:</p>
<ol>
<li>Compute a residual vector <code>r0 = b - A*x0</code>.</li>
<li>Use LSQR to solve the system  <code>A*dx = r0</code>.</li>
<li>Add the correction dx to obtain a final solution <code>x = x0 + dx</code>.</li>
</ol>
<p>This requires that <code>x0</code> be available before and after the call
to LSQR.  To judge the benefits, suppose LSQR takes k1 iterations
to solve A<em>x = b and k2 iterations to solve A</em>dx = r0.
If x0 is 'good', norm(r0) will be smaller than norm(b).
If the same stopping tolerances atol and btol are used for each
system, k1 and k2 will be similar, but the final solution x0 + dx
should be more accurate.  The only way to reduce the total work
is to use a larger stopping tolerance for the second system.
If some value btol is suitable for A<em>x = b, the larger value
btol</em>norm(b)/norm(r0)  should be suitable for A*dx = r0.</p>
<p>Preconditioning is another way to reduce the number of iterations.
If it is possible to solve a related system <code>M*x = b</code>
efficiently, where M approximates A in some helpful way (e.g. M -
A has low rank or its elements are small relative to those of A),
LSQR may converge more rapidly on the system <code>A*M(inverse)*z =
b</code>, after which x can be recovered by solving M*x = z.</p>
<p>If A is symmetric, LSQR should not be used!</p>
<p>Alternatives are the symmetric conjugate-gradient method (cg)
and/or SYMMLQ.  SYMMLQ is an implementation of symmetric cg that
applies to any symmetric A and will converge more rapidly than
LSQR.  If A is positive definite, there are other implementations
of symmetric cg that require slightly less work per iteration than
SYMMLQ (but will take the same number of iterations).</p>
<h2 id="references_33">References<a class="headerlink" href="#references_33" title="Permanent link">&para;</a></h2>
<p>.. [1] C. C. Paige and M. A. Saunders (1982a).
'LSQR: An algorithm for sparse linear equations and
sparse least squares', ACM TOMS 8(1), 43-71.
.. [2] C. C. Paige and M. A. Saunders (1982b).
'Algorithm 583.  LSQR: Sparse linear equations and least
squares problems', ACM TOMS 8(2), 195-209.
.. [3] M. A. Saunders (1995).  'Solution of sparse rectangular
systems using LSQR and CRAIG', BIT 35, 588-604.</p>
<h2 id="examples_269">Examples<a class="headerlink" href="#examples_269" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import lsqr
A = csc_matrix([[1., 0.], [1., 1.], [0., 1.]], dtype=float)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The first example has the trivial solution <code>[0, 0]</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([0., 0., 0.], dtype=float)
x, istop, itn, normr = lsqr(A, b)[:4]
The exact solution is  x = 0
istop
0
x
array([ 0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The stopping code <code>istop=0</code> returned indicates that a vector of zeros was
found as a solution. The returned solution <code>x</code> indeed contains <code>[0., 0.]</code>.
The next example has a non-trivial solution:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([1., 0., -1.], dtype=float)
x, istop, itn, r1norm = lsqr(A, b)[:4]
istop
1
x
array([ 1., -1.])
itn
1
r1norm
4.440892098500627e-16</p>
</blockquote>
</blockquote>
</blockquote>
<p>As indicated by <code>istop=1</code>, <code>lsqr</code> found a solution obeying the tolerance
limits. The given solution <code>[1., -1.]</code> obviously solves the equation. The
remaining return values include information about the number of iterations
(<code>itn=1</code>) and the remaining difference of left and right side of the solved
equation.
The final example demonstrates the behavior in the case where there is no
solution for the equation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([1., 0.01, -1.], dtype=float)
x, istop, itn, r1norm = lsqr(A, b)[:4]
istop
2
x
array([ 1.00333333, -0.99666667])
A.dot(x)-b
array([ 0.00333333, -0.00333333,  0.00333333])
r1norm
0.005773502691896255</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>istop</code> indicates that the system is inconsistent and thus <code>x</code> is rather an
approximate solution to the corresponding least-squares problem. <code>r1norm</code>
contains the norm of the minimal residual that was found.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minres</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shift</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">show</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use MINimum RESidual iteration to solve Ax=b</p>
<p>MINRES minimizes norm(A*x - b) for a real symmetric matrix A.  Unlike
the Conjugate Gradient method, A can be indefinite or singular.</p>
<p>If shift != 0 then the method solves (A - shift*I)x = b</p>
<h2 id="parameters_439">Parameters<a class="headerlink" href="#parameters_439" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real symmetric N-by-N matrix of the linear system
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_349">Returns<a class="headerlink" href="#returns_349" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_30">Other Parameters<a class="headerlink" href="#other-parameters_30" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol : float
Tolerance to achieve. The algorithm terminates when the relative
residual is below <code>tol</code>.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M : {sparse matrix, dense matrix, LinearOperator}
Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<h2 id="references_34">References<a class="headerlink" href="#references_34" title="Permanent link">&para;</a></h2>
<p>Solution of sparse indefinite systems of linear equations,
C. C. Paige and M. A. Saunders (1975),
SIAM J. Numer. Anal. 12(4), pp. 617-629.
https://web.stanford.edu/group/SOL/software/minres/</p>
<p>This file is a translation of the following MATLAB implementation:
https://web.stanford.edu/group/SOL/software/minres/minres-matlab.zip</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">norm</span> <span class="o">:</span> <span class="o">?</span><span class="n">ord</span><span class="o">:[`</span><span class="nc">Fro</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">T2_tuple_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Norm of a sparse matrix</p>
<p>This function is able to return one of seven different matrix norms,
depending on the value of the <code>ord</code> parameter.</p>
<h2 id="parameters_440">Parameters<a class="headerlink" href="#parameters_440" title="Permanent link">&para;</a></h2>
<p>x : a sparse matrix
Input sparse matrix.
ord : {non-zero int, inf, -inf, 'fro'}, optional
Order of the norm (see table under <code>Notes</code>). inf means numpy's
<code>inf</code> object.
axis : {int, 2-tuple of ints, None}, optional
If <code>axis</code> is an integer, it specifies the axis of <code>x</code> along which to
compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
axes that hold 2-D matrices, and the matrix norms of these matrices
are computed.  If <code>axis</code> is None then either a vector norm (when <code>x</code>
is 1-D) or a matrix norm (when <code>x</code> is 2-D) is returned.</p>
<h2 id="returns_350">Returns<a class="headerlink" href="#returns_350" title="Permanent link">&para;</a></h2>
<p>n : float or ndarray</p>
<h2 id="notes_201">Notes<a class="headerlink" href="#notes_201" title="Permanent link">&para;</a></h2>
<p>Some of the ord are not implemented because some associated functions like,
_multi_svd_norm, are not yet available for sparse matrix.</p>
<p>This docstring is modified based on numpy.linalg.norm.
https://github.com/numpy/numpy/blob/master/numpy/linalg/linalg.py</p>
<p>The following norms can be calculated:</p>
<p>=====  ============================
ord    norm for sparse matrices
=====  ============================
None   Frobenius norm
'fro'  Frobenius norm
inf    max(sum(abs(x), axis=1))
-inf   min(sum(abs(x), axis=1))
0      abs(x).sum(axis=axis)
1      max(sum(abs(x), axis=0))
-1     min(sum(abs(x), axis=0))
2      Not implemented
-2     Not implemented
other  Not implemented
=====  ============================</p>
<p>The Frobenius norm is given by [1]_:</p>
<p>:math:<code>||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}</code></p>
<h2 id="references_35">References<a class="headerlink" href="#references_35" title="Permanent link">&para;</a></h2>
<p>.. [1] G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
<h2 id="examples_270">Examples<a class="headerlink" href="#examples_270" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import *
import numpy as np
from scipy.sparse.linalg import norm
a = np.arange(9) - 4
a
array([-4, -3, -2, -1, 0, 1, 2, 3, 4])
b = a.reshape((3, 3))
b
array([[-4, -3, -2],
[-1, 0, 1],
[ 2, 3, 4]])</p>
<p>b = csr_matrix(b)
norm(b)
7.745966692414834
norm(b, 'fro')
7.745966692414834
norm(b, np.inf)
9
norm(b, -np.inf)
2
norm(b, 1)
7
norm(b, -1)
6</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">onenormest</span> <span class="o">:</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">itmax</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">compute_v</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">compute_w</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Other_linear_operator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute a lower bound of the 1-norm of a sparse matrix.</p>
<h2 id="parameters_441">Parameters<a class="headerlink" href="#parameters_441" title="Permanent link">&para;</a></h2>
<p>A : ndarray or other linear operator
A linear operator that can be transposed and that can
produce matrix products.
t : int, optional
A positive parameter controlling the tradeoff between
accuracy versus time and memory usage.
Larger values take longer and use more memory
but give more accurate output.
itmax : int, optional
Use at most this many iterations.
compute_v : bool, optional
Request a norm-maximizing linear operator input vector if True.
compute_w : bool, optional
Request a norm-maximizing linear operator output vector if True.</p>
<h2 id="returns_351">Returns<a class="headerlink" href="#returns_351" title="Permanent link">&para;</a></h2>
<p>est : float
An underestimate of the 1-norm of the sparse matrix.
v : ndarray, optional
The vector such that ||Av||_1 == est*||v||_1.
It can be thought of as an input to the linear operator
that gives an output with particularly large norm.
w : ndarray, optional
The vector Av which has relatively large 1-norm.
It can be thought of as an output of the linear operator
that is relatively large in norm compared to the input.</p>
<h2 id="notes_202">Notes<a class="headerlink" href="#notes_202" title="Permanent link">&para;</a></h2>
<p>This is algorithm 2.4 of [1].</p>
<p>In [2] it is described as follows.
'This algorithm typically requires the evaluation of
about 4t matrix-vector products and almost invariably
produces a norm estimate (which is, in fact, a lower
bound on the norm) correct to within a factor 3.'</p>
<p>.. versionadded:: 0.13.0</p>
<h2 id="references_36">References<a class="headerlink" href="#references_36" title="Permanent link">&para;</a></h2>
<p>.. [1] Nicholas J. Higham and Francoise Tisseur (2000),
'A Block Algorithm for Matrix 1-Norm Estimation,
with an Application to 1-Norm Pseudospectra.'
SIAM J. Matrix Anal. Appl. Vol. 21, No. 4, pp. 1185-1201.</p>
<p>.. [2] Awad H. Al-Mohy and Nicholas J. Higham (2009),
'A new scaling and squaring algorithm for the matrix exponential.'
SIAM J. Matrix Anal. Appl. Vol. 31, No. 3, pp. 970-989.</p>
<h2 id="examples_271">Examples<a class="headerlink" href="#examples_271" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import onenormest
A = csc_matrix([[1., 0., 0.], [5., 8., 2.], [0., -1., 0.]], dtype=float)
A.todense()
matrix([[ 1.,  0.,  0.],
[ 5.,  8.,  2.],
[ 0., -1.,  0.]])
onenormest(A)
9.0
np.linalg.norm(A.todense(), ord=1)
9.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qmr</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Use Quasi-Minimal Residual iteration to solve <code>Ax = b</code>.</p>
<h2 id="parameters_442">Parameters<a class="headerlink" href="#parameters_442" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, dense matrix, LinearOperator}
The real-valued N-by-N matrix of the linear system.
Alternatively, <code>A</code> can be a linear operator which can
produce <code>Ax</code> and <code>A^T x</code> using, e.g.,
<code>scipy.sparse.linalg.LinearOperator</code>.
b : {array, matrix}
Right hand side of the linear system. Has shape (N,) or (N,1).</p>
<h2 id="returns_352">Returns<a class="headerlink" href="#returns_352" title="Permanent link">&para;</a></h2>
<p>x : {array, matrix}
The converged solution.
info : integer
Provides convergence information:
0  : successful exit</p>
<blockquote>
<p>0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</blockquote>
<h2 id="other-parameters_31">Other Parameters<a class="headerlink" href="#other-parameters_31" title="Permanent link">&para;</a></h2>
<p>x0  : {array, matrix}
Starting guess for the solution.
tol, atol : float, optional
Tolerances for convergence, <code>norm(residual) &lt;= max(tol*norm(b), atol)</code>.
The default for <code>atol</code> is <code>'legacy'</code>, which emulates
a different legacy behavior.</p>
<p>.. warning::</p>
<p>The default value for <code>atol</code> will be changed in a future release.
For future compatibility, specify <code>atol</code> explicitly.
maxiter : integer
Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.
M1 : {sparse matrix, dense matrix, LinearOperator}
Left preconditioner for A.
M2 : {sparse matrix, dense matrix, LinearOperator}
Right preconditioner for A. Used together with the left
preconditioner M1.  The matrix M1<em>A</em>M2 should have better
conditioned than A alone.
callback : function
User-supplied function to call after each iteration.  It is called
as callback(xk), where xk is the current solution vector.</p>
<h2 id="see-also_209">See Also<a class="headerlink" href="#see-also_209" title="Permanent link">&para;</a></h2>
<p>LinearOperator</p>
<h2 id="examples_272">Examples<a class="headerlink" href="#examples_272" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import qmr
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
b = np.array([2, 4, -1], dtype=float)
x, exitCode = qmr(A, b)
print(exitCode)            # 0 indicates successful convergence
0
np.allclose(A.dot(x), b)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spilu</span> <span class="o">:</span> <span class="o">?</span><span class="n">drop_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fill_factor</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">drop_rule</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag_pivot_thresh</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">relax</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">panel_size</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute an incomplete LU decomposition for a sparse, square matrix.</p>
<p>The resulting object is an approximation to the inverse of <code>A</code>.</p>
<h2 id="parameters_443">Parameters<a class="headerlink" href="#parameters_443" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Sparse matrix to factorize
drop_tol : float, optional
Drop tolerance (0 &lt;= tol &lt;= 1) for an incomplete LU decomposition.
(default: 1e-4)
fill_factor : float, optional
Specifies the fill ratio upper bound (&gt;= 1.0) for ILU. (default: 10)
drop_rule : str, optional
Comma-separated string of drop rules to use.
Available rules: <code>basic</code>, <code>prows</code>, <code>column</code>, <code>area</code>,
<code>secondary</code>, <code>dynamic</code>, <code>interp</code>. (Default: <code>basic,area</code>)</p>
<p>See SuperLU documentation for details.</p>
<p>Remaining other options
Same as for <code>splu</code></p>
<h2 id="returns_353">Returns<a class="headerlink" href="#returns_353" title="Permanent link">&para;</a></h2>
<p>invA_approx : scipy.sparse.linalg.SuperLU
Object, which has a <code>solve</code> method.</p>
<h2 id="see-also_210">See also<a class="headerlink" href="#see-also_210" title="Permanent link">&para;</a></h2>
<p>splu : complete LU decomposition</p>
<h2 id="notes_203">Notes<a class="headerlink" href="#notes_203" title="Permanent link">&para;</a></h2>
<p>To improve the better approximation to the inverse, you may need to
increase <code>fill_factor</code> AND decrease <code>drop_tol</code>.</p>
<p>This function uses the SuperLU library.</p>
<h2 id="examples_273">Examples<a class="headerlink" href="#examples_273" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import spilu
A = csc_matrix([[1., 0., 0.], [5., 0., 2.], [0., -1., 0.]], dtype=float)
B = spilu(A)
x = np.array([1., 2., 3.], dtype=float)
B.solve(x)
array([ 1. , -3. , -1.5])
A.dot(B.solve(x))
array([ 1.,  2.,  3.])
B.solve(A.dot(x))
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">splu</span> <span class="o">:</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag_pivot_thresh</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">relax</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">panel_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the LU decomposition of a sparse, square matrix.</p>
<h2 id="parameters_444">Parameters<a class="headerlink" href="#parameters_444" title="Permanent link">&para;</a></h2>
<p>A : sparse matrix
Sparse matrix to factorize. Should be in CSR or CSC format.
permc_spec : str, optional
How to permute the columns of the matrix for sparsity preservation.
(default: 'COLAMD')</p>
<ul>
<li><code>NATURAL</code>: natural ordering.</li>
<li><code>MMD_ATA</code>: minimum degree ordering on the structure of A^T A.</li>
<li><code>MMD_AT_PLUS_A</code>: minimum degree ordering on the structure of A^T+A.</li>
<li><code>COLAMD</code>: approximate minimum degree column ordering</li>
</ul>
<p>diag_pivot_thresh : float, optional
Threshold used for a diagonal entry to be an acceptable pivot.
See SuperLU user's guide for details [1]<em>
relax : int, optional
Expert option for customizing the degree of relaxing supernodes.
See SuperLU user's guide for details [1]</em>
panel_size : int, optional
Expert option for customizing the panel size.
See SuperLU user's guide for details [1]<em>
options : dict, optional
Dictionary containing additional expert options to SuperLU.
See SuperLU user guide [1]</em> (section 2.4 on the 'Options' argument)
for more details. For example, you can specify
<code>options=dict(Equil=False, IterRefine='SINGLE'))</code>
to turn equilibration off and perform a single iterative refinement.</p>
<h2 id="returns_354">Returns<a class="headerlink" href="#returns_354" title="Permanent link">&para;</a></h2>
<p>invA : scipy.sparse.linalg.SuperLU
Object, which has a <code>solve</code> method.</p>
<h2 id="see-also_211">See also<a class="headerlink" href="#see-also_211" title="Permanent link">&para;</a></h2>
<p>spilu : incomplete LU decomposition</p>
<h2 id="notes_204">Notes<a class="headerlink" href="#notes_204" title="Permanent link">&para;</a></h2>
<p>This function uses the SuperLU library.</p>
<h2 id="references_37">References<a class="headerlink" href="#references_37" title="Permanent link">&para;</a></h2>
<p>.. [1] SuperLU http://crd.lbl.gov/~xiaoye/SuperLU/</p>
<h2 id="examples_274">Examples<a class="headerlink" href="#examples_274" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import splu
A = csc_matrix([[1., 0., 0.], [5., 0., 2.], [0., -1., 0.]], dtype=float)
B = splu(A)
x = np.array([1., 2., 3.], dtype=float)
B.solve(x)
array([ 1. , -3. , -1.5])
A.dot(B.solve(x))
array([ 1.,  2.,  3.])
B.solve(A.dot(x))
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spsolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">permc_spec</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">use_umfpack</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the sparse linear system Ax=b, where b may be a vector or a matrix.</p>
<h2 id="parameters_445">Parameters<a class="headerlink" href="#parameters_445" title="Permanent link">&para;</a></h2>
<p>A : ndarray or sparse matrix
The square matrix A will be converted into CSC or CSR form
b : ndarray or sparse matrix
The matrix or vector representing the right hand side of the equation.
If a vector, b.shape must be (n,) or (n, 1).
permc_spec : str, optional
How to permute the columns of the matrix for sparsity preservation.
(default: 'COLAMD')</p>
<ul>
<li><code>NATURAL</code>: natural ordering.</li>
<li><code>MMD_ATA</code>: minimum degree ordering on the structure of A^T A.</li>
<li><code>MMD_AT_PLUS_A</code>: minimum degree ordering on the structure of A^T+A.</li>
<li><code>COLAMD</code>: approximate minimum degree column ordering
use_umfpack : bool, optional
if True (default) then use umfpack for the solution.  This is
only referenced if b is a vector and <code>scikit-umfpack</code> is installed.</li>
</ul>
<h2 id="returns_355">Returns<a class="headerlink" href="#returns_355" title="Permanent link">&para;</a></h2>
<p>x : ndarray or sparse matrix
the solution of the sparse linear equation.
If b is a vector, then x is a vector of size A.shape[1]
If b is a matrix, then x is a matrix of size (A.shape[1], b.shape[1])</p>
<h2 id="notes_205">Notes<a class="headerlink" href="#notes_205" title="Permanent link">&para;</a></h2>
<p>For solving the matrix expression AX = B, this solver assumes the resulting
matrix X is sparse, as is often the case for very sparse inputs.  If the
resulting X is dense, the construction of this sparse result will be
relatively expensive.  In that case, consider converting A to a dense
matrix and using scipy.linalg.solve or its variants.</p>
<h2 id="examples_275">Examples<a class="headerlink" href="#examples_275" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import spsolve
A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
B = csc_matrix([[2, 0], [-1, 0], [2, 0]], dtype=float)
x = spsolve(A, B)
np.allclose(A.dot(x).todense(), B.todense())
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spsolve_triangular</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_A</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">unit_diagonal</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation <code>A x = b</code> for <code>x</code>, assuming A is a triangular matrix.</p>
<h2 id="parameters_446">Parameters<a class="headerlink" href="#parameters_446" title="Permanent link">&para;</a></h2>
<p>A : (M, M) sparse matrix
A sparse square triangular matrix. Should be in CSR format.
b : (M,) or (M, N) array_like
Right-hand side matrix in <code>A x = b</code>
lower : bool, optional
Whether <code>A</code> is a lower or upper triangular matrix.
Default is lower triangular matrix.
overwrite_A : bool, optional
Allow changing <code>A</code>. The indices of <code>A</code> are going to be sorted and zero
entries are going to be removed.
Enabling gives a performance gain. Default is False.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code>.
Enabling gives a performance gain. Default is False.
If <code>overwrite_b</code> is True, it should be ensured that
<code>b</code> has an appropriate dtype to be able to store the result.
unit_diagonal : bool, optional
If True, diagonal elements of <code>a</code> are assumed to be 1 and will not be
referenced.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="returns_356">Returns<a class="headerlink" href="#returns_356" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, N) ndarray
Solution to the system <code>A x = b</code>. Shape of return matches shape of <code>b</code>.</p>
<h2 id="raises_29">Raises<a class="headerlink" href="#raises_29" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If <code>A</code> is singular or not triangular.
ValueError
If shape of <code>A</code> or shape of <code>b</code> do not match the requirements.</p>
<h2 id="notes_206">Notes<a class="headerlink" href="#notes_206" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_276">Examples<a class="headerlink" href="#examples_276" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix
from scipy.sparse.linalg import spsolve_triangular
A = csr_matrix([[3, 0, 0], [1, -1, 0], [2, 0, 1]], dtype=float)
B = np.array([[2, 0], [-1, 0], [2, 0]], dtype=float)
x = spsolve_triangular(A, B)
np.allclose(A.dot(x), B)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svds</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ncv</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">which</span><span class="o">:[`</span><span class="nc">LM</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SM</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">v0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_singular_vectors</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">solver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the largest or smallest k singular values/vectors for a sparse matrix. The order of the singular values is not guaranteed.</p>
<h2 id="parameters_447">Parameters<a class="headerlink" href="#parameters_447" title="Permanent link">&para;</a></h2>
<p>A : {sparse matrix, LinearOperator}
Array to compute the SVD on, of shape (M, N)
k : int, optional
Number of singular values and vectors to compute.
Must be 1 &lt;= k &lt; min(A.shape).
ncv : int, optional
The number of Lanczos vectors generated
ncv must be greater than k+1 and smaller than n;
it is recommended that ncv &gt; 2*k
Default: <code>min(n, max(2*k + 1, 20))</code>
tol : float, optional
Tolerance for singular values. Zero (default) means machine precision.
which : str, ['LM' | 'SM'], optional
Which <code>k</code> singular values to find:</p>
<ul>
<li>'LM' : largest singular values</li>
<li>'SM' : smallest singular values</li>
</ul>
<p>.. versionadded:: 0.12.0
v0 : ndarray, optional
Starting vector for iteration, of length min(A.shape). Should be an
(approximate) left singular vector if N &gt; M and a right singular
vector otherwise.
Default: random</p>
<p>.. versionadded:: 0.12.0
maxiter : int, optional
Maximum number of iterations.</p>
<p>.. versionadded:: 0.12.0
return_singular_vectors : bool or str, optional
- True: return singular vectors (True) in addition to singular values.</p>
<p>.. versionadded:: 0.12.0</p>
<ul>
<li>'u': only return the u matrix, without computing vh (if N &gt; M).</li>
<li>'vh': only return the vh matrix, without computing u (if N &lt;= M).</li>
</ul>
<p>.. versionadded:: 0.16.0
solver : str, optional
Eigenvalue solver to use. Should be 'arpack' or 'lobpcg'.
Default: 'arpack'</p>
<h2 id="returns_357">Returns<a class="headerlink" href="#returns_357" title="Permanent link">&para;</a></h2>
<p>u : ndarray, shape=(M, k)
Unitary matrix having left singular vectors as columns.
If <code>return_singular_vectors</code> is 'vh', this variable is not computed,
and None is returned instead.
s : ndarray, shape=(k,)
The singular values.
vt : ndarray, shape=(k, N)
Unitary matrix having right singular vectors as rows.
If <code>return_singular_vectors</code> is 'u', this variable is not computed,
and None is returned instead.</p>
<h2 id="notes_207">Notes<a class="headerlink" href="#notes_207" title="Permanent link">&para;</a></h2>
<p>This is a naive implementation using ARPACK or LOBPCG as an eigensolver
on A.H * A or A * A.H, depending on which one is more efficient.</p>
<h2 id="examples_277">Examples<a class="headerlink" href="#examples_277" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix
from scipy.sparse.linalg import svds, eigs
A = csc_matrix([[1, 0, 0], [5, 0, 2], [0, -1, 0], [0, 0, 3]], dtype=float)
u, s, vt = svds(A, k=2)
s
array([ 2.75193379,  5.6059665 ])
np.sqrt(eigs(A.dot(A.T), k=2)[0]).real
array([ 5.6059665 ,  2.75193379])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">use_solver</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Select default sparse direct solver to be used.</p>
<h2 id="parameters_448">Parameters<a class="headerlink" href="#parameters_448" title="Permanent link">&para;</a></h2>
<p>useUmfpack : bool, optional
Use UMFPACK over SuperLU. Has effect only if scikits.umfpack is
installed. Default: True
assumeSortedIndices : bool, optional
Allow UMFPACK to skip the step of sorting indices for a CSR/CSC matrix.
Has effect only if useUmfpack is True and scikits.umfpack is installed.
Default: False</p>
<h2 id="notes_208">Notes<a class="headerlink" href="#notes_208" title="Permanent link">&para;</a></h2>
<p>The default sparse solver is umfpack when available
(scikits.umfpack is installed). This can be changed by passing
useUmfpack = False, which then causes the always present SuperLU
based solver to be used.</p>
<p>Umfpack requires a CSR/CSC matrix to have sorted column/row indices. If
sure that the matrix fulfills this, pass <code>assumeSortedIndices=True</code>
to gain some speed.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Sputils</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">asmatrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bmat</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_reshape_kwargs</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Unpack keyword arguments for reshape function.</p>
<p>This is useful because keyword arguments after star arguments are not
allowed in Python 2, but star keyword arguments are. This function unpacks
'order' and 'copy' from the star keyword arguments (with defaults) and
throws an error for any remaining.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_shape</span> <span class="o">:</span> <span class="o">?</span><span class="n">current_shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Imitate numpy.matrix handling of shape arguments</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">downcast_intp_index</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Down-cast index array to np.intp dtype if it is of a larger dtype.</p>
<p>Raise an error if the array contains a value that is too large for
intp.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_index_dtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_contents</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Based on input (integer) arrays <code>a</code>, determine a suitable index data
type that can hold the data in the arrays.</p>
<h2 id="parameters_449">Parameters<a class="headerlink" href="#parameters_449" title="Permanent link">&para;</a></h2>
<p>arrays : tuple of array_like
Input arrays whose types/contents to check
maxval : float, optional
Maximum value needed
check_contents : bool, optional
Whether to check the values in the arrays and not just their types.
Default: False (check only the types)</p>
<h2 id="returns_358">Returns<a class="headerlink" href="#returns_358" title="Permanent link">&para;</a></h2>
<p>dtype : dtype
Suitable index data type (int32 or int64)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_sum_dtype</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Mimic numpy's casting for np.sum</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getdtype</span> <span class="o">:</span> <span class="o">?</span><span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">default</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Function used to simplify argument processing.  If 'dtype' is not
specified (is None), returns a.dtype; otherwise returns a np.dtype
object created from the specified dtype argument.  If 'dtype' and 'a'
are both None, construct a data type out of the 'default' parameter.
Furthermore, 'dtype' must be in 'allowed' set.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_pydata_spmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Check whether object is pydata/sparse matrix, avoiding importing the module.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isdense</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isintlike</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x appropriate as an index into a sparse matrix? Returns True
if it can be cast safely to a machine int.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ismatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isscalarlike</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x either a scalar, an array scalar, or a 0-dim array?</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">issequence</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isshape</span> <span class="o">:</span> <span class="o">?</span><span class="n">nonneg</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x a valid 2-tuple of dimensions?</p>
<p>If nonneg, also checks that the dimensions are non-negative.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_native</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the nearest supported sparse dtype for the
combination of one or more types.</p>
<p>upcast(t0, t1, ..., tn) -&gt; T  where T is a supported dtype</p>
<h2 id="examples_278">Examples<a class="headerlink" href="#examples_278" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>upcast('int32')
<type 'numpy.int32'>
upcast('bool')
<type 'numpy.bool_'>
upcast('int32','float32')
<type 'numpy.float64'>
upcast('bool',complex,float)
<type 'numpy.complex128'></p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast_char</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Same as <code>upcast</code> but taking dtype.char as input (faster).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upcast_scalar</span> <span class="o">:</span> <span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">scalar</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Determine data type for binary operation between an array of
type <code>dtype</code> and a scalar.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">validateaxis</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">block_diag</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">mats</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Build a block diagonal sparse matrix from provided matrices.</p>
<h2 id="parameters_450">Parameters<a class="headerlink" href="#parameters_450" title="Permanent link">&para;</a></h2>
<p>mats : sequence of matrices
Input matrices.
format : str, optional
The sparse format of the result (e.g. 'csr').  If not given, the matrix
is returned in 'coo' format.
dtype : dtype specifier, optional
The data-type of the output matrix.  If not given, the dtype is
determined from that of <code>blocks</code>.</p>
<h2 id="returns_359">Returns<a class="headerlink" href="#returns_359" title="Permanent link">&para;</a></h2>
<p>res : sparse matrix</p>
<h2 id="notes_209">Notes<a class="headerlink" href="#notes_209" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.11.0</p>
<h2 id="see-also_212">See Also<a class="headerlink" href="#see-also_212" title="Permanent link">&para;</a></h2>
<p>bmat, diags</p>
<h2 id="examples_279">Examples<a class="headerlink" href="#examples_279" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import coo_matrix, block_diag
A = coo_matrix([[1, 2], [3, 4]])
B = coo_matrix([[5], [6]])
C = coo_matrix([[7]])
block_diag((A, B, C)).toarray()
array([[1, 2, 0, 0],
[3, 4, 0, 0],
[0, 0, 5, 0],
[0, 0, 6, 0],
[0, 0, 0, 7]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bmat</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:[`</span><span class="nc">Lil</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bsr</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Csr</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Csc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Coo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dia</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dok</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">blocks</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Build a sparse matrix from sparse sub-blocks</p>
<h2 id="parameters_451">Parameters<a class="headerlink" href="#parameters_451" title="Permanent link">&para;</a></h2>
<p>blocks : array_like
Grid of sparse matrices with compatible shapes.
An entry of None implies an all-zero matrix.
format : {'bsr', 'coo', 'csc', 'csr', 'dia', 'dok', 'lil'}, optional
The sparse format of the result (e.g. 'csr').  By default an
appropriate sparse matrix format is returned.
This choice is subject to change.
dtype : dtype, optional
The data-type of the output matrix.  If not given, the dtype is
determined from that of <code>blocks</code>.</p>
<h2 id="returns_360">Returns<a class="headerlink" href="#returns_360" title="Permanent link">&para;</a></h2>
<p>bmat : sparse matrix</p>
<h2 id="see-also_213">See Also<a class="headerlink" href="#see-also_213" title="Permanent link">&para;</a></h2>
<p>block_diag, diags</p>
<h2 id="examples_280">Examples<a class="headerlink" href="#examples_280" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import coo_matrix, bmat
A = coo_matrix([[1, 2], [3, 4]])
B = coo_matrix([[5], [6]])
C = coo_matrix([[7]])
bmat([[A, B], [None, C]]).toarray()
array([[1, 2, 5],
[3, 4, 6],
[0, 0, 7]])</p>
<p>bmat([[A, None], [None, C]]).toarray()
array([[1, 2, 0],
[3, 4, 0],
[0, 0, 7]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diags</span> <span class="o">:</span> <span class="o">?</span><span class="n">offsets</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:[`</span><span class="nc">Lil</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Csr</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Csc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dia</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">diagonals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a sparse matrix from diagonals.</p>
<h2 id="parameters_452">Parameters<a class="headerlink" href="#parameters_452" title="Permanent link">&para;</a></h2>
<p>diagonals : sequence of array_like
Sequence of arrays containing the matrix diagonals,
corresponding to <code>offsets</code>.
offsets : sequence of int or an int, optional
Diagonals to set:
- k = 0  the main diagonal (default)
- k &gt; 0  the k-th upper diagonal
- k &lt; 0  the k-th lower diagonal
shape : tuple of int, optional
Shape of the result. If omitted, a square matrix large enough
to contain the diagonals is returned.
format : {'dia', 'csr', 'csc', 'lil', ...}, optional
Matrix format of the result.  By default (format=None) an
appropriate sparse matrix format is returned.  This choice is
subject to change.
dtype : dtype, optional
Data type of the matrix.</p>
<h2 id="see-also_214">See Also<a class="headerlink" href="#see-also_214" title="Permanent link">&para;</a></h2>
<p>spdiags : construct matrix from diagonals</p>
<h2 id="notes_210">Notes<a class="headerlink" href="#notes_210" title="Permanent link">&para;</a></h2>
<p>This function differs from <code>spdiags</code> in the way it handles
off-diagonals.</p>
<p>The result from <code>diags</code> is the sparse equivalent of::</p>
<p>np.diag(diagonals[0], offsets[0])
+ ...
+ np.diag(diagonals[k], offsets[k])</p>
<p>Repeated diagonal offsets are disallowed.</p>
<p>.. versionadded:: 0.11</p>
<h2 id="examples_281">Examples<a class="headerlink" href="#examples_281" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import diags
diagonals = [[1, 2, 3, 4], [1, 2, 3], [1, 2]]
diags(diagonals, [0, -1, 2]).toarray()
array([[1, 0, 1, 0],
[1, 2, 0, 2],
[0, 2, 3, 0],
[0, 0, 3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Broadcasting of scalars is supported (but shape needs to be
specified):</p>
<blockquote>
<blockquote>
<blockquote>
<p>diags([1, -2, 1], [-1, 0, 1], shape=(4, 4)).toarray()
array([[-2.,  1.,  0.,  0.],
[ 1., -2.,  1.,  0.],
[ 0.,  1., -2.,  1.],
[ 0.,  0.,  1., -2.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>If only one diagonal is wanted (as in <code>numpy.diag</code>), the following
works as well:</p>
<blockquote>
<blockquote>
<blockquote>
<p>diags([1, 2, 3], 1).toarray()
array([[ 0.,  1.,  0.,  0.],
[ 0.,  0.,  2.,  0.],
[ 0.,  0.,  0.,  3.],
[ 0.,  0.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eye</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sparse matrix with ones on diagonal</p>
<p>Returns a sparse (m x n) matrix where the k-th diagonal
is all ones and everything else is zeros.</p>
<h2 id="parameters_453">Parameters<a class="headerlink" href="#parameters_453" title="Permanent link">&para;</a></h2>
<p>m : int
Number of rows in the matrix.
n : int, optional
Number of columns. Default: <code>m</code>.
k : int, optional
Diagonal to place ones on. Default: 0 (main diagonal).
dtype : dtype, optional
Data type of the matrix.
format : str, optional
Sparse format of the result, e.g. format='csr', etc.</p>
<h2 id="examples_282">Examples<a class="headerlink" href="#examples_282" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import sparse
sparse.eye(3).toarray()
array([[ 1.,  0.,  0.],
[ 0.,  1.,  0.],
[ 0.,  0.,  1.]])
sparse.eye(3, dtype=np.int8)
&lt;3x3 sparse matrix of type '<class 'numpy.int8'>'
with 3 stored elements (1 diagonals) in DIAgonal format&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">find</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Dense</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the indices and values of the nonzero elements of a matrix</p>
<h2 id="parameters_454">Parameters<a class="headerlink" href="#parameters_454" title="Permanent link">&para;</a></h2>
<p>A : dense or sparse matrix
Matrix whose nonzero elements are desired.</p>
<h2 id="returns_361">Returns<a class="headerlink" href="#returns_361" title="Permanent link">&para;</a></h2>
<p>(I,J,V) : tuple of arrays
I,J, and V contain the row indices, column indices, and values
of the nonzero matrix entries.</p>
<h2 id="examples_283">Examples<a class="headerlink" href="#examples_283" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, find
A = csr_matrix([[7.0, 8.0, 0],[0, 0, 9.0]])
find(A)
(array([0, 0, 1], dtype=int32), array([0, 1, 2], dtype=int32), array([ 7.,  8.,  9.]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hstack</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">blocks</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Stack sparse matrices horizontally (column wise)</p>
<h2 id="parameters_455">Parameters<a class="headerlink" href="#parameters_455" title="Permanent link">&para;</a></h2>
<p>blocks
sequence of sparse matrices with compatible shapes
format : str
sparse format of the result (e.g. 'csr')
by default an appropriate sparse matrix format is returned.
This choice is subject to change.
dtype : dtype, optional
The data-type of the output matrix.  If not given, the dtype is
determined from that of <code>blocks</code>.</p>
<h2 id="see-also_215">See Also<a class="headerlink" href="#see-also_215" title="Permanent link">&para;</a></h2>
<p>vstack : stack sparse matrices vertically (row wise)</p>
<h2 id="examples_284">Examples<a class="headerlink" href="#examples_284" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import coo_matrix, hstack
A = coo_matrix([[1, 2], [3, 4]])
B = coo_matrix([[5], [6]])
hstack([A,B]).toarray()
array([[1, 2, 5],
[3, 4, 6]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">identity</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Identity matrix in sparse format</p>
<p>Returns an identity matrix with shape (n,n) using a given
sparse format and dtype.</p>
<h2 id="parameters_456">Parameters<a class="headerlink" href="#parameters_456" title="Permanent link">&para;</a></h2>
<p>n : int
Shape of the identity matrix.
dtype : dtype, optional
Data type of the matrix
format : str, optional
Sparse format of the result, e.g. format='csr', etc.</p>
<h2 id="examples_285">Examples<a class="headerlink" href="#examples_285" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import identity
identity(3).toarray()
array([[ 1.,  0.,  0.],
[ 0.,  1.,  0.],
[ 0.,  0.,  1.]])
identity(3, dtype='int8', format='dia')
&lt;3x3 sparse matrix of type '<class 'numpy.int8'>'
with 3 stored elements (1 diagonals) in DIAgonal format&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">issparse</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_457">Parameters<a class="headerlink" href="#parameters_457" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_362">Returns<a class="headerlink" href="#returns_362" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_211">Notes<a class="headerlink" href="#notes_211" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_286">Examples<a class="headerlink" href="#examples_286" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a sparse matrix type?</p>
<h2 id="parameters_458">Parameters<a class="headerlink" href="#parameters_458" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a sparse matrix</p>
<h2 id="returns_363">Returns<a class="headerlink" href="#returns_363" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a sparse matrix, False otherwise</p>
<h2 id="notes_212">Notes<a class="headerlink" href="#notes_212" title="Permanent link">&para;</a></h2>
<p>issparse and isspmatrix are aliases for the same function.</p>
<h2 id="examples_287">Examples<a class="headerlink" href="#examples_287" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix
isspmatrix(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import isspmatrix
isspmatrix(5)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_bsr</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of a bsr_matrix type?</p>
<h2 id="parameters_459">Parameters<a class="headerlink" href="#parameters_459" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a bsr matrix</p>
<h2 id="returns_364">Returns<a class="headerlink" href="#returns_364" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a bsr matrix, False otherwise</p>
<h2 id="examples_288">Examples<a class="headerlink" href="#examples_288" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import bsr_matrix, isspmatrix_bsr
isspmatrix_bsr(bsr_matrix([[5]]))
True</p>
<p>from scipy.sparse import bsr_matrix, csr_matrix, isspmatrix_bsr
isspmatrix_bsr(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_coo</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of coo_matrix type?</p>
<h2 id="parameters_460">Parameters<a class="headerlink" href="#parameters_460" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a coo matrix</p>
<h2 id="returns_365">Returns<a class="headerlink" href="#returns_365" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a coo matrix, False otherwise</p>
<h2 id="examples_289">Examples<a class="headerlink" href="#examples_289" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import coo_matrix, isspmatrix_coo
isspmatrix_coo(coo_matrix([[5]]))
True</p>
<p>from scipy.sparse import coo_matrix, csr_matrix, isspmatrix_coo
isspmatrix_coo(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_csc</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of csc_matrix type?</p>
<h2 id="parameters_461">Parameters<a class="headerlink" href="#parameters_461" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a csc matrix</p>
<h2 id="returns_366">Returns<a class="headerlink" href="#returns_366" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a csc matrix, False otherwise</p>
<h2 id="examples_290">Examples<a class="headerlink" href="#examples_290" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csc_matrix, isspmatrix_csc
isspmatrix_csc(csc_matrix([[5]]))
True</p>
<p>from scipy.sparse import csc_matrix, csr_matrix, isspmatrix_csc
isspmatrix_csc(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_csr</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of csr_matrix type?</p>
<h2 id="parameters_462">Parameters<a class="headerlink" href="#parameters_462" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a csr matrix</p>
<h2 id="returns_367">Returns<a class="headerlink" href="#returns_367" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a csr matrix, False otherwise</p>
<h2 id="examples_291">Examples<a class="headerlink" href="#examples_291" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, isspmatrix_csr
isspmatrix_csr(csr_matrix([[5]]))
True</p>
<p>from scipy.sparse import csc_matrix, csr_matrix, isspmatrix_csc
isspmatrix_csr(csc_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_dia</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of dia_matrix type?</p>
<h2 id="parameters_463">Parameters<a class="headerlink" href="#parameters_463" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a dia matrix</p>
<h2 id="returns_368">Returns<a class="headerlink" href="#returns_368" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a dia matrix, False otherwise</p>
<h2 id="examples_292">Examples<a class="headerlink" href="#examples_292" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import dia_matrix, isspmatrix_dia
isspmatrix_dia(dia_matrix([[5]]))
True</p>
<p>from scipy.sparse import dia_matrix, csr_matrix, isspmatrix_dia
isspmatrix_dia(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_dok</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of dok_matrix type?</p>
<h2 id="parameters_464">Parameters<a class="headerlink" href="#parameters_464" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a dok matrix</p>
<h2 id="returns_369">Returns<a class="headerlink" href="#returns_369" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a dok matrix, False otherwise</p>
<h2 id="examples_293">Examples<a class="headerlink" href="#examples_293" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import dok_matrix, isspmatrix_dok
isspmatrix_dok(dok_matrix([[5]]))
True</p>
<p>from scipy.sparse import dok_matrix, csr_matrix, isspmatrix_dok
isspmatrix_dok(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isspmatrix_lil</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Is x of lil_matrix type?</p>
<h2 id="parameters_465">Parameters<a class="headerlink" href="#parameters_465" title="Permanent link">&para;</a></h2>
<p>x
object to check for being a lil matrix</p>
<h2 id="returns_370">Returns<a class="headerlink" href="#returns_370" title="Permanent link">&para;</a></h2>
<p>bool
True if x is a lil matrix, False otherwise</p>
<h2 id="examples_294">Examples<a class="headerlink" href="#examples_294" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import lil_matrix, isspmatrix_lil
isspmatrix_lil(lil_matrix([[5]]))
True</p>
<p>from scipy.sparse import lil_matrix, csr_matrix, isspmatrix_lil
isspmatrix_lil(csr_matrix([[5]]))
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kron</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kronecker product of sparse matrices A and B</p>
<h2 id="parameters_466">Parameters<a class="headerlink" href="#parameters_466" title="Permanent link">&para;</a></h2>
<p>A : sparse or dense matrix
first matrix of the product
B : sparse or dense matrix
second matrix of the product
format : str, optional
format of the result (e.g. 'csr')</p>
<h2 id="returns_371">Returns<a class="headerlink" href="#returns_371" title="Permanent link">&para;</a></h2>
<p>kronecker product in a sparse matrix format</p>
<h2 id="examples_295">Examples<a class="headerlink" href="#examples_295" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import sparse
A = sparse.csr_matrix(np.array([[0, 2], [5, 0]]))
B = sparse.csr_matrix(np.array([[1, 2], [3, 4]]))
sparse.kron(A, B).toarray()
array([[ 0,  0,  2,  4],
[ 0,  0,  6,  8],
[ 5, 10,  0,  0],
[15, 20,  0,  0]])</p>
<p>sparse.kron(A, [[1, 2], [3, 4]]).toarray()
array([[ 0,  0,  2,  4],
[ 0,  0,  6,  8],
[ 5, 10,  0,  0],
[15, 20,  0,  0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kronsum</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kronecker sum of sparse matrices A and B</p>
<p>Kronecker sum of two sparse matrices is a sum of two Kronecker
products kron(I_n,A) + kron(B,I_m) where A has shape (m,m)
and B has shape (n,n) and I_m and I_n are identity matrices
of shape (m,m) and (n,n) respectively.</p>
<h2 id="parameters_467">Parameters<a class="headerlink" href="#parameters_467" title="Permanent link">&para;</a></h2>
<p>A
square matrix
B
square matrix
format : str
format of the result (e.g. 'csr')</p>
<h2 id="returns_372">Returns<a class="headerlink" href="#returns_372" title="Permanent link">&para;</a></h2>
<p>kronecker sum in a sparse matrix format</p>
<h2 id="examples_296">Examples<a class="headerlink" href="#examples_296" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">load_npz</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">File_like_object</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Load a sparse matrix from a file using <code>.npz</code> format.</p>
<h2 id="parameters_468">Parameters<a class="headerlink" href="#parameters_468" title="Permanent link">&para;</a></h2>
<p>file : str or file-like object
Either the file name (string) or an open file (file-like object)
where the data will be loaded.</p>
<h2 id="returns_373">Returns<a class="headerlink" href="#returns_373" title="Permanent link">&para;</a></h2>
<p>result : csc_matrix, csr_matrix, bsr_matrix, dia_matrix or coo_matrix
A sparse matrix containing the loaded data.</p>
<h2 id="raises_30">Raises<a class="headerlink" href="#raises_30" title="Permanent link">&para;</a></h2>
<p>IOError
If the input file does not exist or cannot be read.</p>
<h2 id="see-also_216">See Also<a class="headerlink" href="#see-also_216" title="Permanent link">&para;</a></h2>
<p>scipy.sparse.save_npz: Save a sparse matrix to a file using <code>.npz</code> format.
numpy.load: Load several arrays from a <code>.npz</code> archive.</p>
<h2 id="examples_297">Examples<a class="headerlink" href="#examples_297" title="Permanent link">&para;</a></h2>
<p>Store sparse matrix to disk, and load it again:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.sparse
sparse_matrix = scipy.sparse.csc_matrix(np.array([[0, 0, 3], [4, 0, 0]]))
sparse_matrix
&lt;2x3 sparse matrix of type '<class 'numpy.int64'>'
with 2 stored elements in Compressed Sparse Column format&gt;
sparse_matrix.todense()
matrix([[0, 0, 3],
[4, 0, 0]], dtype=int64)</p>
<p>scipy.sparse.save_npz('/tmp/sparse_matrix.npz', sparse_matrix)
sparse_matrix = scipy.sparse.load_npz('/tmp/sparse_matrix.npz')</p>
<p>sparse_matrix
&lt;2x3 sparse matrix of type '<class 'numpy.int64'>'
with 2 stored elements in Compressed Sparse Column format&gt;
sparse_matrix.todense()
matrix([[0, 0, 3],
[4, 0, 0]], dtype=int64)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rand</span> <span class="o">:</span> <span class="o">?</span><span class="n">density</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">random_state</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Numpy_random_RandomState</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Generate a sparse matrix of the given shape and density with uniformly
distributed values.</p>
<h2 id="parameters_469">Parameters<a class="headerlink" href="#parameters_469" title="Permanent link">&para;</a></h2>
<p>m, n : int
shape of the matrix
density : real, optional
density of the generated matrix: density equal to one means a full
matrix, density of 0 means a matrix with no non-zero items.
format : str, optional
sparse matrix format.
dtype : dtype, optional
type of the returned matrix values.
random_state : {numpy.random.RandomState, int}, optional
Random number generator or random seed. If not given, the singleton
numpy.random will be used.</p>
<h2 id="returns_374">Returns<a class="headerlink" href="#returns_374" title="Permanent link">&para;</a></h2>
<p>res : sparse matrix</p>
<h2 id="notes_213">Notes<a class="headerlink" href="#notes_213" title="Permanent link">&para;</a></h2>
<p>Only float types are supported for now.</p>
<h2 id="see-also_217">See Also<a class="headerlink" href="#see-also_217" title="Permanent link">&para;</a></h2>
<p>scipy.sparse.random : Similar function that allows a user-specified random
data source.</p>
<h2 id="examples_298">Examples<a class="headerlink" href="#examples_298" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import rand
matrix = rand(3, 4, density=0.25, format='csr', random_state=42)
matrix
&lt;3x4 sparse matrix of type '<class 'numpy.float64'>'
with 3 stored elements in Compressed Sparse Row format&gt;
matrix.todense()
matrix([[0.05641158, 0.        , 0.        , 0.65088847],
[0.        , 0.        , 0.        , 0.14286682],
[0.        , 0.        , 0.        , 0.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">random</span> <span class="o">:</span> <span class="o">?</span><span class="n">density</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">random_state</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Numpy_random_RandomState</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">data_rvs</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Generate a sparse matrix of the given shape and density with randomly
distributed values.</p>
<h2 id="parameters_470">Parameters<a class="headerlink" href="#parameters_470" title="Permanent link">&para;</a></h2>
<p>m, n : int
shape of the matrix
density : real, optional
density of the generated matrix: density equal to one means a full
matrix, density of 0 means a matrix with no non-zero items.
format : str, optional
sparse matrix format.
dtype : dtype, optional
type of the returned matrix values.
random_state : {numpy.random.RandomState, int}, optional
Random number generator or random seed. If not given, the singleton
numpy.random will be used.  This random state will be used
for sampling the sparsity structure, but not necessarily for sampling
the values of the structurally nonzero entries of the matrix.
data_rvs : callable, optional
Samples a requested number of random values.
This function should take a single argument specifying the length
of the ndarray that it will return.  The structurally nonzero entries
of the sparse random matrix will be taken from the array sampled
by this function.  By default, uniform [0, 1) random values will be
sampled using the same random state as is used for sampling
the sparsity structure.</p>
<h2 id="returns_375">Returns<a class="headerlink" href="#returns_375" title="Permanent link">&para;</a></h2>
<p>res : sparse matrix</p>
<h2 id="notes_214">Notes<a class="headerlink" href="#notes_214" title="Permanent link">&para;</a></h2>
<p>Only float types are supported for now.</p>
<h2 id="examples_299">Examples<a class="headerlink" href="#examples_299" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import random
from scipy import stats</p>
<p>class CustomRandomState(np.random.RandomState):
...     def randint(self, k):
...         i = np.random.randint(k)
...         return i - i % 2
np.random.seed(12345)
rs = CustomRandomState()
rvs = stats.poisson(25, loc=10).rvs
S = random(3, 4, density=0.25, random_state=rs, data_rvs=rvs)
S.A
array([[ 36.,   0.,  33.,   0.],   # random
[  0.,   0.,   0.,   0.],
[  0.,   0.,  36.,   0.]])</p>
<p>from scipy.sparse import random
from scipy.stats import rv_continuous
class CustomDistribution(rv_continuous):
...     def _rvs(self, <em>args, </em><em>kwargs):
...         return self._random_state.randn( </em>self._size)
X = CustomDistribution(seed=2906)
Y = X()  # get a frozen version of the distribution
S = random(3, 4, density=0.25, random_state=2906, data_rvs=Y.rvs)
S.A
array([[ 0.        ,  0.        ,  0.        ,  0.        ],
[ 0.13569738,  1.9467163 , -0.81205367,  0.        ],
[ 0.        ,  0.        ,  0.        ,  0.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">save_npz</span> <span class="o">:</span> <span class="o">?</span><span class="n">compressed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">file</span><span class="o">:[`</span><span class="nc">File_like_object</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">matrix</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Save a sparse matrix to a file using <code>.npz</code> format.</p>
<h2 id="parameters_471">Parameters<a class="headerlink" href="#parameters_471" title="Permanent link">&para;</a></h2>
<p>file : str or file-like object
Either the file name (string) or an open file (file-like object)
where the data will be saved. If file is a string, the <code>.npz</code>
extension will be appended to the file name if it is not already
there.
matrix: spmatrix (format: <code>csc</code>, <code>csr</code>, <code>bsr</code>, <code>dia</code> or coo``)
The sparse matrix to save.
compressed : bool, optional
Allow compressing the file. Default: True</p>
<h2 id="see-also_218">See Also<a class="headerlink" href="#see-also_218" title="Permanent link">&para;</a></h2>
<p>scipy.sparse.load_npz: Load a sparse matrix from a file using <code>.npz</code> format.
numpy.savez: Save several arrays into a <code>.npz</code> archive.
numpy.savez_compressed : Save several arrays into a compressed <code>.npz</code> archive.</p>
<h2 id="examples_300">Examples<a class="headerlink" href="#examples_300" title="Permanent link">&para;</a></h2>
<p>Store sparse matrix to disk, and load it again:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.sparse
sparse_matrix = scipy.sparse.csc_matrix(np.array([[0, 0, 3], [4, 0, 0]]))
sparse_matrix
&lt;2x3 sparse matrix of type '<class 'numpy.int64'>'
with 2 stored elements in Compressed Sparse Column format&gt;
sparse_matrix.todense()
matrix([[0, 0, 3],
[4, 0, 0]], dtype=int64)</p>
<p>scipy.sparse.save_npz('/tmp/sparse_matrix.npz', sparse_matrix)
sparse_matrix = scipy.sparse.load_npz('/tmp/sparse_matrix.npz')</p>
<p>sparse_matrix
&lt;2x3 sparse matrix of type '<class 'numpy.int64'>'
with 2 stored elements in Compressed Sparse Column format&gt;
sparse_matrix.todense()
matrix([[0, 0, 3],
[4, 0, 0]], dtype=int64)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spdiags</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">diags</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a sparse matrix from diagonals.</p>
<h2 id="parameters_472">Parameters<a class="headerlink" href="#parameters_472" title="Permanent link">&para;</a></h2>
<p>data : array_like
matrix diagonals stored row-wise
diags : diagonals to set
- k = 0  the main diagonal
- k &gt; 0  the k-th upper diagonal
- k &lt; 0  the k-th lower diagonal
m, n : int
shape of the result
format : str, optional
Format of the result. By default (format=None) an appropriate sparse
matrix format is returned.  This choice is subject to change.</p>
<h2 id="see-also_219">See Also<a class="headerlink" href="#see-also_219" title="Permanent link">&para;</a></h2>
<p>diags : more convenient form of this function
dia_matrix : the sparse DIAgonal format.</p>
<h2 id="examples_301">Examples<a class="headerlink" href="#examples_301" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import spdiags
data = np.array([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]])
diags = np.array([0, -1, 2])
spdiags(data, diags, 4, 4).toarray()
array([[1, 0, 3, 0],
[1, 2, 0, 4],
[0, 2, 3, 0],
[0, 0, 3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tril</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Dense</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the lower triangular portion of a matrix in sparse format</p>
<p>Returns the elements on or below the k-th diagonal of the matrix A.
- k = 0 corresponds to the main diagonal
- k &gt; 0 is above the main diagonal
- k &lt; 0 is below the main diagonal</p>
<h2 id="parameters_473">Parameters<a class="headerlink" href="#parameters_473" title="Permanent link">&para;</a></h2>
<p>A : dense or sparse matrix
Matrix whose lower trianglar portion is desired.
k : integer : optional
The top-most diagonal of the lower triangle.
format : string
Sparse format of the result, e.g. format='csr', etc.</p>
<h2 id="returns_376">Returns<a class="headerlink" href="#returns_376" title="Permanent link">&para;</a></h2>
<p>L : sparse matrix
Lower triangular portion of A in sparse format.</p>
<h2 id="see-also_220">See Also<a class="headerlink" href="#see-also_220" title="Permanent link">&para;</a></h2>
<p>triu : upper triangle in sparse format</p>
<h2 id="examples_302">Examples<a class="headerlink" href="#examples_302" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, tril
A = csr_matrix([[1, 2, 0, 0, 3], [4, 5, 0, 6, 7], [0, 0, 8, 9, 0]],
...                dtype='int32')
A.toarray()
array([[1, 2, 0, 0, 3],
[4, 5, 0, 6, 7],
[0, 0, 8, 9, 0]])
tril(A).toarray()
array([[1, 0, 0, 0, 0],
[4, 5, 0, 0, 0],
[0, 0, 8, 0, 0]])
tril(A).nnz
4
tril(A, k=1).toarray()
array([[1, 2, 0, 0, 0],
[4, 5, 0, 0, 0],
[0, 0, 8, 9, 0]])
tril(A, k=-1).toarray()
array([[0, 0, 0, 0, 0],
[4, 0, 0, 0, 0],
[0, 0, 0, 0, 0]])
tril(A, format='csc')
&lt;3x5 sparse matrix of type '<class 'numpy.int32'>'
with 4 stored elements in Compressed Sparse Column format&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">triu</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Dense</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spmatrix</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Object</span><span class="o">|`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the upper triangular portion of a matrix in sparse format</p>
<p>Returns the elements on or above the k-th diagonal of the matrix A.
- k = 0 corresponds to the main diagonal
- k &gt; 0 is above the main diagonal
- k &lt; 0 is below the main diagonal</p>
<h2 id="parameters_474">Parameters<a class="headerlink" href="#parameters_474" title="Permanent link">&para;</a></h2>
<p>A : dense or sparse matrix
Matrix whose upper trianglar portion is desired.
k : integer : optional
The bottom-most diagonal of the upper triangle.
format : string
Sparse format of the result, e.g. format='csr', etc.</p>
<h2 id="returns_377">Returns<a class="headerlink" href="#returns_377" title="Permanent link">&para;</a></h2>
<p>L : sparse matrix
Upper triangular portion of A in sparse format.</p>
<h2 id="see-also_221">See Also<a class="headerlink" href="#see-also_221" title="Permanent link">&para;</a></h2>
<p>tril : lower triangle in sparse format</p>
<h2 id="examples_303">Examples<a class="headerlink" href="#examples_303" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import csr_matrix, triu
A = csr_matrix([[1, 2, 0, 0, 3], [4, 5, 0, 6, 7], [0, 0, 8, 9, 0]],
...                dtype='int32')
A.toarray()
array([[1, 2, 0, 0, 3],
[4, 5, 0, 6, 7],
[0, 0, 8, 9, 0]])
triu(A).toarray()
array([[1, 2, 0, 0, 3],
[0, 5, 0, 6, 7],
[0, 0, 8, 9, 0]])
triu(A).nnz
8
triu(A, k=1).toarray()
array([[0, 2, 0, 0, 3],
[0, 0, 0, 6, 7],
[0, 0, 0, 9, 0]])
triu(A, k=-1).toarray()
array([[1, 2, 0, 0, 3],
[4, 5, 0, 6, 7],
[0, 0, 8, 9, 0]])
triu(A, format='csc')
&lt;3x5 sparse matrix of type '<class 'numpy.int32'>'
with 8 stored elements in Compressed Sparse Column format&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vstack</span> <span class="o">:</span> <span class="o">?</span><span class="n">format</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">blocks</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Stack sparse matrices vertically (row wise)</p>
<h2 id="parameters_475">Parameters<a class="headerlink" href="#parameters_475" title="Permanent link">&para;</a></h2>
<p>blocks
sequence of sparse matrices with compatible shapes
format : str, optional
sparse format of the result (e.g. 'csr')
by default an appropriate sparse matrix format is returned.
This choice is subject to change.
dtype : dtype, optional
The data-type of the output matrix.  If not given, the dtype is
determined from that of <code>blocks</code>.</p>
<h2 id="see-also_222">See Also<a class="headerlink" href="#see-also_222" title="Permanent link">&para;</a></h2>
<p>hstack : stack sparse matrices horizontally (column wise)</p>
<h2 id="examples_304">Examples<a class="headerlink" href="#examples_304" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import coo_matrix, vstack
A = coo_matrix([[1, 2], [3, 4]])
B = coo_matrix([[5, 6]])
vstack([A, B]).toarray()
array([[1, 2],
[3, 4],
[5, 6]])</p>
</blockquote>
</blockquote>
</blockquote>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../Signal/" title="Signal" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Signal
              </div>
            </div>
          </a>
        
        
          <a href="../Spatial/" title="Spatial" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Spatial
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.d710d30a.min.js"></script>
      <script src="../../assets/javascripts/bundle.a45f732b.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: ["instant", "tabs"],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.c03f0417.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>