


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.2.3">
    
    
      
        <title>Special - OCaml scikit-learn interface</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6e35a1a6.min.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a46bcfb3.min.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#parameters" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="OCaml scikit-learn interface" class="md-header-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            OCaml scikit-learn interface
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Special
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
          

  

<nav class="md-tabs md-tabs--active" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../np/" class="md-tabs__link">
          Np
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../" class="md-tabs__link md-tabs__link--active">
          Scipy
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../sklearn/Base/" class="md-tabs__link">
          Sklearn
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OCaml scikit-learn interface" class="md-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    OCaml scikit-learn interface
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Np
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Np" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Np
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/" title="Numpy for OCaml" class="md-nav__link">
      Numpy for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/Numpy/" title="Numpy" class="md-nav__link">
      Numpy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/NumpyRaw/" title="NumpyRaw" class="md-nav__link">
      NumpyRaw
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/PyList/" title="PyList" class="md-nav__link">
      PyList
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/dtype/" title="Dtype" class="md-nav__link">
      Dtype
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/obj/" title="Obj" class="md-nav__link">
      Obj
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Scipy
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Scipy" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Scipy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="SciPy library for OCaml" class="md-nav__link">
      SciPy library for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Constants/" title="Constants" class="md-nav__link">
      Constants
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fft/" title="Fft" class="md-nav__link">
      Fft
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fftpack/" title="Fftpack" class="md-nav__link">
      Fftpack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Integrate/" title="Integrate" class="md-nav__link">
      Integrate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interpolate/" title="Interpolate" class="md-nav__link">
      Interpolate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Io/" title="Io" class="md-nav__link">
      Io
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Linalg/" title="Linalg" class="md-nav__link">
      Linalg
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Misc/" title="Misc" class="md-nav__link">
      Misc
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Ndimage/" title="Ndimage" class="md-nav__link">
      Ndimage
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Odr/" title="Odr" class="md-nav__link">
      Odr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Optimize/" title="Optimize" class="md-nav__link">
      Optimize
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Signal/" title="Signal" class="md-nav__link">
      Signal
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Sparse/" title="Sparse" class="md-nav__link">
      Sparse
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Spatial/" title="Spatial" class="md-nav__link">
      Spatial
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Special" class="md-nav__link md-nav__link--active">
      Special
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Stats/" title="Stats" class="md-nav__link">
      Stats
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Version/" title="Version" class="md-nav__link">
      Version
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Sklearn
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Sklearn" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Sklearn
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Base/" title="Base" class="md-nav__link">
      Base
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Calibration/" title="Calibration" class="md-nav__link">
      Calibration
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Compose/" title="Compose" class="md-nav__link">
      Compose
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Covariance/" title="Covariance" class="md-nav__link">
      Covariance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cross_decomposition/" title="Cross decomposition" class="md-nav__link">
      Cross decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Datasets/" title="Datasets" class="md-nav__link">
      Datasets
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Decomposition/" title="Decomposition" class="md-nav__link">
      Decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Discriminant_analysis/" title="Discriminant analysis" class="md-nav__link">
      Discriminant analysis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Dummy/" title="Dummy" class="md-nav__link">
      Dummy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Ensemble/" title="Ensemble" class="md-nav__link">
      Ensemble
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Exceptions/" title="Exceptions" class="md-nav__link">
      Exceptions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Experimental/" title="Experimental" class="md-nav__link">
      Experimental
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Externals/" title="Externals" class="md-nav__link">
      Externals
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_extraction/" title="Feature extraction" class="md-nav__link">
      Feature extraction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_selection/" title="Feature selection" class="md-nav__link">
      Feature selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Gaussian_process/" title="Gaussian process" class="md-nav__link">
      Gaussian process
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Impute/" title="Impute" class="md-nav__link">
      Impute
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Inspection/" title="Inspection" class="md-nav__link">
      Inspection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Isotonic/" title="Isotonic" class="md-nav__link">
      Isotonic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_approximation/" title="Kernel approximation" class="md-nav__link">
      Kernel approximation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_ridge/" title="Kernel ridge" class="md-nav__link">
      Kernel ridge
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Linear_model/" title="Linear model" class="md-nav__link">
      Linear model
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Manifold/" title="Manifold" class="md-nav__link">
      Manifold
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Metrics/" title="Metrics" class="md-nav__link">
      Metrics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Mixture/" title="Mixture" class="md-nav__link">
      Mixture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Model_selection/" title="Model selection" class="md-nav__link">
      Model selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multiclass/" title="Multiclass" class="md-nav__link">
      Multiclass
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multioutput/" title="Multioutput" class="md-nav__link">
      Multioutput
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Naive_bayes/" title="Naive bayes" class="md-nav__link">
      Naive bayes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neighbors/" title="Neighbors" class="md-nav__link">
      Neighbors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neural_network/" title="Neural network" class="md-nav__link">
      Neural network
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Pipeline/" title="Pipeline" class="md-nav__link">
      Pipeline
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Preprocessing/" title="Preprocessing" class="md-nav__link">
      Preprocessing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Random_projection/" title="Random projection" class="md-nav__link">
      Random projection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Semi_supervised/" title="Semi supervised" class="md-nav__link">
      Semi supervised
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Svm/" title="Svm" class="md-nav__link">
      Svm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tests/" title="Tests" class="md-nav__link">
      Tests
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tree/" title="Tree" class="md-nav__link">
      Tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Utils/" title="Utils" class="md-nav__link">
      Utils
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/arr/" title="Arr" class="md-nav__link">
      Arr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/dict/" title="Dict" class="md-nav__link">
      Dict
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/lehy/ocaml-sklearn/edit/master/docs/scipy/Special.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  
                
                
                <p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">SpecialFunctionError</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">SpecialFunctionError</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SpecialFunctionError</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">SpecialFunctionWarning</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">SpecialFunctionWarning</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SpecialFunctionWarning</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Errstate</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Errstate</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Errstate</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Context manager for special-function error handling.</p>
<p>Using an instance of <code>errstate</code> as a context manager allows
statements in that context to execute with a known error handling
behavior. Upon entering the context the error handling is set with
<code>seterr</code>, and upon exiting it is restored to what it was before.</p>
<h2 id="parameters">Parameters<a class="headerlink" href="#parameters" title="Permanent link">&para;</a></h2>
<p>kwargs : {all, singular, underflow, overflow, slow, loss, no_result, domain, arg, other}
Keyword arguments. The valid keywords are possible
special-function errors. Each keyword should have a string
value that defines the treatement for the particular type of
error. Values must be 'ignore', 'warn', or 'other'. See
<code>seterr</code> for details.</p>
<h2 id="see-also">See Also<a class="headerlink" href="#see-also" title="Permanent link">&para;</a></h2>
<p>geterr : get the current way of handling special-function errors
seterr : set how special-function errors are handled
numpy.errstate : similar numpy function for floating-point errors</p>
<h2 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc
from pytest import raises
sc.gammaln(0)
inf
with sc.errstate(singular='raise'):
...     with raises(sc.SpecialFunctionError):
...         sc.gammaln(0)
...
sc.gammaln(0)
inf</p>
</blockquote>
</blockquote>
</blockquote>
<p>We can also raise on every category except one.</p>
<blockquote>
<blockquote>
<blockquote>
<p>with sc.errstate(all='raise', singular='ignore'):
...     sc.gammaln(0)
...     with raises(sc.SpecialFunctionError):
...         sc.spence(-1)
...
inf</p>
</blockquote>
</blockquote>
</blockquote>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Orthogonal</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Int</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Int</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.<strong>int</strong>().  For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<blockquote>
<blockquote>
<blockquote>
<p>int('0b100', base=0)
4</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">as_integer_ratio</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return integer ratio.</p>
<p>Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(10).as_integer_ratio()
(10, 1)
(-10).as_integer_ratio()
(-10, 1)
(0).as_integer_ratio()
(0, 1)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bit_length</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Number of bits necessary to represent self in binary.</p>
<blockquote>
<blockquote>
<blockquote>
<p>bin(37)
'0b100101'
(37).bit_length()
6</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">from_bytes</span> <span class="o">:</span> <span class="o">?</span><span class="n">signed</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">bytes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">byteorder</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the integer represented by the given array of bytes.</p>
<p>bytes
Holds the array of bytes to convert.  The argument must either
support the buffer protocol or be an iterable object producing bytes.
Bytes and bytearray are examples of built-in objects that support the
buffer protocol.
byteorder
The byte order used to represent the integer.  If byteorder is 'big',
the most significant byte is at the beginning of the byte array.  If
byteorder is 'little', the most significant byte is at the end of the
byte array.  To request the native byte order of the host system, use
`sys.byteorder' as the byte order value.
signed
Indicates whether two's complement is used to represent the integer.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_bytes</span> <span class="o">:</span> <span class="o">?</span><span class="n">signed</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">length</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">byteorder</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an array of bytes representing an integer.</p>
<p>length
Length of bytes object to use.  An OverflowError is raised if the
integer is not representable with the given number of bytes.
byteorder
The byte order used to represent the integer.  If byteorder is 'big',
the most significant byte is at the beginning of the byte array.  If
byteorder is 'little', the most significant byte is at the end of the
byte array.  To request the native byte order of the host system, use
`sys.byteorder' as the byte order value.
signed
Determines whether two's complement is used to represent the integer.
If signed is False and a negative integer is given, an OverflowError
is raised.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Orthopoly1d</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Orthopoly1d</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Orthopoly1d</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">weights</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">hn</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kn</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">wfunc</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">limits</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eval_func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">roots</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>A one-dimensional polynomial class.</p>
<p>A convenience class, used to encapsulate 'natural' operations on
polynomials so that said operations may take on their customary
form in code (see Examples).</p>
<h2 id="parameters_1">Parameters<a class="headerlink" href="#parameters_1" title="Permanent link">&para;</a></h2>
<p>c_or_r : array_like
The polynomial's coefficients, in decreasing powers, or if
the value of the second parameter is True, the polynomial's
roots (values where the polynomial evaluates to 0).  For example,
<code>poly1d([1, 2, 3])</code> returns an object that represents
:math:<code>x^2 + 2x + 3</code>, whereas <code>poly1d([1, 2, 3], True)</code> returns
one that represents :math:<code>(x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x -6</code>.
r : bool, optional
If True, <code>c_or_r</code> specifies the polynomial's roots; the default
is False.
variable : str, optional
Changes the variable used when printing <code>p</code> from <code>x</code> to <code>variable</code>
(see Examples).</p>
<h2 id="examples_1">Examples<a class="headerlink" href="#examples_1" title="Permanent link">&para;</a></h2>
<p>Construct the polynomial :math:<code>x^2 + 2x + 3</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p = np.poly1d([1, 2, 3])
print(np.poly1d(p))
2
1 x + 2 x + 3</p>
</blockquote>
</blockquote>
</blockquote>
<p>Evaluate the polynomial at :math:<code>x = 0.5</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p(0.5)
4.25</p>
</blockquote>
</blockquote>
</blockquote>
<p>Find the roots:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p.r
array([-1.+1.41421356j, -1.-1.41421356j])
p(p.r)
array([ -4.44089210e-16+0.j,  -4.44089210e-16+0.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>These numbers in the previous line represent (0, 0) to machine precision</p>
<p>Show the coefficients:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p.c
array([1, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Display the order (the leading zero-coefficients are removed):</p>
<blockquote>
<blockquote>
<blockquote>
<p>p.order
2</p>
</blockquote>
</blockquote>
</blockquote>
<p>Show the coefficient of the k-th power in the polynomial
(which is equivalent to <code>p.c[-(i+1)]</code>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>p[1]
2</p>
</blockquote>
</blockquote>
</blockquote>
<p>Polynomials can be added, subtracted, multiplied, and divided
(returns quotient and remainder):</p>
<blockquote>
<blockquote>
<blockquote>
<p>p * p
poly1d([ 1,  4, 10, 12,  9])</p>
<p>(p**3 + 4) / p
(poly1d([ 1.,  4., 10., 12.,  9.]), poly1d([4.]))</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>asarray(p)</code> gives the coefficient array, so polynomials can be
used in all functions that accept arrays:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p**2 # square of polynomial
poly1d([ 1,  4, 10, 12,  9])</p>
<p>np.square(p) # square of individual coefficients
array([1, 4, 9])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The variable used in the string representation of <code>p</code> can be modified,
using the <code>variable</code> parameter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p = np.poly1d([1,2,3], variable='z')
print(p)
2
1 z + 2 z + 3</p>
</blockquote>
</blockquote>
</blockquote>
<p>Construct a polynomial from its roots:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.poly1d([1, 2], True)
poly1d([ 1., -3.,  2.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>This is the same polynomial as obtained by:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.poly1d([1, -1]) * np.poly1d([1, -2])
poly1d([ 1, -3,  2])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">val_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">setitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">val_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">deriv</span> <span class="o">:</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a derivative of this polynomial.</p>
<p>Refer to <code>polyder</code> for full documentation.</p>
<h2 id="see-also_1">See Also<a class="headerlink" href="#see-also_1" title="Permanent link">&para;</a></h2>
<p>polyder : equivalent function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">integ</span> <span class="o">:</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an antiderivative (indefinite integral) of this polynomial.</p>
<p>Refer to <code>polyint</code> for full documentation.</p>
<h2 id="see-also_2">See Also<a class="headerlink" href="#see-also_2" title="Permanent link">&para;</a></h2>
<p>polyint : equivalent function</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Cephes</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">agm</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>agm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>agm(a, b)</p>
<p>Compute the arithmetic-geometric mean of <code>a</code> and <code>b</code>.</p>
<p>Start with a_0 = a and b_0 = b and iteratively compute::</p>
<p>a_{n+1} = (a_n + b_n)/2
b_{n+1} = sqrt(a_n*b_n)</p>
<p>a_n and b_n converge to the same limit as n increases; their common
limit is agm(a, b).</p>
<h2 id="parameters_2">Parameters<a class="headerlink" href="#parameters_2" title="Permanent link">&para;</a></h2>
<p>a, b : array_like
Real values only.  If the values are both negative, the result
is negative.  If one value is negative and the other is positive,
<code>nan</code> is returned.</p>
<h2 id="returns">Returns<a class="headerlink" href="#returns" title="Permanent link">&para;</a></h2>
<p>float
The arithmetic-geometric mean of <code>a</code> and <code>b</code>.</p>
<h2 id="examples_2">Examples<a class="headerlink" href="#examples_2" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import agm
a, b = 24.0, 6.0
agm(a, b)
13.458171481725614</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare that result to the iteration:</p>
<blockquote>
<blockquote>
<blockquote>
<p>while a != b:
...     a, b = (a + b)/2, np.sqrt(a*b)
...     print('a = %19.16f  b=%19.16f' % (a, b))
...
a = 15.0000000000000000  b=12.0000000000000000
a = 13.5000000000000000  b=13.4164078649987388
a = 13.4582039324993694  b=13.4581390309909850
a = 13.4581714817451772  b=13.4581714817060547
a = 13.4581714817256159  b=13.4581714817256159</p>
</blockquote>
</blockquote>
</blockquote>
<p>When array-like arguments are given, broadcasting applies:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1.5], [3], [6]])  # a has shape (3, 1).
b = np.array([6, 12, 24, 48])    # b has shape (4,).
agm(a, b)
array([[  3.36454287,   5.42363427,   9.05798751,  15.53650756],
[  4.37037309,   6.72908574,  10.84726853,  18.11597502],
[  6.        ,   8.74074619,  13.45817148,  21.69453707]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">airy</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>airy(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>airy(z)</p>
<p>Airy functions and their derivatives.</p>
<h2 id="parameters_3">Parameters<a class="headerlink" href="#parameters_3" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex argument.</p>
<h2 id="returns_1">Returns<a class="headerlink" href="#returns_1" title="Permanent link">&para;</a></h2>
<p>Ai, Aip, Bi, Bip : ndarrays
Airy functions Ai and Bi, and their derivatives Aip and Bip.</p>
<h2 id="notes">Notes<a class="headerlink" href="#notes" title="Permanent link">&para;</a></h2>
<p>The Airy functions Ai and Bi are two independent solutions of</p>
<p>.. math:: y''(x) = x y(x).</p>
<p>For real <code>z</code> in [-10, 10], the computation is carried out by calling
the Cephes [1]_ <code>airy</code> routine, which uses power series summation
for small <code>z</code> and rational minimax approximations for large <code>z</code>.</p>
<p>Outside this range, the AMOS [2]_ <code>zairy</code> and <code>zbiry</code> routines are
employed.  They are computed using power series for :math:<code>|z| &lt; 1</code> and
the following relations to modified Bessel functions for larger <code>z</code>
(where :math:<code>t \equiv 2 z^{3/2}/3</code>):</p>
<p>.. math::</p>
<p>Ai(z) = \frac{1}{\pi \sqrt{3}} K_{1/3}(t)</p>
<p>Ai'(z) = -\frac{z}{\pi \sqrt{3}} K_{2/3}(t)</p>
<p>Bi(z) = \sqrt{\frac{z}{3}} \left(I_{-1/3}(t) + I_{1/3}(t) \right)</p>
<p>Bi'(z) = \frac{z}{\sqrt{3}} \left(I_{-2/3}(t) + I_{2/3}(t)\right)</p>
<h2 id="see-also_3">See also<a class="headerlink" href="#see-also_3" title="Permanent link">&para;</a></h2>
<p>airye : exponentially scaled Airy functions.</p>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/
.. [2] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<h2 id="examples_3">Examples<a class="headerlink" href="#examples_3" title="Permanent link">&para;</a></h2>
<p>Compute the Airy functions on the interval [-15, 5].</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
x = np.linspace(-15, 5, 201)
ai, aip, bi, bip = special.airy(x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot Ai(x) and Bi(x).</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.plot(x, ai, 'r', label='Ai(x)')
plt.plot(x, bi, 'b--', label='Bi(x)')
plt.ylim(-0.5, 1.0)
plt.grid()
plt.legend(loc='upper left')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">airye</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>airye(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>airye(z)</p>
<p>Exponentially scaled Airy functions and their derivatives.</p>
<p>Scaling::</p>
<p>eAi  = Ai  * exp(2.0/3.0<em>z</em>sqrt(z))
eAip = Aip * exp(2.0/3.0<em>z</em>sqrt(z))
eBi  = Bi  * exp(-abs(2.0/3.0<em>(z</em>sqrt(z)).real))
eBip = Bip * exp(-abs(2.0/3.0<em>(z</em>sqrt(z)).real))</p>
<h2 id="parameters_4">Parameters<a class="headerlink" href="#parameters_4" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex argument.</p>
<h2 id="returns_2">Returns<a class="headerlink" href="#returns_2" title="Permanent link">&para;</a></h2>
<p>eAi, eAip, eBi, eBip : array_like
Airy functions Ai and Bi, and their derivatives Aip and Bip</p>
<h2 id="notes_1">Notes<a class="headerlink" href="#notes_1" title="Permanent link">&para;</a></h2>
<p>Wrapper for the AMOS [1]_ routines <code>zairy</code> and <code>zbiry</code>.</p>
<h2 id="see-also_4">See also<a class="headerlink" href="#see-also_4" title="Permanent link">&para;</a></h2>
<p>airy</p>
<h2 id="references_1">References<a class="headerlink" href="#references_1" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>bdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>bdtr(k, n, p)</p>
<p>Binomial distribution cumulative distribution function.</p>
<p>Sum of the terms 0 through <code>k</code> of the Binomial probability density.</p>
<p>.. math::
\mathrm{bdtr}(k, n, p) = \sum_{j=0}^k {{n}\choose{j}} p^j (1-p)^{n-j}</p>
<h2 id="parameters_5">Parameters<a class="headerlink" href="#parameters_5" title="Permanent link">&para;</a></h2>
<p>k : array_like
Number of successes (int).
n : array_like
Number of events (int).
p : array_like
Probability of success in a single event (float).</p>
<h2 id="returns_3">Returns<a class="headerlink" href="#returns_3" title="Permanent link">&para;</a></h2>
<p>y : ndarray
Probability of <code>k</code> or fewer successes in <code>n</code> independent events with
success probabilities of <code>p</code>.</p>
<h2 id="notes_2">Notes<a class="headerlink" href="#notes_2" title="Permanent link">&para;</a></h2>
<p>The terms are not summed directly; instead the regularized incomplete beta
function is employed, according to the formula,</p>
<p>.. math::
\mathrm{bdtr}(k, n, p) = I_{1 - p}(n - k, k + 1).</p>
<p>Wrapper for the Cephes [1]_ routine <code>bdtr</code>.</p>
<h2 id="references_2">References<a class="headerlink" href="#references_2" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bdtrc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>bdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>bdtrc(k, n, p)</p>
<p>Binomial distribution survival function.</p>
<p>Sum of the terms <code>k + 1</code> through <code>n</code> of the binomial probability density,</p>
<p>.. math::
\mathrm{bdtrc}(k, n, p) = \sum_{j=k+1}^n {{n}\choose{j}} p^j (1-p)^{n-j}</p>
<h2 id="parameters_6">Parameters<a class="headerlink" href="#parameters_6" title="Permanent link">&para;</a></h2>
<p>k : array_like
Number of successes (int).
n : array_like
Number of events (int)
p : array_like
Probability of success in a single event.</p>
<h2 id="returns_4">Returns<a class="headerlink" href="#returns_4" title="Permanent link">&para;</a></h2>
<p>y : ndarray
Probability of <code>k + 1</code> or more successes in <code>n</code> independent events
with success probabilities of <code>p</code>.</p>
<h2 id="see-also_5">See also<a class="headerlink" href="#see-also_5" title="Permanent link">&para;</a></h2>
<p>bdtr
betainc</p>
<h2 id="notes_3">Notes<a class="headerlink" href="#notes_3" title="Permanent link">&para;</a></h2>
<p>The terms are not summed directly; instead the regularized incomplete beta
function is employed, according to the formula,</p>
<p>.. math::
\mathrm{bdtrc}(k, n, p) = I_{p}(k + 1, n - k).</p>
<p>Wrapper for the Cephes [1]_ routine <code>bdtrc</code>.</p>
<h2 id="references_3">References<a class="headerlink" href="#references_3" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>bdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>bdtri(k, n, y)</p>
<p>Inverse function to <code>bdtr</code> with respect to <code>p</code>.</p>
<p>Finds the event probability <code>p</code> such that the sum of the terms 0 through
<code>k</code> of the binomial probability density is equal to the given cumulative
probability <code>y</code>.</p>
<h2 id="parameters_7">Parameters<a class="headerlink" href="#parameters_7" title="Permanent link">&para;</a></h2>
<p>k : array_like
Number of successes (float).
n : array_like
Number of events (float)
y : array_like
Cumulative probability (probability of <code>k</code> or fewer successes in <code>n</code>
events).</p>
<h2 id="returns_5">Returns<a class="headerlink" href="#returns_5" title="Permanent link">&para;</a></h2>
<p>p : ndarray
The event probability such that <code>bdtr(k, n, p) = y</code>.</p>
<h2 id="see-also_6">See also<a class="headerlink" href="#see-also_6" title="Permanent link">&para;</a></h2>
<p>bdtr
betaincinv</p>
<h2 id="notes_4">Notes<a class="headerlink" href="#notes_4" title="Permanent link">&para;</a></h2>
<p>The computation is carried out using the inverse beta integral function
and the relation,::</p>
<p>1 - p = betaincinv(n - k, k + 1, y).</p>
<p>Wrapper for the Cephes [1]_ routine <code>bdtri</code>.</p>
<h2 id="references_4">References<a class="headerlink" href="#references_4" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bdtrik</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>bdtrik(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>bdtrik(y, n, p)</p>
<p>Inverse function to <code>bdtr</code> with respect to <code>k</code>.</p>
<p>Finds the number of successes <code>k</code> such that the sum of the terms 0 through
<code>k</code> of the Binomial probability density for <code>n</code> events with probability
<code>p</code> is equal to the given cumulative probability <code>y</code>.</p>
<h2 id="parameters_8">Parameters<a class="headerlink" href="#parameters_8" title="Permanent link">&para;</a></h2>
<p>y : array_like
Cumulative probability (probability of <code>k</code> or fewer successes in <code>n</code>
events).
n : array_like
Number of events (float).
p : array_like
Success probability (float).</p>
<h2 id="returns_6">Returns<a class="headerlink" href="#returns_6" title="Permanent link">&para;</a></h2>
<p>k : ndarray
The number of successes <code>k</code> such that <code>bdtr(k, n, p) = y</code>.</p>
<h2 id="see-also_7">See also<a class="headerlink" href="#see-also_7" title="Permanent link">&para;</a></h2>
<p>bdtr</p>
<h2 id="notes_5">Notes<a class="headerlink" href="#notes_5" title="Permanent link">&para;</a></h2>
<p>Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the
cumulative incomplete beta distribution.</p>
<p>Computation of <code>k</code> involves a search for a value that produces the desired
value of <code>y</code>.  The search relies on the monotonicity of <code>y</code> with <code>k</code>.</p>
<p>Wrapper for the CDFLIB [2]_ Fortran routine <code>cdfbin</code>.</p>
<h2 id="references_5">References<a class="headerlink" href="#references_5" title="Permanent link">&para;</a></h2>
<p>.. [1] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.
.. [2] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bdtrin</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>bdtrin(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>bdtrin(k, y, p)</p>
<p>Inverse function to <code>bdtr</code> with respect to <code>n</code>.</p>
<p>Finds the number of events <code>n</code> such that the sum of the terms 0 through
<code>k</code> of the Binomial probability density for events with probability <code>p</code> is
equal to the given cumulative probability <code>y</code>.</p>
<h2 id="parameters_9">Parameters<a class="headerlink" href="#parameters_9" title="Permanent link">&para;</a></h2>
<p>k : array_like
Number of successes (float).
y : array_like
Cumulative probability (probability of <code>k</code> or fewer successes in <code>n</code>
events).
p : array_like
Success probability (float).</p>
<h2 id="returns_7">Returns<a class="headerlink" href="#returns_7" title="Permanent link">&para;</a></h2>
<p>n : ndarray
The number of events <code>n</code> such that <code>bdtr(k, n, p) = y</code>.</p>
<h2 id="see-also_8">See also<a class="headerlink" href="#see-also_8" title="Permanent link">&para;</a></h2>
<p>bdtr</p>
<h2 id="notes_6">Notes<a class="headerlink" href="#notes_6" title="Permanent link">&para;</a></h2>
<p>Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the
cumulative incomplete beta distribution.</p>
<p>Computation of <code>n</code> involves a search for a value that produces the desired
value of <code>y</code>.  The search relies on the monotonicity of <code>y</code> with <code>n</code>.</p>
<p>Wrapper for the CDFLIB [2]_ Fortran routine <code>cdfbin</code>.</p>
<h2 id="references_6">References<a class="headerlink" href="#references_6" title="Permanent link">&para;</a></h2>
<p>.. [1] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.
.. [2] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bei</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>bei(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>bei(x)</p>
<p>Kelvin function bei</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">beip</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>beip(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>beip(x)</p>
<p>Derivative of the Kelvin function <code>bei</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ber</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ber(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ber(x)</p>
<p>Kelvin function ber.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">berp</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>berp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>berp(x)</p>
<p>Derivative of the Kelvin function <code>ber</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">besselpoly</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>besselpoly(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>besselpoly(a, lmb, nu)</p>
<p>Weighted integral of a Bessel function.</p>
<p>.. math::</p>
<p>\int_0^1 x^\lambda J_\nu(2 a x) \, dx</p>
<p>where :math:<code>J_\nu</code> is a Bessel function and :math:<code>\lambda=lmb</code>,
:math:<code>\nu=nu</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">beta</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>beta(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>beta(a, b, out=None)</p>
<p>Beta function.</p>
<p>This function is defined in [1]_ as</p>
<p>.. math::</p>
<p>B(a, b) = \int_0^1 t^{a-1}(1-t)^{b-1}dt
= \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)},</p>
<p>where :math:<code>\Gamma</code> is the gamma function.</p>
<h2 id="parameters_10">Parameters<a class="headerlink" href="#parameters_10" title="Permanent link">&para;</a></h2>
<p>a, b : array-like
Real-valued arguments
out : ndarray, optional
Optional output array for the function result</p>
<h2 id="returns_8">Returns<a class="headerlink" href="#returns_8" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Value of the beta function</p>
<h2 id="see-also_9">See Also<a class="headerlink" href="#see-also_9" title="Permanent link">&para;</a></h2>
<p>gamma : the gamma function
betainc :  the incomplete beta function
betaln : the natural logarithm of the absolute
value of the beta function</p>
<h2 id="references_7">References<a class="headerlink" href="#references_7" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions,
Eq. 5.12.1. https://dlmf.nist.gov/5.12</p>
<h2 id="examples_4">Examples<a class="headerlink" href="#examples_4" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>The beta function relates to the gamma function by the
definition given above:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.beta(2, 3)
0.08333333333333333
sc.gamma(2)*sc.gamma(3)/sc.gamma(2 + 3)
0.08333333333333333</p>
</blockquote>
</blockquote>
</blockquote>
<p>As this relationship demonstrates, the beta function
is symmetric:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.beta(1.7, 2.4)
0.16567527689031739
sc.beta(2.4, 1.7)
0.16567527689031739</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function satisfies :math:<code>B(1, b) = 1/b</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.beta(1, 4)
0.25</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">betainc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>betainc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>betainc(a, b, x, out=None)</p>
<p>Incomplete beta function.</p>
<p>Computes the incomplete beta function, defined as [1]_:</p>
<p>.. math::</p>
<p>I_x(a, b) = \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)} \int_0^x
t^{a-1}(1-t)^{b-1}dt,</p>
<p>for :math:<code>0 \leq x \leq 1</code>.</p>
<h2 id="parameters_11">Parameters<a class="headerlink" href="#parameters_11" title="Permanent link">&para;</a></h2>
<p>a, b : array-like
Positive, real-valued parameters
x : array-like
Real-valued such that :math:<code>0 \leq x \leq 1</code>,
the upper limit of integration
out : ndarray, optional
Optional output array for the function values</p>
<h2 id="returns_9">Returns<a class="headerlink" href="#returns_9" title="Permanent link">&para;</a></h2>
<p>array-like
Value of the incomplete beta function</p>
<h2 id="see-also_10">See Also<a class="headerlink" href="#see-also_10" title="Permanent link">&para;</a></h2>
<p>beta : beta function
betaincinv : inverse of the incomplete beta function</p>
<h2 id="notes_7">Notes<a class="headerlink" href="#notes_7" title="Permanent link">&para;</a></h2>
<p>The incomplete beta function is also sometimes defined
without the <code>gamma</code> terms, in which case the above
definition is the so-called regularized incomplete beta
function. Under this definition, you can get the incomplete
beta function by multiplying the result of the SciPy
function by <code>beta</code>.</p>
<h2 id="references_8">References<a class="headerlink" href="#references_8" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/8.17</p>
<h2 id="examples_5">Examples<a class="headerlink" href="#examples_5" title="Permanent link">&para;</a></h2>
<p>Let :math:<code>B(a, b)</code> be the <code>beta</code> function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>The coefficient in terms of <code>gamma</code> is equal to
:math:<code>1/B(a, b)</code>. Also, when :math:<code>x=1</code>
the integral is equal to :math:<code>B(a, b)</code>.
Therefore, :math:<code>I_{x=1}(a, b) = 1</code> for any :math:<code>a, b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.betainc(0.2, 3.5, 1.0)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>It satisfies
:math:<code>I_x(a, b) = x^a F(a, 1-b, a+1, x)/ (aB(a, b))</code>,
where :math:<code>F</code> is the hypergeometric function <code>hyp2f1</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, b, x = 1.4, 3.1, 0.5
x**a * sc.hyp2f1(a, 1 - b, a + 1, x)/(a * sc.beta(a, b))
0.8148904036225295
sc.betainc(a, b, x)
0.8148904036225296</p>
</blockquote>
</blockquote>
</blockquote>
<p>This functions satisfies the relationship
:math:<code>I_x(a, b) = 1 - I_{1-x}(b, a)</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.betainc(2.2, 3.1, 0.4)
0.49339638807619446
1 - sc.betainc(3.1, 2.2, 1 - 0.4)
0.49339638807619446</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">betaincinv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>betaincinv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>betaincinv(a, b, y, out=None)</p>
<p>Inverse of the incomplete beta function.</p>
<p>Computes :math:<code>x</code> such that:</p>
<p>.. math::</p>
<p>y = I_x(a, b) = \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}
\int_0^x t^{a-1}(1-t)^{b-1}dt,</p>
<p>where :math:<code>I_x</code> is the normalized incomplete beta
function <code>betainc</code> and
:math:<code>\Gamma</code> is the <code>gamma</code> function [1]_.</p>
<h2 id="parameters_12">Parameters<a class="headerlink" href="#parameters_12" title="Permanent link">&para;</a></h2>
<p>a, b : array-like
Positive, real-valued parameters
y : array-like
Real-valued input
out : ndarray, optional
Optional output array for function values</p>
<h2 id="returns_10">Returns<a class="headerlink" href="#returns_10" title="Permanent link">&para;</a></h2>
<p>array-like
Value of the inverse of the incomplete beta function</p>
<h2 id="see-also_11">See Also<a class="headerlink" href="#see-also_11" title="Permanent link">&para;</a></h2>
<p>betainc : incomplete beta function
gamma : gamma function</p>
<h2 id="references_9">References<a class="headerlink" href="#references_9" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/8.17</p>
<h2 id="examples_6">Examples<a class="headerlink" href="#examples_6" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function is the inverse of <code>betainc</code> for fixed
values of :math:<code>a</code> and :math:<code>b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, b = 1.2, 3.1
y = sc.betainc(a, b, 0.2)
sc.betaincinv(a, b, y)
0.2</p>
<p>a, b = 7.5, 0.4
x = sc.betaincinv(a, b, 0.5)
sc.betainc(a, b, x)
0.5</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">betaln</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>betaln(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>betaln(a, b)</p>
<p>Natural logarithm of absolute value of beta function.</p>
<p>Computes <code>ln(abs(beta(a, b)))</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binom</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>binom(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>binom(n, k)</p>
<p>Binomial coefficient</p>
<h2 id="see-also_12">See Also<a class="headerlink" href="#see-also_12" title="Permanent link">&para;</a></h2>
<p>comb : The number of combinations of N things taken k at a time.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">boxcox</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>boxcox(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>boxcox(x, lmbda)</p>
<p>Compute the Box-Cox transformation.</p>
<p>The Box-Cox transformation is::</p>
<p>y = (x**lmbda - 1) / lmbda  if lmbda != 0
log(x)                  if lmbda == 0</p>
<p>Returns <code>nan</code> if <code>x &lt; 0</code>.
Returns <code>-inf</code> if <code>x == 0</code> and <code>lmbda &lt; 0</code>.</p>
<h2 id="parameters_13">Parameters<a class="headerlink" href="#parameters_13" title="Permanent link">&para;</a></h2>
<p>x : array_like
Data to be transformed.
lmbda : array_like
Power parameter of the Box-Cox transform.</p>
<h2 id="returns_11">Returns<a class="headerlink" href="#returns_11" title="Permanent link">&para;</a></h2>
<p>y : array
Transformed data.</p>
<h2 id="notes_8">Notes<a class="headerlink" href="#notes_8" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.14.0</p>
<h2 id="examples_7">Examples<a class="headerlink" href="#examples_7" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import boxcox
boxcox([1, 4, 10], 2.5)
array([   0.        ,   12.4       ,  126.09110641])
boxcox(2, [0, 1, 2])
array([ 0.69314718,  1.        ,  1.5       ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">boxcox1p</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>boxcox1p(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>boxcox1p(x, lmbda)</p>
<p>Compute the Box-Cox transformation of 1 + <code>x</code>.</p>
<p>The Box-Cox transformation computed by <code>boxcox1p</code> is::</p>
<p>y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0
log(1+x)                    if lmbda == 0</p>
<p>Returns <code>nan</code> if <code>x &lt; -1</code>.
Returns <code>-inf</code> if <code>x == -1</code> and <code>lmbda &lt; 0</code>.</p>
<h2 id="parameters_14">Parameters<a class="headerlink" href="#parameters_14" title="Permanent link">&para;</a></h2>
<p>x : array_like
Data to be transformed.
lmbda : array_like
Power parameter of the Box-Cox transform.</p>
<h2 id="returns_12">Returns<a class="headerlink" href="#returns_12" title="Permanent link">&para;</a></h2>
<p>y : array
Transformed data.</p>
<h2 id="notes_9">Notes<a class="headerlink" href="#notes_9" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.14.0</p>
<h2 id="examples_8">Examples<a class="headerlink" href="#examples_8" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import boxcox1p
boxcox1p(1e-4, [0, 0.5, 1])
array([  9.99950003e-05,   9.99975001e-05,   1.00000000e-04])
boxcox1p([0.01, 0.1], 0.25)
array([ 0.00996272,  0.09645476])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">btdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>btdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>btdtr(a, b, x)</p>
<p>Cumulative distribution function of the beta distribution.</p>
<p>Returns the integral from zero to <code>x</code> of the beta probability density
function,</p>
<p>.. math::
I = \int_0^x \frac{\Gamma(a + b)}{\Gamma(a)\Gamma(b)} t^{a-1} (1-t)^{b-1}\,dt</p>
<p>where :math:<code>\Gamma</code> is the gamma function.</p>
<h2 id="parameters_15">Parameters<a class="headerlink" href="#parameters_15" title="Permanent link">&para;</a></h2>
<p>a : array_like
Shape parameter (a &gt; 0).
b : array_like
Shape parameter (b &gt; 0).
x : array_like
Upper limit of integration, in [0, 1].</p>
<h2 id="returns_13">Returns<a class="headerlink" href="#returns_13" title="Permanent link">&para;</a></h2>
<p>I : ndarray
Cumulative distribution function of the beta distribution with
parameters <code>a</code> and <code>b</code> at <code>x</code>.</p>
<h2 id="see-also_13">See Also<a class="headerlink" href="#see-also_13" title="Permanent link">&para;</a></h2>
<p>betainc</p>
<h2 id="notes_10">Notes<a class="headerlink" href="#notes_10" title="Permanent link">&para;</a></h2>
<p>This function is identical to the incomplete beta integral function
<code>betainc</code>.</p>
<p>Wrapper for the Cephes [1]_ routine <code>btdtr</code>.</p>
<h2 id="references_10">References<a class="headerlink" href="#references_10" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">btdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>btdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>btdtri(a, b, p)</p>
<p>The <code>p</code>-th quantile of the beta distribution.</p>
<p>This function is the inverse of the beta cumulative distribution function,
<code>btdtr</code>, returning the value of <code>x</code> for which <code>btdtr(a, b, x) = p</code>, or</p>
<p>.. math::
p = \int_0^x \frac{\Gamma(a + b)}{\Gamma(a)\Gamma(b)} t^{a-1} (1-t)^{b-1}\,dt</p>
<h2 id="parameters_16">Parameters<a class="headerlink" href="#parameters_16" title="Permanent link">&para;</a></h2>
<p>a : array_like
Shape parameter (<code>a</code> &gt; 0).
b : array_like
Shape parameter (<code>b</code> &gt; 0).
p : array_like
Cumulative probability, in [0, 1].</p>
<h2 id="returns_14">Returns<a class="headerlink" href="#returns_14" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The quantile corresponding to <code>p</code>.</p>
<h2 id="see-also_14">See Also<a class="headerlink" href="#see-also_14" title="Permanent link">&para;</a></h2>
<p>betaincinv
btdtr</p>
<h2 id="notes_11">Notes<a class="headerlink" href="#notes_11" title="Permanent link">&para;</a></h2>
<p>The value of <code>x</code> is found by interval halving or Newton iterations.</p>
<p>Wrapper for the Cephes [1]_ routine <code>incbi</code>, which solves the equivalent
problem of finding the inverse of the incomplete beta integral.</p>
<h2 id="references_11">References<a class="headerlink" href="#references_11" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">btdtria</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>btdtria(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>btdtria(p, b, x)</p>
<p>Inverse of <code>btdtr</code> with respect to <code>a</code>.</p>
<p>This is the inverse of the beta cumulative distribution function, <code>btdtr</code>,
considered as a function of <code>a</code>, returning the value of <code>a</code> for which
<code>btdtr(a, b, x) = p</code>, or</p>
<p>.. math::
p = \int_0^x \frac{\Gamma(a + b)}{\Gamma(a)\Gamma(b)} t^{a-1} (1-t)^{b-1}\,dt</p>
<h2 id="parameters_17">Parameters<a class="headerlink" href="#parameters_17" title="Permanent link">&para;</a></h2>
<p>p : array_like
Cumulative probability, in [0, 1].
b : array_like
Shape parameter (<code>b</code> &gt; 0).
x : array_like
The quantile, in [0, 1].</p>
<h2 id="returns_15">Returns<a class="headerlink" href="#returns_15" title="Permanent link">&para;</a></h2>
<p>a : ndarray
The value of the shape parameter <code>a</code> such that <code>btdtr(a, b, x) = p</code>.</p>
<h2 id="see-also_15">See Also<a class="headerlink" href="#see-also_15" title="Permanent link">&para;</a></h2>
<p>btdtr : Cumulative distribution function of the beta distribution.
btdtri : Inverse with respect to <code>x</code>.
btdtrib : Inverse with respect to <code>b</code>.</p>
<h2 id="notes_12">Notes<a class="headerlink" href="#notes_12" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfbet</code>.</p>
<p>The cumulative distribution function <code>p</code> is computed using a routine by
DiDinato and Morris [2]_.  Computation of <code>a</code> involves a search for a value
that produces the desired value of <code>p</code>.  The search relies on the
monotonicity of <code>p</code> with <code>a</code>.</p>
<h2 id="references_12">References<a class="headerlink" href="#references_12" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] DiDinato, A. R. and Morris, A. H.,
Algorithm 708: Significant Digit Computation of the Incomplete Beta
Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">btdtrib</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>btdtrib(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>btdtria(a, p, x)</p>
<p>Inverse of <code>btdtr</code> with respect to <code>b</code>.</p>
<p>This is the inverse of the beta cumulative distribution function, <code>btdtr</code>,
considered as a function of <code>b</code>, returning the value of <code>b</code> for which
<code>btdtr(a, b, x) = p</code>, or</p>
<p>.. math::
p = \int_0^x \frac{\Gamma(a + b)}{\Gamma(a)\Gamma(b)} t^{a-1} (1-t)^{b-1}\,dt</p>
<h2 id="parameters_18">Parameters<a class="headerlink" href="#parameters_18" title="Permanent link">&para;</a></h2>
<p>a : array_like
Shape parameter (<code>a</code> &gt; 0).
p : array_like
Cumulative probability, in [0, 1].
x : array_like
The quantile, in [0, 1].</p>
<h2 id="returns_16">Returns<a class="headerlink" href="#returns_16" title="Permanent link">&para;</a></h2>
<p>b : ndarray
The value of the shape parameter <code>b</code> such that <code>btdtr(a, b, x) = p</code>.</p>
<h2 id="see-also_16">See Also<a class="headerlink" href="#see-also_16" title="Permanent link">&para;</a></h2>
<p>btdtr : Cumulative distribution function of the beta distribution.
btdtri : Inverse with respect to <code>x</code>.
btdtria : Inverse with respect to <code>a</code>.</p>
<h2 id="notes_13">Notes<a class="headerlink" href="#notes_13" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfbet</code>.</p>
<p>The cumulative distribution function <code>p</code> is computed using a routine by
DiDinato and Morris [2]_.  Computation of <code>b</code> involves a search for a value
that produces the desired value of <code>p</code>.  The search relies on the
monotonicity of <code>p</code> with <code>b</code>.</p>
<h2 id="references_13">References<a class="headerlink" href="#references_13" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] DiDinato, A. R. and Morris, A. H.,
Algorithm 708: Significant Digit Computation of the Incomplete Beta
Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cbrt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>cbrt(x)</p>
<p>Element-wise cube root of <code>x</code>.</p>
<h2 id="parameters_19">Parameters<a class="headerlink" href="#parameters_19" title="Permanent link">&para;</a></h2>
<p>x : array_like
<code>x</code> must contain real numbers.</p>
<h2 id="returns_17">Returns<a class="headerlink" href="#returns_17" title="Permanent link">&para;</a></h2>
<p>float
The cube root of each value in <code>x</code>.</p>
<h2 id="examples_9">Examples<a class="headerlink" href="#examples_9" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import cbrt</p>
<p>cbrt(8)
2.0
cbrt([-8, -3, 0.125, 1.331])
array([-2.        , -1.44224957,  0.5       ,  1.1       ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chdtr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chdtr(v, x)</p>
<p>Chi square cumulative distribution function</p>
<p>Returns the area under the left hand tail (from 0 to <code>x</code>) of the Chi
square probability density function with <code>v</code> degrees of freedom::</p>
<p>1/(2<strong>(v/2) * gamma(v/2)) * integral(t</strong>(v/2-1) * exp(-t/2), t=0..x)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chdtrc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chdtrc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chdtrc(v, x)</p>
<p>Chi square survival function</p>
<p>Returns the area under the right hand tail (from <code>x</code> to
infinity) of the Chi square probability density function with <code>v</code>
degrees of freedom::</p>
<p>1/(2<strong>(v/2) * gamma(v/2)) * integral(t</strong>(v/2-1) * exp(-t/2), t=x..inf)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chdtri(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chdtri(v, p)</p>
<p>Inverse to <code>chdtrc</code></p>
<p>Returns the argument x such that <code>chdtrc(v, x) == p</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chdtriv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chdtriv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chdtriv(p, x)</p>
<p>Inverse to <code>chdtr</code> vs <code>v</code></p>
<p>Returns the argument v such that <code>chdtr(v, x) == p</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chndtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chndtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chndtr(x, df, nc)</p>
<p>Non-central chi square cumulative distribution function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chndtridf</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chndtridf(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chndtridf(x, p, nc)</p>
<p>Inverse to <code>chndtr</code> vs <code>df</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chndtrinc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chndtrinc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chndtrinc(x, df, p)</p>
<p>Inverse to <code>chndtr</code> vs <code>nc</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chndtrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chndtrix(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chndtrix(p, df, nc)</p>
<p>Inverse to <code>chndtr</code> vs <code>x</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosdg</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cosdg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>cosdg(x)</p>
<p>Cosine of the angle <code>x</code> given in degrees.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosm1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cosm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>cosm1(x)</p>
<p>cos(x) - 1 for use when <code>x</code> is near zero.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cotdg</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cotdg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>cotdg(x)</p>
<p>Cotangent of the angle <code>x</code> given in degrees.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dawsn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>dawsn(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>dawsn(x)</p>
<p>Dawson's integral.</p>
<p>Computes::</p>
<p>exp(-x<strong>2) * integral(exp(t</strong>2), t=0..x).</p>
<h2 id="see-also_17">See Also<a class="headerlink" href="#see-also_17" title="Permanent link">&para;</a></h2>
<p>wofz, erf, erfc, erfcx, erfi</p>
<h2 id="references_14">References<a class="headerlink" href="#references_14" title="Permanent link">&para;</a></h2>
<p>.. [1] Steven G. Johnson, Faddeeva W function implementation.
http://ab-initio.mit.edu/Faddeeva</p>
<h2 id="examples_10">Examples<a class="headerlink" href="#examples_10" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
import matplotlib.pyplot as plt
x = np.linspace(-15, 15, num=1000)
plt.plot(x, special.dawsn(x))
plt.xlabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>')
plt.ylabel('<span><span class="MathJax_Preview">dawsn(x)</span><script type="math/tex">dawsn(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipe</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ellipe(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ellipe(m)</p>
<p>Complete elliptic integral of the second kind</p>
<p>This function is defined as</p>
<p>.. math:: E(m) = \int_0^{\pi/2} [1 - m \sin(t)^2]^{1/2} dt</p>
<h2 id="parameters_20">Parameters<a class="headerlink" href="#parameters_20" title="Permanent link">&para;</a></h2>
<p>m : array_like
Defines the parameter of the elliptic integral.</p>
<h2 id="returns_18">Returns<a class="headerlink" href="#returns_18" title="Permanent link">&para;</a></h2>
<p>E : ndarray
Value of the elliptic integral.</p>
<h2 id="notes_14">Notes<a class="headerlink" href="#notes_14" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>ellpe</code>.</p>
<p>For <code>m &gt; 0</code> the computation uses the approximation,</p>
<p>.. math:: E(m) \approx P(1-m) - (1-m) \log(1-m) Q(1-m),</p>
<p>where :math:<code>P</code> and :math:<code>Q</code> are tenth-order polynomials.  For
<code>m &lt; 0</code>, the relation</p>
<p>.. math:: E(m) = E(m/(m - 1)) \sqrt(1-m)</p>
<p>is used.</p>
<p>The parameterization in terms of :math:<code>m</code> follows that of section
17.2 in [2]_. Other parameterizations in terms of the
complementary parameter :math:<code>1 - m</code>, modular angle
:math:<code>\sin^2(\alpha) = m</code>, or modulus :math:<code>k^2 = m</code> are also
used, so be careful that you choose the correct parameter.</p>
<h2 id="see-also_18">See Also<a class="headerlink" href="#see-also_18" title="Permanent link">&para;</a></h2>
<p>ellipkm1 : Complete elliptic integral of the first kind, near <code>m</code> = 1
ellipk : Complete elliptic integral of the first kind
ellipkinc : Incomplete elliptic integral of the first kind
ellipeinc : Incomplete elliptic integral of the second kind</p>
<h2 id="references_15">References<a class="headerlink" href="#references_15" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<h2 id="examples_11">Examples<a class="headerlink" href="#examples_11" title="Permanent link">&para;</a></h2>
<p>This function is used in finding the circumference of an
ellipse with semi-major axis <code>a</code> and semi-minor axis <code>b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special</p>
<p>a = 3.5
b = 2.1
e_sq = 1.0 - b<strong>2/a</strong>2  # eccentricity squared</p>
</blockquote>
</blockquote>
</blockquote>
<p>Then the circumference is found using the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>C = 4<em>a</em>special.ellipe(e_sq)  # circumference formula
C
17.868899204378693</p>
</blockquote>
</blockquote>
</blockquote>
<p>When <code>a</code> and <code>b</code> are the same (meaning eccentricity is 0),
this reduces to the circumference of a circle.</p>
<blockquote>
<blockquote>
<blockquote>
<p>4<em>a</em>special.ellipe(0.0)  # formula for ellipse with a = b
21.991148575128552
2<em>np.pi</em>a  # formula for circle of radius a
21.991148575128552</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipeinc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ellipeinc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ellipeinc(phi, m)</p>
<p>Incomplete elliptic integral of the second kind</p>
<p>This function is defined as</p>
<p>.. math:: E(\phi, m) = \int_0^{\phi} [1 - m \sin(t)^2]^{1/2} dt</p>
<h2 id="parameters_21">Parameters<a class="headerlink" href="#parameters_21" title="Permanent link">&para;</a></h2>
<p>phi : array_like
amplitude of the elliptic integral.</p>
<p>m : array_like
parameter of the elliptic integral.</p>
<h2 id="returns_19">Returns<a class="headerlink" href="#returns_19" title="Permanent link">&para;</a></h2>
<p>E : ndarray
Value of the elliptic integral.</p>
<h2 id="notes_15">Notes<a class="headerlink" href="#notes_15" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>ellie</code>.</p>
<p>Computation uses arithmetic-geometric means algorithm.</p>
<p>The parameterization in terms of :math:<code>m</code> follows that of section
17.2 in [2]_. Other parameterizations in terms of the
complementary parameter :math:<code>1 - m</code>, modular angle
:math:<code>\sin^2(\alpha) = m</code>, or modulus :math:<code>k^2 = m</code> are also
used, so be careful that you choose the correct parameter.</p>
<h2 id="see-also_19">See Also<a class="headerlink" href="#see-also_19" title="Permanent link">&para;</a></h2>
<p>ellipkm1 : Complete elliptic integral of the first kind, near <code>m</code> = 1
ellipk : Complete elliptic integral of the first kind
ellipkinc : Incomplete elliptic integral of the first kind
ellipe : Complete elliptic integral of the second kind</p>
<h2 id="references_16">References<a class="headerlink" href="#references_16" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipj</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ellipj(x1, x2[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ellipj(u, m)</p>
<p>Jacobian elliptic functions</p>
<p>Calculates the Jacobian elliptic functions of parameter <code>m</code> between
0 and 1, and real argument <code>u</code>.</p>
<h2 id="parameters_22">Parameters<a class="headerlink" href="#parameters_22" title="Permanent link">&para;</a></h2>
<p>m : array_like
Parameter.
u : array_like
Argument.</p>
<h2 id="returns_20">Returns<a class="headerlink" href="#returns_20" title="Permanent link">&para;</a></h2>
<p>sn, cn, dn, ph : ndarrays
The returned functions::</p>
<p>sn(u|m), cn(u|m), dn(u|m)</p>
<p>The value <code>ph</code> is such that if <code>u = ellipkinc(ph, m)</code>,
then <code>sn(u|m) = sin(ph)</code> and <code>cn(u|m) = cos(ph)</code>.</p>
<h2 id="notes_16">Notes<a class="headerlink" href="#notes_16" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>ellpj</code>.</p>
<p>These functions are periodic, with quarter-period on the real axis
equal to the complete elliptic integral <code>ellipk(m)</code>.</p>
<p>Relation to incomplete elliptic integral: If <code>u = ellipkinc(phi,m)</code>, then
<code>sn(u|m) = sin(phi)</code>, and <code>cn(u|m) = cos(phi)</code>.  The <code>phi</code> is called
the amplitude of <code>u</code>.</p>
<p>Computation is by means of the arithmetic-geometric mean algorithm,
except when <code>m</code> is within 1e-9 of 0 or 1.  In the latter case with <code>m</code>
close to 1, the approximation applies only for <code>phi &lt; pi/2</code>.</p>
<h2 id="see-also_20">See also<a class="headerlink" href="#see-also_20" title="Permanent link">&para;</a></h2>
<p>ellipk : Complete elliptic integral of the first kind
ellipkinc : Incomplete elliptic integral of the first kind</p>
<h2 id="references_17">References<a class="headerlink" href="#references_17" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipk</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ellipk(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ellipk(m)</p>
<p>Complete elliptic integral of the first kind.</p>
<p>This function is defined as</p>
<p>.. math:: K(m) = \int_0^{\pi/2} [1 - m \sin(t)^2]^{-1/2} dt</p>
<h2 id="parameters_23">Parameters<a class="headerlink" href="#parameters_23" title="Permanent link">&para;</a></h2>
<p>m : array_like
The parameter of the elliptic integral.</p>
<h2 id="returns_21">Returns<a class="headerlink" href="#returns_21" title="Permanent link">&para;</a></h2>
<p>K : array_like
Value of the elliptic integral.</p>
<h2 id="notes_17">Notes<a class="headerlink" href="#notes_17" title="Permanent link">&para;</a></h2>
<p>For more precision around point m = 1, use <code>ellipkm1</code>, which this
function calls.</p>
<p>The parameterization in terms of :math:<code>m</code> follows that of section
17.2 in [1]_. Other parameterizations in terms of the
complementary parameter :math:<code>1 - m</code>, modular angle
:math:<code>\sin^2(\alpha) = m</code>, or modulus :math:<code>k^2 = m</code> are also
used, so be careful that you choose the correct parameter.</p>
<h2 id="see-also_21">See Also<a class="headerlink" href="#see-also_21" title="Permanent link">&para;</a></h2>
<p>ellipkm1 : Complete elliptic integral of the first kind around m = 1
ellipkinc : Incomplete elliptic integral of the first kind
ellipe : Complete elliptic integral of the second kind
ellipeinc : Incomplete elliptic integral of the second kind</p>
<h2 id="references_18">References<a class="headerlink" href="#references_18" title="Permanent link">&para;</a></h2>
<p>.. [1] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipkinc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ellipkinc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ellipkinc(phi, m)</p>
<p>Incomplete elliptic integral of the first kind</p>
<p>This function is defined as</p>
<p>.. math:: K(\phi, m) = \int_0^{\phi} [1 - m \sin(t)^2]^{-1/2} dt</p>
<p>This function is also called <code>F(phi, m)</code>.</p>
<h2 id="parameters_24">Parameters<a class="headerlink" href="#parameters_24" title="Permanent link">&para;</a></h2>
<p>phi : array_like
amplitude of the elliptic integral</p>
<p>m : array_like
parameter of the elliptic integral</p>
<h2 id="returns_22">Returns<a class="headerlink" href="#returns_22" title="Permanent link">&para;</a></h2>
<p>K : ndarray
Value of the elliptic integral</p>
<h2 id="notes_18">Notes<a class="headerlink" href="#notes_18" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>ellik</code>.  The computation is
carried out using the arithmetic-geometric mean algorithm.</p>
<p>The parameterization in terms of :math:<code>m</code> follows that of section
17.2 in [2]_. Other parameterizations in terms of the
complementary parameter :math:<code>1 - m</code>, modular angle
:math:<code>\sin^2(\alpha) = m</code>, or modulus :math:<code>k^2 = m</code> are also
used, so be careful that you choose the correct parameter.</p>
<h2 id="see-also_22">See Also<a class="headerlink" href="#see-also_22" title="Permanent link">&para;</a></h2>
<p>ellipkm1 : Complete elliptic integral of the first kind, near <code>m</code> = 1
ellipk : Complete elliptic integral of the first kind
ellipe : Complete elliptic integral of the second kind
ellipeinc : Incomplete elliptic integral of the second kind</p>
<h2 id="references_19">References<a class="headerlink" href="#references_19" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipkm1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ellipkm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ellipkm1(p)</p>
<p>Complete elliptic integral of the first kind around <code>m</code> = 1</p>
<p>This function is defined as</p>
<p>.. math:: K(p) = \int_0^{\pi/2} [1 - m \sin(t)^2]^{-1/2} dt</p>
<p>where <code>m = 1 - p</code>.</p>
<h2 id="parameters_25">Parameters<a class="headerlink" href="#parameters_25" title="Permanent link">&para;</a></h2>
<p>p : array_like
Defines the parameter of the elliptic integral as <code>m = 1 - p</code>.</p>
<h2 id="returns_23">Returns<a class="headerlink" href="#returns_23" title="Permanent link">&para;</a></h2>
<p>K : ndarray
Value of the elliptic integral.</p>
<h2 id="notes_19">Notes<a class="headerlink" href="#notes_19" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>ellpk</code>.</p>
<p>For <code>p &lt;= 1</code>, computation uses the approximation,</p>
<p>.. math:: K(p) \approx P(p) - \log(p) Q(p),</p>
<p>where :math:<code>P</code> and :math:<code>Q</code> are tenth-order polynomials.  The
argument <code>p</code> is used internally rather than <code>m</code> so that the logarithmic
singularity at <code>m = 1</code> will be shifted to the origin; this preserves
maximum accuracy.  For <code>p &gt; 1</code>, the identity</p>
<p>.. math:: K(p) = K(1/p)/\sqrt(p)</p>
<p>is used.</p>
<h2 id="see-also_23">See Also<a class="headerlink" href="#see-also_23" title="Permanent link">&para;</a></h2>
<p>ellipk : Complete elliptic integral of the first kind
ellipkinc : Incomplete elliptic integral of the first kind
ellipe : Complete elliptic integral of the second kind
ellipeinc : Incomplete elliptic integral of the second kind</p>
<h2 id="references_20">References<a class="headerlink" href="#references_20" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">entr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>entr(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>entr(x)</p>
<p>Elementwise function for computing entropy.</p>
<p>.. math:: \text{entr}(x) = \begin{cases} - x \log(x) &amp; x &gt; 0  \ 0 &amp; x = 0 \ -\infty &amp; \text{otherwise} \end{cases}</p>
<h2 id="parameters_26">Parameters<a class="headerlink" href="#parameters_26" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Input array.</p>
<h2 id="returns_24">Returns<a class="headerlink" href="#returns_24" title="Permanent link">&para;</a></h2>
<p>res : ndarray
The value of the elementwise entropy function at the given points <code>x</code>.</p>
<h2 id="see-also_24">See Also<a class="headerlink" href="#see-also_24" title="Permanent link">&para;</a></h2>
<p>kl_div, rel_entr</p>
<h2 id="notes_20">Notes<a class="headerlink" href="#notes_20" title="Permanent link">&para;</a></h2>
<p>This function is concave.</p>
<p>.. versionadded:: 0.15.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">erf</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>erf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>erf(z)</p>
<p>Returns the error function of complex argument.</p>
<p>It is defined as <code>2/sqrt(pi)*integral(exp(-t**2), t=0..z)</code>.</p>
<h2 id="parameters_27">Parameters<a class="headerlink" href="#parameters_27" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Input array.</p>
<h2 id="returns_25">Returns<a class="headerlink" href="#returns_25" title="Permanent link">&para;</a></h2>
<p>res : ndarray
The values of the error function at the given points <code>x</code>.</p>
<h2 id="see-also_25">See Also<a class="headerlink" href="#see-also_25" title="Permanent link">&para;</a></h2>
<p>erfc, erfinv, erfcinv, wofz, erfcx, erfi</p>
<h2 id="notes_21">Notes<a class="headerlink" href="#notes_21" title="Permanent link">&para;</a></h2>
<p>The cumulative of the unit normal distribution is given by
<code>Phi(z) = 1/2[1 + erf(z/sqrt(2))]</code>.</p>
<h2 id="references_21">References<a class="headerlink" href="#references_21" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Error_function
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover,
1972. http://www.math.sfu.ca/~cbm/aands/page_297.htm
.. [3] Steven G. Johnson, Faddeeva W function implementation.
http://ab-initio.mit.edu/Faddeeva</p>
<h2 id="examples_12">Examples<a class="headerlink" href="#examples_12" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
import matplotlib.pyplot as plt
x = np.linspace(-3, 3)
plt.plot(x, special.erf(x))
plt.xlabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>')
plt.ylabel('<span><span class="MathJax_Preview">erf(x)</span><script type="math/tex">erf(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">erfc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>erfc(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>erfc(x, out=None)</p>
<p>Complementary error function, <code>1 - erf(x)</code>.</p>
<h2 id="parameters_28">Parameters<a class="headerlink" href="#parameters_28" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real or complex valued argument
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_26">Returns<a class="headerlink" href="#returns_26" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the complementary error function</p>
<h2 id="see-also_26">See Also<a class="headerlink" href="#see-also_26" title="Permanent link">&para;</a></h2>
<p>erf, erfi, erfcx, dawsn, wofz</p>
<h2 id="references_22">References<a class="headerlink" href="#references_22" title="Permanent link">&para;</a></h2>
<p>.. [1] Steven G. Johnson, Faddeeva W function implementation.
http://ab-initio.mit.edu/Faddeeva</p>
<h2 id="examples_13">Examples<a class="headerlink" href="#examples_13" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
import matplotlib.pyplot as plt
x = np.linspace(-3, 3)
plt.plot(x, special.erfc(x))
plt.xlabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>')
plt.ylabel('<span><span class="MathJax_Preview">erfc(x)</span><script type="math/tex">erfc(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">erfcx</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>erfcx(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>erfcx(x, out=None)</p>
<p>Scaled complementary error function, <code>exp(x**2) * erfc(x)</code>.</p>
<h2 id="parameters_29">Parameters<a class="headerlink" href="#parameters_29" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real or complex valued argument
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_27">Returns<a class="headerlink" href="#returns_27" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the scaled complementary error function</p>
<h2 id="see-also_27">See Also<a class="headerlink" href="#see-also_27" title="Permanent link">&para;</a></h2>
<p>erf, erfc, erfi, dawsn, wofz</p>
<h2 id="notes_22">Notes<a class="headerlink" href="#notes_22" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.12.0</p>
<h2 id="references_23">References<a class="headerlink" href="#references_23" title="Permanent link">&para;</a></h2>
<p>.. [1] Steven G. Johnson, Faddeeva W function implementation.
http://ab-initio.mit.edu/Faddeeva</p>
<h2 id="examples_14">Examples<a class="headerlink" href="#examples_14" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
import matplotlib.pyplot as plt
x = np.linspace(-3, 3)
plt.plot(x, special.erfcx(x))
plt.xlabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>')
plt.ylabel('<span><span class="MathJax_Preview">erfcx(x)</span><script type="math/tex">erfcx(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">erfi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>erfi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>erfi(z, out=None)</p>
<p>Imaginary error function, <code>-i erf(i z)</code>.</p>
<h2 id="parameters_30">Parameters<a class="headerlink" href="#parameters_30" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex valued argument
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_28">Returns<a class="headerlink" href="#returns_28" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the imaginary error function</p>
<h2 id="see-also_28">See Also<a class="headerlink" href="#see-also_28" title="Permanent link">&para;</a></h2>
<p>erf, erfc, erfcx, dawsn, wofz</p>
<h2 id="notes_23">Notes<a class="headerlink" href="#notes_23" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.12.0</p>
<h2 id="references_24">References<a class="headerlink" href="#references_24" title="Permanent link">&para;</a></h2>
<p>.. [1] Steven G. Johnson, Faddeeva W function implementation.
http://ab-initio.mit.edu/Faddeeva</p>
<h2 id="examples_15">Examples<a class="headerlink" href="#examples_15" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
import matplotlib.pyplot as plt
x = np.linspace(-3, 3)
plt.plot(x, special.erfi(x))
plt.xlabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>')
plt.ylabel('<span><span class="MathJax_Preview">erfi(x)</span><script type="math/tex">erfi(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_chebyc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_chebyc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_chebyc(n, x, out=None)</p>
<p>Evaluate Chebyshev polynomial of the first kind on [-2, 2] at a
point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>C_n(x) = 2 T_n(x/2)</p>
<p>where :math:<code>T_n</code> is a Chebyshev polynomial of the first kind. See
22.5.11 in [AS]_ for details.</p>
<h2 id="parameters_31">Parameters<a class="headerlink" href="#parameters_31" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>eval_chebyt</code>.
x : array_like
Points at which to evaluate the Chebyshev polynomial</p>
<h2 id="returns_29">Returns<a class="headerlink" href="#returns_29" title="Permanent link">&para;</a></h2>
<p>C : ndarray
Values of the Chebyshev polynomial</p>
<h2 id="see-also_29">See Also<a class="headerlink" href="#see-also_29" title="Permanent link">&para;</a></h2>
<p>roots_chebyc : roots and quadrature weights of Chebyshev
polynomials of the first kind on [-2, 2]
chebyc : Chebyshev polynomial object
numpy.polynomial.chebyshev.Chebyshev : Chebyshev series
eval_chebyt : evaluate Chebycshev polynomials of the first kind</p>
<h2 id="references_25">References<a class="headerlink" href="#references_25" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<h2 id="examples_16">Examples<a class="headerlink" href="#examples_16" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>They are a scaled version of the Chebyshev polynomials of the
first kind.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-2, 2, 6)
sc.eval_chebyc(3, x)
array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])
2 * sc.eval_chebyt(3, x / 2)
array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_chebys</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_chebys(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_chebys(n, x, out=None)</p>
<p>Evaluate Chebyshev polynomial of the second kind on [-2, 2] at a
point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>S_n(x) = U_n(x/2)</p>
<p>where :math:<code>U_n</code> is a Chebyshev polynomial of the second
kind. See 22.5.13 in [AS]_ for details.</p>
<h2 id="parameters_32">Parameters<a class="headerlink" href="#parameters_32" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>eval_chebyu</code>.
x : array_like
Points at which to evaluate the Chebyshev polynomial</p>
<h2 id="returns_30">Returns<a class="headerlink" href="#returns_30" title="Permanent link">&para;</a></h2>
<p>S : ndarray
Values of the Chebyshev polynomial</p>
<h2 id="see-also_30">See Also<a class="headerlink" href="#see-also_30" title="Permanent link">&para;</a></h2>
<p>roots_chebys : roots and quadrature weights of Chebyshev
polynomials of the second kind on [-2, 2]
chebys : Chebyshev polynomial object
eval_chebyu : evaluate Chebyshev polynomials of the second kind</p>
<h2 id="references_26">References<a class="headerlink" href="#references_26" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<h2 id="examples_17">Examples<a class="headerlink" href="#examples_17" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>They are a scaled version of the Chebyshev polynomials of the
second kind.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-2, 2, 6)
sc.eval_chebys(3, x)
array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])
sc.eval_chebyu(3, x / 2)
array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_chebyt(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_chebyt(n, x, out=None)</p>
<p>Evaluate Chebyshev polynomial of the first kind at a point.</p>
<p>The Chebyshev polynomials of the first kind can be defined via the
Gauss hypergeometric function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>T_n(x) = {}_2F_1(n, -n; 1/2; (1 - x)/2).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.47 in [AS]_ for details.</p>
<h2 id="parameters_33">Parameters<a class="headerlink" href="#parameters_33" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to the Gauss hypergeometric
function.
x : array_like
Points at which to evaluate the Chebyshev polynomial</p>
<h2 id="returns_31">Returns<a class="headerlink" href="#returns_31" title="Permanent link">&para;</a></h2>
<p>T : ndarray
Values of the Chebyshev polynomial</p>
<h2 id="see-also_31">See Also<a class="headerlink" href="#see-also_31" title="Permanent link">&para;</a></h2>
<p>roots_chebyt : roots and quadrature weights of Chebyshev
polynomials of the first kind
chebyu : Chebychev polynomial object
eval_chebyu : evaluate Chebyshev polynomials of the second kind
hyp2f1 : Gauss hypergeometric function
numpy.polynomial.chebyshev.Chebyshev : Chebyshev series</p>
<h2 id="notes_24">Notes<a class="headerlink" href="#notes_24" title="Permanent link">&para;</a></h2>
<p>This routine is numerically stable for <code>x</code> in <code>[-1, 1]</code> at least
up to order <code>10000</code>.</p>
<h2 id="references_27">References<a class="headerlink" href="#references_27" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_chebyu(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_chebyu(n, x, out=None)</p>
<p>Evaluate Chebyshev polynomial of the second kind at a point.</p>
<p>The Chebyshev polynomials of the second kind can be defined via
the Gauss hypergeometric function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>U_n(x) = (n + 1) {}_2F_1(-n, n + 2; 3/2; (1 - x)/2).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.48 in [AS]_ for details.</p>
<h2 id="parameters_34">Parameters<a class="headerlink" href="#parameters_34" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to the Gauss hypergeometric
function.
x : array_like
Points at which to evaluate the Chebyshev polynomial</p>
<h2 id="returns_32">Returns<a class="headerlink" href="#returns_32" title="Permanent link">&para;</a></h2>
<p>U : ndarray
Values of the Chebyshev polynomial</p>
<h2 id="see-also_32">See Also<a class="headerlink" href="#see-also_32" title="Permanent link">&para;</a></h2>
<p>roots_chebyu : roots and quadrature weights of Chebyshev
polynomials of the second kind
chebyu : Chebyshev polynomial object
eval_chebyt : evaluate Chebyshev polynomials of the first kind
hyp2f1 : Gauss hypergeometric function</p>
<h2 id="references_28">References<a class="headerlink" href="#references_28" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_gegenbauer</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_gegenbauer(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_gegenbauer(n, alpha, x, out=None)</p>
<p>Evaluate Gegenbauer polynomial at a point.</p>
<p>The Gegenbauer polynomials can be defined via the Gauss
hypergeometric function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>C_n^{(\alpha)} = \frac{(2\alpha)_n}{\Gamma(n + 1)}
{}_2F_1(-n, 2\alpha + n; \alpha + 1/2; (1 - z)/2).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.46 in [AS]_ for details.</p>
<h2 id="parameters_35">Parameters<a class="headerlink" href="#parameters_35" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to the Gauss hypergeometric
function.
alpha : array_like
Parameter
x : array_like
Points at which to evaluate the Gegenbauer polynomial</p>
<h2 id="returns_33">Returns<a class="headerlink" href="#returns_33" title="Permanent link">&para;</a></h2>
<p>C : ndarray
Values of the Gegenbauer polynomial</p>
<h2 id="see-also_33">See Also<a class="headerlink" href="#see-also_33" title="Permanent link">&para;</a></h2>
<p>roots_gegenbauer : roots and quadrature weights of Gegenbauer
polynomials
gegenbauer : Gegenbauer polynomial object
hyp2f1 : Gauss hypergeometric function</p>
<h2 id="references_29">References<a class="headerlink" href="#references_29" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_genlaguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_genlaguerre(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_genlaguerre(n, alpha, x, out=None)</p>
<p>Evaluate generalized Laguerre polynomial at a point.</p>
<p>The generalized Laguerre polynomials can be defined via the
confluent hypergeometric function :math:<code>{}_1F_1</code> as</p>
<p>.. math::</p>
<p>L_n^{(\alpha)}(x) = \binom{n + \alpha}{n}
{}_1F_1(-n, \alpha + 1, x).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.54 in [AS]_ for details. The Laguerre
polynomials are the special case where :math:<code>\alpha = 0</code>.</p>
<h2 id="parameters_36">Parameters<a class="headerlink" href="#parameters_36" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer the result is
determined via the relation to the confluent hypergeometric
function.
alpha : array_like
Parameter; must have <code>alpha &gt; -1</code>
x : array_like
Points at which to evaluate the generalized Laguerre
polynomial</p>
<h2 id="returns_34">Returns<a class="headerlink" href="#returns_34" title="Permanent link">&para;</a></h2>
<p>L : ndarray
Values of the generalized Laguerre polynomial</p>
<h2 id="see-also_34">See Also<a class="headerlink" href="#see-also_34" title="Permanent link">&para;</a></h2>
<p>roots_genlaguerre : roots and quadrature weights of generalized
Laguerre polynomials
genlaguerre : generalized Laguerre polynomial object
hyp1f1 : confluent hypergeometric function
eval_laguerre : evaluate Laguerre polynomials</p>
<h2 id="references_30">References<a class="headerlink" href="#references_30" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_hermite</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_hermite(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_hermite(n, x, out=None)</p>
<p>Evaluate physicist's Hermite polynomial at a point.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n} e^{-x^2};</p>
<p>:math:<code>H_n</code> is a polynomial of degree :math:<code>n</code>. See 22.11.7 in
[AS]_ for details.</p>
<h2 id="parameters_37">Parameters<a class="headerlink" href="#parameters_37" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial
x : array_like
Points at which to evaluate the Hermite polynomial</p>
<h2 id="returns_35">Returns<a class="headerlink" href="#returns_35" title="Permanent link">&para;</a></h2>
<p>H : ndarray
Values of the Hermite polynomial</p>
<h2 id="see-also_35">See Also<a class="headerlink" href="#see-also_35" title="Permanent link">&para;</a></h2>
<p>roots_hermite : roots and quadrature weights of physicist's
Hermite polynomials
hermite : physicist's Hermite polynomial object
numpy.polynomial.hermite.Hermite : Physicist's Hermite series
eval_hermitenorm : evaluate Probabilist's Hermite polynomials</p>
<h2 id="references_31">References<a class="headerlink" href="#references_31" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_hermitenorm</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_hermitenorm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_hermitenorm(n, x, out=None)</p>
<p>Evaluate probabilist's (normalized) Hermite polynomial at a
point.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>He_n(x) = (-1)^n e^{x^2/2} \frac{d^n}{dx^n} e^{-x^2/2};</p>
<p>:math:<code>He_n</code> is a polynomial of degree :math:<code>n</code>. See 22.11.8 in
[AS]_ for details.</p>
<h2 id="parameters_38">Parameters<a class="headerlink" href="#parameters_38" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial
x : array_like
Points at which to evaluate the Hermite polynomial</p>
<h2 id="returns_36">Returns<a class="headerlink" href="#returns_36" title="Permanent link">&para;</a></h2>
<p>He : ndarray
Values of the Hermite polynomial</p>
<h2 id="see-also_36">See Also<a class="headerlink" href="#see-also_36" title="Permanent link">&para;</a></h2>
<p>roots_hermitenorm : roots and quadrature weights of probabilist's
Hermite polynomials
hermitenorm : probabilist's Hermite polynomial object
numpy.polynomial.hermite_e.HermiteE : Probabilist's Hermite series
eval_hermite : evaluate physicist's Hermite polynomials</p>
<h2 id="references_32">References<a class="headerlink" href="#references_32" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_jacobi(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_jacobi(n, alpha, beta, x, out=None)</p>
<p>Evaluate Jacobi polynomial at a point.</p>
<p>The Jacobi polynomials can be defined via the Gauss hypergeometric
function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>P_n^{(\alpha, \beta)}(x) = \frac{(\alpha + 1)_n}{\Gamma(n + 1)}
{}_2F_1(-n, 1 + \alpha + \beta + n; \alpha + 1; (1 - z)/2)</p>
<p>where :math:<code>(\cdot)_n</code> is the Pochhammer symbol; see <code>poch</code>. When
:math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.42 in [AS]_ for details.</p>
<h2 id="parameters_39">Parameters<a class="headerlink" href="#parameters_39" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer the result is
determined via the relation to the Gauss hypergeometric
function.
alpha : array_like
Parameter
beta : array_like
Parameter
x : array_like
Points at which to evaluate the polynomial</p>
<h2 id="returns_37">Returns<a class="headerlink" href="#returns_37" title="Permanent link">&para;</a></h2>
<p>P : ndarray
Values of the Jacobi polynomial</p>
<h2 id="see-also_37">See Also<a class="headerlink" href="#see-also_37" title="Permanent link">&para;</a></h2>
<p>roots_jacobi : roots and quadrature weights of Jacobi polynomials
jacobi : Jacobi polynomial object
hyp2f1 : Gauss hypergeometric function</p>
<h2 id="references_33">References<a class="headerlink" href="#references_33" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_laguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_laguerre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_laguerre(n, x, out=None)</p>
<p>Evaluate Laguerre polynomial at a point.</p>
<p>The Laguerre polynomials can be defined via the confluent
hypergeometric function :math:<code>{}_1F_1</code> as</p>
<p>.. math::</p>
<p>L_n(x) = {}_1F_1(-n, 1, x).</p>
<p>See 22.5.16 and 22.5.54 in [AS]_ for details. When :math:<code>n</code> is an
integer the result is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_40">Parameters<a class="headerlink" href="#parameters_40" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer the result is
determined via the relation to the confluent hypergeometric
function.
x : array_like
Points at which to evaluate the Laguerre polynomial</p>
<h2 id="returns_38">Returns<a class="headerlink" href="#returns_38" title="Permanent link">&para;</a></h2>
<p>L : ndarray
Values of the Laguerre polynomial</p>
<h2 id="see-also_38">See Also<a class="headerlink" href="#see-also_38" title="Permanent link">&para;</a></h2>
<p>roots_laguerre : roots and quadrature weights of Laguerre
polynomials
laguerre : Laguerre polynomial object
numpy.polynomial.laguerre.Laguerre : Laguerre series
eval_genlaguerre : evaluate generalized Laguerre polynomials</p>
<h2 id="references_34">References<a class="headerlink" href="#references_34" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_legendre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_legendre(n, x, out=None)</p>
<p>Evaluate Legendre polynomial at a point.</p>
<p>The Legendre polynomials can be defined via the Gauss
hypergeometric function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>P_n(x) = {}_2F_1(-n, n + 1; 1; (1 - x)/2).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.49 in [AS]_ for details.</p>
<h2 id="parameters_41">Parameters<a class="headerlink" href="#parameters_41" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to the Gauss hypergeometric
function.
x : array_like
Points at which to evaluate the Legendre polynomial</p>
<h2 id="returns_39">Returns<a class="headerlink" href="#returns_39" title="Permanent link">&para;</a></h2>
<p>P : ndarray
Values of the Legendre polynomial</p>
<h2 id="see-also_39">See Also<a class="headerlink" href="#see-also_39" title="Permanent link">&para;</a></h2>
<p>roots_legendre : roots and quadrature weights of Legendre
polynomials
legendre : Legendre polynomial object
hyp2f1 : Gauss hypergeometric function
numpy.polynomial.legendre.Legendre : Legendre series</p>
<h2 id="references_35">References<a class="headerlink" href="#references_35" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_sh_chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_sh_chebyt(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_sh_chebyt(n, x, out=None)</p>
<p>Evaluate shifted Chebyshev polynomial of the first kind at a
point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>T_n^*(x) = T_n(2x - 1)</p>
<p>where :math:<code>T_n</code> is a Chebyshev polynomial of the first kind. See
22.5.14 in [AS]_ for details.</p>
<h2 id="parameters_42">Parameters<a class="headerlink" href="#parameters_42" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>eval_chebyt</code>.
x : array_like
Points at which to evaluate the shifted Chebyshev polynomial</p>
<h2 id="returns_40">Returns<a class="headerlink" href="#returns_40" title="Permanent link">&para;</a></h2>
<p>T : ndarray
Values of the shifted Chebyshev polynomial</p>
<h2 id="see-also_40">See Also<a class="headerlink" href="#see-also_40" title="Permanent link">&para;</a></h2>
<p>roots_sh_chebyt : roots and quadrature weights of shifted
Chebyshev polynomials of the first kind
sh_chebyt : shifted Chebyshev polynomial object
eval_chebyt : evaluate Chebyshev polynomials of the first kind
numpy.polynomial.chebyshev.Chebyshev : Chebyshev series</p>
<h2 id="references_36">References<a class="headerlink" href="#references_36" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_sh_chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_sh_chebyu(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_sh_chebyu(n, x, out=None)</p>
<p>Evaluate shifted Chebyshev polynomial of the second kind at a
point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>U_n^*(x) = U_n(2x - 1)</p>
<p>where :math:<code>U_n</code> is a Chebyshev polynomial of the first kind. See
22.5.15 in [AS]_ for details.</p>
<h2 id="parameters_43">Parameters<a class="headerlink" href="#parameters_43" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>eval_chebyu</code>.
x : array_like
Points at which to evaluate the shifted Chebyshev polynomial</p>
<h2 id="returns_41">Returns<a class="headerlink" href="#returns_41" title="Permanent link">&para;</a></h2>
<p>U : ndarray
Values of the shifted Chebyshev polynomial</p>
<h2 id="see-also_41">See Also<a class="headerlink" href="#see-also_41" title="Permanent link">&para;</a></h2>
<p>roots_sh_chebyu : roots and quadrature weights of shifted
Chebychev polynomials of the second kind
sh_chebyu : shifted Chebyshev polynomial object
eval_chebyu : evaluate Chebyshev polynomials of the second kind</p>
<h2 id="references_37">References<a class="headerlink" href="#references_37" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_sh_jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_sh_jacobi(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_sh_jacobi(n, p, q, x, out=None)</p>
<p>Evaluate shifted Jacobi polynomial at a point.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>G_n^{(p, q)}(x)
= \binom{2n + p - 1}{n}^{-1} P_n^{(p - q, q - 1)}(2x - 1),</p>
<p>where :math:<code>P_n^{(\cdot, \cdot)}</code> is the n-th Jacobi
polynomial. See 22.5.2 in [AS]_ for details.</p>
<h2 id="parameters_44">Parameters<a class="headerlink" href="#parameters_44" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>binom</code> and <code>eval_jacobi</code>.
p : float
Parameter
q : float
Parameter</p>
<h2 id="returns_42">Returns<a class="headerlink" href="#returns_42" title="Permanent link">&para;</a></h2>
<p>G : ndarray
Values of the shifted Jacobi polynomial.</p>
<h2 id="see-also_42">See Also<a class="headerlink" href="#see-also_42" title="Permanent link">&para;</a></h2>
<p>roots_sh_jacobi : roots and quadrature weights of shifted Jacobi
polynomials
sh_jacobi : shifted Jacobi polynomial object
eval_jacobi : evaluate Jacobi polynomials</p>
<h2 id="references_38">References<a class="headerlink" href="#references_38" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_sh_legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_sh_legendre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_sh_legendre(n, x, out=None)</p>
<p>Evaluate shifted Legendre polynomial at a point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>P_n^*(x) = P_n(2x - 1)</p>
<p>where :math:<code>P_n</code> is a Legendre polynomial. See 2.2.11 in [AS]_
for details.</p>
<h2 id="parameters_45">Parameters<a class="headerlink" href="#parameters_45" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the value is
determined via the relation to <code>eval_legendre</code>.
x : array_like
Points at which to evaluate the shifted Legendre polynomial</p>
<h2 id="returns_43">Returns<a class="headerlink" href="#returns_43" title="Permanent link">&para;</a></h2>
<p>P : ndarray
Values of the shifted Legendre polynomial</p>
<h2 id="see-also_43">See Also<a class="headerlink" href="#see-also_43" title="Permanent link">&para;</a></h2>
<p>roots_sh_legendre : roots and quadrature weights of shifted
Legendre polynomials
sh_legendre : shifted Legendre polynomial object
eval_legendre : evaluate Legendre polynomials
numpy.polynomial.legendre.Legendre : Legendre series</p>
<h2 id="references_39">References<a class="headerlink" href="#references_39" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exp1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>exp1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>exp1(z, out=None)</p>
<p>Exponential integral E1.</p>
<p>For complex :math:<code>z \ne 0</code> the exponential integral can be defined as
[1]_</p>
<p>.. math::</p>
<p>E_1(z) = \int_z^\infty \frac{e^{-t}}{t} dt,</p>
<p>where the path of the integral does not cross the negative real
axis or pass through the origin.</p>
<h2 id="parameters_46">Parameters<a class="headerlink" href="#parameters_46" title="Permanent link">&para;</a></h2>
<p>z: array_like
Real or complex argument.
out: ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_44">Returns<a class="headerlink" href="#returns_44" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the exponential integral E1</p>
<h2 id="see-also_44">See Also<a class="headerlink" href="#see-also_44" title="Permanent link">&para;</a></h2>
<p>expi : exponential integral :math:<code>Ei</code>
expn : generalization of :math:<code>E_1</code></p>
<h2 id="notes_25">Notes<a class="headerlink" href="#notes_25" title="Permanent link">&para;</a></h2>
<p>For :math:<code>x &gt; 0</code> it is related to the exponential integral
:math:<code>Ei</code> (see <code>expi</code>) via the relation</p>
<p>.. math::</p>
<p>E_1(x) = -Ei(-x).</p>
<h2 id="references_40">References<a class="headerlink" href="#references_40" title="Permanent link">&para;</a></h2>
<p>.. [1] Digital Library of Mathematical Functions, 6.2.1
https://dlmf.nist.gov/6.2#E1</p>
<h2 id="examples_18">Examples<a class="headerlink" href="#examples_18" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has a pole at 0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.exp1(0)
inf</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has a branch cut on the negative real axis.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.exp1(-1)
nan
sc.exp1(complex(-1, 0))
(-1.8951178163559368-3.141592653589793j)
sc.exp1(complex(-1, -0.0))
(-1.8951178163559368+3.141592653589793j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>It approaches 0 along the positive real axis.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.exp1([1, 10, 100, 1000])
array([2.19383934e-01, 4.15696893e-06, 3.68359776e-46, 0.00000000e+00])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is related to <code>expi</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3, 4])
sc.exp1(x)
array([0.21938393, 0.04890051, 0.01304838, 0.00377935])
-sc.expi(-x)
array([0.21938393, 0.04890051, 0.01304838, 0.00377935])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exp10</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>exp10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>exp10(x)</p>
<p>Compute <code>10**x</code> element-wise.</p>
<h2 id="parameters_47">Parameters<a class="headerlink" href="#parameters_47" title="Permanent link">&para;</a></h2>
<p>x : array_like
<code>x</code> must contain real numbers.</p>
<h2 id="returns_45">Returns<a class="headerlink" href="#returns_45" title="Permanent link">&para;</a></h2>
<p>float
<code>10**x</code>, computed element-wise.</p>
<h2 id="examples_19">Examples<a class="headerlink" href="#examples_19" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import exp10</p>
<p>exp10(3)
1000.0
x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]])
exp10(x)
array([[  0.1       ,   0.31622777,   1.        ],
[  3.16227766,  10.        ,  31.6227766 ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exp2</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>exp2(x)</p>
<p>Compute <code>2**x</code> element-wise.</p>
<h2 id="parameters_48">Parameters<a class="headerlink" href="#parameters_48" title="Permanent link">&para;</a></h2>
<p>x : array_like
<code>x</code> must contain real numbers.</p>
<h2 id="returns_46">Returns<a class="headerlink" href="#returns_46" title="Permanent link">&para;</a></h2>
<p>float
<code>2**x</code>, computed element-wise.</p>
<h2 id="examples_20">Examples<a class="headerlink" href="#examples_20" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import exp2</p>
<p>exp2(3)
8.0
x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]])
exp2(x)
array([[ 0.5       ,  0.70710678,  1.        ],
[ 1.41421356,  2.        ,  2.82842712]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>expi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>expi(x, out=None)</p>
<p>Exponential integral Ei.</p>
<p>For real :math:<code>x</code>, the exponential integral is defined as [1]_</p>
<p>.. math::</p>
<p>Ei(x) = \int_{-\infty}^x \frac{e^t}{t} dt.</p>
<p>For :math:<code>x &gt; 0</code> the integral is understood as a Cauchy principle
value.</p>
<p>It is extended to the complex plane by analytic continuation of
the function on the interval :math:<code>(0, \infty)</code>. The complex
variant has a branch cut on the negative real axis.</p>
<h2 id="parameters_49">Parameters<a class="headerlink" href="#parameters_49" title="Permanent link">&para;</a></h2>
<p>x: array_like
Real or complex valued argument
out: ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_47">Returns<a class="headerlink" href="#returns_47" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the exponential integral</p>
<h2 id="notes_26">Notes<a class="headerlink" href="#notes_26" title="Permanent link">&para;</a></h2>
<p>The exponential integrals :math:<code>E_1</code> and :math:<code>Ei</code> satisfy the
relation</p>
<p>.. math::</p>
<p>E_1(x) = -Ei(-x)</p>
<p>for :math:<code>x &gt; 0</code>.</p>
<h2 id="see-also_45">See Also<a class="headerlink" href="#see-also_45" title="Permanent link">&para;</a></h2>
<p>exp1 : Exponential integral :math:<code>E_1</code>
expn : Generalized exponential integral :math:<code>E_n</code></p>
<h2 id="references_41">References<a class="headerlink" href="#references_41" title="Permanent link">&para;</a></h2>
<p>.. [1] Digital Library of Mathematical Functions, 6.2.5
https://dlmf.nist.gov/6.2#E5</p>
<h2 id="examples_21">Examples<a class="headerlink" href="#examples_21" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is related to <code>exp1</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3, 4])
-sc.expi(-x)
array([0.21938393, 0.04890051, 0.01304838, 0.00377935])
sc.exp1(x)
array([0.21938393, 0.04890051, 0.01304838, 0.00377935])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The complex variant has a branch cut on the negative real axis.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc
sc.expi(-1 + 1e-12j)
(-0.21938393439552062+3.1415926535894254j)
sc.expi(-1 - 1e-12j)
(-0.21938393439552062-3.1415926535894254j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>As the complex variant approaches the branch cut, the real parts
approach the value of the real variant.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.expi(-1)
-0.21938393439552062</p>
</blockquote>
</blockquote>
</blockquote>
<p>The SciPy implementation returns the real variant for complex
values on the branch cut.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.expi(complex(-1, 0.0))
(-0.21938393439552062-0j)
sc.expi(complex(-1, -0.0))
(-0.21938393439552062-0j)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expit</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>expit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>expit(x)</p>
<p>Expit (a.k.a. logistic sigmoid) ufunc for ndarrays.</p>
<p>The expit function, also known as the logistic sigmoid function, is
defined as <code>expit(x) = 1/(1+exp(-x))</code>.  It is the inverse of the
logit function.</p>
<h2 id="parameters_50">Parameters<a class="headerlink" href="#parameters_50" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The ndarray to apply expit to element-wise.</p>
<h2 id="returns_48">Returns<a class="headerlink" href="#returns_48" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An ndarray of the same shape as x. Its entries
are <code>expit</code> of the corresponding entry of x.</p>
<h2 id="see-also_46">See Also<a class="headerlink" href="#see-also_46" title="Permanent link">&para;</a></h2>
<p>logit</p>
<h2 id="notes_27">Notes<a class="headerlink" href="#notes_27" title="Permanent link">&para;</a></h2>
<p>As a ufunc expit takes a number of optional
keyword arguments. For more information
see <code>ufuncs &lt;https://docs.scipy.org/doc/numpy/reference/ufuncs.html&gt;</code>_</p>
<p>.. versionadded:: 0.10.0</p>
<h2 id="examples_22">Examples<a class="headerlink" href="#examples_22" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import expit, logit</p>
<p>expit([-np.inf, -1.5, 0, 1.5, np.inf])
array([ 0.        ,  0.18242552,  0.5       ,  0.81757448,  1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>logit</code> is the inverse of <code>expit</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>logit(expit([-2.5, 0, 3.1, 5.0]))
array([-2.5,  0. ,  3.1,  5. ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot expit(x) for x in [-6, 6]:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
x = np.linspace(-6, 6, 121)
y = expit(x)
plt.plot(x, y)
plt.grid()
plt.xlim(-6, 6)
plt.xlabel('x')
plt.title('expit(x)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>expm1(x)</p>
<p>Compute <code>exp(x) - 1</code>.</p>
<p>When <code>x</code> is near zero, <code>exp(x)</code> is near 1, so the numerical calculation
of <code>exp(x) - 1</code> can suffer from catastrophic loss of precision.
<code>expm1(x)</code> is implemented to avoid the loss of precision that occurs when
<code>x</code> is near zero.</p>
<h2 id="parameters_51">Parameters<a class="headerlink" href="#parameters_51" title="Permanent link">&para;</a></h2>
<p>x : array_like
<code>x</code> must contain real numbers.</p>
<h2 id="returns_49">Returns<a class="headerlink" href="#returns_49" title="Permanent link">&para;</a></h2>
<p>float
<code>exp(x) - 1</code> computed element-wise.</p>
<h2 id="examples_23">Examples<a class="headerlink" href="#examples_23" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import expm1</p>
<p>expm1(1.0)
1.7182818284590451
expm1([-0.2, -0.1, 0, 0.1, 0.2])
array([-0.18126925, -0.09516258,  0.        ,  0.10517092,  0.22140276])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The exact value of <code>exp(7.5e-13) - 1</code> is::</p>
<p>7.5000000000028125000000007031250000001318...<em>10</em>*-13.</p>
<p>Here is what <code>expm1(7.5e-13)</code> gives:</p>
<blockquote>
<blockquote>
<blockquote>
<p>expm1(7.5e-13)
7.5000000000028135e-13</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare that to <code>exp(7.5e-13) - 1</code>, where the subtraction results in
a 'catastrophic' loss of precision:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.exp(7.5e-13) - 1
7.5006667543675576e-13</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>expn(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>expn(n, x, out=None)</p>
<p>Generalized exponential integral En.</p>
<p>For integer :math:<code>n \geq 0</code> and real :math:<code>x \geq 0</code> the
generalized exponential integral is defined as [dlmf]_</p>
<p>.. math::</p>
<p>E_n(x) = x^{n - 1} \int_x^\infty \frac{e^{-t}}{t^n} dt.</p>
<h2 id="parameters_52">Parameters<a class="headerlink" href="#parameters_52" title="Permanent link">&para;</a></h2>
<p>n: array_like
Non-negative integers
x: array_like
Real argument
out: ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_50">Returns<a class="headerlink" href="#returns_50" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the generalized exponential integral</p>
<h2 id="see-also_47">See Also<a class="headerlink" href="#see-also_47" title="Permanent link">&para;</a></h2>
<p>exp1 : special case of :math:<code>E_n</code> for :math:<code>n = 1</code>
expi : related to :math:<code>E_n</code> when :math:<code>n = 1</code></p>
<h2 id="references_42">References<a class="headerlink" href="#references_42" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] Digital Library of Mathematical Functions, 8.19.2
https://dlmf.nist.gov/8.19#E2</p>
<h2 id="examples_24">Examples<a class="headerlink" href="#examples_24" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>Its domain is nonnegative n and x.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.expn(-1, 1.0), sc.expn(1, -1.0)
(nan, nan)</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has a pole at <code>x = 0</code> for <code>n = 1, 2</code>; for larger <code>n</code> it
is equal to <code>1 / (n - 1)</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.expn([0, 1, 2, 3, 4], 0)
array([       inf,        inf, 1.        , 0.5       , 0.33333333])</p>
</blockquote>
</blockquote>
</blockquote>
<p>For n equal to 0 it reduces to <code>exp(-x) / x</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3, 4])
sc.expn(0, x)
array([0.36787944, 0.06766764, 0.01659569, 0.00457891])
np.exp(-x) / x
array([0.36787944, 0.06766764, 0.01659569, 0.00457891])</p>
</blockquote>
</blockquote>
</blockquote>
<p>For n equal to 1 it reduces to <code>exp1</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.expn(1, x)
array([0.21938393, 0.04890051, 0.01304838, 0.00377935])
sc.exp1(x)
array([0.21938393, 0.04890051, 0.01304838, 0.00377935])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exprel</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>exprel(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>exprel(x)</p>
<p>Relative error exponential, <code>(exp(x) - 1)/x</code>.</p>
<p>When <code>x</code> is near zero, <code>exp(x)</code> is near 1, so the numerical calculation
of <code>exp(x) - 1</code> can suffer from catastrophic loss of precision.
<code>exprel(x)</code> is implemented to avoid the loss of precision that occurs when
<code>x</code> is near zero.</p>
<h2 id="parameters_53">Parameters<a class="headerlink" href="#parameters_53" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Input array.  <code>x</code> must contain real numbers.</p>
<h2 id="returns_51">Returns<a class="headerlink" href="#returns_51" title="Permanent link">&para;</a></h2>
<p>float
<code>(exp(x) - 1)/x</code>, computed element-wise.</p>
<h2 id="see-also_48">See Also<a class="headerlink" href="#see-also_48" title="Permanent link">&para;</a></h2>
<p>expm1</p>
<h2 id="notes_28">Notes<a class="headerlink" href="#notes_28" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.17.0</p>
<h2 id="examples_25">Examples<a class="headerlink" href="#examples_25" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import exprel</p>
<p>exprel(0.01)
1.0050167084168056
exprel([-0.25, -0.1, 0, 0.1, 0.25])
array([ 0.88479687,  0.95162582,  1.        ,  1.05170918,  1.13610167])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare <code>exprel(5e-9)</code> to the naive calculation.  The exact value
is <code>1.00000000250000000416...</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>exprel(5e-9)
1.0000000025</p>
<p>(np.exp(5e-9) - 1)/5e-9
0.99999999392252903</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>fdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>fdtr(dfn, dfd, x)</p>
<p>F cumulative distribution function.</p>
<p>Returns the value of the cumulative distribution function of the
F-distribution, also known as Snedecor's F-distribution or the
Fisher-Snedecor distribution.</p>
<p>The F-distribution with parameters :math:<code>d_n</code> and :math:<code>d_d</code> is the
distribution of the random variable,</p>
<p>.. math::
X = \frac{U_n/d_n}{U_d/d_d},</p>
<p>where :math:<code>U_n</code> and :math:<code>U_d</code> are random variables distributed
:math:<code>\chi^2</code>, with :math:<code>d_n</code> and :math:<code>d_d</code> degrees of freedom,
respectively.</p>
<h2 id="parameters_54">Parameters<a class="headerlink" href="#parameters_54" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
First parameter (positive float).
dfd : array_like
Second parameter (positive float).
x : array_like
Argument (nonnegative float).</p>
<h2 id="returns_52">Returns<a class="headerlink" href="#returns_52" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The CDF of the F-distribution with parameters <code>dfn</code> and <code>dfd</code> at <code>x</code>.</p>
<h2 id="notes_29">Notes<a class="headerlink" href="#notes_29" title="Permanent link">&para;</a></h2>
<p>The regularized incomplete beta function is used, according to the
formula,</p>
<p>.. math::
F(d_n, d_d; x) = I_{xd_n/(d_d + xd_n)}(d_n/2, d_d/2).</p>
<p>Wrapper for the Cephes [1]_ routine <code>fdtr</code>.</p>
<h2 id="references_43">References<a class="headerlink" href="#references_43" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fdtrc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>fdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>fdtrc(dfn, dfd, x)</p>
<p>F survival function.</p>
<p>Returns the complemented F-distribution function (the integral of the
density from <code>x</code> to infinity).</p>
<h2 id="parameters_55">Parameters<a class="headerlink" href="#parameters_55" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
First parameter (positive float).
dfd : array_like
Second parameter (positive float).
x : array_like
Argument (nonnegative float).</p>
<h2 id="returns_53">Returns<a class="headerlink" href="#returns_53" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The complemented F-distribution function with parameters <code>dfn</code> and
<code>dfd</code> at <code>x</code>.</p>
<h2 id="see-also_49">See also<a class="headerlink" href="#see-also_49" title="Permanent link">&para;</a></h2>
<p>fdtr</p>
<h2 id="notes_30">Notes<a class="headerlink" href="#notes_30" title="Permanent link">&para;</a></h2>
<p>The regularized incomplete beta function is used, according to the
formula,</p>
<p>.. math::
F(d_n, d_d; x) = I_{d_d/(d_d + xd_n)}(d_d/2, d_n/2).</p>
<p>Wrapper for the Cephes [1]_ routine <code>fdtrc</code>.</p>
<h2 id="references_44">References<a class="headerlink" href="#references_44" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>fdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>fdtri(dfn, dfd, p)</p>
<p>The <code>p</code>-th quantile of the F-distribution.</p>
<p>This function is the inverse of the F-distribution CDF, <code>fdtr</code>, returning
the <code>x</code> such that <code>fdtr(dfn, dfd, x) = p</code>.</p>
<h2 id="parameters_56">Parameters<a class="headerlink" href="#parameters_56" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
First parameter (positive float).
dfd : array_like
Second parameter (positive float).
p : array_like
Cumulative probability, in [0, 1].</p>
<h2 id="returns_54">Returns<a class="headerlink" href="#returns_54" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The quantile corresponding to <code>p</code>.</p>
<h2 id="notes_31">Notes<a class="headerlink" href="#notes_31" title="Permanent link">&para;</a></h2>
<p>The computation is carried out using the relation to the inverse
regularized beta function, :math:<code>I^{-1}_x(a, b)</code>.  Let
:math:<code>z = I^{-1}_p(d_d/2, d_n/2).</code>  Then,</p>
<p>.. math::
x = \frac{d_d (1 - z)}{d_n z}.</p>
<p>If <code>p</code> is such that :math:<code>x &lt; 0.5</code>, the following relation is used
instead for improved stability: let
:math:<code>z' = I^{-1}_{1 - p}(d_n/2, d_d/2).</code> Then,</p>
<p>.. math::
x = \frac{d_d z'}{d_n (1 - z')}.</p>
<p>Wrapper for the Cephes [1]_ routine <code>fdtri</code>.</p>
<h2 id="references_45">References<a class="headerlink" href="#references_45" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fdtridfd</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>fdtridfd(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>fdtridfd(dfn, p, x)</p>
<p>Inverse to <code>fdtr</code> vs dfd</p>
<p>Finds the F density argument dfd such that <code>fdtr(dfn, dfd, x) == p</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fresnel</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>fresnel(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>fresnel(z, out=None)</p>
<p>Fresnel integrals.</p>
<p>The Fresnel integrals are defined as</p>
<p>.. math::</p>
<p>S(z) &amp;= \int_0^z \cos(\pi t^2 /2) dt \
C(z) &amp;= \int_0^z \sin(\pi t^2 /2) dt.</p>
<p>See [dlmf]_ for details.</p>
<h2 id="parameters_57">Parameters<a class="headerlink" href="#parameters_57" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex valued argument
out : 2-tuple of ndarrays, optional
Optional output arrays for the function results</p>
<h2 id="returns_55">Returns<a class="headerlink" href="#returns_55" title="Permanent link">&para;</a></h2>
<p>S, C : 2-tuple of scalar or ndarray
Values of the Fresnel integrals</p>
<h2 id="see-also_50">See Also<a class="headerlink" href="#see-also_50" title="Permanent link">&para;</a></h2>
<p>fresnel_zeros : zeros of the Fresnel integrals</p>
<h2 id="references_46">References<a class="headerlink" href="#references_46" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/7.2#iii</p>
<h2 id="examples_26">Examples<a class="headerlink" href="#examples_26" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>As z goes to infinity along the real axis, S and C converge to 0.5.</p>
<blockquote>
<blockquote>
<blockquote>
<p>S, C = sc.fresnel([0.1, 1, 10, 100, np.inf])
S
array([0.00052359, 0.43825915, 0.46816998, 0.4968169 , 0.5       ])
C
array([0.09999753, 0.7798934 , 0.49989869, 0.4999999 , 0.5       ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>They are related to the error function <code>erf</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>z = np.array([1, 2, 3, 4])
zeta = 0.5 * np.sqrt(np.pi) * (1 - 1j) * z
S, C = sc.fresnel(z)
C + 1j*S
array([0.7798934 +0.43825915j, 0.48825341+0.34341568j,
0.60572079+0.496313j  , 0.49842603+0.42051575j])
0.5 * (1 + 1j) * sc.erf(zeta)
array([0.7798934 +0.43825915j, 0.48825341+0.34341568j,
0.60572079+0.496313j  , 0.49842603+0.42051575j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gamma</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gamma(z)</p>
<p>Gamma function.</p>
<p>The Gamma function is defined as</p>
<p>.. math::</p>
<p>\Gamma(z) = \int_0^\infty t^{z-1} e^{-t} dt</p>
<p>for :math:<code>\Re(z) &gt; 0</code> and is extended to the rest of the complex
plane by analytic continuation. See [dlmf]_ for more details.</p>
<h2 id="parameters_58">Parameters<a class="headerlink" href="#parameters_58" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex valued argument</p>
<h2 id="returns_56">Returns<a class="headerlink" href="#returns_56" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the Gamma function</p>
<h2 id="notes_32">Notes<a class="headerlink" href="#notes_32" title="Permanent link">&para;</a></h2>
<p>The Gamma function is often referred to as the generalized
factorial since :math:<code>\Gamma(n + 1) = n!</code> for natural numbers
:math:<code>n</code>. More generally it satisfies the recurrence relation
:math:<code>\Gamma(z + 1) = z \cdot \Gamma(z)</code> for complex :math:<code>z</code>,
which, combined with the fact that :math:<code>\Gamma(1) = 1</code>, implies
the above identity for :math:<code>z = n</code>.</p>
<h2 id="references_47">References<a class="headerlink" href="#references_47" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/5.2#E1</p>
<h2 id="examples_27">Examples<a class="headerlink" href="#examples_27" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import gamma, factorial</p>
<p>gamma([0, 0.5, 1, 5])
array([         inf,   1.77245385,   1.        ,  24.        ])</p>
<p>z = 2.5 + 1j
gamma(z)
(0.77476210455108352+0.70763120437959293j)
gamma(z+1), z*gamma(z)  # Recurrence property
((1.2292740569981171+2.5438401155000685j),
(1.2292740569981158+2.5438401155000658j))</p>
<p>gamma(0.5)**2  # gamma(0.5) = sqrt(pi)
3.1415926535897927</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot gamma(x) for real x</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-3.5, 5.5, 2251)
y = gamma(x)</p>
<p>import matplotlib.pyplot as plt
plt.plot(x, y, 'b', alpha=0.6, label='gamma(x)')
k = np.arange(1, 7)
plt.plot(k, factorial(k-1), 'k*', alpha=0.6,
...          label='(x-1)!, x = 1, 2, ...')
plt.xlim(-3.5, 5.5)
plt.ylim(-10, 25)
plt.grid()
plt.xlabel('x')
plt.legend(loc='lower right')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gammainc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gammainc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gammainc(a, x)</p>
<p>Regularized lower incomplete gamma function.</p>
<p>It is defined as</p>
<p>.. math::</p>
<p>P(a, x) = \frac{1}{\Gamma(a)} \int_0^x t^{a - 1}e^{-t} dt</p>
<p>for :math:<code>a &gt; 0</code> and :math:<code>x \geq 0</code>. See [dlmf]_ for details.</p>
<h2 id="parameters_59">Parameters<a class="headerlink" href="#parameters_59" title="Permanent link">&para;</a></h2>
<p>a : array_like
Positive parameter
x : array_like
Nonnegative argument</p>
<h2 id="returns_57">Returns<a class="headerlink" href="#returns_57" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the lower incomplete gamma function</p>
<h2 id="notes_33">Notes<a class="headerlink" href="#notes_33" title="Permanent link">&para;</a></h2>
<p>The function satisfies the relation <code>gammainc(a, x) +
gammaincc(a, x) = 1</code> where <code>gammaincc</code> is the regularized upper
incomplete gamma function.</p>
<p>The implementation largely follows that of [boost]_.</p>
<h2 id="see-also_51">See also<a class="headerlink" href="#see-also_51" title="Permanent link">&para;</a></h2>
<p>gammaincc : regularized upper incomplete gamma function
gammaincinv : inverse of the regularized lower incomplete gamma
function with respect to <code>x</code>
gammainccinv : inverse of the regularized upper incomplete gamma
function with respect to <code>x</code></p>
<h2 id="references_48">References<a class="headerlink" href="#references_48" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical functions
https://dlmf.nist.gov/8.2#E4
.. [boost] Maddock et. al., 'Incomplete Gamma Functions',
https://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html</p>
<h2 id="examples_28">Examples<a class="headerlink" href="#examples_28" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is the CDF of the gamma distribution, so it starts at 0 and
monotonically increases to 1.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammainc(0.5, [0, 1, 10, 100])
array([0.        , 0.84270079, 0.99999226, 1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is equal to one minus the upper incomplete gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, x = 0.5, 0.4
sc.gammainc(a, x)
0.6289066304773024
1 - sc.gammaincc(a, x)
0.6289066304773024</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gammaincc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gammaincc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gammaincc(a, x)</p>
<p>Regularized upper incomplete gamma function.</p>
<p>It is defined as</p>
<p>.. math::</p>
<p>Q(a, x) = \frac{1}{\Gamma(a)} \int_x^\infty t^{a - 1}e^{-t} dt</p>
<p>for :math:<code>a &gt; 0</code> and :math:<code>x \geq 0</code>. See [dlmf]_ for details.</p>
<h2 id="parameters_60">Parameters<a class="headerlink" href="#parameters_60" title="Permanent link">&para;</a></h2>
<p>a : array_like
Positive parameter
x : array_like
Nonnegative argument</p>
<h2 id="returns_58">Returns<a class="headerlink" href="#returns_58" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the upper incomplete gamma function</p>
<h2 id="notes_34">Notes<a class="headerlink" href="#notes_34" title="Permanent link">&para;</a></h2>
<p>The function satisfies the relation <code>gammainc(a, x) +
gammaincc(a, x) = 1</code> where <code>gammainc</code> is the regularized lower
incomplete gamma function.</p>
<p>The implementation largely follows that of [boost]_.</p>
<h2 id="see-also_52">See also<a class="headerlink" href="#see-also_52" title="Permanent link">&para;</a></h2>
<p>gammainc : regularized lower incomplete gamma function
gammaincinv : inverse of the regularized lower incomplete gamma
function with respect to <code>x</code>
gammainccinv : inverse to of the regularized upper incomplete
gamma function with respect to <code>x</code></p>
<h2 id="references_49">References<a class="headerlink" href="#references_49" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical functions
https://dlmf.nist.gov/8.2#E4
.. [boost] Maddock et. al., 'Incomplete Gamma Functions',
https://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html</p>
<h2 id="examples_29">Examples<a class="headerlink" href="#examples_29" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is the survival function of the gamma distribution, so it
starts at 1 and monotonically decreases to 0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammaincc(0.5, [0, 1, 10, 100, 1000])
array([1.00000000e+00, 1.57299207e-01, 7.74421643e-06, 2.08848758e-45,
0.00000000e+00])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is equal to one minus the lower incomplete gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, x = 0.5, 0.4
sc.gammaincc(a, x)
0.37109336952269756
1 - sc.gammainc(a, x)
0.37109336952269756</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gammainccinv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gammainccinv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gammainccinv(a, y)</p>
<p>Inverse of the upper incomplete gamma function with respect to <code>x</code></p>
<p>Given an input :math:<code>y</code> between 0 and 1, returns :math:<code>x</code> such
that :math:<code>y = Q(a, x)</code>. Here :math:<code>Q</code> is the upper incomplete
gamma function; see <code>gammaincc</code>. This is well-defined because the
upper incomplete gamma function is monotonic as can be seen from
its definition in [dlmf]_.</p>
<h2 id="parameters_61">Parameters<a class="headerlink" href="#parameters_61" title="Permanent link">&para;</a></h2>
<p>a : array_like
Positive parameter
y : array_like
Argument between 0 and 1, inclusive</p>
<h2 id="returns_59">Returns<a class="headerlink" href="#returns_59" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the inverse of the upper incomplete gamma function</p>
<h2 id="see-also_53">See Also<a class="headerlink" href="#see-also_53" title="Permanent link">&para;</a></h2>
<p>gammaincc : regularized upper incomplete gamma function
gammainc : regularized lower incomplete gamma function
gammaincinv : inverse of the regularized lower incomplete gamma
function with respect to <code>x</code></p>
<h2 id="references_50">References<a class="headerlink" href="#references_50" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/8.2#E4</p>
<h2 id="examples_30">Examples<a class="headerlink" href="#examples_30" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It starts at infinity and monotonically decreases to 0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammainccinv(0.5, [0, 0.1, 0.5, 1])
array([       inf, 1.35277173, 0.22746821, 0.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It inverts the upper incomplete gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, x = 0.5, [0, 0.1, 0.5, 1]
sc.gammaincc(a, sc.gammainccinv(a, x))
array([0. , 0.1, 0.5, 1. ])</p>
<p>a, x = 0.5, [0, 10, 50]
sc.gammainccinv(a, sc.gammaincc(a, x))
array([ 0., 10., 50.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gammaincinv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gammaincinv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gammaincinv(a, y)</p>
<p>Inverse to the lower incomplete gamma function with respect to <code>x</code>.</p>
<p>Given an input :math:<code>y</code> between 0 and 1, returns :math:<code>x</code> such
that :math:<code>y = P(a, x)</code>. Here :math:<code>P</code> is the regularized lower
incomplete gamma function; see <code>gammainc</code>. This is well-defined
because the lower incomplete gamma function is monotonic as can be
seen from its definition in [dlmf]_.</p>
<h2 id="parameters_62">Parameters<a class="headerlink" href="#parameters_62" title="Permanent link">&para;</a></h2>
<p>a : array_like
Positive parameter
y : array_like
Parameter between 0 and 1, inclusive</p>
<h2 id="returns_60">Returns<a class="headerlink" href="#returns_60" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the inverse of the lower incomplete gamma function</p>
<h2 id="see-also_54">See Also<a class="headerlink" href="#see-also_54" title="Permanent link">&para;</a></h2>
<p>gammainc : regularized lower incomplete gamma function
gammaincc : regularized upper incomplete gamma function
gammainccinv : inverse of the regualizred upper incomplete gamma
function with respect to <code>x</code></p>
<h2 id="references_51">References<a class="headerlink" href="#references_51" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/8.2#E4</p>
<h2 id="examples_31">Examples<a class="headerlink" href="#examples_31" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It starts at 0 and monotonically increases to infinity.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammaincinv(0.5, [0, 0.1 ,0.5, 1])
array([0.        , 0.00789539, 0.22746821,        inf])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It inverts the lower incomplete gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, x = 0.5, [0, 0.1, 0.5, 1]
sc.gammainc(a, sc.gammaincinv(a, x))
array([0. , 0.1, 0.5, 1. ])</p>
<p>a, x = 0.5, [0, 10, 25]
sc.gammaincinv(a, sc.gammainc(a, x))
array([ 0.        , 10.        , 25.00001465])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gammaln</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gammaln(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gammaln(x, out=None)</p>
<p>Logarithm of the absolute value of the Gamma function.</p>
<p>Defined as</p>
<p>.. math::</p>
<p>\ln(\lvert\Gamma(x)\rvert)</p>
<p>where :math:<code>\Gamma</code> is the Gamma function. For more details on
the Gamma function, see [dlmf]_.</p>
<h2 id="parameters_63">Parameters<a class="headerlink" href="#parameters_63" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real argument
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_61">Returns<a class="headerlink" href="#returns_61" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the log of the absolute value of Gamma</p>
<h2 id="see-also_55">See Also<a class="headerlink" href="#see-also_55" title="Permanent link">&para;</a></h2>
<p>gammasgn : sign of the gamma function
loggamma : principal branch of the logarithm of the gamma function</p>
<h2 id="notes_35">Notes<a class="headerlink" href="#notes_35" title="Permanent link">&para;</a></h2>
<p>It is the same function as the Python standard library function
:func:<code>math.lgamma</code>.</p>
<p>When used in conjunction with <code>gammasgn</code>, this function is useful
for working in logspace on the real axis without having to deal
with complex numbers via the relation <code>exp(gammaln(x)) =
gammasgn(x) * gamma(x)</code>.</p>
<p>For complex-valued log-gamma, use <code>loggamma</code> instead of <code>gammaln</code>.</p>
<h2 id="references_52">References<a class="headerlink" href="#references_52" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/5</p>
<h2 id="examples_32">Examples<a class="headerlink" href="#examples_32" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has two positive zeros.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammaln([1, 2])
array([0., 0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has poles at nonpositive integers.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammaln([0, -1, -2, -3, -4])
array([inf, inf, inf, inf, inf])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It asymptotically approaches <code>x * log(x)</code> (Stirling's formula).</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1e10, 1e20, 1e40, 1e80])
sc.gammaln(x)
array([2.20258509e+11, 4.50517019e+21, 9.11034037e+41, 1.83206807e+82])
x * np.log(x)
array([2.30258509e+11, 4.60517019e+21, 9.21034037e+41, 1.84206807e+82])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gammasgn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gammasgn(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gammasgn(x)</p>
<p>Sign of the gamma function.</p>
<p>It is defined as</p>
<p>.. math::</p>
<p>\text{gammasgn}(x) =
\begin{cases}
+1 &amp; \Gamma(x) &gt; 0 \
-1 &amp; \Gamma(x) &lt; 0
\end{cases}</p>
<p>where :math:<code>\Gamma</code> is the Gamma function; see <code>gamma</code>. This
definition is complete since the Gamma function is never zero;
see the discussion after [dlmf]_.</p>
<h2 id="parameters_64">Parameters<a class="headerlink" href="#parameters_64" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real argument</p>
<h2 id="returns_62">Returns<a class="headerlink" href="#returns_62" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Sign of the Gamma function</p>
<h2 id="notes_36">Notes<a class="headerlink" href="#notes_36" title="Permanent link">&para;</a></h2>
<p>The Gamma function can be computed as <code>gammasgn(x) *
np.exp(gammaln(x))</code>.</p>
<h2 id="see-also_56">See Also<a class="headerlink" href="#see-also_56" title="Permanent link">&para;</a></h2>
<p>gamma : the Gamma function
gammaln : log of the absolute value of the Gamma function
loggamma : analytic continuation of the log of the Gamma function</p>
<h2 id="references_53">References<a class="headerlink" href="#references_53" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/5.2#E1</p>
<h2 id="examples_33">Examples<a class="headerlink" href="#examples_33" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is 1 for <code>x &gt; 0</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammasgn([1, 2, 3, 4])
array([1., 1., 1., 1.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It alternates between -1 and 1 for negative integers.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammasgn([-0.5, -1.5, -2.5, -3.5])
array([-1.,  1., -1.,  1.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It can be used to compute the Gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = [1.5, 0.5, -0.5, -1.5]
sc.gammasgn(x) * np.exp(sc.gammaln(x))
array([ 0.88622693,  1.77245385, -3.5449077 ,  2.3632718 ])
sc.gamma(x)
array([ 0.88622693,  1.77245385, -3.5449077 ,  2.3632718 ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gdtr(a, b, x)</p>
<p>Gamma distribution cumulative distribution function.</p>
<p>Returns the integral from zero to <code>x</code> of the gamma probability density
function,</p>
<p>.. math::</p>
<p>F = \int_0^x \frac{a^b}{\Gamma(b)} t^{b-1} e^{-at}\,dt,</p>
<p>where :math:<code>\Gamma</code> is the gamma function.</p>
<h2 id="parameters_65">Parameters<a class="headerlink" href="#parameters_65" title="Permanent link">&para;</a></h2>
<p>a : array_like
The rate parameter of the gamma distribution, sometimes denoted
:math:<code>\beta</code> (float).  It is also the reciprocal of the scale
parameter :math:<code>\theta</code>.
b : array_like
The shape parameter of the gamma distribution, sometimes denoted
:math:<code>\alpha</code> (float).
x : array_like
The quantile (upper limit of integration; float).</p>
<h2 id="see-also_57">See also<a class="headerlink" href="#see-also_57" title="Permanent link">&para;</a></h2>
<p>gdtrc : 1 - CDF of the gamma distribution.</p>
<h2 id="returns_63">Returns<a class="headerlink" href="#returns_63" title="Permanent link">&para;</a></h2>
<p>F : ndarray
The CDF of the gamma distribution with parameters <code>a</code> and <code>b</code>
evaluated at <code>x</code>.</p>
<h2 id="notes_37">Notes<a class="headerlink" href="#notes_37" title="Permanent link">&para;</a></h2>
<p>The evaluation is carried out using the relation to the incomplete gamma
integral (regularized gamma function).</p>
<p>Wrapper for the Cephes [1]_ routine <code>gdtr</code>.</p>
<h2 id="references_54">References<a class="headerlink" href="#references_54" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gdtrc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gdtrc(a, b, x)</p>
<p>Gamma distribution survival function.</p>
<p>Integral from <code>x</code> to infinity of the gamma probability density function,</p>
<p>.. math::</p>
<p>F = \int_x^\infty \frac{a^b}{\Gamma(b)} t^{b-1} e^{-at}\,dt,</p>
<p>where :math:<code>\Gamma</code> is the gamma function.</p>
<h2 id="parameters_66">Parameters<a class="headerlink" href="#parameters_66" title="Permanent link">&para;</a></h2>
<p>a : array_like
The rate parameter of the gamma distribution, sometimes denoted
:math:<code>\beta</code> (float).  It is also the reciprocal of the scale
parameter :math:<code>\theta</code>.
b : array_like
The shape parameter of the gamma distribution, sometimes denoted
:math:<code>\alpha</code> (float).
x : array_like
The quantile (lower limit of integration; float).</p>
<h2 id="returns_64">Returns<a class="headerlink" href="#returns_64" title="Permanent link">&para;</a></h2>
<p>F : ndarray
The survival function of the gamma distribution with parameters <code>a</code>
and <code>b</code> evaluated at <code>x</code>.</p>
<h2 id="see-also_58">See Also<a class="headerlink" href="#see-also_58" title="Permanent link">&para;</a></h2>
<p>gdtr, gdtrix</p>
<h2 id="notes_38">Notes<a class="headerlink" href="#notes_38" title="Permanent link">&para;</a></h2>
<p>The evaluation is carried out using the relation to the incomplete gamma
integral (regularized gamma function).</p>
<p>Wrapper for the Cephes [1]_ routine <code>gdtrc</code>.</p>
<h2 id="references_55">References<a class="headerlink" href="#references_55" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gdtria</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gdtria(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gdtria(p, b, x, out=None)</p>
<p>Inverse of <code>gdtr</code> vs a.</p>
<p>Returns the inverse with respect to the parameter <code>a</code> of <code>p =
gdtr(a, b, x)</code>, the cumulative distribution function of the gamma
distribution.</p>
<h2 id="parameters_67">Parameters<a class="headerlink" href="#parameters_67" title="Permanent link">&para;</a></h2>
<p>p : array_like
Probability values.
b : array_like
<code>b</code> parameter values of <code>gdtr(a, b, x)</code>.  <code>b</code> is the 'shape' parameter
of the gamma distribution.
x : array_like
Nonnegative real values, from the domain of the gamma distribution.
out : ndarray, optional
If a fourth argument is given, it must be a numpy.ndarray whose size
matches the broadcast result of <code>a</code>, <code>b</code> and <code>x</code>.  <code>out</code> is then the
array returned by the function.</p>
<h2 id="returns_65">Returns<a class="headerlink" href="#returns_65" title="Permanent link">&para;</a></h2>
<p>a : ndarray
Values of the <code>a</code> parameter such that <code>p = gdtr(a, b, x)</code>.  <code>1/a</code>
is the 'scale' parameter of the gamma distribution.</p>
<h2 id="see-also_59">See Also<a class="headerlink" href="#see-also_59" title="Permanent link">&para;</a></h2>
<p>gdtr : CDF of the gamma distribution.
gdtrib : Inverse with respect to <code>b</code> of <code>gdtr(a, b, x)</code>.
gdtrix : Inverse with respect to <code>x</code> of <code>gdtr(a, b, x)</code>.</p>
<h2 id="notes_39">Notes<a class="headerlink" href="#notes_39" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfgam</code>.</p>
<p>The cumulative distribution function <code>p</code> is computed using a routine by
DiDinato and Morris [2]_.  Computation of <code>a</code> involves a search for a value
that produces the desired value of <code>p</code>.  The search relies on the
monotonicity of <code>p</code> with <code>a</code>.</p>
<h2 id="references_56">References<a class="headerlink" href="#references_56" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] DiDinato, A. R. and Morris, A. H.,
Computation of the incomplete gamma function ratios and their
inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.</p>
<h2 id="examples_34">Examples<a class="headerlink" href="#examples_34" title="Permanent link">&para;</a></h2>
<p>First evaluate <code>gdtr</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import gdtr, gdtria
p = gdtr(1.2, 3.4, 5.6)
print(p)
0.94378087442</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify the inverse.</p>
<blockquote>
<blockquote>
<blockquote>
<p>gdtria(p, 3.4, 5.6)
1.2</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gdtrib</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gdtrib(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gdtrib(a, p, x, out=None)</p>
<p>Inverse of <code>gdtr</code> vs b.</p>
<p>Returns the inverse with respect to the parameter <code>b</code> of <code>p =
gdtr(a, b, x)</code>, the cumulative distribution function of the gamma
distribution.</p>
<h2 id="parameters_68">Parameters<a class="headerlink" href="#parameters_68" title="Permanent link">&para;</a></h2>
<p>a : array_like
<code>a</code> parameter values of <code>gdtr(a, b, x)</code>. <code>1/a</code> is the 'scale'
parameter of the gamma distribution.
p : array_like
Probability values.
x : array_like
Nonnegative real values, from the domain of the gamma distribution.
out : ndarray, optional
If a fourth argument is given, it must be a numpy.ndarray whose size
matches the broadcast result of <code>a</code>, <code>b</code> and <code>x</code>.  <code>out</code> is then the
array returned by the function.</p>
<h2 id="returns_66">Returns<a class="headerlink" href="#returns_66" title="Permanent link">&para;</a></h2>
<p>b : ndarray
Values of the <code>b</code> parameter such that <code>p = gdtr(a, b, x)</code>.  <code>b</code> is
the 'shape' parameter of the gamma distribution.</p>
<h2 id="see-also_60">See Also<a class="headerlink" href="#see-also_60" title="Permanent link">&para;</a></h2>
<p>gdtr : CDF of the gamma distribution.
gdtria : Inverse with respect to <code>a</code> of <code>gdtr(a, b, x)</code>.
gdtrix : Inverse with respect to <code>x</code> of <code>gdtr(a, b, x)</code>.</p>
<h2 id="notes_40">Notes<a class="headerlink" href="#notes_40" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfgam</code>.</p>
<p>The cumulative distribution function <code>p</code> is computed using a routine by
DiDinato and Morris [2]_.  Computation of <code>b</code> involves a search for a value
that produces the desired value of <code>p</code>.  The search relies on the
monotonicity of <code>p</code> with <code>b</code>.</p>
<h2 id="references_57">References<a class="headerlink" href="#references_57" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] DiDinato, A. R. and Morris, A. H.,
Computation of the incomplete gamma function ratios and their
inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.</p>
<h2 id="examples_35">Examples<a class="headerlink" href="#examples_35" title="Permanent link">&para;</a></h2>
<p>First evaluate <code>gdtr</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import gdtr, gdtrib
p = gdtr(1.2, 3.4, 5.6)
print(p)
0.94378087442</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify the inverse.</p>
<blockquote>
<blockquote>
<blockquote>
<p>gdtrib(1.2, p, 5.6)
3.3999999999723882</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gdtrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gdtrix(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gdtrix(a, b, p, out=None)</p>
<p>Inverse of <code>gdtr</code> vs x.</p>
<p>Returns the inverse with respect to the parameter <code>x</code> of <code>p =
gdtr(a, b, x)</code>, the cumulative distribution function of the gamma
distribution. This is also known as the p'th quantile of the
distribution.</p>
<h2 id="parameters_69">Parameters<a class="headerlink" href="#parameters_69" title="Permanent link">&para;</a></h2>
<p>a : array_like
<code>a</code> parameter values of <code>gdtr(a, b, x)</code>.  <code>1/a</code> is the 'scale'
parameter of the gamma distribution.
b : array_like
<code>b</code> parameter values of <code>gdtr(a, b, x)</code>.  <code>b</code> is the 'shape' parameter
of the gamma distribution.
p : array_like
Probability values.
out : ndarray, optional
If a fourth argument is given, it must be a numpy.ndarray whose size
matches the broadcast result of <code>a</code>, <code>b</code> and <code>x</code>.  <code>out</code> is then the
array returned by the function.</p>
<h2 id="returns_67">Returns<a class="headerlink" href="#returns_67" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Values of the <code>x</code> parameter such that <code>p = gdtr(a, b, x)</code>.</p>
<h2 id="see-also_61">See Also<a class="headerlink" href="#see-also_61" title="Permanent link">&para;</a></h2>
<p>gdtr : CDF of the gamma distribution.
gdtria : Inverse with respect to <code>a</code> of <code>gdtr(a, b, x)</code>.
gdtrib : Inverse with respect to <code>b</code> of <code>gdtr(a, b, x)</code>.</p>
<h2 id="notes_41">Notes<a class="headerlink" href="#notes_41" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfgam</code>.</p>
<p>The cumulative distribution function <code>p</code> is computed using a routine by
DiDinato and Morris [2]_.  Computation of <code>x</code> involves a search for a value
that produces the desired value of <code>p</code>.  The search relies on the
monotonicity of <code>p</code> with <code>x</code>.</p>
<h2 id="references_58">References<a class="headerlink" href="#references_58" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] DiDinato, A. R. and Morris, A. H.,
Computation of the incomplete gamma function ratios and their
inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.</p>
<h2 id="examples_36">Examples<a class="headerlink" href="#examples_36" title="Permanent link">&para;</a></h2>
<p>First evaluate <code>gdtr</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import gdtr, gdtrix
p = gdtr(1.2, 3.4, 5.6)
print(p)
0.94378087442</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify the inverse.</p>
<blockquote>
<blockquote>
<blockquote>
<p>gdtrix(1.2, 3.4, p)
5.5999999999999996</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hankel1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hankel1(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hankel1(v, z)</p>
<p>Hankel function of the first kind</p>
<h2 id="parameters_70">Parameters<a class="headerlink" href="#parameters_70" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_68">Returns<a class="headerlink" href="#returns_68" title="Permanent link">&para;</a></h2>
<p>out : Values of the Hankel function of the first kind.</p>
<h2 id="notes_42">Notes<a class="headerlink" href="#notes_42" title="Permanent link">&para;</a></h2>
<p>A wrapper for the AMOS [1]_ routine <code>zbesh</code>, which carries out the
computation using the relation,</p>
<p>.. math:: H^{(1)}_v(z) = \frac{2}{\imath\pi} \exp(-\imath \pi v/2) K_v(z \exp(-\imath\pi/2))</p>
<p>where :math:<code>K_v</code> is the modified Bessel function of the second kind.
For negative orders, the relation</p>
<p>.. math:: H^{(1)}_{-v}(z) = H^{(1)}_v(z) \exp(\imath\pi v)</p>
<p>is used.</p>
<h2 id="see-also_62">See also<a class="headerlink" href="#see-also_62" title="Permanent link">&para;</a></h2>
<p>hankel1e : this function with leading exponential behavior stripped off.</p>
<h2 id="references_59">References<a class="headerlink" href="#references_59" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hankel1e</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hankel1e(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hankel1e(v, z)</p>
<p>Exponentially scaled Hankel function of the first kind</p>
<p>Defined as::</p>
<p>hankel1e(v, z) = hankel1(v, z) * exp(-1j * z)</p>
<h2 id="parameters_71">Parameters<a class="headerlink" href="#parameters_71" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_69">Returns<a class="headerlink" href="#returns_69" title="Permanent link">&para;</a></h2>
<p>out : Values of the exponentially scaled Hankel function.</p>
<h2 id="notes_43">Notes<a class="headerlink" href="#notes_43" title="Permanent link">&para;</a></h2>
<p>A wrapper for the AMOS [1]_ routine <code>zbesh</code>, which carries out the
computation using the relation,</p>
<p>.. math:: H^{(1)}_v(z) = \frac{2}{\imath\pi} \exp(-\imath \pi v/2) K_v(z \exp(-\imath\pi/2))</p>
<p>where :math:<code>K_v</code> is the modified Bessel function of the second kind.
For negative orders, the relation</p>
<p>.. math:: H^{(1)}_{-v}(z) = H^{(1)}_v(z) \exp(\imath\pi v)</p>
<p>is used.</p>
<h2 id="references_60">References<a class="headerlink" href="#references_60" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hankel2</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hankel2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hankel2(v, z)</p>
<p>Hankel function of the second kind</p>
<h2 id="parameters_72">Parameters<a class="headerlink" href="#parameters_72" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_70">Returns<a class="headerlink" href="#returns_70" title="Permanent link">&para;</a></h2>
<p>out : Values of the Hankel function of the second kind.</p>
<h2 id="notes_44">Notes<a class="headerlink" href="#notes_44" title="Permanent link">&para;</a></h2>
<p>A wrapper for the AMOS [1]_ routine <code>zbesh</code>, which carries out the
computation using the relation,</p>
<p>.. math:: H^{(2)}_v(z) = -\frac{2}{\imath\pi} \exp(\imath \pi v/2) K_v(z \exp(\imath\pi/2))</p>
<p>where :math:<code>K_v</code> is the modified Bessel function of the second kind.
For negative orders, the relation</p>
<p>.. math:: H^{(2)}_{-v}(z) = H^{(2)}_v(z) \exp(-\imath\pi v)</p>
<p>is used.</p>
<h2 id="see-also_63">See also<a class="headerlink" href="#see-also_63" title="Permanent link">&para;</a></h2>
<p>hankel2e : this function with leading exponential behavior stripped off.</p>
<h2 id="references_61">References<a class="headerlink" href="#references_61" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hankel2e</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hankel2e(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hankel2e(v, z)</p>
<p>Exponentially scaled Hankel function of the second kind</p>
<p>Defined as::</p>
<p>hankel2e(v, z) = hankel2(v, z) * exp(1j * z)</p>
<h2 id="parameters_73">Parameters<a class="headerlink" href="#parameters_73" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_71">Returns<a class="headerlink" href="#returns_71" title="Permanent link">&para;</a></h2>
<p>out : Values of the exponentially scaled Hankel function of the second kind.</p>
<h2 id="notes_45">Notes<a class="headerlink" href="#notes_45" title="Permanent link">&para;</a></h2>
<p>A wrapper for the AMOS [1]_ routine <code>zbesh</code>, which carries out the
computation using the relation,</p>
<p>.. math:: H^{(2)}_v(z) = -\frac{2}{\imath\pi} \exp(\frac{\imath \pi v}{2}) K_v(z exp(\frac{\imath\pi}{2}))</p>
<p>where :math:<code>K_v</code> is the modified Bessel function of the second kind.
For negative orders, the relation</p>
<p>.. math:: H^{(2)}_{-v}(z) = H^{(2)}_v(z) \exp(-\imath\pi v)</p>
<p>is used.</p>
<h2 id="references_62">References<a class="headerlink" href="#references_62" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">huber</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>huber(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>huber(delta, r)</p>
<p>Huber loss function.</p>
<p>.. math:: \text{huber}(\delta, r) = \begin{cases} \infty &amp; \delta &lt; 0  \ \frac{1}{2}r^2 &amp; 0 \le \delta, | r | \le \delta \ \delta ( |r| - \frac{1}{2}\delta ) &amp; \text{otherwise} \end{cases}</p>
<h2 id="parameters_74">Parameters<a class="headerlink" href="#parameters_74" title="Permanent link">&para;</a></h2>
<p>delta : ndarray
Input array, indicating the quadratic vs. linear loss changepoint.
r : ndarray
Input array, possibly representing residuals.</p>
<h2 id="returns_72">Returns<a class="headerlink" href="#returns_72" title="Permanent link">&para;</a></h2>
<p>res : ndarray
The computed Huber loss function values.</p>
<h2 id="notes_46">Notes<a class="headerlink" href="#notes_46" title="Permanent link">&para;</a></h2>
<p>This function is convex in r.</p>
<p>.. versionadded:: 0.15.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hyp0f1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hyp0f1(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hyp0f1(v, z, out=None)</p>
<p>Confluent hypergeometric limit function 0F1.</p>
<h2 id="parameters_75">Parameters<a class="headerlink" href="#parameters_75" title="Permanent link">&para;</a></h2>
<p>v : array_like
Real valued parameter
z : array_like
Real or complex valued argument
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_73">Returns<a class="headerlink" href="#returns_73" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
The confluent hypergeometric limit function</p>
<h2 id="notes_47">Notes<a class="headerlink" href="#notes_47" title="Permanent link">&para;</a></h2>
<p>This function is defined as:</p>
<p>.. math:: <em>0F_1(v, z) = \sum</em>{k=0}^{\infty}\frac{z^k}{(v)_k k!}.</p>
<p>It's also the limit as :math:<code>q \to \infty</code> of :math:<code>_1F_1(q; v; z/q)</code>,
and satisfies the differential equation :math:<code>f''(z) + vf'(z) =
f(z)</code>. See [1]_ for more information.</p>
<h2 id="references_63">References<a class="headerlink" href="#references_63" title="Permanent link">&para;</a></h2>
<p>.. [1] Wolfram MathWorld, 'Confluent Hypergeometric Limit Function',
http://mathworld.wolfram.com/ConfluentHypergeometricLimitFunction.html</p>
<h2 id="examples_37">Examples<a class="headerlink" href="#examples_37" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is one when <code>z</code> is zero.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.hyp0f1(1, 0)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is the limit of the confluent hypergeometric function as <code>q</code>
goes to infinity.</p>
<blockquote>
<blockquote>
<blockquote>
<p>q = np.array([1, 10, 100, 1000])
v = 1
z = 1
sc.hyp1f1(q, v, z / q)
array([2.71828183, 2.31481985, 2.28303778, 2.27992985])
sc.hyp0f1(v, z)
2.2795853023360673</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is related to Bessel functions.</p>
<blockquote>
<blockquote>
<blockquote>
<p>n = 1
x = np.linspace(0, 1, 5)
sc.jv(n, x)
array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059])
(0.5 * x)<strong>n / sc.factorial(n) * sc.hyp0f1(n + 1, -0.25 * x</strong>2)
array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hyp1f1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hyp1f1(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hyp1f1(a, b, x, out=None)</p>
<p>Confluent hypergeometric function 1F1.</p>
<p>The confluent hypergeometric function is defined by the series</p>
<p>.. math::</p>
<p>{}<em>1F_1(a; b; x) = \sum</em>{k = 0}^\infty \frac{(a)_k}{(b)_k k!} x^k.</p>
<p>See [dlmf]_ for more details. Here :math:<code>(\cdot)_k</code> is the
Pochhammer symbol; see <code>poch</code>.</p>
<h2 id="parameters_76">Parameters<a class="headerlink" href="#parameters_76" title="Permanent link">&para;</a></h2>
<p>a, b : array_like
Real parameters
x : array_like
Real or complex argument
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_74">Returns<a class="headerlink" href="#returns_74" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the confluent hypergeometric function</p>
<h2 id="see-also_64">See also<a class="headerlink" href="#see-also_64" title="Permanent link">&para;</a></h2>
<p>hyperu : another confluent hypergeometric function
hyp0f1 : confluent hypergeometric limit function
hyp2f1 : Gaussian hypergeometric function</p>
<h2 id="references_64">References<a class="headerlink" href="#references_64" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/13.2#E2</p>
<h2 id="examples_38">Examples<a class="headerlink" href="#examples_38" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is one when <code>x</code> is zero:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.hyp1f1(0.5, 0.5, 0)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is singular when <code>b</code> is a nonpositive integer.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.hyp1f1(0.5, -1, 0)
inf</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is a polynomial when <code>a</code> is a nonpositive integer.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, b, x = -1, 0.5, np.array([1.0, 2.0, 3.0, 4.0])
sc.hyp1f1(a, b, x)
array([-1., -3., -5., -7.])
1 + (a / b) * x
array([-1., -3., -5., -7.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It reduces to the exponential function when <code>a = b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.hyp1f1(2, 2, [1, 2, 3, 4])
array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003])
np.exp([1, 2, 3, 4])
array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hyp2f1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hyp2f1(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hyp2f1(a, b, c, z)</p>
<p>Gauss hypergeometric function 2F1(a, b; c; z)</p>
<h2 id="parameters_77">Parameters<a class="headerlink" href="#parameters_77" title="Permanent link">&para;</a></h2>
<p>a, b, c : array_like
Arguments, should be real-valued.
z : array_like
Argument, real or complex.</p>
<h2 id="returns_75">Returns<a class="headerlink" href="#returns_75" title="Permanent link">&para;</a></h2>
<p>hyp2f1 : scalar or ndarray
The values of the gaussian hypergeometric function.</p>
<h2 id="see-also_65">See also<a class="headerlink" href="#see-also_65" title="Permanent link">&para;</a></h2>
<p>hyp0f1 : confluent hypergeometric limit function.
hyp1f1 : Kummer's (confluent hypergeometric) function.</p>
<h2 id="notes_48">Notes<a class="headerlink" href="#notes_48" title="Permanent link">&para;</a></h2>
<p>This function is defined for :math:<code>|z| &lt; 1</code> as</p>
<p>.. math::</p>
<p>\mathrm{hyp2f1}(a, b, c, z) = \sum_{n=0}^\infty
\frac{(a)_n (b)_n}{(c)_n}\frac{z^n}{n!},</p>
<p>and defined on the rest of the complex z-plane by analytic
continuation [1]_.
Here :math:<code>(\cdot)_n</code> is the Pochhammer symbol; see <code>poch</code>. When
:math:<code>n</code> is an integer the result is a polynomial of degree :math:<code>n</code>.</p>
<p>The implementation for complex values of <code>z</code> is described in [2]_.</p>
<h2 id="references_65">References<a class="headerlink" href="#references_65" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/15.2
.. [2] S. Zhang and J.M. Jin, 'Computation of Special Functions', Wiley 1996
.. [3] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<h2 id="examples_39">Examples<a class="headerlink" href="#examples_39" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has poles when <code>c</code> is a negative integer.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.hyp2f1(1, 1, -2, 1)
inf</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is a polynomial when <code>a</code> or <code>b</code> is a negative integer.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, b, c = -1, 1, 1.5
z = np.linspace(0, 1, 5)
sc.hyp2f1(a, b, c, z)
array([1.        , 0.83333333, 0.66666667, 0.5       , 0.33333333])
1 + a * b * z / c
array([1.        , 0.83333333, 0.66666667, 0.5       , 0.33333333])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is symmetric in <code>a</code> and <code>b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.linspace(0, 1, 5)
b = np.linspace(0, 1, 5)
sc.hyp2f1(a, b, 1, 0.5)
array([1.        , 1.03997334, 1.1803406 , 1.47074441, 2.        ])
sc.hyp2f1(b, a, 1, 0.5)
array([1.        , 1.03997334, 1.1803406 , 1.47074441, 2.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It contains many other functions as special cases.</p>
<blockquote>
<blockquote>
<blockquote>
<p>z = 0.5
sc.hyp2f1(1, 1, 2, z)
1.3862943611198901
-np.log(1 - z) / z
1.3862943611198906</p>
<p>sc.hyp2f1(0.5, 1, 1.5, z**2)
1.098612288668109
np.log((1 + z) / (1 - z)) / (2 * z)
1.0986122886681098</p>
<p>sc.hyp2f1(0.5, 1, 1.5, -z**2)
0.9272952180016117
np.arctan(z) / z
0.9272952180016123</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hyperu</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hyperu(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hyperu(a, b, x, out=None)</p>
<p>Confluent hypergeometric function U</p>
<p>It is defined as the solution to the equation</p>
<p>.. math::</p>
<p>x \frac{d^2w}{dx^2} + (b - x) \frac{dw}{dx} - aw = 0</p>
<p>which satisfies the property</p>
<p>.. math::</p>
<p>U(a, b, x) \sim x^{-a}</p>
<p>as :math:<code>x \to \infty</code>. See [dlmf]_ for more details.</p>
<h2 id="parameters_78">Parameters<a class="headerlink" href="#parameters_78" title="Permanent link">&para;</a></h2>
<p>a, b : array_like
Real valued parameters
x : array_like
Real valued argument
out : ndarray
Optional output array for the function values</p>
<h2 id="returns_76">Returns<a class="headerlink" href="#returns_76" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of <code>U</code></p>
<h2 id="references_66">References<a class="headerlink" href="#references_66" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematics Functions
https://dlmf.nist.gov/13.2#E6</p>
<h2 id="examples_40">Examples<a class="headerlink" href="#examples_40" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has a branch cut along the negative <code>x</code> axis.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-0.1, -10, 5)
sc.hyperu(1, 1, x)
array([nan, nan, nan, nan, nan])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It approaches zero as <code>x</code> goes to infinity.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 10, 100])
sc.hyperu(1, 1, x)
array([0.59634736, 0.09156333, 0.00990194])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It satisfies Kummer's transformation.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, b, x = 2, 1, 1
sc.hyperu(a, b, x)
0.1926947246463881
x**(1 - b) * sc.hyperu(a - b + 1, 2 - b, x)
0.1926947246463881</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">i0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>i0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>i0(x)</p>
<p>Modified Bessel function of order 0.</p>
<p>Defined as,</p>
<p>.. math::
I_0(x) = \sum_{k=0}^\infty \frac{(x^2/4)^k}{(k!)^2} = J_0(\imath x),</p>
<p>where :math:<code>J_0</code> is the Bessel function of the first kind of order 0.</p>
<h2 id="parameters_79">Parameters<a class="headerlink" href="#parameters_79" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_77">Returns<a class="headerlink" href="#returns_77" title="Permanent link">&para;</a></h2>
<p>I : ndarray
Value of the modified Bessel function of order 0 at <code>x</code>.</p>
<h2 id="notes_49">Notes<a class="headerlink" href="#notes_49" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 8] and (8, infinity).
Chebyshev polynomial expansions are employed in each interval.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>i0</code>.</p>
<h2 id="see-also_66">See also<a class="headerlink" href="#see-also_66" title="Permanent link">&para;</a></h2>
<p>iv
i0e</p>
<h2 id="references_67">References<a class="headerlink" href="#references_67" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">i0e</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>i0e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>i0e(x)</p>
<p>Exponentially scaled modified Bessel function of order 0.</p>
<p>Defined as::</p>
<p>i0e(x) = exp(-abs(x)) * i0(x).</p>
<h2 id="parameters_80">Parameters<a class="headerlink" href="#parameters_80" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_78">Returns<a class="headerlink" href="#returns_78" title="Permanent link">&para;</a></h2>
<p>I : ndarray
Value of the exponentially scaled modified Bessel function of order 0
at <code>x</code>.</p>
<h2 id="notes_50">Notes<a class="headerlink" href="#notes_50" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 8] and (8, infinity).
Chebyshev polynomial expansions are employed in each interval.  The
polynomial expansions used are the same as those in <code>i0</code>, but
they are not multiplied by the dominant exponential factor.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>i0e</code>.</p>
<h2 id="see-also_67">See also<a class="headerlink" href="#see-also_67" title="Permanent link">&para;</a></h2>
<p>iv
i0</p>
<h2 id="references_68">References<a class="headerlink" href="#references_68" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">i1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>i1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>i1(x)</p>
<p>Modified Bessel function of order 1.</p>
<p>Defined as,</p>
<p>.. math::
I_1(x) = \frac{1}{2}x \sum_{k=0}^\infty \frac{(x^2/4)^k}{k! (k + 1)!}
= -\imath J_1(\imath x),</p>
<p>where :math:<code>J_1</code> is the Bessel function of the first kind of order 1.</p>
<h2 id="parameters_81">Parameters<a class="headerlink" href="#parameters_81" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_79">Returns<a class="headerlink" href="#returns_79" title="Permanent link">&para;</a></h2>
<p>I : ndarray
Value of the modified Bessel function of order 1 at <code>x</code>.</p>
<h2 id="notes_51">Notes<a class="headerlink" href="#notes_51" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 8] and (8, infinity).
Chebyshev polynomial expansions are employed in each interval.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>i1</code>.</p>
<h2 id="see-also_68">See also<a class="headerlink" href="#see-also_68" title="Permanent link">&para;</a></h2>
<p>iv
i1e</p>
<h2 id="references_69">References<a class="headerlink" href="#references_69" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">i1e</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>i1e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>i1e(x)</p>
<p>Exponentially scaled modified Bessel function of order 1.</p>
<p>Defined as::</p>
<p>i1e(x) = exp(-abs(x)) * i1(x)</p>
<h2 id="parameters_82">Parameters<a class="headerlink" href="#parameters_82" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_80">Returns<a class="headerlink" href="#returns_80" title="Permanent link">&para;</a></h2>
<p>I : ndarray
Value of the exponentially scaled modified Bessel function of order 1
at <code>x</code>.</p>
<h2 id="notes_52">Notes<a class="headerlink" href="#notes_52" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 8] and (8, infinity).
Chebyshev polynomial expansions are employed in each interval. The
polynomial expansions used are the same as those in <code>i1</code>, but
they are not multiplied by the dominant exponential factor.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>i1e</code>.</p>
<h2 id="see-also_69">See also<a class="headerlink" href="#see-also_69" title="Permanent link">&para;</a></h2>
<p>iv
i1</p>
<h2 id="references_70">References<a class="headerlink" href="#references_70" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv_boxcox</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>inv_boxcox(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>inv_boxcox(y, lmbda)</p>
<p>Compute the inverse of the Box-Cox transformation.</p>
<p>Find <code>x</code> such that::</p>
<p>y = (x**lmbda - 1) / lmbda  if lmbda != 0
log(x)                  if lmbda == 0</p>
<h2 id="parameters_83">Parameters<a class="headerlink" href="#parameters_83" title="Permanent link">&para;</a></h2>
<p>y : array_like
Data to be transformed.
lmbda : array_like
Power parameter of the Box-Cox transform.</p>
<h2 id="returns_81">Returns<a class="headerlink" href="#returns_81" title="Permanent link">&para;</a></h2>
<p>x : array
Transformed data.</p>
<h2 id="notes_53">Notes<a class="headerlink" href="#notes_53" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.16.0</p>
<h2 id="examples_41">Examples<a class="headerlink" href="#examples_41" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import boxcox, inv_boxcox
y = boxcox([1, 4, 10], 2.5)
inv_boxcox(y, 2.5)
array([1., 4., 10.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv_boxcox1p</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>inv_boxcox1p(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>inv_boxcox1p(y, lmbda)</p>
<p>Compute the inverse of the Box-Cox transformation.</p>
<p>Find <code>x</code> such that::</p>
<p>y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0
log(1+x)                    if lmbda == 0</p>
<h2 id="parameters_84">Parameters<a class="headerlink" href="#parameters_84" title="Permanent link">&para;</a></h2>
<p>y : array_like
Data to be transformed.
lmbda : array_like
Power parameter of the Box-Cox transform.</p>
<h2 id="returns_82">Returns<a class="headerlink" href="#returns_82" title="Permanent link">&para;</a></h2>
<p>x : array
Transformed data.</p>
<h2 id="notes_54">Notes<a class="headerlink" href="#notes_54" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.16.0</p>
<h2 id="examples_42">Examples<a class="headerlink" href="#examples_42" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import boxcox1p, inv_boxcox1p
y = boxcox1p([1, 4, 10], 2.5)
inv_boxcox1p(y, 2.5)
array([1., 4., 10.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">it2i0k0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>it2i0k0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>it2i0k0(x)</p>
<p>Integrals related to modified Bessel functions of order 0</p>
<h2 id="returns_83">Returns<a class="headerlink" href="#returns_83" title="Permanent link">&para;</a></h2>
<p>ii0
<code>integral((i0(t)-1)/t, t=0..x)</code>
ik0
<code>integral(k0(t)/t, t=x..inf)</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">it2j0y0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>it2j0y0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>it2j0y0(x)</p>
<p>Integrals related to Bessel functions of order 0</p>
<h2 id="returns_84">Returns<a class="headerlink" href="#returns_84" title="Permanent link">&para;</a></h2>
<p>ij0
<code>integral((1-j0(t))/t, t=0..x)</code>
iy0
<code>integral(y0(t)/t, t=x..inf)</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">it2struve0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>it2struve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>it2struve0(x)</p>
<p>Integral related to the Struve function of order 0.</p>
<p>Returns the integral,</p>
<p>.. math::
\int_x^\infty \frac{H_0(t)}{t}\,dt</p>
<p>where :math:<code>H_0</code> is the Struve function of order 0.</p>
<h2 id="parameters_85">Parameters<a class="headerlink" href="#parameters_85" title="Permanent link">&para;</a></h2>
<p>x : array_like
Lower limit of integration.</p>
<h2 id="returns_85">Returns<a class="headerlink" href="#returns_85" title="Permanent link">&para;</a></h2>
<p>I : ndarray
The value of the integral.</p>
<h2 id="see-also_70">See also<a class="headerlink" href="#see-also_70" title="Permanent link">&para;</a></h2>
<p>struve</p>
<h2 id="notes_55">Notes<a class="headerlink" href="#notes_55" title="Permanent link">&para;</a></h2>
<p>Wrapper for a Fortran routine created by Shanjie Zhang and Jianming
Jin [1]_.</p>
<h2 id="references_71">References<a class="headerlink" href="#references_71" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itairy</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>itairy(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>itairy(x)</p>
<p>Integrals of Airy functions</p>
<p>Calculates the integrals of Airy functions from 0 to <code>x</code>.</p>
<h2 id="parameters_86">Parameters<a class="headerlink" href="#parameters_86" title="Permanent link">&para;</a></h2>
<p>x: array_like
Upper limit of integration (float).</p>
<h2 id="returns_86">Returns<a class="headerlink" href="#returns_86" title="Permanent link">&para;</a></h2>
<p>Apt
Integral of Ai(t) from 0 to x.
Bpt
Integral of Bi(t) from 0 to x.
Ant
Integral of Ai(-t) from 0 to x.
Bnt
Integral of Bi(-t) from 0 to x.</p>
<h2 id="notes_56">Notes<a class="headerlink" href="#notes_56" title="Permanent link">&para;</a></h2>
<p>Wrapper for a Fortran routine created by Shanjie Zhang and Jianming
Jin [1]_.</p>
<h2 id="references_72">References<a class="headerlink" href="#references_72" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iti0k0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>iti0k0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>iti0k0(x)</p>
<p>Integrals of modified Bessel functions of order 0</p>
<p>Returns simple integrals from 0 to <code>x</code> of the zeroth order modified
Bessel functions <code>i0</code> and <code>k0</code>.</p>
<h2 id="returns_87">Returns<a class="headerlink" href="#returns_87" title="Permanent link">&para;</a></h2>
<p>ii0, ik0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itj0y0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>itj0y0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>itj0y0(x)</p>
<p>Integrals of Bessel functions of order 0</p>
<p>Returns simple integrals from 0 to <code>x</code> of the zeroth order Bessel
functions <code>j0</code> and <code>y0</code>.</p>
<h2 id="returns_88">Returns<a class="headerlink" href="#returns_88" title="Permanent link">&para;</a></h2>
<p>ij0, iy0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itmodstruve0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>itmodstruve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>itmodstruve0(x)</p>
<p>Integral of the modified Struve function of order 0.</p>
<p>.. math::
I = \int_0^x L_0(t)\,dt</p>
<h2 id="parameters_87">Parameters<a class="headerlink" href="#parameters_87" title="Permanent link">&para;</a></h2>
<p>x : array_like
Upper limit of integration (float).</p>
<h2 id="returns_89">Returns<a class="headerlink" href="#returns_89" title="Permanent link">&para;</a></h2>
<p>I : ndarray
The integral of :math:<code>L_0</code> from 0 to <code>x</code>.</p>
<h2 id="notes_57">Notes<a class="headerlink" href="#notes_57" title="Permanent link">&para;</a></h2>
<p>Wrapper for a Fortran routine created by Shanjie Zhang and Jianming
Jin [1]_.</p>
<h2 id="references_73">References<a class="headerlink" href="#references_73" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itstruve0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>itstruve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>itstruve0(x)</p>
<p>Integral of the Struve function of order 0.</p>
<p>.. math::
I = \int_0^x H_0(t)\,dt</p>
<h2 id="parameters_88">Parameters<a class="headerlink" href="#parameters_88" title="Permanent link">&para;</a></h2>
<p>x : array_like
Upper limit of integration (float).</p>
<h2 id="returns_90">Returns<a class="headerlink" href="#returns_90" title="Permanent link">&para;</a></h2>
<p>I : ndarray
The integral of :math:<code>H_0</code> from 0 to <code>x</code>.</p>
<h2 id="see-also_71">See also<a class="headerlink" href="#see-also_71" title="Permanent link">&para;</a></h2>
<p>struve</p>
<h2 id="notes_58">Notes<a class="headerlink" href="#notes_58" title="Permanent link">&para;</a></h2>
<p>Wrapper for a Fortran routine created by Shanjie Zhang and Jianming
Jin [1]_.</p>
<h2 id="references_74">References<a class="headerlink" href="#references_74" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>iv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>iv(v, z)</p>
<p>Modified Bessel function of the first kind of real order.</p>
<h2 id="parameters_89">Parameters<a class="headerlink" href="#parameters_89" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order. If <code>z</code> is of real type and negative, <code>v</code> must be integer
valued.
z : array_like of float or complex
Argument.</p>
<h2 id="returns_91">Returns<a class="headerlink" href="#returns_91" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Values of the modified Bessel function.</p>
<h2 id="notes_59">Notes<a class="headerlink" href="#notes_59" title="Permanent link">&para;</a></h2>
<p>For real <code>z</code> and :math:<code>v \in [-50, 50]</code>, the evaluation is carried out
using Temme's method [1]_.  For larger orders, uniform asymptotic
expansions are applied.</p>
<p>For complex <code>z</code> and positive <code>v</code>, the AMOS [2]_ <code>zbesi</code> routine is
called. It uses a power series for small <code>z</code>, the asymptotic expansion
for large <code>abs(z)</code>, the Miller algorithm normalized by the Wronskian
and a Neumann series for intermediate magnitudes, and the uniform
asymptotic expansions for :math:<code>I_v(z)</code> and :math:<code>J_v(z)</code> for large
orders.  Backward recurrence is used to generate sequences or reduce
orders when necessary.</p>
<p>The calculations above are done in the right half plane and continued
into the left half plane by the formula,</p>
<p>.. math:: I_v(z \exp(\pm\imath\pi)) = \exp(\pm\pi v) I_v(z)</p>
<p>(valid when the real part of <code>z</code> is positive).  For negative <code>v</code>, the
formula</p>
<p>.. math:: I_{-v}(z) = I_v(z) + \frac{2}{\pi} \sin(\pi v) K_v(z)</p>
<p>is used, where :math:<code>K_v(z)</code> is the modified Bessel function of the
second kind, evaluated using the AMOS routine <code>zbesk</code>.</p>
<h2 id="see-also_72">See also<a class="headerlink" href="#see-also_72" title="Permanent link">&para;</a></h2>
<p>kve : This function with leading exponential behavior stripped off.</p>
<h2 id="references_75">References<a class="headerlink" href="#references_75" title="Permanent link">&para;</a></h2>
<p>.. [1] Temme, Journal of Computational Physics, vol 21, 343 (1976)
.. [2] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ive</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ive(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ive(v, z)</p>
<p>Exponentially scaled modified Bessel function of the first kind</p>
<p>Defined as::</p>
<p>ive(v, z) = iv(v, z) * exp(-abs(z.real))</p>
<h2 id="parameters_90">Parameters<a class="headerlink" href="#parameters_90" title="Permanent link">&para;</a></h2>
<p>v : array_like of float
Order.
z : array_like of float or complex
Argument.</p>
<h2 id="returns_92">Returns<a class="headerlink" href="#returns_92" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Values of the exponentially scaled modified Bessel function.</p>
<h2 id="notes_60">Notes<a class="headerlink" href="#notes_60" title="Permanent link">&para;</a></h2>
<p>For positive <code>v</code>, the AMOS [1]_ <code>zbesi</code> routine is called. It uses a
power series for small <code>z</code>, the asymptotic expansion for large
<code>abs(z)</code>, the Miller algorithm normalized by the Wronskian and a
Neumann series for intermediate magnitudes, and the uniform asymptotic
expansions for :math:<code>I_v(z)</code> and :math:<code>J_v(z)</code> for large orders.
Backward recurrence is used to generate sequences or reduce orders when
necessary.</p>
<p>The calculations above are done in the right half plane and continued
into the left half plane by the formula,</p>
<p>.. math:: I_v(z \exp(\pm\imath\pi)) = \exp(\pm\pi v) I_v(z)</p>
<p>(valid when the real part of <code>z</code> is positive).  For negative <code>v</code>, the
formula</p>
<p>.. math:: I_{-v}(z) = I_v(z) + \frac{2}{\pi} \sin(\pi v) K_v(z)</p>
<p>is used, where :math:<code>K_v(z)</code> is the modified Bessel function of the
second kind, evaluated using the AMOS routine <code>zbesk</code>.</p>
<h2 id="references_76">References<a class="headerlink" href="#references_76" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">j0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>j0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>j0(x)</p>
<p>Bessel function of the first kind of order 0.</p>
<h2 id="parameters_91">Parameters<a class="headerlink" href="#parameters_91" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float).</p>
<h2 id="returns_93">Returns<a class="headerlink" href="#returns_93" title="Permanent link">&para;</a></h2>
<p>J : ndarray
Value of the Bessel function of the first kind of order 0 at <code>x</code>.</p>
<h2 id="notes_61">Notes<a class="headerlink" href="#notes_61" title="Permanent link">&para;</a></h2>
<p>The domain is divided into the intervals [0, 5] and (5, infinity). In the
first interval the following rational approximation is used:</p>
<p>.. math::</p>
<p>J_0(x) \approx (w - r_1^2)(w - r_2^2) \frac{P_3(w)}{Q_8(w)},</p>
<p>where :math:<code>w = x^2</code> and :math:<code>r_1</code>, :math:<code>r_2</code> are the zeros of
:math:<code>J_0</code>, and :math:<code>P_3</code> and :math:<code>Q_8</code> are polynomials of degrees 3
and 8, respectively.</p>
<p>In the second interval, the Hankel asymptotic expansion is employed with
two rational functions of degree 6/6 and 7/7.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>j0</code>.
It should not be confused with the spherical Bessel functions (see
<code>spherical_jn</code>).</p>
<h2 id="see-also_73">See also<a class="headerlink" href="#see-also_73" title="Permanent link">&para;</a></h2>
<p>jv : Bessel function of real order and complex argument.
spherical_jn : spherical Bessel functions.</p>
<h2 id="references_77">References<a class="headerlink" href="#references_77" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">j1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>j1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>j1(x)</p>
<p>Bessel function of the first kind of order 1.</p>
<h2 id="parameters_92">Parameters<a class="headerlink" href="#parameters_92" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float).</p>
<h2 id="returns_94">Returns<a class="headerlink" href="#returns_94" title="Permanent link">&para;</a></h2>
<p>J : ndarray
Value of the Bessel function of the first kind of order 1 at <code>x</code>.</p>
<h2 id="notes_62">Notes<a class="headerlink" href="#notes_62" title="Permanent link">&para;</a></h2>
<p>The domain is divided into the intervals [0, 8] and (8, infinity). In the
first interval a 24 term Chebyshev expansion is used. In the second, the
asymptotic trigonometric representation is employed using two rational
functions of degree 5/5.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>j1</code>.
It should not be confused with the spherical Bessel functions (see
<code>spherical_jn</code>).</p>
<h2 id="see-also_74">See also<a class="headerlink" href="#see-also_74" title="Permanent link">&para;</a></h2>
<p>jv
spherical_jn : spherical Bessel functions.</p>
<h2 id="references_78">References<a class="headerlink" href="#references_78" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>jv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>jv(v, z)</p>
<p>Bessel function of the first kind of real order and complex argument.</p>
<h2 id="parameters_93">Parameters<a class="headerlink" href="#parameters_93" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_95">Returns<a class="headerlink" href="#returns_95" title="Permanent link">&para;</a></h2>
<p>J : ndarray
Value of the Bessel function, :math:<code>J_v(z)</code>.</p>
<h2 id="notes_63">Notes<a class="headerlink" href="#notes_63" title="Permanent link">&para;</a></h2>
<p>For positive <code>v</code> values, the computation is carried out using the AMOS
[1]_ <code>zbesj</code> routine, which exploits the connection to the modified
Bessel function :math:<code>I_v</code>,</p>
<p>.. math::
J_v(z) = \exp(v\pi\imath/2) I_v(-\imath z)\qquad (\Im z &gt; 0)</p>
<p>J_v(z) = \exp(-v\pi\imath/2) I_v(\imath z)\qquad (\Im z &lt; 0)</p>
<p>For negative <code>v</code> values the formula,</p>
<p>.. math:: J_{-v}(z) = J_v(z) \cos(\pi v) - Y_v(z) \sin(\pi v)</p>
<p>is used, where :math:<code>Y_v(z)</code> is the Bessel function of the second
kind, computed using the AMOS routine <code>zbesy</code>.  Note that the second
term is exactly zero for integer <code>v</code>; to improve accuracy the second
term is explicitly omitted for <code>v</code> values such that <code>v = floor(v)</code>.</p>
<p>Not to be confused with the spherical Bessel functions (see <code>spherical_jn</code>).</p>
<h2 id="see-also_75">See also<a class="headerlink" href="#see-also_75" title="Permanent link">&para;</a></h2>
<p>jve : :math:<code>J_v</code> with leading exponential behavior stripped off.
spherical_jn : spherical Bessel functions.</p>
<h2 id="references_79">References<a class="headerlink" href="#references_79" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>jv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>jv(v, z)</p>
<p>Bessel function of the first kind of real order and complex argument.</p>
<h2 id="parameters_94">Parameters<a class="headerlink" href="#parameters_94" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_96">Returns<a class="headerlink" href="#returns_96" title="Permanent link">&para;</a></h2>
<p>J : ndarray
Value of the Bessel function, :math:<code>J_v(z)</code>.</p>
<h2 id="notes_64">Notes<a class="headerlink" href="#notes_64" title="Permanent link">&para;</a></h2>
<p>For positive <code>v</code> values, the computation is carried out using the AMOS
[1]_ <code>zbesj</code> routine, which exploits the connection to the modified
Bessel function :math:<code>I_v</code>,</p>
<p>.. math::
J_v(z) = \exp(v\pi\imath/2) I_v(-\imath z)\qquad (\Im z &gt; 0)</p>
<p>J_v(z) = \exp(-v\pi\imath/2) I_v(\imath z)\qquad (\Im z &lt; 0)</p>
<p>For negative <code>v</code> values the formula,</p>
<p>.. math:: J_{-v}(z) = J_v(z) \cos(\pi v) - Y_v(z) \sin(\pi v)</p>
<p>is used, where :math:<code>Y_v(z)</code> is the Bessel function of the second
kind, computed using the AMOS routine <code>zbesy</code>.  Note that the second
term is exactly zero for integer <code>v</code>; to improve accuracy the second
term is explicitly omitted for <code>v</code> values such that <code>v = floor(v)</code>.</p>
<p>Not to be confused with the spherical Bessel functions (see <code>spherical_jn</code>).</p>
<h2 id="see-also_76">See also<a class="headerlink" href="#see-also_76" title="Permanent link">&para;</a></h2>
<p>jve : :math:<code>J_v</code> with leading exponential behavior stripped off.
spherical_jn : spherical Bessel functions.</p>
<h2 id="references_80">References<a class="headerlink" href="#references_80" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jve</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>jve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>jve(v, z)</p>
<p>Exponentially scaled Bessel function of order <code>v</code>.</p>
<p>Defined as::</p>
<p>jve(v, z) = jv(v, z) * exp(-abs(z.imag))</p>
<h2 id="parameters_95">Parameters<a class="headerlink" href="#parameters_95" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_97">Returns<a class="headerlink" href="#returns_97" title="Permanent link">&para;</a></h2>
<p>J : ndarray
Value of the exponentially scaled Bessel function.</p>
<h2 id="notes_65">Notes<a class="headerlink" href="#notes_65" title="Permanent link">&para;</a></h2>
<p>For positive <code>v</code> values, the computation is carried out using the AMOS
[1]_ <code>zbesj</code> routine, which exploits the connection to the modified
Bessel function :math:<code>I_v</code>,</p>
<p>.. math::
J_v(z) = \exp(v\pi\imath/2) I_v(-\imath z)\qquad (\Im z &gt; 0)</p>
<p>J_v(z) = \exp(-v\pi\imath/2) I_v(\imath z)\qquad (\Im z &lt; 0)</p>
<p>For negative <code>v</code> values the formula,</p>
<p>.. math:: J_{-v}(z) = J_v(z) \cos(\pi v) - Y_v(z) \sin(\pi v)</p>
<p>is used, where :math:<code>Y_v(z)</code> is the Bessel function of the second
kind, computed using the AMOS routine <code>zbesy</code>.  Note that the second
term is exactly zero for integer <code>v</code>; to improve accuracy the second
term is explicitly omitted for <code>v</code> values such that <code>v = floor(v)</code>.</p>
<h2 id="references_81">References<a class="headerlink" href="#references_81" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">k0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>k0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>k0(x)</p>
<p>Modified Bessel function of the second kind of order 0, :math:<code>K_0</code>.</p>
<p>This function is also sometimes referred to as the modified Bessel
function of the third kind of order 0.</p>
<h2 id="parameters_96">Parameters<a class="headerlink" href="#parameters_96" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float).</p>
<h2 id="returns_98">Returns<a class="headerlink" href="#returns_98" title="Permanent link">&para;</a></h2>
<p>K : ndarray
Value of the modified Bessel function :math:<code>K_0</code> at <code>x</code>.</p>
<h2 id="notes_66">Notes<a class="headerlink" href="#notes_66" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 2] and (2, infinity).
Chebyshev polynomial expansions are employed in each interval.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>k0</code>.</p>
<h2 id="see-also_77">See also<a class="headerlink" href="#see-also_77" title="Permanent link">&para;</a></h2>
<p>kv
k0e</p>
<h2 id="references_82">References<a class="headerlink" href="#references_82" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">k0e</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>k0e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>k0e(x)</p>
<p>Exponentially scaled modified Bessel function K of order 0</p>
<p>Defined as::</p>
<p>k0e(x) = exp(x) * k0(x).</p>
<h2 id="parameters_97">Parameters<a class="headerlink" href="#parameters_97" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_99">Returns<a class="headerlink" href="#returns_99" title="Permanent link">&para;</a></h2>
<p>K : ndarray
Value of the exponentially scaled modified Bessel function K of order
0 at <code>x</code>.</p>
<h2 id="notes_67">Notes<a class="headerlink" href="#notes_67" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 2] and (2, infinity).
Chebyshev polynomial expansions are employed in each interval.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>k0e</code>.</p>
<h2 id="see-also_78">See also<a class="headerlink" href="#see-also_78" title="Permanent link">&para;</a></h2>
<p>kv
k0</p>
<h2 id="references_83">References<a class="headerlink" href="#references_83" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">k1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>k1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>k1(x)</p>
<p>Modified Bessel function of the second kind of order 1, :math:<code>K_1(x)</code>.</p>
<h2 id="parameters_98">Parameters<a class="headerlink" href="#parameters_98" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_100">Returns<a class="headerlink" href="#returns_100" title="Permanent link">&para;</a></h2>
<p>K : ndarray
Value of the modified Bessel function K of order 1 at <code>x</code>.</p>
<h2 id="notes_68">Notes<a class="headerlink" href="#notes_68" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 2] and (2, infinity).
Chebyshev polynomial expansions are employed in each interval.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>k1</code>.</p>
<h2 id="see-also_79">See also<a class="headerlink" href="#see-also_79" title="Permanent link">&para;</a></h2>
<p>kv
k1e</p>
<h2 id="references_84">References<a class="headerlink" href="#references_84" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">k1e</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>k1e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>k1e(x)</p>
<p>Exponentially scaled modified Bessel function K of order 1</p>
<p>Defined as::</p>
<p>k1e(x) = exp(x) * k1(x)</p>
<h2 id="parameters_99">Parameters<a class="headerlink" href="#parameters_99" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_101">Returns<a class="headerlink" href="#returns_101" title="Permanent link">&para;</a></h2>
<p>K : ndarray
Value of the exponentially scaled modified Bessel function K of order
1 at <code>x</code>.</p>
<h2 id="notes_69">Notes<a class="headerlink" href="#notes_69" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 2] and (2, infinity).
Chebyshev polynomial expansions are employed in each interval.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>k1e</code>.</p>
<h2 id="see-also_80">See also<a class="headerlink" href="#see-also_80" title="Permanent link">&para;</a></h2>
<p>kv
k1</p>
<h2 id="references_85">References<a class="headerlink" href="#references_85" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kei</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kei(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kei(x)</p>
<p>Kelvin function ker</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">keip</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>keip(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>keip(x)</p>
<p>Derivative of the Kelvin function kei</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kelvin</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kelvin(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kelvin(x)</p>
<p>Kelvin functions as complex numbers</p>
<h2 id="returns_102">Returns<a class="headerlink" href="#returns_102" title="Permanent link">&para;</a></h2>
<p>Be, Ke, Bep, Kep
The tuple (Be, Ke, Bep, Kep) contains complex numbers
representing the real and imaginary Kelvin functions and their
derivatives evaluated at <code>x</code>.  For example, kelvin(x)[0].real =
ber x and kelvin(x)[0].imag = bei x with similar relationships
for ker and kei.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ker</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ker(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ker(x)</p>
<p>Kelvin function ker</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kerp</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kerp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kerp(x)</p>
<p>Derivative of the Kelvin function ker</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kl_div</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kl_div(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kl_div(x, y, out=None)</p>
<p>Elementwise function for computing Kullback-Leibler divergence.</p>
<p>.. math::</p>
<p>\mathrm{kl_div}(x, y) =
\begin{cases}
x \log(x / y) - x + y &amp; x &gt; 0, y &gt; 0 \
y &amp; x = 0, y \ge 0 \
\infty &amp; \text{otherwise}
\end{cases}</p>
<h2 id="parameters_100">Parameters<a class="headerlink" href="#parameters_100" title="Permanent link">&para;</a></h2>
<p>x, y : array_like
Real arguments
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_103">Returns<a class="headerlink" href="#returns_103" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the Kullback-Liebler divergence.</p>
<h2 id="see-also_81">See Also<a class="headerlink" href="#see-also_81" title="Permanent link">&para;</a></h2>
<p>entr, rel_entr</p>
<h2 id="notes_70">Notes<a class="headerlink" href="#notes_70" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.15.0</p>
<p>This function is non-negative and is jointly convex in <code>x</code> and <code>y</code>.</p>
<p>The origin of this function is in convex programming; see [1]_ for
details. This is why the the function contains the extra :math:<code>-x
+ y</code> terms over what might be expected from the Kullback-Leibler
divergence. For a version of the function without the extra terms,
see <code>rel_entr</code>.</p>
<h2 id="references_86">References<a class="headerlink" href="#references_86" title="Permanent link">&para;</a></h2>
<p>.. [1] Grant, Boyd, and Ye, 'CVX: Matlab Software for Disciplined Convex
Programming', http://cvxr.com/cvx/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kn(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kn(n, x)</p>
<p>Modified Bessel function of the second kind of integer order <code>n</code></p>
<p>Returns the modified Bessel function of the second kind for integer order
<code>n</code> at real <code>z</code>.</p>
<p>These are also sometimes called functions of the third kind, Basset
functions, or Macdonald functions.</p>
<h2 id="parameters_101">Parameters<a class="headerlink" href="#parameters_101" title="Permanent link">&para;</a></h2>
<p>n : array_like of int
Order of Bessel functions (floats will truncate with a warning)
z : array_like of float
Argument at which to evaluate the Bessel functions</p>
<h2 id="returns_104">Returns<a class="headerlink" href="#returns_104" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The results</p>
<h2 id="notes_71">Notes<a class="headerlink" href="#notes_71" title="Permanent link">&para;</a></h2>
<p>Wrapper for AMOS [1]<em> routine <code>zbesk</code>.  For a discussion of the
algorithm used, see [2]</em> and the references therein.</p>
<h2 id="see-also_82">See Also<a class="headerlink" href="#see-also_82" title="Permanent link">&para;</a></h2>
<p>kv : Same function, but accepts real order and complex argument
kvp : Derivative of this function</p>
<h2 id="references_87">References<a class="headerlink" href="#references_87" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/
.. [2] Donald E. Amos, 'Algorithm 644: A portable package for Bessel
functions of a complex argument and nonnegative order', ACM
TOMS Vol. 12 Issue 3, Sept. 1986, p. 265</p>
<h2 id="examples_43">Examples<a class="headerlink" href="#examples_43" title="Permanent link">&para;</a></h2>
<p>Plot the function of several orders for real input:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import kn
import matplotlib.pyplot as plt
x = np.linspace(0, 5, 1000)
for N in range(6):
...     plt.plot(x, kn(N, x), label='<span><span class="MathJax_Preview">K_{}(x)</span><script type="math/tex">K_{}(x)</script></span>'.format(N))
plt.ylim(0, 10)
plt.legend()
plt.title(r'Modified Bessel function of the second kind <span><span class="MathJax_Preview">K_n(x)</span><script type="math/tex">K_n(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Calculate for a single value at multiple orders:</p>
<blockquote>
<blockquote>
<blockquote>
<p>kn([4, 5, 6], 1)
array([   44.23241585,   360.9605896 ,  3653.83831186])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kolmogi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kolmogi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kolmogi(p)</p>
<p>Inverse Survival Function of Kolmogorov distribution</p>
<p>It is the inverse function to <code>kolmogorov</code>.
Returns y such that <code>kolmogorov(y) == p</code>.</p>
<h2 id="parameters_102">Parameters<a class="headerlink" href="#parameters_102" title="Permanent link">&para;</a></h2>
<p>p : float array_like
Probability</p>
<h2 id="returns_105">Returns<a class="headerlink" href="#returns_105" title="Permanent link">&para;</a></h2>
<p>float
The value(s) of kolmogi(p)</p>
<h2 id="notes_72">Notes<a class="headerlink" href="#notes_72" title="Permanent link">&para;</a></h2>
<p><code>kolmogorov</code> is used by <code>stats.kstest</code> in the application of the
Kolmogorov-Smirnov Goodness of Fit test. For historial reasons this
function is exposed in <code>scpy.special</code>, but the recommended way to achieve
the most accurate CDF/SF/PDF/PPF/ISF computations is to use the
<code>stats.kstwobign</code> distribution.</p>
<h2 id="see-also_83">See Also<a class="headerlink" href="#see-also_83" title="Permanent link">&para;</a></h2>
<p>kolmogorov : The Survival Function for the distribution
scipy.stats.kstwobign : Provides the functionality as a continuous distribution
smirnov, smirnovi : Functions for the one-sided distribution</p>
<h2 id="examples_44">Examples<a class="headerlink" href="#examples_44" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import kolmogi
kolmogi([0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0])
array([        inf,  1.22384787,  1.01918472,  0.82757356,  0.67644769,
0.57117327,  0.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kolmogorov</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kolmogorov(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kolmogorov(y)</p>
<p>Complementary cumulative distribution (Survival Function) function of
Kolmogorov distribution.</p>
<p>Returns the complementary cumulative distribution function of
Kolmogorov's limiting distribution (<code>D_n*\sqrt(n)</code> as n goes to infinity)
of a two-sided test for equality between an empirical and a theoretical
distribution. It is equal to the (limit as n-&gt;infinity of the)
probability that <code>sqrt(n) * max absolute deviation &gt; y</code>.</p>
<h2 id="parameters_103">Parameters<a class="headerlink" href="#parameters_103" title="Permanent link">&para;</a></h2>
<p>y : float array_like
Absolute deviation between the Empirical CDF (ECDF) and the target CDF,
multiplied by sqrt(n).</p>
<h2 id="returns_106">Returns<a class="headerlink" href="#returns_106" title="Permanent link">&para;</a></h2>
<p>float
The value(s) of kolmogorov(y)</p>
<h2 id="notes_73">Notes<a class="headerlink" href="#notes_73" title="Permanent link">&para;</a></h2>
<p><code>kolmogorov</code> is used by <code>stats.kstest</code> in the application of the
Kolmogorov-Smirnov Goodness of Fit test. For historial reasons this
function is exposed in <code>scpy.special</code>, but the recommended way to achieve
the most accurate CDF/SF/PDF/PPF/ISF computations is to use the
<code>stats.kstwobign</code> distribution.</p>
<h2 id="see-also_84">See Also<a class="headerlink" href="#see-also_84" title="Permanent link">&para;</a></h2>
<p>kolmogi : The Inverse Survival Function for the distribution
scipy.stats.kstwobign : Provides the functionality as a continuous distribution
smirnov, smirnovi : Functions for the one-sided distribution</p>
<h2 id="examples_45">Examples<a class="headerlink" href="#examples_45" title="Permanent link">&para;</a></h2>
<p>Show the probability of a gap at least as big as 0, 0.5 and 1.0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import kolmogorov
from scipy.stats import kstwobign
kolmogorov([0, 0.5, 1.0])
array([ 1.        ,  0.96394524,  0.26999967])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare a sample of size 1000 drawn from a Laplace(0, 1) distribution against
the target distribution, a Normal(0, 1) distribution.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.stats import norm, laplace
n = 1000
np.random.seed(seed=233423)
lap01 = laplace(0, 1)
x = np.sort(lap01.rvs(n))
np.mean(x), np.std(x)
(-0.083073685397609842, 1.3676426568399822)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Construct the Empirical CDF and the K-S statistic Dn.</p>
<blockquote>
<blockquote>
<blockquote>
<p>target = norm(0,1)  # Normal mean 0, stddev 1
cdfs = target.cdf(x)
ecdfs = np.arange(n+1, dtype=float)/n
gaps = np.column_stack([cdfs - ecdfs[:n], ecdfs[1:] - cdfs])
Dn = np.max(gaps)
Kn = np.sqrt(n) * Dn
print('Dn=%f, sqrt(n)<em>Dn=%f' % (Dn, Kn))
Dn=0.058286, sqrt(n)</em>Dn=1.843153
print(chr(10).join(['For a sample of size n drawn from a N(0, 1) distribution:',
...   ' the approximate Kolmogorov probability that sqrt(n)<em>Dn&gt;=%f is %f' %  (Kn, kolmogorov(Kn)),
...   ' the approximate Kolmogorov probability that sqrt(n)</em>Dn&lt;=%f is %f' %  (Kn, kstwobign.cdf(Kn))]))
For a sample of size n drawn from a N(0, 1) distribution:
the approximate Kolmogorov probability that sqrt(n)<em>Dn&gt;=1.843153 is 0.002240
the approximate Kolmogorov probability that sqrt(n)</em>Dn&lt;=1.843153 is 0.997760</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the Empirical CDF against the target N(0, 1) CDF.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.step(np.concatenate([[-3], x]), ecdfs, where='post', label='Empirical CDF')
x3 = np.linspace(-3, 3, 100)
plt.plot(x3, target.cdf(x3), label='CDF for N(0, 1)')
plt.ylim([0, 1]); plt.grid(True); plt.legend();</p>
<h1 id="add-vertical-lines-marking-dn-and-dn-">Add vertical lines marking Dn+ and Dn-<a class="headerlink" href="#add-vertical-lines-marking-dn-and-dn-" title="Permanent link">&para;</a></h1>
<p>iminus, iplus = np.argmax(gaps, axis=0)
plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus], color='r', linestyle='dashed', lw=4)
plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1], color='r', linestyle='dashed', lw=4)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kv(v, z)</p>
<p>Modified Bessel function of the second kind of real order <code>v</code></p>
<p>Returns the modified Bessel function of the second kind for real order
<code>v</code> at complex <code>z</code>.</p>
<p>These are also sometimes called functions of the third kind, Basset
functions, or Macdonald functions.  They are defined as those solutions
of the modified Bessel equation for which,</p>
<p>.. math::
K_v(x) \sim \sqrt{\pi/(2x)} \exp(-x)</p>
<p>as :math:<code>x \to \infty</code> [3]_.</p>
<h2 id="parameters_104">Parameters<a class="headerlink" href="#parameters_104" title="Permanent link">&para;</a></h2>
<p>v : array_like of float
Order of Bessel functions
z : array_like of complex
Argument at which to evaluate the Bessel functions</p>
<h2 id="returns_107">Returns<a class="headerlink" href="#returns_107" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The results. Note that input must be of complex type to get complex
output, e.g. <code>kv(3, -2+0j)</code> instead of <code>kv(3, -2)</code>.</p>
<h2 id="notes_74">Notes<a class="headerlink" href="#notes_74" title="Permanent link">&para;</a></h2>
<p>Wrapper for AMOS [1]<em> routine <code>zbesk</code>.  For a discussion of the
algorithm used, see [2]</em> and the references therein.</p>
<h2 id="see-also_85">See Also<a class="headerlink" href="#see-also_85" title="Permanent link">&para;</a></h2>
<p>kve : This function with leading exponential behavior stripped off.
kvp : Derivative of this function</p>
<h2 id="references_88">References<a class="headerlink" href="#references_88" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/
.. [2] Donald E. Amos, 'Algorithm 644: A portable package for Bessel
functions of a complex argument and nonnegative order', ACM
TOMS Vol. 12 Issue 3, Sept. 1986, p. 265
.. [3] NIST Digital Library of Mathematical Functions,
Eq. 10.25.E3. https://dlmf.nist.gov/10.25.E3</p>
<h2 id="examples_46">Examples<a class="headerlink" href="#examples_46" title="Permanent link">&para;</a></h2>
<p>Plot the function of several orders for real input:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import kv
import matplotlib.pyplot as plt
x = np.linspace(0, 5, 1000)
for N in np.linspace(0, 6, 5):
...     plt.plot(x, kv(N, x), label='<span><span class="MathJax_Preview">K_{{{}}}(x)</span><script type="math/tex">K_{{{}}}(x)</script></span>'.format(N))
plt.ylim(0, 10)
plt.legend()
plt.title(r'Modified Bessel function of the second kind <span><span class="MathJax_Preview">K_\nu(x)</span><script type="math/tex">K_\nu(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Calculate for a single value at multiple orders:</p>
<blockquote>
<blockquote>
<blockquote>
<p>kv([4, 4.5, 5], 1+2j)
array([ 0.1992+2.3892j,  2.3493+3.6j   ,  7.2827+3.8104j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kve</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kve(v, z)</p>
<p>Exponentially scaled modified Bessel function of the second kind.</p>
<p>Returns the exponentially scaled, modified Bessel function of the
second kind (sometimes called the third kind) for real order <code>v</code> at
complex <code>z</code>::</p>
<p>kve(v, z) = kv(v, z) * exp(z)</p>
<h2 id="parameters_105">Parameters<a class="headerlink" href="#parameters_105" title="Permanent link">&para;</a></h2>
<p>v : array_like of float
Order of Bessel functions
z : array_like of complex
Argument at which to evaluate the Bessel functions</p>
<h2 id="returns_108">Returns<a class="headerlink" href="#returns_108" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The exponentially scaled modified Bessel function of the second kind.</p>
<h2 id="notes_75">Notes<a class="headerlink" href="#notes_75" title="Permanent link">&para;</a></h2>
<p>Wrapper for AMOS [1]<em> routine <code>zbesk</code>.  For a discussion of the
algorithm used, see [2]</em> and the references therein.</p>
<h2 id="references_89">References<a class="headerlink" href="#references_89" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/
.. [2] Donald E. Amos, 'Algorithm 644: A portable package for Bessel
functions of a complex argument and nonnegative order', ACM
TOMS Vol. 12 Issue 3, Sept. 1986, p. 265</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">log1p</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>log1p(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>log1p(x)</p>
<p>Calculates log(1+x) for use when <code>x</code> is near zero</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">log_ndtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>log_ndtr(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>log_ndtr(x)</p>
<p>Logarithm of Gaussian cumulative distribution function.</p>
<p>Returns the log of the area under the standard Gaussian probability
density function, integrated from minus infinity to <code>x</code>::</p>
<p>log(1/sqrt(2<em>pi) * integral(exp(-t</em>*2 / 2), t=-inf..x))</p>
<h2 id="parameters_106">Parameters<a class="headerlink" href="#parameters_106" title="Permanent link">&para;</a></h2>
<p>x : array_like, real or complex
Argument</p>
<h2 id="returns_109">Returns<a class="headerlink" href="#returns_109" title="Permanent link">&para;</a></h2>
<p>ndarray
The value of the log of the normal CDF evaluated at <code>x</code></p>
<h2 id="see-also_86">See Also<a class="headerlink" href="#see-also_86" title="Permanent link">&para;</a></h2>
<p>erf
erfc
scipy.stats.norm
ndtr</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">loggamma</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>loggamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>loggamma(z, out=None)</p>
<p>Principal branch of the logarithm of the Gamma function.</p>
<p>Defined to be :math:<code>\log(\Gamma(x))</code> for :math:<code>x &gt; 0</code> and
extended to the complex plane by analytic continuation. The
function has a single branch cut on the negative real axis.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="parameters_107">Parameters<a class="headerlink" href="#parameters_107" title="Permanent link">&para;</a></h2>
<p>z : array-like
Values in the complex plain at which to compute <code>loggamma</code>
out : ndarray, optional
Output array for computed values of <code>loggamma</code></p>
<h2 id="returns_110">Returns<a class="headerlink" href="#returns_110" title="Permanent link">&para;</a></h2>
<p>loggamma : ndarray
Values of <code>loggamma</code> at z.</p>
<h2 id="notes_76">Notes<a class="headerlink" href="#notes_76" title="Permanent link">&para;</a></h2>
<p>It is not generally true that :math:<code>\log\Gamma(z) =
\log(\Gamma(z))</code>, though the real parts of the functions do
agree. The benefit of not defining <code>loggamma</code> as
:math:<code>\log(\Gamma(z))</code> is that the latter function has a
complicated branch cut structure whereas <code>loggamma</code> is analytic
except for on the negative real axis.</p>
<p>The identities</p>
<p>.. math::
\exp(\log\Gamma(z)) &amp;= \Gamma(z) \
\log\Gamma(z + 1) &amp;= \log(z) + \log\Gamma(z)</p>
<p>make <code>loggamma</code> useful for working in complex logspace.</p>
<p>On the real line <code>loggamma</code> is related to <code>gammaln</code> via
<code>exp(loggamma(x + 0j)) = gammasgn(x)*exp(gammaln(x))</code>, up to
rounding error.</p>
<p>The implementation here is based on [hare1997]_.</p>
<h2 id="see-also_87">See also<a class="headerlink" href="#see-also_87" title="Permanent link">&para;</a></h2>
<p>gammaln : logarithm of the absolute value of the Gamma function
gammasgn : sign of the gamma function</p>
<h2 id="references_90">References<a class="headerlink" href="#references_90" title="Permanent link">&para;</a></h2>
<p>.. [hare1997] D.E.G. Hare,
<em>Computing the Principal Branch of log-Gamma</em>,
Journal of Algorithms, Volume 25, Issue 2, November 1997, pages 221-236.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">logit</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>logit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>logit(x)</p>
<p>Logit ufunc for ndarrays.</p>
<p>The logit function is defined as logit(p) = log(p/(1-p)).
Note that logit(0) = -inf, logit(1) = inf, and logit(p)
for p&lt;0 or p&gt;1 yields nan.</p>
<h2 id="parameters_108">Parameters<a class="headerlink" href="#parameters_108" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The ndarray to apply logit to element-wise.</p>
<h2 id="returns_111">Returns<a class="headerlink" href="#returns_111" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An ndarray of the same shape as x. Its entries
are logit of the corresponding entry of x.</p>
<h2 id="see-also_88">See Also<a class="headerlink" href="#see-also_88" title="Permanent link">&para;</a></h2>
<p>expit</p>
<h2 id="notes_77">Notes<a class="headerlink" href="#notes_77" title="Permanent link">&para;</a></h2>
<p>As a ufunc logit takes a number of optional
keyword arguments. For more information
see <code>ufuncs &lt;https://docs.scipy.org/doc/numpy/reference/ufuncs.html&gt;</code>_</p>
<p>.. versionadded:: 0.10.0</p>
<h2 id="examples_47">Examples<a class="headerlink" href="#examples_47" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import logit, expit</p>
<p>logit([0, 0.25, 0.5, 0.75, 1])
array([       -inf, -1.09861229,  0.        ,  1.09861229,         inf])</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>expit</code> is the inverse of <code>logit</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>expit(logit([0.1, 0.75, 0.999]))
array([ 0.1  ,  0.75 ,  0.999])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot logit(x) for x in [0, 1]:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
x = np.linspace(0, 1, 501)
y = logit(x)
plt.plot(x, y)
plt.grid()
plt.ylim(-6, 6)
plt.xlabel('x')
plt.title('logit(x)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lpmv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>lpmv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>lpmv(m, v, x)</p>
<p>Associated Legendre function of integer order and real degree.</p>
<p>Defined as</p>
<p>.. math::</p>
<p>P_v^m = (-1)^m (1 - x^2)^{m/2} \frac{d^m}{dx^m} P_v(x)</p>
<p>where</p>
<p>.. math::</p>
<p>P_v = \sum_{k = 0}^\infty \frac{(-v)_k (v + 1)_k}{(k!)^2}
\left(\frac{1 - x}{2}\right)^k</p>
<p>is the Legendre function of the first kind. Here :math:<code>(\cdot)_k</code>
is the Pochhammer symbol; see <code>poch</code>.</p>
<h2 id="parameters_109">Parameters<a class="headerlink" href="#parameters_109" title="Permanent link">&para;</a></h2>
<p>m : array_like
Order (int or float). If passed a float not equal to an
integer the function returns NaN.
v : array_like
Degree (float).
x : array_like
Argument (float). Must have <code>|x| &lt;= 1</code>.</p>
<h2 id="returns_112">Returns<a class="headerlink" href="#returns_112" title="Permanent link">&para;</a></h2>
<p>pmv : ndarray
Value of the associated Legendre function.</p>
<h2 id="see-also_89">See Also<a class="headerlink" href="#see-also_89" title="Permanent link">&para;</a></h2>
<p>lpmn : Compute the associated Legendre function for all orders
<code>0, ..., m</code> and degrees <code>0, ..., n</code>.
clpmn : Compute the associated Legendre function at complex
arguments.</p>
<h2 id="notes_78">Notes<a class="headerlink" href="#notes_78" title="Permanent link">&para;</a></h2>
<p>Note that this implementation includes the Condon-Shortley phase.</p>
<h2 id="references_91">References<a class="headerlink" href="#references_91" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Jin, 'Computation of Special Functions', John Wiley
and Sons, Inc, 1996.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_a</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>mathieu_a(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_a(m, q)</p>
<p>Characteristic value of even Mathieu functions</p>
<p>Returns the characteristic value for the even solution,
<code>ce_m(z, q)</code>, of Mathieu's equation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_b</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>mathieu_b(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_b(m, q)</p>
<p>Characteristic value of odd Mathieu functions</p>
<p>Returns the characteristic value for the odd solution,
<code>se_m(z, q)</code>, of Mathieu's equation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_cem</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>mathieu_cem(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_cem(m, q, x)</p>
<p>Even Mathieu function and its derivative</p>
<p>Returns the even Mathieu function, <code>ce_m(x, q)</code>, of order <code>m</code> and
parameter <code>q</code> evaluated at <code>x</code> (given in degrees).  Also returns the
derivative with respect to <code>x</code> of ce_m(x, q)</p>
<h2 id="parameters_110">Parameters<a class="headerlink" href="#parameters_110" title="Permanent link">&para;</a></h2>
<p>m
Order of the function
q
Parameter of the function
x
Argument of the function, <em>given in degrees, not radians</em></p>
<h2 id="returns_113">Returns<a class="headerlink" href="#returns_113" title="Permanent link">&para;</a></h2>
<p>y
Value of the function
yp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_modcem1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>mathieu_modcem1(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_modcem1(m, q, x)</p>
<p>Even modified Mathieu function of the first kind and its derivative</p>
<p>Evaluates the even modified Mathieu function of the first kind,
<code>Mc1m(x, q)</code>, and its derivative at <code>x</code> for order <code>m</code> and parameter
<code>q</code>.</p>
<h2 id="returns_114">Returns<a class="headerlink" href="#returns_114" title="Permanent link">&para;</a></h2>
<p>y
Value of the function
yp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_modcem2</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>mathieu_modcem2(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_modcem2(m, q, x)</p>
<p>Even modified Mathieu function of the second kind and its derivative</p>
<p>Evaluates the even modified Mathieu function of the second kind,
Mc2m(x, q), and its derivative at <code>x</code> (given in degrees) for order <code>m</code>
and parameter <code>q</code>.</p>
<h2 id="returns_115">Returns<a class="headerlink" href="#returns_115" title="Permanent link">&para;</a></h2>
<p>y
Value of the function
yp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_modsem1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>mathieu_modsem1(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_modsem1(m, q, x)</p>
<p>Odd modified Mathieu function of the first kind and its derivative</p>
<p>Evaluates the odd modified Mathieu function of the first kind,
Ms1m(x, q), and its derivative at <code>x</code> (given in degrees) for order <code>m</code>
and parameter <code>q</code>.</p>
<h2 id="returns_116">Returns<a class="headerlink" href="#returns_116" title="Permanent link">&para;</a></h2>
<p>y
Value of the function
yp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_modsem2</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>mathieu_modsem2(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_modsem2(m, q, x)</p>
<p>Odd modified Mathieu function of the second kind and its derivative</p>
<p>Evaluates the odd modified Mathieu function of the second kind,
Ms2m(x, q), and its derivative at <code>x</code> (given in degrees) for order <code>m</code>
and parameter q.</p>
<h2 id="returns_117">Returns<a class="headerlink" href="#returns_117" title="Permanent link">&para;</a></h2>
<p>y
Value of the function
yp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_sem</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>mathieu_sem(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_sem(m, q, x)</p>
<p>Odd Mathieu function and its derivative</p>
<p>Returns the odd Mathieu function, se_m(x, q), of order <code>m</code> and
parameter <code>q</code> evaluated at <code>x</code> (given in degrees).  Also returns the
derivative with respect to <code>x</code> of se_m(x, q).</p>
<h2 id="parameters_111">Parameters<a class="headerlink" href="#parameters_111" title="Permanent link">&para;</a></h2>
<p>m
Order of the function
q
Parameter of the function
x
Argument of the function, <em>given in degrees, not radians</em>.</p>
<h2 id="returns_118">Returns<a class="headerlink" href="#returns_118" title="Permanent link">&para;</a></h2>
<p>y
Value of the function
yp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">modfresnelm</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>modfresnelm(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>modfresnelm(x)</p>
<p>Modified Fresnel negative integrals</p>
<h2 id="returns_119">Returns<a class="headerlink" href="#returns_119" title="Permanent link">&para;</a></h2>
<p>fm
Integral <code>F_-(x)</code>: <code>integral(exp(-1j*t*t), t=x..inf)</code>
km
Integral <code>K_-(x)</code>: <code>1/sqrt(pi)*exp(1j*(x*x+pi/4))*fp</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">modfresnelp</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>modfresnelp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>modfresnelp(x)</p>
<p>Modified Fresnel positive integrals</p>
<h2 id="returns_120">Returns<a class="headerlink" href="#returns_120" title="Permanent link">&para;</a></h2>
<p>fp
Integral <code>F_+(x)</code>: <code>integral(exp(1j*t*t), t=x..inf)</code>
kp
Integral <code>K_+(x)</code>: <code>1/sqrt(pi)*exp(-1j*(x*x+pi/4))*fp</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">modstruve</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>modstruve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>modstruve(v, x)</p>
<p>Modified Struve function.</p>
<p>Return the value of the modified Struve function of order <code>v</code> at <code>x</code>.  The
modified Struve function is defined as,</p>
<p>.. math::
L_v(x) = -\imath \exp(-\pi\imath v/2) H_v(\imath x),</p>
<p>where :math:<code>H_v</code> is the Struve function.</p>
<h2 id="parameters_112">Parameters<a class="headerlink" href="#parameters_112" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order of the modified Struve function (float).
x : array_like
Argument of the Struve function (float; must be positive unless <code>v</code> is
an integer).</p>
<h2 id="returns_121">Returns<a class="headerlink" href="#returns_121" title="Permanent link">&para;</a></h2>
<p>L : ndarray
Value of the modified Struve function of order <code>v</code> at <code>x</code>.</p>
<h2 id="notes_79">Notes<a class="headerlink" href="#notes_79" title="Permanent link">&para;</a></h2>
<p>Three methods discussed in [1]_ are used to evaluate the function:</p>
<ul>
<li>power series</li>
<li>expansion in Bessel functions (if :math:<code>|x| &lt; |v| + 20</code>)</li>
<li>asymptotic large-x expansion (if :math:<code>x \geq 0.7v + 12</code>)</li>
</ul>
<p>Rounding errors are estimated based on the largest terms in the sums, and
the result associated with the smallest error is returned.</p>
<h2 id="see-also_90">See also<a class="headerlink" href="#see-also_90" title="Permanent link">&para;</a></h2>
<p>struve</p>
<h2 id="references_92">References<a class="headerlink" href="#references_92" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/11</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nbdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nbdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nbdtr(k, n, p)</p>
<p>Negative binomial cumulative distribution function.</p>
<p>Returns the sum of the terms 0 through <code>k</code> of the negative binomial
distribution probability mass function,</p>
<p>.. math::</p>
<p>F = \sum_{j=0}^k {{n + j - 1}\choose{j}} p^n (1 - p)^j.</p>
<p>In a sequence of Bernoulli trials with individual success probabilities
<code>p</code>, this is the probability that <code>k</code> or fewer failures precede the nth
success.</p>
<h2 id="parameters_113">Parameters<a class="headerlink" href="#parameters_113" title="Permanent link">&para;</a></h2>
<p>k : array_like
The maximum number of allowed failures (nonnegative int).
n : array_like
The target number of successes (positive int).
p : array_like
Probability of success in a single event (float).</p>
<h2 id="returns_122">Returns<a class="headerlink" href="#returns_122" title="Permanent link">&para;</a></h2>
<p>F : ndarray
The probability of <code>k</code> or fewer failures before <code>n</code> successes in a
sequence of events with individual success probability <code>p</code>.</p>
<h2 id="see-also_91">See also<a class="headerlink" href="#see-also_91" title="Permanent link">&para;</a></h2>
<p>nbdtrc</p>
<h2 id="notes_80">Notes<a class="headerlink" href="#notes_80" title="Permanent link">&para;</a></h2>
<p>If floating point values are passed for <code>k</code> or <code>n</code>, they will be truncated
to integers.</p>
<p>The terms are not summed directly; instead the regularized incomplete beta
function is employed, according to the formula,</p>
<p>.. math::
\mathrm{nbdtr}(k, n, p) = I_{p}(n, k + 1).</p>
<p>Wrapper for the Cephes [1]_ routine <code>nbdtr</code>.</p>
<h2 id="references_93">References<a class="headerlink" href="#references_93" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nbdtrc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nbdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nbdtrc(k, n, p)</p>
<p>Negative binomial survival function.</p>
<p>Returns the sum of the terms <code>k + 1</code> to infinity of the negative binomial
distribution probability mass function,</p>
<p>.. math::</p>
<p>F = \sum_{j=k + 1}^\infty {{n + j - 1}\choose{j}} p^n (1 - p)^j.</p>
<p>In a sequence of Bernoulli trials with individual success probabilities
<code>p</code>, this is the probability that more than <code>k</code> failures precede the nth
success.</p>
<h2 id="parameters_114">Parameters<a class="headerlink" href="#parameters_114" title="Permanent link">&para;</a></h2>
<p>k : array_like
The maximum number of allowed failures (nonnegative int).
n : array_like
The target number of successes (positive int).
p : array_like
Probability of success in a single event (float).</p>
<h2 id="returns_123">Returns<a class="headerlink" href="#returns_123" title="Permanent link">&para;</a></h2>
<p>F : ndarray
The probability of <code>k + 1</code> or more failures before <code>n</code> successes in a
sequence of events with individual success probability <code>p</code>.</p>
<h2 id="notes_81">Notes<a class="headerlink" href="#notes_81" title="Permanent link">&para;</a></h2>
<p>If floating point values are passed for <code>k</code> or <code>n</code>, they will be truncated
to integers.</p>
<p>The terms are not summed directly; instead the regularized incomplete beta
function is employed, according to the formula,</p>
<p>.. math::
\mathrm{nbdtrc}(k, n, p) = I_{1 - p}(k + 1, n).</p>
<p>Wrapper for the Cephes [1]_ routine <code>nbdtrc</code>.</p>
<h2 id="references_94">References<a class="headerlink" href="#references_94" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nbdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nbdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nbdtri(k, n, y)</p>
<p>Inverse of <code>nbdtr</code> vs <code>p</code>.</p>
<p>Returns the inverse with respect to the parameter <code>p</code> of
<code>y = nbdtr(k, n, p)</code>, the negative binomial cumulative distribution
function.</p>
<h2 id="parameters_115">Parameters<a class="headerlink" href="#parameters_115" title="Permanent link">&para;</a></h2>
<p>k : array_like
The maximum number of allowed failures (nonnegative int).
n : array_like
The target number of successes (positive int).
y : array_like
The probability of <code>k</code> or fewer failures before <code>n</code> successes (float).</p>
<h2 id="returns_124">Returns<a class="headerlink" href="#returns_124" title="Permanent link">&para;</a></h2>
<p>p : ndarray
Probability of success in a single event (float) such that
<code>nbdtr(k, n, p) = y</code>.</p>
<h2 id="see-also_92">See also<a class="headerlink" href="#see-also_92" title="Permanent link">&para;</a></h2>
<p>nbdtr : Cumulative distribution function of the negative binomial.
nbdtrik : Inverse with respect to <code>k</code> of <code>nbdtr(k, n, p)</code>.
nbdtrin : Inverse with respect to <code>n</code> of <code>nbdtr(k, n, p)</code>.</p>
<h2 id="notes_82">Notes<a class="headerlink" href="#notes_82" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>nbdtri</code>.</p>
<h2 id="references_95">References<a class="headerlink" href="#references_95" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nbdtrik</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nbdtrik(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nbdtrik(y, n, p)</p>
<p>Inverse of <code>nbdtr</code> vs <code>k</code>.</p>
<p>Returns the inverse with respect to the parameter <code>k</code> of
<code>y = nbdtr(k, n, p)</code>, the negative binomial cumulative distribution
function.</p>
<h2 id="parameters_116">Parameters<a class="headerlink" href="#parameters_116" title="Permanent link">&para;</a></h2>
<p>y : array_like
The probability of <code>k</code> or fewer failures before <code>n</code> successes (float).
n : array_like
The target number of successes (positive int).
p : array_like
Probability of success in a single event (float).</p>
<h2 id="returns_125">Returns<a class="headerlink" href="#returns_125" title="Permanent link">&para;</a></h2>
<p>k : ndarray
The maximum number of allowed failures such that <code>nbdtr(k, n, p) = y</code>.</p>
<h2 id="see-also_93">See also<a class="headerlink" href="#see-also_93" title="Permanent link">&para;</a></h2>
<p>nbdtr : Cumulative distribution function of the negative binomial.
nbdtri : Inverse with respect to <code>p</code> of <code>nbdtr(k, n, p)</code>.
nbdtrin : Inverse with respect to <code>n</code> of <code>nbdtr(k, n, p)</code>.</p>
<h2 id="notes_83">Notes<a class="headerlink" href="#notes_83" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfnbn</code>.</p>
<p>Formula 26.5.26 of [2]_,</p>
<p>.. math::
\sum_{j=k + 1}^\infty {{n + j - 1}\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),</p>
<p>is used to reduce calculation of the cumulative distribution function to
that of a regularized incomplete beta :math:<code>I</code>.</p>
<p>Computation of <code>k</code> involves a search for a value that produces the desired
value of <code>y</code>.  The search relies on the monotonicity of <code>y</code> with <code>k</code>.</p>
<h2 id="references_96">References<a class="headerlink" href="#references_96" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nbdtrin</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nbdtrin(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nbdtrin(k, y, p)</p>
<p>Inverse of <code>nbdtr</code> vs <code>n</code>.</p>
<p>Returns the inverse with respect to the parameter <code>n</code> of
<code>y = nbdtr(k, n, p)</code>, the negative binomial cumulative distribution
function.</p>
<h2 id="parameters_117">Parameters<a class="headerlink" href="#parameters_117" title="Permanent link">&para;</a></h2>
<p>k : array_like
The maximum number of allowed failures (nonnegative int).
y : array_like
The probability of <code>k</code> or fewer failures before <code>n</code> successes (float).
p : array_like
Probability of success in a single event (float).</p>
<h2 id="returns_126">Returns<a class="headerlink" href="#returns_126" title="Permanent link">&para;</a></h2>
<p>n : ndarray
The number of successes <code>n</code> such that <code>nbdtr(k, n, p) = y</code>.</p>
<h2 id="see-also_94">See also<a class="headerlink" href="#see-also_94" title="Permanent link">&para;</a></h2>
<p>nbdtr : Cumulative distribution function of the negative binomial.
nbdtri : Inverse with respect to <code>p</code> of <code>nbdtr(k, n, p)</code>.
nbdtrik : Inverse with respect to <code>k</code> of <code>nbdtr(k, n, p)</code>.</p>
<h2 id="notes_84">Notes<a class="headerlink" href="#notes_84" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfnbn</code>.</p>
<p>Formula 26.5.26 of [2]_,</p>
<p>.. math::
\sum_{j=k + 1}^\infty {{n + j - 1}\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),</p>
<p>is used to reduce calculation of the cumulative distribution function to
that of a regularized incomplete beta :math:<code>I</code>.</p>
<p>Computation of <code>n</code> involves a search for a value that produces the desired
value of <code>y</code>.  The search relies on the monotonicity of <code>y</code> with <code>n</code>.</p>
<h2 id="references_97">References<a class="headerlink" href="#references_97" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ncfdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ncfdtr(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ncfdtr(dfn, dfd, nc, f)</p>
<p>Cumulative distribution function of the non-central F distribution.</p>
<p>The non-central F describes the distribution of,</p>
<p>.. math::
Z = \frac{X/d_n}{Y/d_d}</p>
<p>where :math:<code>X</code> and :math:<code>Y</code> are independently distributed, with
:math:<code>X</code> distributed non-central :math:<code>\chi^2</code> with noncentrality
parameter <code>nc</code> and :math:<code>d_n</code> degrees of freedom, and :math:<code>Y</code>
distributed :math:<code>\chi^2</code> with :math:<code>d_d</code> degrees of freedom.</p>
<h2 id="parameters_118">Parameters<a class="headerlink" href="#parameters_118" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
Degrees of freedom of the numerator sum of squares.  Range (0, inf).
dfd : array_like
Degrees of freedom of the denominator sum of squares.  Range (0, inf).
nc : array_like
Noncentrality parameter.  Should be in range (0, 1e4).
f : array_like
Quantiles, i.e. the upper limit of integration.</p>
<h2 id="returns_127">Returns<a class="headerlink" href="#returns_127" title="Permanent link">&para;</a></h2>
<p>cdf : float or ndarray
The calculated CDF.  If all inputs are scalar, the return will be a
float.  Otherwise it will be an array.</p>
<h2 id="see-also_95">See Also<a class="headerlink" href="#see-also_95" title="Permanent link">&para;</a></h2>
<p>ncfdtri : Quantile function; inverse of <code>ncfdtr</code> with respect to <code>f</code>.
ncfdtridfd : Inverse of <code>ncfdtr</code> with respect to <code>dfd</code>.
ncfdtridfn : Inverse of <code>ncfdtr</code> with respect to <code>dfn</code>.
ncfdtrinc : Inverse of <code>ncfdtr</code> with respect to <code>nc</code>.</p>
<h2 id="notes_85">Notes<a class="headerlink" href="#notes_85" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdffnc</code>.</p>
<p>The cumulative distribution function is computed using Formula 26.6.20 of
[2]_:</p>
<p>.. math::
F(d_n, d_d, n_c, f) = \sum_{j=0}^\infty e^{-n_c/2} \frac{(n_c/2)^j}{j!} I_{x}(\frac{d_n}{2} + j, \frac{d_d}{2}),</p>
<p>where :math:<code>I</code> is the regularized incomplete beta function, and
:math:<code>x = f d_n/(f d_n + d_d)</code>.</p>
<p>The computation time required for this routine is proportional to the
noncentrality parameter <code>nc</code>.  Very large values of this parameter can
consume immense computer resources.  This is why the search range is
bounded by 10,000.</p>
<h2 id="references_98">References<a class="headerlink" href="#references_98" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<h2 id="examples_48">Examples<a class="headerlink" href="#examples_48" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
from scipy import stats
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the CDF of the non-central F distribution, for nc=0.  Compare with the
F-distribution from scipy.stats:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-1, 8, num=500)
dfn = 3
dfd = 2
ncf_stats = stats.f.cdf(x, dfn, dfd)
ncf_special = special.ncfdtr(dfn, dfd, 0, x)</p>
<p>fig = plt.figure()
ax = fig.add_subplot(111)
ax.plot(x, ncf_stats, 'b-', lw=3)
ax.plot(x, ncf_special, 'r-')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ncfdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>ncfdtri(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ncfdtri(dfn, dfd, nc, p)</p>
<p>Inverse with respect to <code>f</code> of the CDF of the non-central F distribution.</p>
<p>See <code>ncfdtr</code> for more details.</p>
<h2 id="parameters_119">Parameters<a class="headerlink" href="#parameters_119" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
Degrees of freedom of the numerator sum of squares.  Range (0, inf).
dfd : array_like
Degrees of freedom of the denominator sum of squares.  Range (0, inf).
nc : array_like
Noncentrality parameter.  Should be in range (0, 1e4).
p : array_like
Value of the cumulative distribution function.  Must be in the
range [0, 1].</p>
<h2 id="returns_128">Returns<a class="headerlink" href="#returns_128" title="Permanent link">&para;</a></h2>
<p>f : float
Quantiles, i.e. the upper limit of integration.</p>
<h2 id="see-also_96">See Also<a class="headerlink" href="#see-also_96" title="Permanent link">&para;</a></h2>
<p>ncfdtr : CDF of the non-central F distribution.
ncfdtridfd : Inverse of <code>ncfdtr</code> with respect to <code>dfd</code>.
ncfdtridfn : Inverse of <code>ncfdtr</code> with respect to <code>dfn</code>.
ncfdtrinc : Inverse of <code>ncfdtr</code> with respect to <code>nc</code>.</p>
<h2 id="examples_49">Examples<a class="headerlink" href="#examples_49" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import ncfdtr, ncfdtri</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the CDF for several values of <code>f</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>f = [0.5, 1, 1.5]
p = ncfdtr(2, 3, 1.5, f)
p
array([ 0.20782291,  0.36107392,  0.47345752])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the inverse.  We recover the values of <code>f</code>, as expected:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ncfdtri(2, 3, 1.5, p)
array([ 0.5,  1. ,  1.5])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ncfdtridfd</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>ncfdtridfd(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ncfdtridfd(dfn, p, nc, f)</p>
<p>Calculate degrees of freedom (denominator) for the noncentral F-distribution.</p>
<p>This is the inverse with respect to <code>dfd</code> of <code>ncfdtr</code>.
See <code>ncfdtr</code> for more details.</p>
<h2 id="parameters_120">Parameters<a class="headerlink" href="#parameters_120" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
Degrees of freedom of the numerator sum of squares.  Range (0, inf).
p : array_like
Value of the cumulative distribution function.  Must be in the
range [0, 1].
nc : array_like
Noncentrality parameter.  Should be in range (0, 1e4).
f : array_like
Quantiles, i.e. the upper limit of integration.</p>
<h2 id="returns_129">Returns<a class="headerlink" href="#returns_129" title="Permanent link">&para;</a></h2>
<p>dfd : float
Degrees of freedom of the denominator sum of squares.</p>
<h2 id="see-also_97">See Also<a class="headerlink" href="#see-also_97" title="Permanent link">&para;</a></h2>
<p>ncfdtr : CDF of the non-central F distribution.
ncfdtri : Quantile function; inverse of <code>ncfdtr</code> with respect to <code>f</code>.
ncfdtridfn : Inverse of <code>ncfdtr</code> with respect to <code>dfn</code>.
ncfdtrinc : Inverse of <code>ncfdtr</code> with respect to <code>nc</code>.</p>
<h2 id="notes_86">Notes<a class="headerlink" href="#notes_86" title="Permanent link">&para;</a></h2>
<p>The value of the cumulative noncentral F distribution is not necessarily
monotone in either degrees of freedom.  There thus may be two values that
provide a given CDF value.  This routine assumes monotonicity and will
find an arbitrary one of the two values.</p>
<h2 id="examples_50">Examples<a class="headerlink" href="#examples_50" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import ncfdtr, ncfdtridfd</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the CDF for several values of <code>dfd</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>dfd = [1, 2, 3]
p = ncfdtr(2, dfd, 0.25, 15)
p
array([ 0.8097138 ,  0.93020416,  0.96787852])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the inverse.  We recover the values of <code>dfd</code>, as expected:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ncfdtridfd(2, p, 0.25, 15)
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ncfdtridfn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>ncfdtridfn(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ncfdtridfn(p, dfd, nc, f)</p>
<p>Calculate degrees of freedom (numerator) for the noncentral F-distribution.</p>
<p>This is the inverse with respect to <code>dfn</code> of <code>ncfdtr</code>.
See <code>ncfdtr</code> for more details.</p>
<h2 id="parameters_121">Parameters<a class="headerlink" href="#parameters_121" title="Permanent link">&para;</a></h2>
<p>p : array_like
Value of the cumulative distribution function.  Must be in the
range [0, 1].
dfd : array_like
Degrees of freedom of the denominator sum of squares.  Range (0, inf).
nc : array_like
Noncentrality parameter.  Should be in range (0, 1e4).
f : float
Quantiles, i.e. the upper limit of integration.</p>
<h2 id="returns_130">Returns<a class="headerlink" href="#returns_130" title="Permanent link">&para;</a></h2>
<p>dfn : float
Degrees of freedom of the numerator sum of squares.</p>
<h2 id="see-also_98">See Also<a class="headerlink" href="#see-also_98" title="Permanent link">&para;</a></h2>
<p>ncfdtr : CDF of the non-central F distribution.
ncfdtri : Quantile function; inverse of <code>ncfdtr</code> with respect to <code>f</code>.
ncfdtridfd : Inverse of <code>ncfdtr</code> with respect to <code>dfd</code>.
ncfdtrinc : Inverse of <code>ncfdtr</code> with respect to <code>nc</code>.</p>
<h2 id="notes_87">Notes<a class="headerlink" href="#notes_87" title="Permanent link">&para;</a></h2>
<p>The value of the cumulative noncentral F distribution is not necessarily
monotone in either degrees of freedom.  There thus may be two values that
provide a given CDF value.  This routine assumes monotonicity and will
find an arbitrary one of the two values.</p>
<h2 id="examples_51">Examples<a class="headerlink" href="#examples_51" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import ncfdtr, ncfdtridfn</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the CDF for several values of <code>dfn</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>dfn = [1, 2, 3]
p = ncfdtr(dfn, 2, 0.25, 15)
p
array([ 0.92562363,  0.93020416,  0.93188394])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the inverse.  We recover the values of <code>dfn</code>, as expected:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ncfdtridfn(p, 2, 0.25, 15)
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ncfdtrinc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>ncfdtrinc(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ncfdtrinc(dfn, dfd, p, f)</p>
<p>Calculate non-centrality parameter for non-central F distribution.</p>
<p>This is the inverse with respect to <code>nc</code> of <code>ncfdtr</code>.
See <code>ncfdtr</code> for more details.</p>
<h2 id="parameters_122">Parameters<a class="headerlink" href="#parameters_122" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
Degrees of freedom of the numerator sum of squares.  Range (0, inf).
dfd : array_like
Degrees of freedom of the denominator sum of squares.  Range (0, inf).
p : array_like
Value of the cumulative distribution function.  Must be in the
range [0, 1].
f : array_like
Quantiles, i.e. the upper limit of integration.</p>
<h2 id="returns_131">Returns<a class="headerlink" href="#returns_131" title="Permanent link">&para;</a></h2>
<p>nc : float
Noncentrality parameter.</p>
<h2 id="see-also_99">See Also<a class="headerlink" href="#see-also_99" title="Permanent link">&para;</a></h2>
<p>ncfdtr : CDF of the non-central F distribution.
ncfdtri : Quantile function; inverse of <code>ncfdtr</code> with respect to <code>f</code>.
ncfdtridfd : Inverse of <code>ncfdtr</code> with respect to <code>dfd</code>.
ncfdtridfn : Inverse of <code>ncfdtr</code> with respect to <code>dfn</code>.</p>
<h2 id="examples_52">Examples<a class="headerlink" href="#examples_52" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import ncfdtr, ncfdtrinc</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the CDF for several values of <code>nc</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>nc = [0.5, 1.5, 2.0]
p = ncfdtr(2, 3, nc, 15)
p
array([ 0.96309246,  0.94327955,  0.93304098])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the inverse.  We recover the values of <code>nc</code>, as expected:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ncfdtrinc(2, 3, p, 15)
array([ 0.5,  1.5,  2. ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nctdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nctdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nctdtr(df, nc, t)</p>
<p>Cumulative distribution function of the non-central <code>t</code> distribution.</p>
<h2 id="parameters_123">Parameters<a class="headerlink" href="#parameters_123" title="Permanent link">&para;</a></h2>
<p>df : array_like
Degrees of freedom of the distribution.  Should be in range (0, inf).
nc : array_like
Noncentrality parameter.  Should be in range (-1e6, 1e6).
t : array_like
Quantiles, i.e. the upper limit of integration.</p>
<h2 id="returns_132">Returns<a class="headerlink" href="#returns_132" title="Permanent link">&para;</a></h2>
<p>cdf : float or ndarray
The calculated CDF.  If all inputs are scalar, the return will be a
float.  Otherwise it will be an array.</p>
<h2 id="see-also_100">See Also<a class="headerlink" href="#see-also_100" title="Permanent link">&para;</a></h2>
<p>nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.
nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.
nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.</p>
<h2 id="examples_53">Examples<a class="headerlink" href="#examples_53" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
from scipy import stats
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the CDF of the non-central t distribution, for nc=0.  Compare with the
t-distribution from scipy.stats:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-5, 5, num=500)
df = 3
nct_stats = stats.t.cdf(x, df)
nct_special = special.nctdtr(df, 0, x)</p>
<p>fig = plt.figure()
ax = fig.add_subplot(111)
ax.plot(x, nct_stats, 'b-', lw=3)
ax.plot(x, nct_special, 'r-')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nctdtridf</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nctdtridf(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nctdtridf(p, nc, t)</p>
<p>Calculate degrees of freedom for non-central t distribution.</p>
<p>See <code>nctdtr</code> for more details.</p>
<h2 id="parameters_124">Parameters<a class="headerlink" href="#parameters_124" title="Permanent link">&para;</a></h2>
<p>p : array_like
CDF values, in range (0, 1].
nc : array_like
Noncentrality parameter.  Should be in range (-1e6, 1e6).
t : array_like
Quantiles, i.e. the upper limit of integration.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nctdtrinc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nctdtrinc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nctdtrinc(df, p, t)</p>
<p>Calculate non-centrality parameter for non-central t distribution.</p>
<p>See <code>nctdtr</code> for more details.</p>
<h2 id="parameters_125">Parameters<a class="headerlink" href="#parameters_125" title="Permanent link">&para;</a></h2>
<p>df : array_like
Degrees of freedom of the distribution.  Should be in range (0, inf).
p : array_like
CDF values, in range (0, 1].
t : array_like
Quantiles, i.e. the upper limit of integration.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nctdtrit</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nctdtrit(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nctdtrit(df, nc, p)</p>
<p>Inverse cumulative distribution function of the non-central t distribution.</p>
<p>See <code>nctdtr</code> for more details.</p>
<h2 id="parameters_126">Parameters<a class="headerlink" href="#parameters_126" title="Permanent link">&para;</a></h2>
<p>df : array_like
Degrees of freedom of the distribution.  Should be in range (0, inf).
nc : array_like
Noncentrality parameter.  Should be in range (-1e6, 1e6).
p : array_like
CDF values, in range (0, 1].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ndtr(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ndtr(x)</p>
<p>Gaussian cumulative distribution function.</p>
<p>Returns the area under the standard Gaussian probability
density function, integrated from minus infinity to <code>x</code></p>
<p>.. math::</p>
<p>\frac{1}{\sqrt{2\pi}} \int_{-\infty}^x \exp(-t^2/2) dt</p>
<h2 id="parameters_127">Parameters<a class="headerlink" href="#parameters_127" title="Permanent link">&para;</a></h2>
<p>x : array_like, real or complex
Argument</p>
<h2 id="returns_133">Returns<a class="headerlink" href="#returns_133" title="Permanent link">&para;</a></h2>
<p>ndarray
The value of the normal CDF evaluated at <code>x</code></p>
<h2 id="see-also_101">See Also<a class="headerlink" href="#see-also_101" title="Permanent link">&para;</a></h2>
<p>erf
erfc
scipy.stats.norm
log_ndtr</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ndtri(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ndtri(y)</p>
<p>Inverse of <code>ndtr</code> vs x</p>
<p>Returns the argument x for which the area under the Gaussian
probability density function (integrated from minus infinity to <code>x</code>)
is equal to y.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nrdtrimn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nrdtrimn(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nrdtrimn(p, x, std)</p>
<p>Calculate mean of normal distribution given other params.</p>
<h2 id="parameters_128">Parameters<a class="headerlink" href="#parameters_128" title="Permanent link">&para;</a></h2>
<p>p : array_like
CDF values, in range (0, 1].
x : array_like
Quantiles, i.e. the upper limit of integration.
std : array_like
Standard deviation.</p>
<h2 id="returns_134">Returns<a class="headerlink" href="#returns_134" title="Permanent link">&para;</a></h2>
<p>mn : float or ndarray
The mean of the normal distribution.</p>
<h2 id="see-also_102">See Also<a class="headerlink" href="#see-also_102" title="Permanent link">&para;</a></h2>
<p>nrdtrimn, ndtr</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nrdtrisd</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nrdtrisd(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nrdtrisd(p, x, mn)</p>
<p>Calculate standard deviation of normal distribution given other params.</p>
<h2 id="parameters_129">Parameters<a class="headerlink" href="#parameters_129" title="Permanent link">&para;</a></h2>
<p>p : array_like
CDF values, in range (0, 1].
x : array_like
Quantiles, i.e. the upper limit of integration.
mn : float or ndarray
The mean of the normal distribution.</p>
<h2 id="returns_135">Returns<a class="headerlink" href="#returns_135" title="Permanent link">&para;</a></h2>
<p>std : array_like
Standard deviation.</p>
<h2 id="see-also_103">See Also<a class="headerlink" href="#see-also_103" title="Permanent link">&para;</a></h2>
<p>ndtr</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_ang1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>obl_ang1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_ang1(m, n, c, x)</p>
<p>Oblate spheroidal angular function of the first kind and its derivative</p>
<p>Computes the oblate spheroidal angular function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>.</p>
<h2 id="returns_136">Returns<a class="headerlink" href="#returns_136" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_ang1_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>obl_ang1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_ang1_cv(m, n, c, cv, x)</p>
<p>Oblate spheroidal angular function obl_ang1 for precomputed characteristic value</p>
<p>Computes the oblate spheroidal angular function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>. Requires
pre-computed characteristic value.</p>
<h2 id="returns_137">Returns<a class="headerlink" href="#returns_137" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>obl_cv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_cv(m, n, c)</p>
<p>Characteristic value of oblate spheroidal function</p>
<p>Computes the characteristic value of oblate spheroidal wave
functions of order <code>m</code>, <code>n</code> (n&gt;=m) and spheroidal parameter <code>c</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_rad1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>obl_rad1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_rad1(m, n, c, x)</p>
<p>Oblate spheroidal radial function of the first kind and its derivative</p>
<p>Computes the oblate spheroidal radial function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>.</p>
<h2 id="returns_138">Returns<a class="headerlink" href="#returns_138" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_rad1_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>obl_rad1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_rad1_cv(m, n, c, cv, x)</p>
<p>Oblate spheroidal radial function obl_rad1 for precomputed characteristic value</p>
<p>Computes the oblate spheroidal radial function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>. Requires
pre-computed characteristic value.</p>
<h2 id="returns_139">Returns<a class="headerlink" href="#returns_139" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_rad2</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>obl_rad2(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_rad2(m, n, c, x)</p>
<p>Oblate spheroidal radial function of the second kind and its derivative.</p>
<p>Computes the oblate spheroidal radial function of the second kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>.</p>
<h2 id="returns_140">Returns<a class="headerlink" href="#returns_140" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_rad2_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>obl_rad2_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_rad2_cv(m, n, c, cv, x)</p>
<p>Oblate spheroidal radial function obl_rad2 for precomputed characteristic value</p>
<p>Computes the oblate spheroidal radial function of the second kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>. Requires
pre-computed characteristic value.</p>
<h2 id="returns_141">Returns<a class="headerlink" href="#returns_141" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">owens_t</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>owens_t(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>owens_t(h, a)</p>
<p>Owen's T Function.</p>
<p>The function T(h, a) gives the probability of the event
(X &gt; h and 0 &lt; Y &lt; a * X) where X and Y are independent
standard normal random variables.</p>
<h2 id="parameters_130">Parameters<a class="headerlink" href="#parameters_130" title="Permanent link">&para;</a></h2>
<p>h: array_like
Input value.
a: array_like
Input value.</p>
<h2 id="returns_142">Returns<a class="headerlink" href="#returns_142" title="Permanent link">&para;</a></h2>
<p>t: scalar or ndarray
Probability of the event (X &gt; h and 0 &lt; Y &lt; a * X),
where X and Y are independent standard normal random variables.</p>
<h2 id="examples_54">Examples<a class="headerlink" href="#examples_54" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
a = 3.5
h = 0.78
special.owens_t(h, a)
0.10877216734852274</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_99">References<a class="headerlink" href="#references_99" title="Permanent link">&para;</a></h2>
<p>.. [1] M. Patefield and D. Tandy, 'Fast and accurate calculation of
Owen's T Function', Statistical Software vol. 5, pp. 1-25, 2000.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pbdv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pbdv(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pbdv(v, x)</p>
<p>Parabolic cylinder function D</p>
<p>Returns (d, dp) the parabolic cylinder function Dv(x) in d and the
derivative, Dv'(x) in dp.</p>
<h2 id="returns_143">Returns<a class="headerlink" href="#returns_143" title="Permanent link">&para;</a></h2>
<p>d
Value of the function
dp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pbvv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pbvv(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pbvv(v, x)</p>
<p>Parabolic cylinder function V</p>
<p>Returns the parabolic cylinder function Vv(x) in v and the
derivative, Vv'(x) in vp.</p>
<h2 id="returns_144">Returns<a class="headerlink" href="#returns_144" title="Permanent link">&para;</a></h2>
<p>v
Value of the function
vp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pbwa</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pbwa(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pbwa(a, x)</p>
<p>Parabolic cylinder function W.</p>
<p>The function is a particular solution to the differential equation</p>
<p>.. math::</p>
<p>y'' + \left(\frac{1}{4}x^2 - a\right)y = 0,</p>
<p>for a full definition see section 12.14 in [1]_.</p>
<h2 id="parameters_131">Parameters<a class="headerlink" href="#parameters_131" title="Permanent link">&para;</a></h2>
<p>a : array_like
Real parameter
x : array_like
Real argument</p>
<h2 id="returns_145">Returns<a class="headerlink" href="#returns_145" title="Permanent link">&para;</a></h2>
<p>w : scalar or ndarray
Value of the function
wp : scalar or ndarray
Value of the derivative in x</p>
<h2 id="notes_88">Notes<a class="headerlink" href="#notes_88" title="Permanent link">&para;</a></h2>
<p>The function is a wrapper for a Fortran routine by Zhang and Jin
[2]_. The implementation is accurate only for <code>|a|, |x| &lt; 5</code> and
returns NaN outside that range.</p>
<h2 id="references_100">References<a class="headerlink" href="#references_100" title="Permanent link">&para;</a></h2>
<p>.. [1] Digital Library of Mathematical Functions, 14.30.
https://dlmf.nist.gov/14.30
.. [2] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>pdtr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pdtr(k, m, out=None)</p>
<p>Poisson cumulative distribution function.</p>
<p>Defined as the probability that a Poisson-distributed random
variable with event rate :math:<code>m</code> is less than or equal to
:math:<code>k</code>. More concretely, this works out to be [1]_</p>
<p>.. math::</p>
<p>\exp(-m) \sum_{j = 0}^{\lfloor{k}\rfloor} \frac{m^j}{m!}.</p>
<h2 id="parameters_132">Parameters<a class="headerlink" href="#parameters_132" title="Permanent link">&para;</a></h2>
<p>k : array_like
Nonnegative real argument
m : array_like
Nonnegative real shape parameter
out : ndarray
Optional output array for the function results</p>
<h2 id="see-also_104">See Also<a class="headerlink" href="#see-also_104" title="Permanent link">&para;</a></h2>
<p>pdtrc : Poisson survival function
pdtrik : inverse of <code>pdtr</code> with respect to <code>k</code>
pdtri : inverse of <code>pdtr</code> with respect to <code>m</code></p>
<h2 id="returns_146">Returns<a class="headerlink" href="#returns_146" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the Poisson cumulative distribution function</p>
<h2 id="references_101">References<a class="headerlink" href="#references_101" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Poisson_distribution</p>
<h2 id="examples_55">Examples<a class="headerlink" href="#examples_55" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is a cumulative distribution function, so it converges to 1
monotonically as <code>k</code> goes to infinity.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.pdtr([1, 10, 100, np.inf], 1)
array([0.73575888, 0.99999999, 1.        , 1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is discontinuous at integers and constant between integers.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.pdtr([1, 1.5, 1.9, 2], 1)
array([0.73575888, 0.73575888, 0.73575888, 0.9196986 ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pdtrc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>pdtrc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pdtrc(k, m)</p>
<p>Poisson survival function</p>
<p>Returns the sum of the terms from k+1 to infinity of the Poisson
distribution: sum(exp(-m) * m**j / j!, j=k+1..inf) = gammainc(
k+1, m).  Arguments must both be non-negative doubles.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>pdtri(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pdtri(k, y)</p>
<p>Inverse to <code>pdtr</code> vs m</p>
<p>Returns the Poisson variable <code>m</code> such that the sum from 0 to <code>k</code> of
the Poisson density is equal to the given probability <code>y</code>:
calculated by gammaincinv(k+1, y). <code>k</code> must be a nonnegative
integer and <code>y</code> between 0 and 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pdtrik</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>pdtrik(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pdtrik(p, m)</p>
<p>Inverse to <code>pdtr</code> vs k</p>
<p>Returns the quantile k such that <code>pdtr(k, m) = p</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">poch</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>poch(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>poch(z, m)</p>
<p>Pochhammer symbol.</p>
<p>The Pochhammer symbol (rising factorial) is defined as</p>
<p>.. math::</p>
<p>(z)_m = \frac{\Gamma(z + m)}{\Gamma(z)}</p>
<p>For positive integer <code>m</code> it reads</p>
<p>.. math::</p>
<p>(z)_m = z (z + 1) ... (z + m - 1)</p>
<p>See [dlmf]_ for more details.</p>
<h2 id="parameters_133">Parameters<a class="headerlink" href="#parameters_133" title="Permanent link">&para;</a></h2>
<p>z, m : array_like
Real-valued arguments.</p>
<h2 id="returns_147">Returns<a class="headerlink" href="#returns_147" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
The value of the function.</p>
<h2 id="references_102">References<a class="headerlink" href="#references_102" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] Nist, Digital Library of Mathematical Functions
https://dlmf.nist.gov/5.2#iii</p>
<h2 id="examples_56">Examples<a class="headerlink" href="#examples_56" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is 1 when m is 0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.poch([1, 2, 3, 4], 0)
array([1., 1., 1., 1.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>For z equal to 1 it reduces to the factorial function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.poch(1, 5)
120.0
1 * 2 * 3 * 4 * 5
120</p>
</blockquote>
</blockquote>
</blockquote>
<p>It can be expressed in terms of the Gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>z, m = 3.7, 2.1
sc.poch(z, m)
20.529581933776953
sc.gamma(z + m) / sc.gamma(z)
20.52958193377696</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_ang1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pro_ang1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_ang1(m, n, c, x)</p>
<p>Prolate spheroidal angular function of the first kind and its derivative</p>
<p>Computes the prolate spheroidal angular function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>.</p>
<h2 id="returns_148">Returns<a class="headerlink" href="#returns_148" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_ang1_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pro_ang1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_ang1_cv(m, n, c, cv, x)</p>
<p>Prolate spheroidal angular function pro_ang1 for precomputed characteristic value</p>
<p>Computes the prolate spheroidal angular function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>. Requires
pre-computed characteristic value.</p>
<h2 id="returns_149">Returns<a class="headerlink" href="#returns_149" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>pro_cv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_cv(m, n, c)</p>
<p>Characteristic value of prolate spheroidal function</p>
<p>Computes the characteristic value of prolate spheroidal wave
functions of order <code>m</code>, <code>n</code> (n&gt;=m) and spheroidal parameter <code>c</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_rad1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pro_rad1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_rad1(m, n, c, x)</p>
<p>Prolate spheroidal radial function of the first kind and its derivative</p>
<p>Computes the prolate spheroidal radial function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>.</p>
<h2 id="returns_150">Returns<a class="headerlink" href="#returns_150" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_rad1_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pro_rad1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_rad1_cv(m, n, c, cv, x)</p>
<p>Prolate spheroidal radial function pro_rad1 for precomputed characteristic value</p>
<p>Computes the prolate spheroidal radial function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>. Requires
pre-computed characteristic value.</p>
<h2 id="returns_151">Returns<a class="headerlink" href="#returns_151" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_rad2</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pro_rad2(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_rad2(m, n, c, x)</p>
<p>Prolate spheroidal radial function of the second kind and its derivative</p>
<p>Computes the prolate spheroidal radial function of the second kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>.</p>
<h2 id="returns_152">Returns<a class="headerlink" href="#returns_152" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_rad2_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pro_rad2_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_rad2_cv(m, n, c, cv, x)</p>
<p>Prolate spheroidal radial function pro_rad2 for precomputed characteristic value</p>
<p>Computes the prolate spheroidal radial function of the second kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>. Requires
pre-computed characteristic value.</p>
<h2 id="returns_153">Returns<a class="headerlink" href="#returns_153" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pseudo_huber</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>pseudo_huber(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pseudo_huber(delta, r)</p>
<p>Pseudo-Huber loss function.</p>
<p>.. math:: \mathrm{pseudo_huber}(\delta, r) = \delta^2 \left( \sqrt{ 1 + \left( \frac{r}{\delta} \right)^2 } - 1 \right)</p>
<h2 id="parameters_134">Parameters<a class="headerlink" href="#parameters_134" title="Permanent link">&para;</a></h2>
<p>delta : ndarray
Input array, indicating the soft quadratic vs. linear loss changepoint.
r : ndarray
Input array, possibly representing residuals.</p>
<h2 id="returns_154">Returns<a class="headerlink" href="#returns_154" title="Permanent link">&para;</a></h2>
<p>res : ndarray
The computed Pseudo-Huber loss function values.</p>
<h2 id="notes_89">Notes<a class="headerlink" href="#notes_89" title="Permanent link">&para;</a></h2>
<p>This function is convex in :math:<code>r</code>.</p>
<p>.. versionadded:: 0.15.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">psi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>psi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>psi(z, out=None)</p>
<p>The digamma function.</p>
<p>The logarithmic derivative of the gamma function evaluated at <code>z</code>.</p>
<h2 id="parameters_135">Parameters<a class="headerlink" href="#parameters_135" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex argument.
out : ndarray, optional
Array for the computed values of <code>psi</code>.</p>
<h2 id="returns_155">Returns<a class="headerlink" href="#returns_155" title="Permanent link">&para;</a></h2>
<p>digamma : ndarray
Computed values of <code>psi</code>.</p>
<h2 id="notes_90">Notes<a class="headerlink" href="#notes_90" title="Permanent link">&para;</a></h2>
<p>For large values not close to the negative real axis <code>psi</code> is
computed using the asymptotic series (5.11.2) from [1]<em>. For small
arguments not close to the negative real axis the recurrence
relation (5.5.2) from [1]</em> is used until the argument is large
enough to use the asymptotic series. For values close to the
negative real axis the reflection formula (5.5.4) from [1]<em> is
used first.  Note that <code>psi</code> has a family of zeros on the
negative real axis which occur between the poles at nonpositive
integers. Around the zeros the reflection formula suffers from
cancellation and the implementation loses precision. The sole
positive zero and the first negative zero, however, are handled
separately by precomputing series expansions using [2]</em>, so the
function should maintain full accuracy around the origin.</p>
<h2 id="references_103">References<a class="headerlink" href="#references_103" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/5
.. [2] Fredrik Johansson and others.
'mpmath: a Python library for arbitrary-precision floating-point arithmetic'
(Version 0.19) http://mpmath.org/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">radian</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>radian(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>radian(d, m, s)</p>
<p>Convert from degrees to radians</p>
<p>Returns the angle given in (d)egrees, (m)inutes, and (s)econds in
radians.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rel_entr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rel_entr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>rel_entr(x, y, out=None)</p>
<p>Elementwise function for computing relative entropy.</p>
<p>.. math::</p>
<p>\mathrm{rel_entr}(x, y) =
\begin{cases}
x \log(x / y) &amp; x &gt; 0, y &gt; 0 \
0 &amp; x = 0, y \ge 0 \
\infty &amp; \text{otherwise}
\end{cases}</p>
<h2 id="parameters_136">Parameters<a class="headerlink" href="#parameters_136" title="Permanent link">&para;</a></h2>
<p>x, y : array_like
Input arrays
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_156">Returns<a class="headerlink" href="#returns_156" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Relative entropy of the inputs</p>
<h2 id="see-also_105">See Also<a class="headerlink" href="#see-also_105" title="Permanent link">&para;</a></h2>
<p>entr, kl_div</p>
<h2 id="notes_91">Notes<a class="headerlink" href="#notes_91" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.15.0</p>
<p>This function is jointly convex in x and y.</p>
<p>The origin of this function is in convex programming; see
[1]_. Given two discrete probability distributions :math:<code>p_1,
\ldots, p_n</code> and :math:<code>q_1, \ldots, q_n</code>, to get the relative
entropy of statistics compute the sum</p>
<p>.. math::</p>
<p>\sum_{i = 1}^n \mathrm{rel_entr}(p_i, q_i).</p>
<p>See [2]_ for details.</p>
<h2 id="references_104">References<a class="headerlink" href="#references_104" title="Permanent link">&para;</a></h2>
<p>.. [1] Grant, Boyd, and Ye, 'CVX: Matlab Software for Disciplined Convex
Programming', http://cvxr.com/cvx/
.. [2] Kullback-Leibler divergence,
https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rgamma</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rgamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>rgamma(z, out=None)</p>
<p>Reciprocal of the Gamma function.</p>
<p>Defined as :math:<code>1 / \Gamma(z)</code>, where :math:<code>\Gamma</code> is the
Gamma function. For more on the Gamma function see <code>gamma</code>.</p>
<h2 id="parameters_137">Parameters<a class="headerlink" href="#parameters_137" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex valued input
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_157">Returns<a class="headerlink" href="#returns_157" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Function results</p>
<h2 id="notes_92">Notes<a class="headerlink" href="#notes_92" title="Permanent link">&para;</a></h2>
<p>The Gamma function has no zeros and has simple poles at
nonpositive integers, so <code>rgamma</code> is an entire function with zeros
at the nonpositive integers. See the discussion in [dlmf]_ for
more details.</p>
<h2 id="see-also_106">See Also<a class="headerlink" href="#see-also_106" title="Permanent link">&para;</a></h2>
<p>gamma, gammaln, loggamma</p>
<h2 id="references_105">References<a class="headerlink" href="#references_105" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] Nist, Digital Library of Mathematical functions,
https://dlmf.nist.gov/5.2#i</p>
<h2 id="examples_57">Examples<a class="headerlink" href="#examples_57" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is the reciprocal of the Gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.rgamma([1, 2, 3, 4])
array([1.        , 1.        , 0.5       , 0.16666667])
1 / sc.gamma([1, 2, 3, 4])
array([1.        , 1.        , 0.5       , 0.16666667])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is zero at nonpositive integers.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.rgamma([0, -1, -2, -3])
array([0., 0., 0., 0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It rapidly underflows to zero along the positive real axis.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.rgamma([10, 100, 179])
array([2.75573192e-006, 1.07151029e-156, 0.00000000e+000])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">round</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>round(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>round(x)</p>
<p>Round to nearest integer</p>
<p>Returns the nearest integer to <code>x</code> as a double precision floating
point result.  If <code>x</code> ends in 0.5 exactly, the nearest even integer
is chosen.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shichi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>shichi(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>shichi(x, out=None)</p>
<p>Hyperbolic sine and cosine integrals.</p>
<p>The hyperbolic sine integral is</p>
<p>.. math::</p>
<p>\int_0^x \frac{\sinh{t}}{t}dt</p>
<p>and the hyperbolic cosine integral is</p>
<p>.. math::</p>
<p>\gamma + \log(x) + \int_0^x \frac{\cosh{t} - 1}{t} dt</p>
<p>where :math:<code>\gamma</code> is Euler's constant and :math:<code>\log</code> is the
principle branch of the logarithm.</p>
<h2 id="parameters_138">Parameters<a class="headerlink" href="#parameters_138" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real or complex points at which to compute the hyperbolic sine
and cosine integrals.</p>
<h2 id="returns_158">Returns<a class="headerlink" href="#returns_158" title="Permanent link">&para;</a></h2>
<p>si : ndarray
Hyperbolic sine integral at <code>x</code>
ci : ndarray
Hyperbolic cosine integral at <code>x</code></p>
<h2 id="notes_93">Notes<a class="headerlink" href="#notes_93" title="Permanent link">&para;</a></h2>
<p>For real arguments with <code>x &lt; 0</code>, <code>chi</code> is the real part of the
hyperbolic cosine integral. For such points <code>chi(x)</code> and <code>chi(x
+ 0j)</code> differ by a factor of <code>1j*pi</code>.</p>
<p>For real arguments the function is computed by calling Cephes'
[1]<em> <em>shichi</em> routine. For complex arguments the algorithm is based
on Mpmath's [2]</em> <em>shi</em> and <em>chi</em> routines.</p>
<h2 id="references_106">References<a class="headerlink" href="#references_106" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/
.. [2] Fredrik Johansson and others.
'mpmath: a Python library for arbitrary-precision floating-point arithmetic'
(Version 0.19) http://mpmath.org/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sici</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>sici(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>sici(x, out=None)</p>
<p>Sine and cosine integrals.</p>
<p>The sine integral is</p>
<p>.. math::</p>
<p>\int_0^x \frac{\sin{t}}{t}dt</p>
<p>and the cosine integral is</p>
<p>.. math::</p>
<p>\gamma + \log(x) + \int_0^x \frac{\cos{t} - 1}{t}dt</p>
<p>where :math:<code>\gamma</code> is Euler's constant and :math:<code>\log</code> is the
principle branch of the logarithm.</p>
<h2 id="parameters_139">Parameters<a class="headerlink" href="#parameters_139" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real or complex points at which to compute the sine and cosine
integrals.</p>
<h2 id="returns_159">Returns<a class="headerlink" href="#returns_159" title="Permanent link">&para;</a></h2>
<p>si : ndarray
Sine integral at <code>x</code>
ci : ndarray
Cosine integral at <code>x</code></p>
<h2 id="notes_94">Notes<a class="headerlink" href="#notes_94" title="Permanent link">&para;</a></h2>
<p>For real arguments with <code>x &lt; 0</code>, <code>ci</code> is the real part of the
cosine integral. For such points <code>ci(x)</code> and <code>ci(x + 0j)</code>
differ by a factor of <code>1j*pi</code>.</p>
<p>For real arguments the function is computed by calling Cephes'
[1]<em> <em>sici</em> routine. For complex arguments the algorithm is based
on Mpmath's [2]</em> <em>si</em> and <em>ci</em> routines.</p>
<h2 id="references_107">References<a class="headerlink" href="#references_107" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/
.. [2] Fredrik Johansson and others.
'mpmath: a Python library for arbitrary-precision floating-point arithmetic'
(Version 0.19) http://mpmath.org/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sindg</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sindg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>sindg(x)</p>
<p>Sine of angle given in degrees</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">smirnov</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>smirnov(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>smirnov(n, d)</p>
<p>Kolmogorov-Smirnov complementary cumulative distribution function</p>
<p>Returns the exact Kolmogorov-Smirnov complementary cumulative
distribution function,(aka the Survival Function) of Dn+ (or Dn-)
for a one-sided test of equality between an empirical and a
theoretical distribution. It is equal to the probability that the
maximum difference between a theoretical distribution and an empirical
one based on <code>n</code> samples is greater than d.</p>
<h2 id="parameters_140">Parameters<a class="headerlink" href="#parameters_140" title="Permanent link">&para;</a></h2>
<p>n : int
Number of samples
d : float array_like
Deviation between the Empirical CDF (ECDF) and the target CDF.</p>
<h2 id="returns_160">Returns<a class="headerlink" href="#returns_160" title="Permanent link">&para;</a></h2>
<p>float
The value(s) of smirnov(n, d), Prob(Dn+ &gt;= d) (Also Prob(Dn- &gt;= d))</p>
<h2 id="notes_95">Notes<a class="headerlink" href="#notes_95" title="Permanent link">&para;</a></h2>
<p><code>smirnov</code> is used by <code>stats.kstest</code> in the application of the
Kolmogorov-Smirnov Goodness of Fit test. For historial reasons this
function is exposed in <code>scpy.special</code>, but the recommended way to achieve
the most accurate CDF/SF/PDF/PPF/ISF computations is to use the
<code>stats.ksone</code> distribution.</p>
<h2 id="see-also_107">See Also<a class="headerlink" href="#see-also_107" title="Permanent link">&para;</a></h2>
<p>smirnovi : The Inverse Survival Function for the distribution
scipy.stats.ksone : Provides the functionality as a continuous distribution
kolmogorov, kolmogi : Functions for the two-sided distribution</p>
<h2 id="examples_58">Examples<a class="headerlink" href="#examples_58" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import smirnov</p>
</blockquote>
</blockquote>
</blockquote>
<p>Show the probability of a gap at least as big as 0, 0.5 and 1.0 for a sample of size 5</p>
<blockquote>
<blockquote>
<blockquote>
<p>smirnov(5, [0, 0.5, 1.0])
array([ 1.   ,  0.056,  0.   ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare a sample of size 5 drawn from a source N(0.5, 1) distribution against
a target N(0, 1) CDF.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.stats import norm
n = 5
gendist = norm(0.5, 1)       # Normal distribution, mean 0.5, stddev 1
np.random.seed(seed=233423)  # Set the seed for reproducibility
x = np.sort(gendist.rvs(size=n))
x
array([-0.20946287,  0.71688765,  0.95164151,  1.44590852,  3.08880533])
target = norm(0, 1)
cdfs = target.cdf(x)
cdfs
array([ 0.41704346,  0.76327829,  0.82936059,  0.92589857,  0.99899518])</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="construct-the-empirical-cdf-and-the-k-s-statistics-dn-dn-dn">Construct the Empirical CDF and the K-S statistics (Dn+, Dn-, Dn)<a class="headerlink" href="#construct-the-empirical-cdf-and-the-k-s-statistics-dn-dn-dn" title="Permanent link">&para;</a></h1>
<blockquote>
<blockquote>
<blockquote>
<p>ecdfs = np.arange(n+1, dtype=float)/n
cols = np.column_stack([x, ecdfs[1:], cdfs, cdfs - ecdfs[:n], ecdfs[1:] - cdfs])
np.set_printoptions(precision=3)
cols
array([[ -2.095e-01,   2.000e-01,   4.170e-01,   4.170e-01,  -2.170e-01],
[  7.169e-01,   4.000e-01,   7.633e-01,   5.633e-01,  -3.633e-01],
[  9.516e-01,   6.000e-01,   8.294e-01,   4.294e-01,  -2.294e-01],
[  1.446e+00,   8.000e-01,   9.259e-01,   3.259e-01,  -1.259e-01],
[  3.089e+00,   1.000e+00,   9.990e-01,   1.990e-01,   1.005e-03]])
gaps = cols[:, -2:]
Dnpm = np.max(gaps, axis=0)
print('Dn-=%f, Dn+=%f' % (Dnpm[0], Dnpm[1]))
Dn-=0.563278, Dn+=0.001005
probs = smirnov(n, Dnpm)
print(chr(10).join(['For a sample of size %d drawn from a N(0, 1) distribution:' % n,
...      ' Smirnov n=%d: Prob(Dn- &gt;= %f) = %.4f' % (n, Dnpm[0], probs[0]),
...      ' Smirnov n=%d: Prob(Dn+ &gt;= %f) = %.4f' % (n, Dnpm[1], probs[1])]))
For a sample of size 5 drawn from a N(0, 1) distribution:
Smirnov n=5: Prob(Dn- &gt;= 0.563278) = 0.0250
Smirnov n=5: Prob(Dn+ &gt;= 0.001005) = 0.9990</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the Empirical CDF against the target N(0, 1) CDF</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.step(np.concatenate([[-3], x]), ecdfs, where='post', label='Empirical CDF')
x3 = np.linspace(-3, 3, 100)
plt.plot(x3, target.cdf(x3), label='CDF for N(0, 1)')
plt.ylim([0, 1]); plt.grid(True); plt.legend();</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="add-vertical-lines-marking-dn-and-dn-_1">Add vertical lines marking Dn+ and Dn-<a class="headerlink" href="#add-vertical-lines-marking-dn-and-dn-_1" title="Permanent link">&para;</a></h1>
<blockquote>
<blockquote>
<blockquote>
<p>iminus, iplus = np.argmax(gaps, axis=0)
plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus], color='r', linestyle='dashed', lw=4)
plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1], color='m', linestyle='dashed', lw=4)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">smirnovi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>smirnovi(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>smirnovi(n, p)</p>
<p>Inverse to <code>smirnov</code></p>
<p>Returns <code>d</code> such that <code>smirnov(n, d) == p</code>, the critical value
corresponding to <code>p</code>.</p>
<h2 id="parameters_141">Parameters<a class="headerlink" href="#parameters_141" title="Permanent link">&para;</a></h2>
<p>n : int
Number of samples
p : float array_like
Probability</p>
<h2 id="returns_161">Returns<a class="headerlink" href="#returns_161" title="Permanent link">&para;</a></h2>
<p>float
The value(s) of smirnovi(n, p), the critical values.</p>
<h2 id="notes_96">Notes<a class="headerlink" href="#notes_96" title="Permanent link">&para;</a></h2>
<p><code>smirnov</code> is used by <code>stats.kstest</code> in the application of the
Kolmogorov-Smirnov Goodness of Fit test. For historial reasons this
function is exposed in <code>scpy.special</code>, but the recommended way to achieve
the most accurate CDF/SF/PDF/PPF/ISF computations is to use the
<code>stats.ksone</code> distribution.</p>
<h2 id="see-also_108">See Also<a class="headerlink" href="#see-also_108" title="Permanent link">&para;</a></h2>
<p>smirnov  : The Survival Function (SF) for the distribution
scipy.stats.ksone : Provides the functionality as a continuous distribution
kolmogorov, kolmogi, scipy.stats.kstwobign : Functions for the two-sided distribution</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spence</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>spence(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>spence(z, out=None)</p>
<p>Spence's function, also known as the dilogarithm.</p>
<p>It is defined to be</p>
<p>.. math::
\int_0^z \frac{\log(t)}{1 - t}dt</p>
<p>for complex :math:<code>z</code>, where the contour of integration is taken
to avoid the branch cut of the logarithm. Spence's function is
analytic everywhere except the negative real axis where it has a
branch cut.</p>
<h2 id="parameters_142">Parameters<a class="headerlink" href="#parameters_142" title="Permanent link">&para;</a></h2>
<p>z : array_like
Points at which to evaluate Spence's function</p>
<h2 id="returns_162">Returns<a class="headerlink" href="#returns_162" title="Permanent link">&para;</a></h2>
<p>s : ndarray
Computed values of Spence's function</p>
<h2 id="notes_97">Notes<a class="headerlink" href="#notes_97" title="Permanent link">&para;</a></h2>
<p>There is a different convention which defines Spence's function by
the integral</p>
<p>.. math::
-\int_0^z \frac{\log(1 - t)}{t}dt;</p>
<p>this is our <code>spence(1 - z)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sph_harm</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sph_harm(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>sph_harm(m, n, theta, phi)</p>
<p>Compute spherical harmonics.</p>
<p>The spherical harmonics are defined as</p>
<p>.. math::</p>
<p>Y^m_n(\theta,\phi) = \sqrt{\frac{2n+1}{4\pi} \frac{(n-m)!}{(n+m)!}}
e^{i m \theta} P^m_n(\cos(\phi))</p>
<p>where :math:<code>P_n^m</code> are the associated Legendre functions; see <code>lpmv</code>.</p>
<h2 id="parameters_143">Parameters<a class="headerlink" href="#parameters_143" title="Permanent link">&para;</a></h2>
<p>m : array_like
Order of the harmonic (int); must have <code>|m| &lt;= n</code>.
n : array_like
Degree of the harmonic (int); must have <code>n &gt;= 0</code>. This is
often denoted by <code>l</code> (lower case L) in descriptions of
spherical harmonics.
theta : array_like
Azimuthal (longitudinal) coordinate; must be in <code>[0, 2*pi]</code>.
phi : array_like
Polar (colatitudinal) coordinate; must be in <code>[0, pi]</code>.</p>
<h2 id="returns_163">Returns<a class="headerlink" href="#returns_163" title="Permanent link">&para;</a></h2>
<p>y_mn : complex float
The harmonic :math:<code>Y^m_n</code> sampled at <code>theta</code> and <code>phi</code>.</p>
<h2 id="notes_98">Notes<a class="headerlink" href="#notes_98" title="Permanent link">&para;</a></h2>
<p>There are different conventions for the meanings of the input
arguments <code>theta</code> and <code>phi</code>. In SciPy <code>theta</code> is the
azimuthal angle and <code>phi</code> is the polar angle. It is common to
see the opposite convention, that is, <code>theta</code> as the polar angle
and <code>phi</code> as the azimuthal angle.</p>
<p>Note that SciPy's spherical harmonics include the Condon-Shortley
phase [2]_ because it is part of <code>lpmv</code>.</p>
<p>With SciPy's conventions, the first several spherical harmonics
are</p>
<p>.. math::</p>
<p>Y_0^0(\theta, \phi) &amp;= \frac{1}{2} \sqrt{\frac{1}{\pi}} \
Y_1^{-1}(\theta, \phi) &amp;= \frac{1}{2} \sqrt{\frac{3}{2\pi}}
e^{-i\theta} \sin(\phi) \
Y_1^0(\theta, \phi) &amp;= \frac{1}{2} \sqrt{\frac{3}{\pi}}
\cos(\phi) \
Y_1^1(\theta, \phi) &amp;= -\frac{1}{2} \sqrt{\frac{3}{2\pi}}
e^{i\theta} \sin(\phi).</p>
<h2 id="references_108">References<a class="headerlink" href="#references_108" title="Permanent link">&para;</a></h2>
<p>.. [1] Digital Library of Mathematical Functions, 14.30.
https://dlmf.nist.gov/14.30
.. [2] https://en.wikipedia.org/wiki/Spherical_harmonics#Condon.E2.80.93Shortley_phase</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">stdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>stdtr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>stdtr(df, t)</p>
<p>Student t distribution cumulative distribution function</p>
<p>Returns the integral from minus infinity to t of the Student t
distribution with df &gt; 0 degrees of freedom::</p>
<p>gamma((df+1)/2)/(sqrt(df<em>pi)</em>gamma(df/2)) *
integral((1+x<strong>2/df)</strong>(-df/2-1/2), x=-inf..t)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">stdtridf</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>stdtridf(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>stdtridf(p, t)</p>
<p>Inverse of <code>stdtr</code> vs df</p>
<p>Returns the argument df such that stdtr(df, t) is equal to <code>p</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">stdtrit</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>stdtrit(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>stdtrit(df, p)</p>
<p>Inverse of <code>stdtr</code> vs <code>t</code></p>
<p>Returns the argument <code>t</code> such that stdtr(df, t) is equal to <code>p</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">struve</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>struve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>struve(v, x)</p>
<p>Struve function.</p>
<p>Return the value of the Struve function of order <code>v</code> at <code>x</code>.  The Struve
function is defined as,</p>
<p>.. math::
H_v(x) = (z/2)^{v + 1} \sum_{n=0}^\infty \frac{(-1)^n (z/2)^{2n}}{\Gamma(n + \frac{3}{2}) \Gamma(n + v + \frac{3}{2})},</p>
<p>where :math:<code>\Gamma</code> is the gamma function.</p>
<h2 id="parameters_144">Parameters<a class="headerlink" href="#parameters_144" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order of the Struve function (float).
x : array_like
Argument of the Struve function (float; must be positive unless <code>v</code> is
an integer).</p>
<h2 id="returns_164">Returns<a class="headerlink" href="#returns_164" title="Permanent link">&para;</a></h2>
<p>H : ndarray
Value of the Struve function of order <code>v</code> at <code>x</code>.</p>
<h2 id="notes_99">Notes<a class="headerlink" href="#notes_99" title="Permanent link">&para;</a></h2>
<p>Three methods discussed in [1]_ are used to evaluate the Struve function:</p>
<ul>
<li>power series</li>
<li>expansion in Bessel functions (if :math:<code>|z| &lt; |v| + 20</code>)</li>
<li>asymptotic large-z expansion (if :math:<code>z \geq 0.7v + 12</code>)</li>
</ul>
<p>Rounding errors are estimated based on the largest terms in the sums, and
the result associated with the smallest error is returned.</p>
<h2 id="see-also_109">See also<a class="headerlink" href="#see-also_109" title="Permanent link">&para;</a></h2>
<p>modstruve</p>
<h2 id="references_109">References<a class="headerlink" href="#references_109" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/11</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tandg</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>tandg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>tandg(x)</p>
<p>Tangent of angle x given in degrees.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tklmbda</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>tklmbda(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>tklmbda(x, lmbda)</p>
<p>Tukey-Lambda cumulative distribution function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">voigt_profile</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>voigt_profile(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>voigt_profile(x, sigma, gamma, out=None)</p>
<p>Voigt profile.</p>
<p>The Voigt profile is a convolution of a 1D Normal distribution with
standard deviation <code>sigma</code> and a 1D Cauchy distribution with half-width at
half-maximum <code>gamma</code>.</p>
<h2 id="parameters_145">Parameters<a class="headerlink" href="#parameters_145" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real argument
sigma : array_like
The standard deviation of the Normal distribution part
gamma : array_like
The half-width at half-maximum of the Cauchy distribution part
out : ndarray, optional
Optional output array for the function values</p>
<h2 id="returns_165">Returns<a class="headerlink" href="#returns_165" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
The Voigt profile at the given arguments</p>
<h2 id="notes_100">Notes<a class="headerlink" href="#notes_100" title="Permanent link">&para;</a></h2>
<p>It can be expressed in terms of Faddeeva function</p>
<p>.. math:: V(x; \sigma, \gamma) = \frac{Re[w(z)]}{\sigma\sqrt{2\pi}},
.. math:: z = \frac{x + i\gamma}{\sqrt{2}\sigma}</p>
<p>where :math:<code>w(z)</code> is the Faddeeva function.</p>
<h2 id="see-also_110">See Also<a class="headerlink" href="#see-also_110" title="Permanent link">&para;</a></h2>
<p>wofz : Faddeeva function</p>
<h2 id="references_110">References<a class="headerlink" href="#references_110" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Voigt_profile</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">wofz</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>wofz(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>wofz(z)</p>
<p>Faddeeva function</p>
<p>Returns the value of the Faddeeva function for complex argument::</p>
<p>exp(-z*<em>2) * erfc(-i</em>z)</p>
<h2 id="see-also_111">See Also<a class="headerlink" href="#see-also_111" title="Permanent link">&para;</a></h2>
<p>dawsn, erf, erfc, erfcx, erfi</p>
<h2 id="references_111">References<a class="headerlink" href="#references_111" title="Permanent link">&para;</a></h2>
<p>.. [1] Steven G. Johnson, Faddeeva W function implementation.
http://ab-initio.mit.edu/Faddeeva</p>
<h2 id="examples_59">Examples<a class="headerlink" href="#examples_59" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
import matplotlib.pyplot as plt</p>
<p>x = np.linspace(-3, 3)
z = special.wofz(x)</p>
<p>plt.plot(x, z.real, label='wofz(x).real')
plt.plot(x, z.imag, label='wofz(x).imag')
plt.xlabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>')
plt.legend(framealpha=1, shadow=True)
plt.grid(alpha=0.25)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">wrightomega</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>wrightomega(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>wrightomega(z, out=None)</p>
<p>Wright Omega function.</p>
<p>Defined as the solution to</p>
<p>.. math::</p>
<p>\omega + \log(\omega) = z</p>
<p>where :math:<code>\log</code> is the principal branch of the complex logarithm.</p>
<h2 id="parameters_146">Parameters<a class="headerlink" href="#parameters_146" title="Permanent link">&para;</a></h2>
<p>z : array_like
Points at which to evaluate the Wright Omega function</p>
<h2 id="returns_166">Returns<a class="headerlink" href="#returns_166" title="Permanent link">&para;</a></h2>
<p>omega : ndarray
Values of the Wright Omega function</p>
<h2 id="notes_101">Notes<a class="headerlink" href="#notes_101" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<p>The function can also be defined as</p>
<p>.. math::</p>
<p>\omega(z) = W_{K(z)}(e^z)</p>
<p>where :math:<code>K(z) = \lceil (\Im(z) - \pi)/(2\pi) \rceil</code> is the
unwinding number and :math:<code>W</code> is the Lambert W function.</p>
<p>The implementation here is taken from [1]_.</p>
<h2 id="see-also_112">See Also<a class="headerlink" href="#see-also_112" title="Permanent link">&para;</a></h2>
<p>lambertw : The Lambert W function</p>
<h2 id="references_112">References<a class="headerlink" href="#references_112" title="Permanent link">&para;</a></h2>
<p>.. [1] Lawrence, Corless, and Jeffrey, 'Algorithm 917: Complex
Double-Precision Evaluation of the Wright :math:<code>\omega</code>
Function.' ACM Transactions on Mathematical Software,
2012. :doi:<code>10.1145/2168773.2168779</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">xlog1py</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>xlog1py(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>xlog1py(x, y)</p>
<p>Compute <code>x*log1p(y)</code> so that the result is 0 if <code>x = 0</code>.</p>
<h2 id="parameters_147">Parameters<a class="headerlink" href="#parameters_147" title="Permanent link">&para;</a></h2>
<p>x : array_like
Multiplier
y : array_like
Argument</p>
<h2 id="returns_167">Returns<a class="headerlink" href="#returns_167" title="Permanent link">&para;</a></h2>
<p>z : array_like
Computed x*log1p(y)</p>
<h2 id="notes_102">Notes<a class="headerlink" href="#notes_102" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.13.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">xlogy</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>xlogy(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>xlogy(x, y)</p>
<p>Compute <code>x*log(y)</code> so that the result is 0 if <code>x = 0</code>.</p>
<h2 id="parameters_148">Parameters<a class="headerlink" href="#parameters_148" title="Permanent link">&para;</a></h2>
<p>x : array_like
Multiplier
y : array_like
Argument</p>
<h2 id="returns_168">Returns<a class="headerlink" href="#returns_168" title="Permanent link">&para;</a></h2>
<p>z : array_like
Computed x*log(y)</p>
<h2 id="notes_103">Notes<a class="headerlink" href="#notes_103" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.13.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">y0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>y0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>y0(x)</p>
<p>Bessel function of the second kind of order 0.</p>
<h2 id="parameters_149">Parameters<a class="headerlink" href="#parameters_149" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float).</p>
<h2 id="returns_169">Returns<a class="headerlink" href="#returns_169" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
Value of the Bessel function of the second kind of order 0 at <code>x</code>.</p>
<h2 id="notes_104">Notes<a class="headerlink" href="#notes_104" title="Permanent link">&para;</a></h2>
<p>The domain is divided into the intervals [0, 5] and (5, infinity). In the
first interval a rational approximation :math:<code>R(x)</code> is employed to
compute,</p>
<p>.. math::</p>
<p>Y_0(x) = R(x) + \frac{2 \log(x) J_0(x)}{\pi},</p>
<p>where :math:<code>J_0</code> is the Bessel function of the first kind of order 0.</p>
<p>In the second interval, the Hankel asymptotic expansion is employed with
two rational functions of degree 6/6 and 7/7.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>y0</code>.</p>
<h2 id="see-also_113">See also<a class="headerlink" href="#see-also_113" title="Permanent link">&para;</a></h2>
<p>j0
yv</p>
<h2 id="references_113">References<a class="headerlink" href="#references_113" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">y1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>y1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>y1(x)</p>
<p>Bessel function of the second kind of order 1.</p>
<h2 id="parameters_150">Parameters<a class="headerlink" href="#parameters_150" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float).</p>
<h2 id="returns_170">Returns<a class="headerlink" href="#returns_170" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
Value of the Bessel function of the second kind of order 1 at <code>x</code>.</p>
<h2 id="notes_105">Notes<a class="headerlink" href="#notes_105" title="Permanent link">&para;</a></h2>
<p>The domain is divided into the intervals [0, 8] and (8, infinity). In the
first interval a 25 term Chebyshev expansion is used, and computing
:math:<code>J_1</code> (the Bessel function of the first kind) is required. In the
second, the asymptotic trigonometric representation is employed using two
rational functions of degree 5/5.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>y1</code>.</p>
<h2 id="see-also_114">See also<a class="headerlink" href="#see-also_114" title="Permanent link">&para;</a></h2>
<p>j1
yn
yv</p>
<h2 id="references_114">References<a class="headerlink" href="#references_114" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">yn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>yn(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>yn(n, x)</p>
<p>Bessel function of the second kind of integer order and real argument.</p>
<h2 id="parameters_151">Parameters<a class="headerlink" href="#parameters_151" title="Permanent link">&para;</a></h2>
<p>n : array_like
Order (integer).
z : array_like
Argument (float).</p>
<h2 id="returns_171">Returns<a class="headerlink" href="#returns_171" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
Value of the Bessel function, :math:<code>Y_n(x)</code>.</p>
<h2 id="notes_106">Notes<a class="headerlink" href="#notes_106" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>yn</code>.</p>
<p>The function is evaluated by forward recurrence on <code>n</code>, starting with
values computed by the Cephes routines <code>y0</code> and <code>y1</code>. If <code>n = 0</code> or 1,
the routine for <code>y0</code> or <code>y1</code> is called directly.</p>
<h2 id="see-also_115">See also<a class="headerlink" href="#see-also_115" title="Permanent link">&para;</a></h2>
<p>yv : For real order and real or complex argument.</p>
<h2 id="references_115">References<a class="headerlink" href="#references_115" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">yv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>yv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>yv(v, z)</p>
<p>Bessel function of the second kind of real order and complex argument.</p>
<h2 id="parameters_152">Parameters<a class="headerlink" href="#parameters_152" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_172">Returns<a class="headerlink" href="#returns_172" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
Value of the Bessel function of the second kind, :math:<code>Y_v(x)</code>.</p>
<h2 id="notes_107">Notes<a class="headerlink" href="#notes_107" title="Permanent link">&para;</a></h2>
<p>For positive <code>v</code> values, the computation is carried out using the
AMOS [1]_ <code>zbesy</code> routine, which exploits the connection to the Hankel
Bessel functions :math:<code>H_v^{(1)}</code> and :math:<code>H_v^{(2)}</code>,</p>
<p>.. math:: Y_v(z) = \frac{1}{2\imath} (H_v^{(1)} - H_v^{(2)}).</p>
<p>For negative <code>v</code> values the formula,</p>
<p>.. math:: Y_{-v}(z) = Y_v(z) \cos(\pi v) + J_v(z) \sin(\pi v)</p>
<p>is used, where :math:<code>J_v(z)</code> is the Bessel function of the first kind,
computed using the AMOS routine <code>zbesj</code>.  Note that the second term is
exactly zero for integer <code>v</code>; to improve accuracy the second term is
explicitly omitted for <code>v</code> values such that <code>v = floor(v)</code>.</p>
<h2 id="see-also_116">See also<a class="headerlink" href="#see-also_116" title="Permanent link">&para;</a></h2>
<p>yve : :math:<code>Y_v</code> with leading exponential behavior stripped off.</p>
<h2 id="references_116">References<a class="headerlink" href="#references_116" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">yve</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>yve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>yve(v, z)</p>
<p>Exponentially scaled Bessel function of the second kind of real order.</p>
<p>Returns the exponentially scaled Bessel function of the second
kind of real order <code>v</code> at complex <code>z</code>::</p>
<p>yve(v, z) = yv(v, z) * exp(-abs(z.imag))</p>
<h2 id="parameters_153">Parameters<a class="headerlink" href="#parameters_153" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_173">Returns<a class="headerlink" href="#returns_173" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
Value of the exponentially scaled Bessel function.</p>
<h2 id="notes_108">Notes<a class="headerlink" href="#notes_108" title="Permanent link">&para;</a></h2>
<p>For positive <code>v</code> values, the computation is carried out using the
AMOS [1]_ <code>zbesy</code> routine, which exploits the connection to the Hankel
Bessel functions :math:<code>H_v^{(1)}</code> and :math:<code>H_v^{(2)}</code>,</p>
<p>.. math:: Y_v(z) = \frac{1}{2\imath} (H_v^{(1)} - H_v^{(2)}).</p>
<p>For negative <code>v</code> values the formula,</p>
<p>.. math:: Y_{-v}(z) = Y_v(z) \cos(\pi v) + J_v(z) \sin(\pi v)</p>
<p>is used, where :math:<code>J_v(z)</code> is the Bessel function of the first kind,
computed using the AMOS routine <code>zbesj</code>.  Note that the second term is
exactly zero for integer <code>v</code>; to improve accuracy the second term is
explicitly omitted for <code>v</code> values such that <code>v = floor(v)</code>.</p>
<h2 id="references_117">References<a class="headerlink" href="#references_117" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zetac</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zetac(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>zetac(x)</p>
<p>Riemann zeta function minus 1.</p>
<p>This function is defined as</p>
<p>.. math:: \zeta(x) = \sum_{k=2}^{\infty} 1 / k^x,</p>
<p>where <code>x &gt; 1</code>.  For <code>x &lt; 1</code> the analytic continuation is
computed. For more information on the Riemann zeta function, see
[dlmf]_.</p>
<h2 id="parameters_154">Parameters<a class="headerlink" href="#parameters_154" title="Permanent link">&para;</a></h2>
<p>x : array_like of float
Values at which to compute zeta(x) - 1 (must be real).</p>
<h2 id="returns_174">Returns<a class="headerlink" href="#returns_174" title="Permanent link">&para;</a></h2>
<p>out : array_like
Values of zeta(x) - 1.</p>
<h2 id="see-also_117">See Also<a class="headerlink" href="#see-also_117" title="Permanent link">&para;</a></h2>
<p>zeta</p>
<h2 id="examples_60">Examples<a class="headerlink" href="#examples_60" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import zetac, zeta</p>
</blockquote>
</blockquote>
</blockquote>
<p>Some special values:</p>
<blockquote>
<blockquote>
<blockquote>
<p>zetac(2), np.pi**2/6 - 1
(0.64493406684822641, 0.6449340668482264)</p>
<p>zetac(-1), -1.0/12 - 1
(-1.0833333333333333, -1.0833333333333333)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare <code>zetac(x)</code> to <code>zeta(x) - 1</code> for large <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>zetac(60), zeta(60) - 1
(8.673617380119933e-19, 0.0)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_118">References<a class="headerlink" href="#references_118" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/25</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">airy</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>airy(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>airy(z)</p>
<p>Airy functions and their derivatives.</p>
<h2 id="parameters_155">Parameters<a class="headerlink" href="#parameters_155" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex argument.</p>
<h2 id="returns_175">Returns<a class="headerlink" href="#returns_175" title="Permanent link">&para;</a></h2>
<p>Ai, Aip, Bi, Bip : ndarrays
Airy functions Ai and Bi, and their derivatives Aip and Bip.</p>
<h2 id="notes_109">Notes<a class="headerlink" href="#notes_109" title="Permanent link">&para;</a></h2>
<p>The Airy functions Ai and Bi are two independent solutions of</p>
<p>.. math:: y''(x) = x y(x).</p>
<p>For real <code>z</code> in [-10, 10], the computation is carried out by calling
the Cephes [1]_ <code>airy</code> routine, which uses power series summation
for small <code>z</code> and rational minimax approximations for large <code>z</code>.</p>
<p>Outside this range, the AMOS [2]_ <code>zairy</code> and <code>zbiry</code> routines are
employed.  They are computed using power series for :math:<code>|z| &lt; 1</code> and
the following relations to modified Bessel functions for larger <code>z</code>
(where :math:<code>t \equiv 2 z^{3/2}/3</code>):</p>
<p>.. math::</p>
<p>Ai(z) = \frac{1}{\pi \sqrt{3}} K_{1/3}(t)</p>
<p>Ai'(z) = -\frac{z}{\pi \sqrt{3}} K_{2/3}(t)</p>
<p>Bi(z) = \sqrt{\frac{z}{3}} \left(I_{-1/3}(t) + I_{1/3}(t) \right)</p>
<p>Bi'(z) = \frac{z}{\sqrt{3}} \left(I_{-2/3}(t) + I_{2/3}(t)\right)</p>
<h2 id="see-also_118">See also<a class="headerlink" href="#see-also_118" title="Permanent link">&para;</a></h2>
<p>airye : exponentially scaled Airy functions.</p>
<h2 id="references_119">References<a class="headerlink" href="#references_119" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/
.. [2] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<h2 id="examples_61">Examples<a class="headerlink" href="#examples_61" title="Permanent link">&para;</a></h2>
<p>Compute the Airy functions on the interval [-15, 5].</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
x = np.linspace(-15, 5, 201)
ai, aip, bi, bip = special.airy(x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot Ai(x) and Bi(x).</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.plot(x, ai, 'r', label='Ai(x)')
plt.plot(x, bi, 'b--', label='Bi(x)')
plt.ylim(-0.5, 1.0)
plt.grid()
plt.legend(loc='upper left')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arange</span> <span class="o">:</span> <span class="o">?</span><span class="n">start</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">step</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">stop</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>arange([start,] stop[, step,], dtype=None)</p>
<p>Return evenly spaced values within a given interval.</p>
<p>Values are generated within the half-open interval <code>[start, stop)</code>
(in other words, the interval including <code>start</code> but excluding <code>stop</code>).
For integer arguments the function is equivalent to the Python built-in
<code>range</code> function, but returns an ndarray rather than a list.</p>
<p>When using a non-integer step, such as 0.1, the results will often not
be consistent.  It is better to use <code>numpy.linspace</code> for these cases.</p>
<h2 id="parameters_156">Parameters<a class="headerlink" href="#parameters_156" title="Permanent link">&para;</a></h2>
<p>start : number, optional
Start of interval.  The interval includes this value.  The default
start value is 0.
stop : number
End of interval.  The interval does not include this value, except
in some cases where <code>step</code> is not an integer and floating point
round-off affects the length of <code>out</code>.
step : number, optional
Spacing between values.  For any output <code>out</code>, this is the distance
between two adjacent values, <code>out[i+1] - out[i]</code>.  The default
step size is 1.  If <code>step</code> is specified as a position argument,
<code>start</code> must also be given.
dtype : dtype
The type of the output array.  If <code>dtype</code> is not given, infer the data
type from the other input arguments.</p>
<h2 id="returns_176">Returns<a class="headerlink" href="#returns_176" title="Permanent link">&para;</a></h2>
<p>arange : ndarray
Array of evenly spaced values.</p>
<p>For floating point arguments, the length of the result is
<code>ceil((stop - start)/step)</code>.  Because of floating point overflow,
this rule may result in the last element of <code>out</code> being greater
than <code>stop</code>.</p>
<h2 id="see-also_119">See Also<a class="headerlink" href="#see-also_119" title="Permanent link">&para;</a></h2>
<p>numpy.linspace : Evenly spaced numbers with careful handling of endpoints.
numpy.ogrid: Arrays of evenly spaced numbers in N-dimensions.
numpy.mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.</p>
<h2 id="examples_62">Examples<a class="headerlink" href="#examples_62" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.arange(3)
array([0, 1, 2])
np.arange(3.0)
array([ 0.,  1.,  2.])
np.arange(3,7)
array([3, 4, 5, 6])
np.arange(3,7,2)
array([3, 5])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arccos</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Trigonometric inverse cosine, element-wise.</p>
<p>The inverse of <code>cos</code> so that, if <code>y = cos(x)</code>, then <code>x = arccos(y)</code>.</p>
<h2 id="parameters_157">Parameters<a class="headerlink" href="#parameters_157" title="Permanent link">&para;</a></h2>
<p>x : array_like
<code>x</code>-coordinate on the unit circle.
For real arguments, the domain is [-1, 1].
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_177">Returns<a class="headerlink" href="#returns_177" title="Permanent link">&para;</a></h2>
<p>angle : ndarray
The angle of the ray intersecting the unit circle at the given
<code>x</code>-coordinate in radians [0, pi].
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_120">See Also<a class="headerlink" href="#see-also_120" title="Permanent link">&para;</a></h2>
<p>cos, arctan, arcsin, emath.arccos</p>
<h2 id="notes_110">Notes<a class="headerlink" href="#notes_110" title="Permanent link">&para;</a></h2>
<p><code>arccos</code> is a multivalued function: for each <code>x</code> there are infinitely
many numbers <code>z</code> such that <code>cos(z) = x</code>. The convention is to return
the angle <code>z</code> whose real part lies in <code>[0, pi]</code>.</p>
<p>For real-valued input data types, <code>arccos</code> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arccos</code> is a complex analytic function that
has branch cuts <code>[-inf, -1]</code> and <code>[1, inf]</code> and is continuous from
above on the former and from below on the latter.</p>
<p>The inverse <code>cos</code> is also known as <code>acos</code> or cos^-1.</p>
<h2 id="references_120">References<a class="headerlink" href="#references_120" title="Permanent link">&para;</a></h2>
<p>M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/</p>
<h2 id="examples_63">Examples<a class="headerlink" href="#examples_63" title="Permanent link">&para;</a></h2>
<p>We expect the arccos of 1 to be 0, and of -1 to be pi:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.arccos([1, -1])
array([ 0.        ,  3.14159265])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot arccos:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
x = np.linspace(-1, 1, num=100)
plt.plot(x, np.arccos(x))
plt.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">around</span> <span class="o">:</span> <span class="o">?</span><span class="n">decimals</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evenly round to the given number of decimals.</p>
<h2 id="parameters_158">Parameters<a class="headerlink" href="#parameters_158" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data.
decimals : int, optional
Number of decimal places to round to (default: 0).  If
decimals is negative, it specifies the number of positions to
the left of the decimal point.
out : ndarray, optional
Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary. See <code>ufuncs-output-type</code> for more
details.</p>
<h2 id="returns_178">Returns<a class="headerlink" href="#returns_178" title="Permanent link">&para;</a></h2>
<p>rounded_array : ndarray
An array of the same type as <code>a</code>, containing the rounded values.
Unless <code>out</code> was specified, a new array is created.  A reference to
the result is returned.</p>
<p>The real and imaginary parts of complex numbers are rounded
separately.  The result of rounding a float is a float.</p>
<h2 id="see-also_121">See Also<a class="headerlink" href="#see-also_121" title="Permanent link">&para;</a></h2>
<p>ndarray.round : equivalent method</p>
<p>ceil, fix, floor, rint, trunc</p>
<h2 id="notes_111">Notes<a class="headerlink" href="#notes_111" title="Permanent link">&para;</a></h2>
<p>For values exactly halfway between rounded decimal values, NumPy
rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
-0.5 and 0.5 round to 0.0, etc.</p>
<p><code>np.around</code> uses a fast but sometimes inexact algorithm to round
floating-point datatypes. For positive <code>decimals</code> it is equivalent to
<code>np.true_divide(np.rint(a * 10**decimals), 10**decimals)</code>, which has
error due to the inexact representation of decimal fractions in the IEEE
floating point standard [1]_ and errors introduced when scaling by powers
of ten. For instance, note the extra '1' in the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.round(56294995342131.5, 3)
56294995342131.51</p>
</blockquote>
</blockquote>
</blockquote>
<p>If your goal is to print such values with a fixed number of decimals, it is
preferable to use numpy's float printing routines to limit the number of
printed decimals:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.format_float_positional(56294995342131.5, precision=3)
'56294995342131.5'</p>
</blockquote>
</blockquote>
</blockquote>
<p>The float printing routines use an accurate but much more computationally
demanding algorithm to compute the number of digits after the decimal
point.</p>
<p>Alternatively, Python's builtin <code>round</code> function uses a more accurate
but slower algorithm for 64-bit floating point values:</p>
<blockquote>
<blockquote>
<blockquote>
<p>round(56294995342131.5, 3)
56294995342131.5
np.round(16.055, 2), round(16.055, 2)  # equals 16.0549999999999997
(16.06, 16.05)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_121">References<a class="headerlink" href="#references_121" title="Permanent link">&para;</a></h2>
<p>.. [1] 'Lecture Notes on the Status of IEEE 754', William Kahan,
https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF
.. [2] 'How Futile are Mindless Assessments of
Roundoff in Floating-Point Computation?', William Kahan,
https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf</p>
<h2 id="examples_64">Examples<a class="headerlink" href="#examples_64" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.around([0.37, 1.64])
array([0.,  2.])
np.around([0.37, 1.64], decimals=1)
array([0.4,  1.6])
np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value
array([0.,  2.,  2.,  4.,  4.])
np.around([1,2,3,11], decimals=1) # ndarray of ints is returned
array([ 1,  2,  3, 11])
np.around([1,2,3,11], decimals=-1)
array([ 0,  0,  0, 10])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binom</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>binom(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>binom(n, k)</p>
<p>Binomial coefficient</p>
<h2 id="see-also_122">See Also<a class="headerlink" href="#see-also_122" title="Permanent link">&para;</a></h2>
<p>comb : The number of combinations of N things taken k at a time.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">c_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (first kind) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the first kind, :math:<code>C_n(x)</code>. These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-2, 2]</code>
with weight function :math:<code>w(x) = 1 / \sqrt{1 - (x/2)^2}</code>. See
22.2.6 in [AS]_ for more details.</p>
<h2 id="parameters_159">Parameters<a class="headerlink" href="#parameters_159" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_179">Returns<a class="headerlink" href="#returns_179" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_123">See Also<a class="headerlink" href="#see-also_123" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_122">References<a class="headerlink" href="#references_122" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cg_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Gegenbauer quadrature.</p>
<p>Compute the sample points and weights for Gauss-Gegenbauer
quadrature. The sample points are the roots of the n-th degree
Gegenbauer polynomial, :math:<code>C^{\alpha}_n(x)</code>. These sample
points and weights correctly integrate polynomials of degree
:math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code> with
weight function :math:<code>w(x) = (1 - x^2)^{\alpha - 1/2}</code>. See
22.2.3 in [AS]_ for more details.</p>
<h2 id="parameters_160">Parameters<a class="headerlink" href="#parameters_160" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
alpha : float
alpha must be &gt; -0.5
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_180">Returns<a class="headerlink" href="#returns_180" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_124">See Also<a class="headerlink" href="#see-also_124" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_123">References<a class="headerlink" href="#references_123" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chebyc</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Chebyshev polynomial of the first kind on :math:<code>[-2, 2]</code>.</p>
<p>Defined as :math:<code>C_n(x) = 2T_n(x/2)</code>, where :math:<code>T_n</code> is the
nth Chebychev polynomial of the first kind.</p>
<h2 id="parameters_161">Parameters<a class="headerlink" href="#parameters_161" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_181">Returns<a class="headerlink" href="#returns_181" title="Permanent link">&para;</a></h2>
<p>C : orthopoly1d
Chebyshev polynomial of the first kind on :math:<code>[-2, 2]</code>.</p>
<h2 id="notes_112">Notes<a class="headerlink" href="#notes_112" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>C_n(x)</code> are orthogonal over :math:<code>[-2, 2]</code>
with weight function :math:<code>1/\sqrt{1 - (x/2)^2}</code>.</p>
<h2 id="see-also_125">See Also<a class="headerlink" href="#see-also_125" title="Permanent link">&para;</a></h2>
<p>chebyt : Chebyshev polynomial of the first kind.</p>
<h2 id="references_124">References<a class="headerlink" href="#references_124" title="Permanent link">&para;</a></h2>
<p>.. [1] Abramowitz and Stegun, 'Handbook of Mathematical Functions'
Section 22. National Bureau of Standards, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chebys</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Chebyshev polynomial of the second kind on :math:<code>[-2, 2]</code>.</p>
<p>Defined as :math:<code>S_n(x) = U_n(x/2)</code> where :math:<code>U_n</code> is the
nth Chebychev polynomial of the second kind.</p>
<h2 id="parameters_162">Parameters<a class="headerlink" href="#parameters_162" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_182">Returns<a class="headerlink" href="#returns_182" title="Permanent link">&para;</a></h2>
<p>S : orthopoly1d
Chebyshev polynomial of the second kind on :math:<code>[-2, 2]</code>.</p>
<h2 id="notes_113">Notes<a class="headerlink" href="#notes_113" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>S_n(x)</code> are orthogonal over :math:<code>[-2, 2]</code>
with weight function :math:<code>\sqrt{1 - (x/2)}^2</code>.</p>
<h2 id="see-also_126">See Also<a class="headerlink" href="#see-also_126" title="Permanent link">&para;</a></h2>
<p>chebyu : Chebyshev polynomial of the second kind</p>
<h2 id="references_125">References<a class="headerlink" href="#references_125" title="Permanent link">&para;</a></h2>
<p>.. [1] Abramowitz and Stegun, 'Handbook of Mathematical Functions'
Section 22. National Bureau of Standards, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Chebyshev polynomial of the first kind.</p>
<p>Defined to be the solution of</p>
<p>.. math::
(1 - x^2)\frac{d^2}{dx^2}T_n - x\frac{d}{dx}T_n + n^2T_n = 0;</p>
<p>:math:<code>T_n</code> is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_163">Parameters<a class="headerlink" href="#parameters_163" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_183">Returns<a class="headerlink" href="#returns_183" title="Permanent link">&para;</a></h2>
<p>T : orthopoly1d
Chebyshev polynomial of the first kind.</p>
<h2 id="notes_114">Notes<a class="headerlink" href="#notes_114" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>T_n</code> are orthogonal over :math:<code>[-1, 1]</code>
with weight function :math:<code>(1 - x^2)^{-1/2}</code>.</p>
<h2 id="see-also_127">See Also<a class="headerlink" href="#see-also_127" title="Permanent link">&para;</a></h2>
<p>chebyu : Chebyshev polynomial of the second kind.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Chebyshev polynomial of the second kind.</p>
<p>Defined to be the solution of</p>
<p>.. math::
(1 - x^2)\frac{d^2}{dx^2}U_n - 3x\frac{d}{dx}U_n
+ n(n + 2)U_n = 0;</p>
<p>:math:<code>U_n</code> is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_164">Parameters<a class="headerlink" href="#parameters_164" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_184">Returns<a class="headerlink" href="#returns_184" title="Permanent link">&para;</a></h2>
<p>U : orthopoly1d
Chebyshev polynomial of the second kind.</p>
<h2 id="notes_115">Notes<a class="headerlink" href="#notes_115" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>U_n</code> are orthogonal over :math:<code>[-1, 1]</code>
with weight function :math:<code>(1 - x^2)^{1/2}</code>.</p>
<h2 id="see-also_128">See Also<a class="headerlink" href="#see-also_128" title="Permanent link">&para;</a></h2>
<p>chebyt : Chebyshev polynomial of the first kind.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cos</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Cosine element-wise.</p>
<h2 id="parameters_165">Parameters<a class="headerlink" href="#parameters_165" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array in radians.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_185">Returns<a class="headerlink" href="#returns_185" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The corresponding cosine values.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_116">Notes<a class="headerlink" href="#notes_116" title="Permanent link">&para;</a></h2>
<p>If <code>out</code> is provided, the function writes the result into it,
and returns a reference to <code>out</code>.  (See Examples)</p>
<h2 id="references_126">References<a class="headerlink" href="#references_126" title="Permanent link">&para;</a></h2>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.</p>
<h2 id="examples_65">Examples<a class="headerlink" href="#examples_65" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.cos(np.array([0, np.pi/2, np.pi]))
array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])</p>
<h1 id="example-of-providing-the-optional-output-parameter">Example of providing the optional output parameter<a class="headerlink" href="#example-of-providing-the-optional-output-parameter" title="Permanent link">&para;</a></h1>
<p>out1 = np.array([0], dtype='d')
out2 = np.cos([0.1], out1)
out2 is out1
True</p>
<h1 id="example-of-valueerror-due-to-provision-of-shape-mis-matched-out">Example of ValueError due to provision of shape mis-matched <code>out</code><a class="headerlink" href="#example-of-valueerror-due-to-provision-of-shape-mis-matched-out" title="Permanent link">&para;</a></h1>
<p>np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_chebyc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_chebyc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_chebyc(n, x, out=None)</p>
<p>Evaluate Chebyshev polynomial of the first kind on [-2, 2] at a
point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>C_n(x) = 2 T_n(x/2)</p>
<p>where :math:<code>T_n</code> is a Chebyshev polynomial of the first kind. See
22.5.11 in [AS]_ for details.</p>
<h2 id="parameters_166">Parameters<a class="headerlink" href="#parameters_166" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>eval_chebyt</code>.
x : array_like
Points at which to evaluate the Chebyshev polynomial</p>
<h2 id="returns_186">Returns<a class="headerlink" href="#returns_186" title="Permanent link">&para;</a></h2>
<p>C : ndarray
Values of the Chebyshev polynomial</p>
<h2 id="see-also_129">See Also<a class="headerlink" href="#see-also_129" title="Permanent link">&para;</a></h2>
<p>roots_chebyc : roots and quadrature weights of Chebyshev
polynomials of the first kind on [-2, 2]
chebyc : Chebyshev polynomial object
numpy.polynomial.chebyshev.Chebyshev : Chebyshev series
eval_chebyt : evaluate Chebycshev polynomials of the first kind</p>
<h2 id="references_127">References<a class="headerlink" href="#references_127" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<h2 id="examples_66">Examples<a class="headerlink" href="#examples_66" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>They are a scaled version of the Chebyshev polynomials of the
first kind.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-2, 2, 6)
sc.eval_chebyc(3, x)
array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])
2 * sc.eval_chebyt(3, x / 2)
array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_chebys</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_chebys(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_chebys(n, x, out=None)</p>
<p>Evaluate Chebyshev polynomial of the second kind on [-2, 2] at a
point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>S_n(x) = U_n(x/2)</p>
<p>where :math:<code>U_n</code> is a Chebyshev polynomial of the second
kind. See 22.5.13 in [AS]_ for details.</p>
<h2 id="parameters_167">Parameters<a class="headerlink" href="#parameters_167" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>eval_chebyu</code>.
x : array_like
Points at which to evaluate the Chebyshev polynomial</p>
<h2 id="returns_187">Returns<a class="headerlink" href="#returns_187" title="Permanent link">&para;</a></h2>
<p>S : ndarray
Values of the Chebyshev polynomial</p>
<h2 id="see-also_130">See Also<a class="headerlink" href="#see-also_130" title="Permanent link">&para;</a></h2>
<p>roots_chebys : roots and quadrature weights of Chebyshev
polynomials of the second kind on [-2, 2]
chebys : Chebyshev polynomial object
eval_chebyu : evaluate Chebyshev polynomials of the second kind</p>
<h2 id="references_128">References<a class="headerlink" href="#references_128" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<h2 id="examples_67">Examples<a class="headerlink" href="#examples_67" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>They are a scaled version of the Chebyshev polynomials of the
second kind.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-2, 2, 6)
sc.eval_chebys(3, x)
array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])
sc.eval_chebyu(3, x / 2)
array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_chebyt(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_chebyt(n, x, out=None)</p>
<p>Evaluate Chebyshev polynomial of the first kind at a point.</p>
<p>The Chebyshev polynomials of the first kind can be defined via the
Gauss hypergeometric function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>T_n(x) = {}_2F_1(n, -n; 1/2; (1 - x)/2).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.47 in [AS]_ for details.</p>
<h2 id="parameters_168">Parameters<a class="headerlink" href="#parameters_168" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to the Gauss hypergeometric
function.
x : array_like
Points at which to evaluate the Chebyshev polynomial</p>
<h2 id="returns_188">Returns<a class="headerlink" href="#returns_188" title="Permanent link">&para;</a></h2>
<p>T : ndarray
Values of the Chebyshev polynomial</p>
<h2 id="see-also_131">See Also<a class="headerlink" href="#see-also_131" title="Permanent link">&para;</a></h2>
<p>roots_chebyt : roots and quadrature weights of Chebyshev
polynomials of the first kind
chebyu : Chebychev polynomial object
eval_chebyu : evaluate Chebyshev polynomials of the second kind
hyp2f1 : Gauss hypergeometric function
numpy.polynomial.chebyshev.Chebyshev : Chebyshev series</p>
<h2 id="notes_117">Notes<a class="headerlink" href="#notes_117" title="Permanent link">&para;</a></h2>
<p>This routine is numerically stable for <code>x</code> in <code>[-1, 1]</code> at least
up to order <code>10000</code>.</p>
<h2 id="references_129">References<a class="headerlink" href="#references_129" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_chebyu(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_chebyu(n, x, out=None)</p>
<p>Evaluate Chebyshev polynomial of the second kind at a point.</p>
<p>The Chebyshev polynomials of the second kind can be defined via
the Gauss hypergeometric function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>U_n(x) = (n + 1) {}_2F_1(-n, n + 2; 3/2; (1 - x)/2).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.48 in [AS]_ for details.</p>
<h2 id="parameters_169">Parameters<a class="headerlink" href="#parameters_169" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to the Gauss hypergeometric
function.
x : array_like
Points at which to evaluate the Chebyshev polynomial</p>
<h2 id="returns_189">Returns<a class="headerlink" href="#returns_189" title="Permanent link">&para;</a></h2>
<p>U : ndarray
Values of the Chebyshev polynomial</p>
<h2 id="see-also_132">See Also<a class="headerlink" href="#see-also_132" title="Permanent link">&para;</a></h2>
<p>roots_chebyu : roots and quadrature weights of Chebyshev
polynomials of the second kind
chebyu : Chebyshev polynomial object
eval_chebyt : evaluate Chebyshev polynomials of the first kind
hyp2f1 : Gauss hypergeometric function</p>
<h2 id="references_130">References<a class="headerlink" href="#references_130" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_gegenbauer</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_gegenbauer(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_gegenbauer(n, alpha, x, out=None)</p>
<p>Evaluate Gegenbauer polynomial at a point.</p>
<p>The Gegenbauer polynomials can be defined via the Gauss
hypergeometric function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>C_n^{(\alpha)} = \frac{(2\alpha)_n}{\Gamma(n + 1)}
{}_2F_1(-n, 2\alpha + n; \alpha + 1/2; (1 - z)/2).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.46 in [AS]_ for details.</p>
<h2 id="parameters_170">Parameters<a class="headerlink" href="#parameters_170" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to the Gauss hypergeometric
function.
alpha : array_like
Parameter
x : array_like
Points at which to evaluate the Gegenbauer polynomial</p>
<h2 id="returns_190">Returns<a class="headerlink" href="#returns_190" title="Permanent link">&para;</a></h2>
<p>C : ndarray
Values of the Gegenbauer polynomial</p>
<h2 id="see-also_133">See Also<a class="headerlink" href="#see-also_133" title="Permanent link">&para;</a></h2>
<p>roots_gegenbauer : roots and quadrature weights of Gegenbauer
polynomials
gegenbauer : Gegenbauer polynomial object
hyp2f1 : Gauss hypergeometric function</p>
<h2 id="references_131">References<a class="headerlink" href="#references_131" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_genlaguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_genlaguerre(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_genlaguerre(n, alpha, x, out=None)</p>
<p>Evaluate generalized Laguerre polynomial at a point.</p>
<p>The generalized Laguerre polynomials can be defined via the
confluent hypergeometric function :math:<code>{}_1F_1</code> as</p>
<p>.. math::</p>
<p>L_n^{(\alpha)}(x) = \binom{n + \alpha}{n}
{}_1F_1(-n, \alpha + 1, x).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.54 in [AS]_ for details. The Laguerre
polynomials are the special case where :math:<code>\alpha = 0</code>.</p>
<h2 id="parameters_171">Parameters<a class="headerlink" href="#parameters_171" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer the result is
determined via the relation to the confluent hypergeometric
function.
alpha : array_like
Parameter; must have <code>alpha &gt; -1</code>
x : array_like
Points at which to evaluate the generalized Laguerre
polynomial</p>
<h2 id="returns_191">Returns<a class="headerlink" href="#returns_191" title="Permanent link">&para;</a></h2>
<p>L : ndarray
Values of the generalized Laguerre polynomial</p>
<h2 id="see-also_134">See Also<a class="headerlink" href="#see-also_134" title="Permanent link">&para;</a></h2>
<p>roots_genlaguerre : roots and quadrature weights of generalized
Laguerre polynomials
genlaguerre : generalized Laguerre polynomial object
hyp1f1 : confluent hypergeometric function
eval_laguerre : evaluate Laguerre polynomials</p>
<h2 id="references_132">References<a class="headerlink" href="#references_132" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_hermite</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_hermite(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_hermite(n, x, out=None)</p>
<p>Evaluate physicist's Hermite polynomial at a point.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n} e^{-x^2};</p>
<p>:math:<code>H_n</code> is a polynomial of degree :math:<code>n</code>. See 22.11.7 in
[AS]_ for details.</p>
<h2 id="parameters_172">Parameters<a class="headerlink" href="#parameters_172" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial
x : array_like
Points at which to evaluate the Hermite polynomial</p>
<h2 id="returns_192">Returns<a class="headerlink" href="#returns_192" title="Permanent link">&para;</a></h2>
<p>H : ndarray
Values of the Hermite polynomial</p>
<h2 id="see-also_135">See Also<a class="headerlink" href="#see-also_135" title="Permanent link">&para;</a></h2>
<p>roots_hermite : roots and quadrature weights of physicist's
Hermite polynomials
hermite : physicist's Hermite polynomial object
numpy.polynomial.hermite.Hermite : Physicist's Hermite series
eval_hermitenorm : evaluate Probabilist's Hermite polynomials</p>
<h2 id="references_133">References<a class="headerlink" href="#references_133" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_hermitenorm</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_hermitenorm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_hermitenorm(n, x, out=None)</p>
<p>Evaluate probabilist's (normalized) Hermite polynomial at a
point.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>He_n(x) = (-1)^n e^{x^2/2} \frac{d^n}{dx^n} e^{-x^2/2};</p>
<p>:math:<code>He_n</code> is a polynomial of degree :math:<code>n</code>. See 22.11.8 in
[AS]_ for details.</p>
<h2 id="parameters_173">Parameters<a class="headerlink" href="#parameters_173" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial
x : array_like
Points at which to evaluate the Hermite polynomial</p>
<h2 id="returns_193">Returns<a class="headerlink" href="#returns_193" title="Permanent link">&para;</a></h2>
<p>He : ndarray
Values of the Hermite polynomial</p>
<h2 id="see-also_136">See Also<a class="headerlink" href="#see-also_136" title="Permanent link">&para;</a></h2>
<p>roots_hermitenorm : roots and quadrature weights of probabilist's
Hermite polynomials
hermitenorm : probabilist's Hermite polynomial object
numpy.polynomial.hermite_e.HermiteE : Probabilist's Hermite series
eval_hermite : evaluate physicist's Hermite polynomials</p>
<h2 id="references_134">References<a class="headerlink" href="#references_134" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_jacobi(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_jacobi(n, alpha, beta, x, out=None)</p>
<p>Evaluate Jacobi polynomial at a point.</p>
<p>The Jacobi polynomials can be defined via the Gauss hypergeometric
function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>P_n^{(\alpha, \beta)}(x) = \frac{(\alpha + 1)_n}{\Gamma(n + 1)}
{}_2F_1(-n, 1 + \alpha + \beta + n; \alpha + 1; (1 - z)/2)</p>
<p>where :math:<code>(\cdot)_n</code> is the Pochhammer symbol; see <code>poch</code>. When
:math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.42 in [AS]_ for details.</p>
<h2 id="parameters_174">Parameters<a class="headerlink" href="#parameters_174" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer the result is
determined via the relation to the Gauss hypergeometric
function.
alpha : array_like
Parameter
beta : array_like
Parameter
x : array_like
Points at which to evaluate the polynomial</p>
<h2 id="returns_194">Returns<a class="headerlink" href="#returns_194" title="Permanent link">&para;</a></h2>
<p>P : ndarray
Values of the Jacobi polynomial</p>
<h2 id="see-also_137">See Also<a class="headerlink" href="#see-also_137" title="Permanent link">&para;</a></h2>
<p>roots_jacobi : roots and quadrature weights of Jacobi polynomials
jacobi : Jacobi polynomial object
hyp2f1 : Gauss hypergeometric function</p>
<h2 id="references_135">References<a class="headerlink" href="#references_135" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_laguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_laguerre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_laguerre(n, x, out=None)</p>
<p>Evaluate Laguerre polynomial at a point.</p>
<p>The Laguerre polynomials can be defined via the confluent
hypergeometric function :math:<code>{}_1F_1</code> as</p>
<p>.. math::</p>
<p>L_n(x) = {}_1F_1(-n, 1, x).</p>
<p>See 22.5.16 and 22.5.54 in [AS]_ for details. When :math:<code>n</code> is an
integer the result is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_175">Parameters<a class="headerlink" href="#parameters_175" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer the result is
determined via the relation to the confluent hypergeometric
function.
x : array_like
Points at which to evaluate the Laguerre polynomial</p>
<h2 id="returns_195">Returns<a class="headerlink" href="#returns_195" title="Permanent link">&para;</a></h2>
<p>L : ndarray
Values of the Laguerre polynomial</p>
<h2 id="see-also_138">See Also<a class="headerlink" href="#see-also_138" title="Permanent link">&para;</a></h2>
<p>roots_laguerre : roots and quadrature weights of Laguerre
polynomials
laguerre : Laguerre polynomial object
numpy.polynomial.laguerre.Laguerre : Laguerre series
eval_genlaguerre : evaluate generalized Laguerre polynomials</p>
<h2 id="references_136">References<a class="headerlink" href="#references_136" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_legendre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_legendre(n, x, out=None)</p>
<p>Evaluate Legendre polynomial at a point.</p>
<p>The Legendre polynomials can be defined via the Gauss
hypergeometric function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>P_n(x) = {}_2F_1(-n, n + 1; 1; (1 - x)/2).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.49 in [AS]_ for details.</p>
<h2 id="parameters_176">Parameters<a class="headerlink" href="#parameters_176" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to the Gauss hypergeometric
function.
x : array_like
Points at which to evaluate the Legendre polynomial</p>
<h2 id="returns_196">Returns<a class="headerlink" href="#returns_196" title="Permanent link">&para;</a></h2>
<p>P : ndarray
Values of the Legendre polynomial</p>
<h2 id="see-also_139">See Also<a class="headerlink" href="#see-also_139" title="Permanent link">&para;</a></h2>
<p>roots_legendre : roots and quadrature weights of Legendre
polynomials
legendre : Legendre polynomial object
hyp2f1 : Gauss hypergeometric function
numpy.polynomial.legendre.Legendre : Legendre series</p>
<h2 id="references_137">References<a class="headerlink" href="#references_137" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_sh_chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_sh_chebyt(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_sh_chebyt(n, x, out=None)</p>
<p>Evaluate shifted Chebyshev polynomial of the first kind at a
point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>T_n^*(x) = T_n(2x - 1)</p>
<p>where :math:<code>T_n</code> is a Chebyshev polynomial of the first kind. See
22.5.14 in [AS]_ for details.</p>
<h2 id="parameters_177">Parameters<a class="headerlink" href="#parameters_177" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>eval_chebyt</code>.
x : array_like
Points at which to evaluate the shifted Chebyshev polynomial</p>
<h2 id="returns_197">Returns<a class="headerlink" href="#returns_197" title="Permanent link">&para;</a></h2>
<p>T : ndarray
Values of the shifted Chebyshev polynomial</p>
<h2 id="see-also_140">See Also<a class="headerlink" href="#see-also_140" title="Permanent link">&para;</a></h2>
<p>roots_sh_chebyt : roots and quadrature weights of shifted
Chebyshev polynomials of the first kind
sh_chebyt : shifted Chebyshev polynomial object
eval_chebyt : evaluate Chebyshev polynomials of the first kind
numpy.polynomial.chebyshev.Chebyshev : Chebyshev series</p>
<h2 id="references_138">References<a class="headerlink" href="#references_138" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_sh_chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_sh_chebyu(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_sh_chebyu(n, x, out=None)</p>
<p>Evaluate shifted Chebyshev polynomial of the second kind at a
point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>U_n^*(x) = U_n(2x - 1)</p>
<p>where :math:<code>U_n</code> is a Chebyshev polynomial of the first kind. See
22.5.15 in [AS]_ for details.</p>
<h2 id="parameters_178">Parameters<a class="headerlink" href="#parameters_178" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>eval_chebyu</code>.
x : array_like
Points at which to evaluate the shifted Chebyshev polynomial</p>
<h2 id="returns_198">Returns<a class="headerlink" href="#returns_198" title="Permanent link">&para;</a></h2>
<p>U : ndarray
Values of the shifted Chebyshev polynomial</p>
<h2 id="see-also_141">See Also<a class="headerlink" href="#see-also_141" title="Permanent link">&para;</a></h2>
<p>roots_sh_chebyu : roots and quadrature weights of shifted
Chebychev polynomials of the second kind
sh_chebyu : shifted Chebyshev polynomial object
eval_chebyu : evaluate Chebyshev polynomials of the second kind</p>
<h2 id="references_139">References<a class="headerlink" href="#references_139" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_sh_jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_sh_jacobi(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_sh_jacobi(n, p, q, x, out=None)</p>
<p>Evaluate shifted Jacobi polynomial at a point.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>G_n^{(p, q)}(x)
= \binom{2n + p - 1}{n}^{-1} P_n^{(p - q, q - 1)}(2x - 1),</p>
<p>where :math:<code>P_n^{(\cdot, \cdot)}</code> is the n-th Jacobi
polynomial. See 22.5.2 in [AS]_ for details.</p>
<h2 id="parameters_179">Parameters<a class="headerlink" href="#parameters_179" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>binom</code> and <code>eval_jacobi</code>.
p : float
Parameter
q : float
Parameter</p>
<h2 id="returns_199">Returns<a class="headerlink" href="#returns_199" title="Permanent link">&para;</a></h2>
<p>G : ndarray
Values of the shifted Jacobi polynomial.</p>
<h2 id="see-also_142">See Also<a class="headerlink" href="#see-also_142" title="Permanent link">&para;</a></h2>
<p>roots_sh_jacobi : roots and quadrature weights of shifted Jacobi
polynomials
sh_jacobi : shifted Jacobi polynomial object
eval_jacobi : evaluate Jacobi polynomials</p>
<h2 id="references_140">References<a class="headerlink" href="#references_140" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_sh_legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_sh_legendre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_sh_legendre(n, x, out=None)</p>
<p>Evaluate shifted Legendre polynomial at a point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>P_n^*(x) = P_n(2x - 1)</p>
<p>where :math:<code>P_n</code> is a Legendre polynomial. See 2.2.11 in [AS]_
for details.</p>
<h2 id="parameters_180">Parameters<a class="headerlink" href="#parameters_180" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the value is
determined via the relation to <code>eval_legendre</code>.
x : array_like
Points at which to evaluate the shifted Legendre polynomial</p>
<h2 id="returns_200">Returns<a class="headerlink" href="#returns_200" title="Permanent link">&para;</a></h2>
<p>P : ndarray
Values of the shifted Legendre polynomial</p>
<h2 id="see-also_143">See Also<a class="headerlink" href="#see-also_143" title="Permanent link">&para;</a></h2>
<p>roots_sh_legendre : roots and quadrature weights of shifted
Legendre polynomials
sh_legendre : shifted Legendre polynomial object
eval_legendre : evaluate Legendre polynomials
numpy.polynomial.legendre.Legendre : Legendre series</p>
<h2 id="references_141">References<a class="headerlink" href="#references_141" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exp</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate the exponential of all elements in the input array.</p>
<h2 id="parameters_181">Parameters<a class="headerlink" href="#parameters_181" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input values.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_201">Returns<a class="headerlink" href="#returns_201" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
Output array, element-wise exponential of <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_144">See Also<a class="headerlink" href="#see-also_144" title="Permanent link">&para;</a></h2>
<p>expm1 : Calculate <code>exp(x) - 1</code> for all elements in the array.
exp2  : Calculate <code>2**x</code> for all elements in the array.</p>
<h2 id="notes_118">Notes<a class="headerlink" href="#notes_118" title="Permanent link">&para;</a></h2>
<p>The irrational number <code>e</code> is also known as Euler's number.  It is
approximately 2.718281, and is the base of the natural logarithm,
<code>ln</code> (this means that, if :math:<code>x = \ln y = \log_e y</code>,
then :math:<code>e^x = y</code>. For real input, <code>exp(x)</code> is always positive.</p>
<p>For complex arguments, <code>x = a + ib</code>, we can write
:math:<code>e^x = e^a e^{ib}</code>.  The first term, :math:<code>e^a</code>, is already
known (it is the real argument, described above).  The second term,
:math:<code>e^{ib}</code>, is :math:<code>\cos b + i \sin b</code>, a function with
magnitude 1 and a periodic phase.</p>
<h2 id="references_142">References<a class="headerlink" href="#references_142" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Exponential function',
https://en.wikipedia.org/wiki/Exponential_function
.. [2] M. Abramovitz and I. A. Stegun, 'Handbook of Mathematical Functions
with Formulas, Graphs, and Mathematical Tables,' Dover, 1964, p. 69,
http://www.math.sfu.ca/~cbm/aands/page_69.htm</p>
<h2 id="examples_68">Examples<a class="headerlink" href="#examples_68" title="Permanent link">&para;</a></h2>
<p>Plot the magnitude and phase of <code>exp(x)</code> in the complex plane:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt</p>
<p>x = np.linspace(-2<em>np.pi, 2</em>np.pi, 100)
xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
out = np.exp(xx)</p>
<p>plt.subplot(121)
plt.imshow(np.abs(out),
...            extent=[-2<em>np.pi, 2</em>np.pi, -2<em>np.pi, 2</em>np.pi], cmap='gray')
plt.title('Magnitude of exp(x)')</p>
<p>plt.subplot(122)
plt.imshow(np.angle(out),
...            extent=[-2<em>np.pi, 2</em>np.pi, -2<em>np.pi, 2</em>np.pi], cmap='hsv')
plt.title('Phase (angle) of exp(x)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">floor</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the floor of the input, element-wise.</p>
<p>The floor of the scalar <code>x</code> is the largest integer <code>i</code>, such that
<code>i &lt;= x</code>.  It is often denoted as :math:<code>\lfloor x \rfloor</code>.</p>
<h2 id="parameters_182">Parameters<a class="headerlink" href="#parameters_182" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input data.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_202">Returns<a class="headerlink" href="#returns_202" title="Permanent link">&para;</a></h2>
<p>y : ndarray or scalar
The floor of each element in <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_145">See Also<a class="headerlink" href="#see-also_145" title="Permanent link">&para;</a></h2>
<p>ceil, trunc, rint</p>
<h2 id="notes_119">Notes<a class="headerlink" href="#notes_119" title="Permanent link">&para;</a></h2>
<p>Some spreadsheet programs calculate the 'floor-towards-zero', in other
words <code>floor(-2.5) == -2</code>.  NumPy instead uses the definition of
<code>floor</code> where <code>floor(-2.5) == -3</code>.</p>
<h2 id="examples_69">Examples<a class="headerlink" href="#examples_69" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
np.floor(a)
array([-2., -2., -1.,  0.,  1.,  1.,  2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gegenbauer</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Gegenbauer (ultraspherical) polynomial.</p>
<p>Defined to be the solution of</p>
<p>.. math::
(1 - x^2)\frac{d^2}{dx^2}C_n^{(\alpha)}
- (2\alpha + 1)x\frac{d}{dx}C_n^{(\alpha)}
+ n(n + 2\alpha)C_n^{(\alpha)} = 0</p>
<p>for :math:<code>\alpha &gt; -1/2</code>; :math:<code>C_n^{(\alpha)}</code> is a polynomial
of degree :math:<code>n</code>.</p>
<h2 id="parameters_183">Parameters<a class="headerlink" href="#parameters_183" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_203">Returns<a class="headerlink" href="#returns_203" title="Permanent link">&para;</a></h2>
<p>C : orthopoly1d
Gegenbauer polynomial.</p>
<h2 id="notes_120">Notes<a class="headerlink" href="#notes_120" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>C_n^{(\alpha)}</code> are orthogonal over
:math:<code>[-1,1]</code> with weight function :math:<code>(1 - x^2)^{(\alpha -
1/2)}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">genlaguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Generalized (associated) Laguerre polynomial.</p>
<p>Defined to be the solution of</p>
<p>.. math::
x\frac{d^2}{dx^2}L_n^{(\alpha)}
+ (\alpha + 1 - x)\frac{d}{dx}L_n^{(\alpha)}
+ nL_n^{(\alpha)} = 0,</p>
<p>where :math:<code>\alpha &gt; -1</code>; :math:<code>L_n^{(\alpha)}</code> is a polynomial
of degree :math:<code>n</code>.</p>
<h2 id="parameters_184">Parameters<a class="headerlink" href="#parameters_184" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
alpha : float
Parameter, must be greater than -1.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_204">Returns<a class="headerlink" href="#returns_204" title="Permanent link">&para;</a></h2>
<p>L : orthopoly1d
Generalized Laguerre polynomial.</p>
<h2 id="notes_121">Notes<a class="headerlink" href="#notes_121" title="Permanent link">&para;</a></h2>
<p>For fixed :math:<code>\alpha</code>, the polynomials :math:<code>L_n^{(\alpha)}</code>
are orthogonal over :math:<code>[0, \infty)</code> with weight function
:math:<code>e^{-x}x^\alpha</code>.</p>
<p>The Laguerre polynomials are the special case where :math:<code>\alpha
= 0</code>.</p>
<h2 id="see-also_146">See Also<a class="headerlink" href="#see-also_146" title="Permanent link">&para;</a></h2>
<p>laguerre : Laguerre polynomial.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">h_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Hermite (physicst's) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Hermite
quadrature. The sample points are the roots of the n-th degree
Hermite polynomial, :math:<code>H_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[-\infty, \infty]</code> with weight
function :math:<code>w(x) = e^{-x^2}</code>. See 22.2.14 in [AS]_ for
details.</p>
<h2 id="parameters_185">Parameters<a class="headerlink" href="#parameters_185" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_205">Returns<a class="headerlink" href="#returns_205" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="notes_122">Notes<a class="headerlink" href="#notes_122" title="Permanent link">&para;</a></h2>
<p>For small n up to 150 a modified version of the Golub-Welsch
algorithm is used. Nodes are computed from the eigenvalue
problem and improved by one step of a Newton iteration.
The weights are computed from the well-known analytical formula.</p>
<p>For n larger than 150 an optimal asymptotic algorithm is applied
which computes nodes and weights in a numerically stable manner.
The algorithm has linear runtime making computation for very
large n (several thousand or more) feasible.</p>
<h2 id="see-also_147">See Also<a class="headerlink" href="#see-also_147" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.hermite.hermgauss
roots_hermitenorm</p>
<h2 id="references_143">References<a class="headerlink" href="#references_143" title="Permanent link">&para;</a></h2>
<p>.. [townsend.trogdon.olver-2014]
Townsend, A. and Trogdon, T. and Olver, S. (2014)
<em>Fast computation of Gauss quadrature nodes and
weights on the whole real line</em>. :arXiv:<code>1410.5286</code>.
.. [townsend.trogdon.olver-2015]
Townsend, A. and Trogdon, T. and Olver, S. (2015)
<em>Fast computation of Gauss quadrature nodes and
weights on the whole real line</em>.
IMA Journal of Numerical Analysis
:doi:<code>10.1093/imanum/drv002</code>.
.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">he_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Hermite (statistician's) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Hermite
quadrature. The sample points are the roots of the n-th degree
Hermite polynomial, :math:<code>He_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[-\infty, \infty]</code> with weight
function :math:<code>w(x) = e^{-x^2/2}</code>. See 22.2.15 in [AS]_ for more
details.</p>
<h2 id="parameters_186">Parameters<a class="headerlink" href="#parameters_186" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_206">Returns<a class="headerlink" href="#returns_206" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="notes_123">Notes<a class="headerlink" href="#notes_123" title="Permanent link">&para;</a></h2>
<p>For small n up to 150 a modified version of the Golub-Welsch
algorithm is used. Nodes are computed from the eigenvalue
problem and improved by one step of a Newton iteration.
The weights are computed from the well-known analytical formula.</p>
<p>For n larger than 150 an optimal asymptotic algorithm is used
which computes nodes and weights in a numerical stable manner.
The algorithm has linear runtime making computation for very
large n (several thousand or more) feasible.</p>
<h2 id="see-also_148">See Also<a class="headerlink" href="#see-also_148" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.hermite_e.hermegauss</p>
<h2 id="references_144">References<a class="headerlink" href="#references_144" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hermite</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Physicist's Hermite polynomial.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>H_n(x) = (-1)^ne^{x^2}\frac{d^n}{dx^n}e^{-x^2};</p>
<p>:math:<code>H_n</code> is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_187">Parameters<a class="headerlink" href="#parameters_187" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_207">Returns<a class="headerlink" href="#returns_207" title="Permanent link">&para;</a></h2>
<p>H : orthopoly1d
Hermite polynomial.</p>
<h2 id="notes_124">Notes<a class="headerlink" href="#notes_124" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>H_n</code> are orthogonal over :math:<code>(-\infty,
\infty)</code> with weight function :math:<code>e^{-x^2}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hermitenorm</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Normalized (probabilist's) Hermite polynomial.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>He_n(x) = (-1)^ne^{x^2/2}\frac{d^n}{dx^n}e^{-x^2/2};</p>
<p>:math:<code>He_n</code> is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_188">Parameters<a class="headerlink" href="#parameters_188" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_208">Returns<a class="headerlink" href="#returns_208" title="Permanent link">&para;</a></h2>
<p>He : orthopoly1d
Hermite polynomial.</p>
<h2 id="notes_125">Notes<a class="headerlink" href="#notes_125" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>He_n</code> are orthogonal over :math:<code>(-\infty,
\infty)</code> with weight function :math:<code>e^{-x^2/2}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hstack</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Stack arrays in sequence horizontally (column wise).</p>
<p>This is equivalent to concatenation along the second axis, except for 1-D
arrays where it concatenates along the first axis. Rebuilds arrays divided
by <code>hsplit</code>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <code>concatenate</code>, <code>stack</code> and
<code>block</code> provide more general stacking and concatenation operations.</p>
<h2 id="parameters_189">Parameters<a class="headerlink" href="#parameters_189" title="Permanent link">&para;</a></h2>
<p>tup : sequence of ndarrays
The arrays must have the same shape along all but the second axis,
except 1-D arrays which can be any length.</p>
<h2 id="returns_209">Returns<a class="headerlink" href="#returns_209" title="Permanent link">&para;</a></h2>
<p>stacked : ndarray
The array formed by stacking the given arrays.</p>
<h2 id="see-also_149">See Also<a class="headerlink" href="#see-also_149" title="Permanent link">&para;</a></h2>
<p>stack : Join a sequence of arrays along a new axis.
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third axis).
concatenate : Join a sequence of arrays along an existing axis.
hsplit : Split array along second axis.
block : Assemble arrays from blocks.</p>
<h2 id="examples_70">Examples<a class="headerlink" href="#examples_70" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array((1,2,3))
b = np.array((2,3,4))
np.hstack((a,b))
array([1, 2, 3, 2, 3, 4])
a = np.array([[1],[2],[3]])
b = np.array([[2],[3],[4]])
np.hstack((a,b))
array([[1, 2],
[2, 3],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">j_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">beta</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Jacobi quadrature.</p>
<p>Compute the sample points and weights for Gauss-Jacobi
quadrature. The sample points are the roots of the n-th degree
Jacobi polynomial, :math:<code>P^{\alpha, \beta}_n(x)</code>. These sample
points and weights correctly integrate polynomials of degree
:math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code> with
weight function :math:<code>w(x) = (1 - x)^{\alpha} (1 +
x)^{\beta}</code>. See 22.2.1 in [AS]_ for details.</p>
<h2 id="parameters_190">Parameters<a class="headerlink" href="#parameters_190" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
alpha : float
alpha must be &gt; -1
beta : float
beta must be &gt; -1
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_210">Returns<a class="headerlink" href="#returns_210" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_150">See Also<a class="headerlink" href="#see-also_150" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_145">References<a class="headerlink" href="#references_145" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">beta</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Jacobi polynomial.</p>
<p>Defined to be the solution of</p>
<p>.. math::
(1 - x^2)\frac{d^2}{dx^2}P_n^{(\alpha, \beta)}
+ (\beta - \alpha - (\alpha + \beta + 2)x)
\frac{d}{dx}P_n^{(\alpha, \beta)}
+ n(n + \alpha + \beta + 1)P_n^{(\alpha, \beta)} = 0</p>
<p>for :math:<code>\alpha, \beta &gt; -1</code>; :math:<code>P_n^{(\alpha, \beta)}</code> is a
polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_191">Parameters<a class="headerlink" href="#parameters_191" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
alpha : float
Parameter, must be greater than -1.
beta : float
Parameter, must be greater than -1.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_211">Returns<a class="headerlink" href="#returns_211" title="Permanent link">&para;</a></h2>
<p>P : orthopoly1d
Jacobi polynomial.</p>
<h2 id="notes_126">Notes<a class="headerlink" href="#notes_126" title="Permanent link">&para;</a></h2>
<p>For fixed :math:<code>\alpha, \beta</code>, the polynomials
:math:<code>P_n^{(\alpha, \beta)}</code> are orthogonal over :math:<code>[-1, 1]</code>
with weight function :math:<code>(1 - x)^\alpha(1 + x)^\beta</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">js_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">p1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">q1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Jacobi (shifted) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Jacobi (shifted)
quadrature. The sample points are the roots of the n-th degree
shifted Jacobi polynomial, :math:<code>G^{p,q}_n(x)</code>. These sample
points and weights correctly integrate polynomials of degree
:math:<code>2n - 1</code> or less over the interval :math:<code>[0, 1]</code> with
weight function :math:<code>w(x) = (1 - x)^{p-q} x^{q-1}</code>. See 22.2.2
in [AS]_ for details.</p>
<h2 id="parameters_192">Parameters<a class="headerlink" href="#parameters_192" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
p1 : float
(p1 - q1) must be &gt; -1
q1 : float
q1 must be &gt; 0
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_212">Returns<a class="headerlink" href="#returns_212" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_151">See Also<a class="headerlink" href="#see-also_151" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_146">References<a class="headerlink" href="#references_146" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">l_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Laguerre quadrature.</p>
<p>Compute the sample points and weights for Gauss-Laguerre
quadrature. The sample points are the roots of the n-th degree
Laguerre polynomial, :math:<code>L_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[0, \infty]</code> with weight function
:math:<code>w(x) = e^{-x}</code>. See 22.2.13 in [AS]_ for details.</p>
<h2 id="parameters_193">Parameters<a class="headerlink" href="#parameters_193" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_213">Returns<a class="headerlink" href="#returns_213" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_152">See Also<a class="headerlink" href="#see-also_152" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.laguerre.laggauss</p>
<h2 id="references_147">References<a class="headerlink" href="#references_147" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">la_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-generalized Laguerre quadrature.</p>
<p>Compute the sample points and weights for Gauss-generalized
Laguerre quadrature. The sample points are the roots of the n-th
degree generalized Laguerre polynomial, :math:<code>L^{\alpha}_n(x)</code>.
These sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[0,
\infty]</code> with weight function :math:<code>w(x) = x^{\alpha}
e^{-x}</code>. See 22.3.9 in [AS]_ for details.</p>
<h2 id="parameters_194">Parameters<a class="headerlink" href="#parameters_194" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
alpha : float
alpha must be &gt; -1
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_214">Returns<a class="headerlink" href="#returns_214" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_153">See Also<a class="headerlink" href="#see-also_153" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_148">References<a class="headerlink" href="#references_148" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">laguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Laguerre polynomial.</p>
<p>Defined to be the solution of</p>
<p>.. math::
x\frac{d^2}{dx^2}L_n + (1 - x)\frac{d}{dx}L_n + nL_n = 0;</p>
<p>:math:<code>L_n</code> is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_195">Parameters<a class="headerlink" href="#parameters_195" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_215">Returns<a class="headerlink" href="#returns_215" title="Permanent link">&para;</a></h2>
<p>L : orthopoly1d
Laguerre Polynomial.</p>
<h2 id="notes_127">Notes<a class="headerlink" href="#notes_127" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>L_n</code> are orthogonal over :math:<code>[0,
\infty)</code> with weight function :math:<code>e^{-x}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Legendre polynomial.</p>
<p>Defined to be the solution of</p>
<p>.. math::
\frac{d}{dx}\left[(1 - x^2)\frac{d}{dx}P_n(x)\right]
+ n(n + 1)P_n(x) = 0;</p>
<p>:math:<code>P_n(x)</code> is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_196">Parameters<a class="headerlink" href="#parameters_196" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_216">Returns<a class="headerlink" href="#returns_216" title="Permanent link">&para;</a></h2>
<p>P : orthopoly1d
Legendre polynomial.</p>
<h2 id="notes_128">Notes<a class="headerlink" href="#notes_128" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>P_n</code> are orthogonal over :math:<code>[-1, 1]</code>
with weight function 1.</p>
<h2 id="examples_71">Examples<a class="headerlink" href="#examples_71" title="Permanent link">&para;</a></h2>
<p>Generate the 3rd-order Legendre polynomial 1/2*(5x^3 + 0x^2 - 3x + 0):</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import legendre
legendre(3)
poly1d([ 2.5,  0. , -1.5,  0. ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">p_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Legendre quadrature.</p>
<p>Compute the sample points and weights for Gauss-Legendre
quadrature. The sample points are the roots of the n-th degree
Legendre polynomial :math:<code>P_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[-1, 1]</code> with weight function
:math:<code>w(x) = 1.0</code>. See 2.2.10 in [AS]_ for more details.</p>
<h2 id="parameters_197">Parameters<a class="headerlink" href="#parameters_197" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_217">Returns<a class="headerlink" href="#returns_217" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_154">See Also<a class="headerlink" href="#see-also_154" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.legendre.leggauss</p>
<h2 id="references_149">References<a class="headerlink" href="#references_149" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">poch</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>poch(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>poch(z, m)</p>
<p>Pochhammer symbol.</p>
<p>The Pochhammer symbol (rising factorial) is defined as</p>
<p>.. math::</p>
<p>(z)_m = \frac{\Gamma(z + m)}{\Gamma(z)}</p>
<p>For positive integer <code>m</code> it reads</p>
<p>.. math::</p>
<p>(z)_m = z (z + 1) ... (z + m - 1)</p>
<p>See [dlmf]_ for more details.</p>
<h2 id="parameters_198">Parameters<a class="headerlink" href="#parameters_198" title="Permanent link">&para;</a></h2>
<p>z, m : array_like
Real-valued arguments.</p>
<h2 id="returns_218">Returns<a class="headerlink" href="#returns_218" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
The value of the function.</p>
<h2 id="references_150">References<a class="headerlink" href="#references_150" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] Nist, Digital Library of Mathematical Functions
https://dlmf.nist.gov/5.2#iii</p>
<h2 id="examples_72">Examples<a class="headerlink" href="#examples_72" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is 1 when m is 0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.poch([1, 2, 3, 4], 0)
array([1., 1., 1., 1.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>For z equal to 1 it reduces to the factorial function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.poch(1, 5)
120.0
1 * 2 * 3 * 4 * 5
120</p>
</blockquote>
</blockquote>
</blockquote>
<p>It can be expressed in terms of the Gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>z, m = 3.7, 2.1
sc.poch(z, m)
20.529581933776953
sc.gamma(z + m) / sc.gamma(z)
20.52958193377696</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ps_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Legendre (shifted) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Legendre
quadrature. The sample points are the roots of the n-th degree
shifted Legendre polynomial :math:<code>P^*_n(x)</code>. These sample points
and weights correctly integrate polynomials of degree :math:<code>2n -
1</code> or less over the interval :math:<code>[0, 1]</code> with weight function
:math:<code>w(x) = 1.0</code>. See 2.2.11 in [AS]_ for details.</p>
<h2 id="parameters_199">Parameters<a class="headerlink" href="#parameters_199" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_219">Returns<a class="headerlink" href="#returns_219" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_155">See Also<a class="headerlink" href="#see-also_155" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_151">References<a class="headerlink" href="#references_151" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_chebyc</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (first kind) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the first kind, :math:<code>C_n(x)</code>. These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-2, 2]</code>
with weight function :math:<code>w(x) = 1 / \sqrt{1 - (x/2)^2}</code>. See
22.2.6 in [AS]_ for more details.</p>
<h2 id="parameters_200">Parameters<a class="headerlink" href="#parameters_200" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_220">Returns<a class="headerlink" href="#returns_220" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_156">See Also<a class="headerlink" href="#see-also_156" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_152">References<a class="headerlink" href="#references_152" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_chebys</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (second kind) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the second kind, :math:<code>S_n(x)</code>. These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-2, 2]</code>
with weight function :math:<code>w(x) = \sqrt{1 - (x/2)^2}</code>. See 22.2.7
in [AS]_ for more details.</p>
<h2 id="parameters_201">Parameters<a class="headerlink" href="#parameters_201" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_221">Returns<a class="headerlink" href="#returns_221" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_157">See Also<a class="headerlink" href="#see-also_157" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_153">References<a class="headerlink" href="#references_153" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (first kind) quadrature.</p>
<p>Computes the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the first kind, :math:<code>T_n(x)</code>.  These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code>
with weight function :math:<code>w(x) = 1/\sqrt{1 - x^2}</code>. See 22.2.4
in [AS]_ for more details.</p>
<h2 id="parameters_202">Parameters<a class="headerlink" href="#parameters_202" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_222">Returns<a class="headerlink" href="#returns_222" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_158">See Also<a class="headerlink" href="#see-also_158" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.chebyshev.chebgauss</p>
<h2 id="references_154">References<a class="headerlink" href="#references_154" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (second kind) quadrature.</p>
<p>Computes the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the second kind, :math:<code>U_n(x)</code>. These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code>
with weight function :math:<code>w(x) = \sqrt{1 - x^2}</code>. See 22.2.5 in
[AS]_ for details.</p>
<h2 id="parameters_203">Parameters<a class="headerlink" href="#parameters_203" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_223">Returns<a class="headerlink" href="#returns_223" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_159">See Also<a class="headerlink" href="#see-also_159" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_155">References<a class="headerlink" href="#references_155" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_gegenbauer</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Gegenbauer quadrature.</p>
<p>Compute the sample points and weights for Gauss-Gegenbauer
quadrature. The sample points are the roots of the n-th degree
Gegenbauer polynomial, :math:<code>C^{\alpha}_n(x)</code>. These sample
points and weights correctly integrate polynomials of degree
:math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code> with
weight function :math:<code>w(x) = (1 - x^2)^{\alpha - 1/2}</code>. See
22.2.3 in [AS]_ for more details.</p>
<h2 id="parameters_204">Parameters<a class="headerlink" href="#parameters_204" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
alpha : float
alpha must be &gt; -0.5
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_224">Returns<a class="headerlink" href="#returns_224" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_160">See Also<a class="headerlink" href="#see-also_160" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_156">References<a class="headerlink" href="#references_156" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_genlaguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-generalized Laguerre quadrature.</p>
<p>Compute the sample points and weights for Gauss-generalized
Laguerre quadrature. The sample points are the roots of the n-th
degree generalized Laguerre polynomial, :math:<code>L^{\alpha}_n(x)</code>.
These sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[0,
\infty]</code> with weight function :math:<code>w(x) = x^{\alpha}
e^{-x}</code>. See 22.3.9 in [AS]_ for details.</p>
<h2 id="parameters_205">Parameters<a class="headerlink" href="#parameters_205" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
alpha : float
alpha must be &gt; -1
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_225">Returns<a class="headerlink" href="#returns_225" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_161">See Also<a class="headerlink" href="#see-also_161" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_157">References<a class="headerlink" href="#references_157" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_hermite</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Hermite (physicst's) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Hermite
quadrature. The sample points are the roots of the n-th degree
Hermite polynomial, :math:<code>H_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[-\infty, \infty]</code> with weight
function :math:<code>w(x) = e^{-x^2}</code>. See 22.2.14 in [AS]_ for
details.</p>
<h2 id="parameters_206">Parameters<a class="headerlink" href="#parameters_206" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_226">Returns<a class="headerlink" href="#returns_226" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="notes_129">Notes<a class="headerlink" href="#notes_129" title="Permanent link">&para;</a></h2>
<p>For small n up to 150 a modified version of the Golub-Welsch
algorithm is used. Nodes are computed from the eigenvalue
problem and improved by one step of a Newton iteration.
The weights are computed from the well-known analytical formula.</p>
<p>For n larger than 150 an optimal asymptotic algorithm is applied
which computes nodes and weights in a numerically stable manner.
The algorithm has linear runtime making computation for very
large n (several thousand or more) feasible.</p>
<h2 id="see-also_162">See Also<a class="headerlink" href="#see-also_162" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.hermite.hermgauss
roots_hermitenorm</p>
<h2 id="references_158">References<a class="headerlink" href="#references_158" title="Permanent link">&para;</a></h2>
<p>.. [townsend.trogdon.olver-2014]
Townsend, A. and Trogdon, T. and Olver, S. (2014)
<em>Fast computation of Gauss quadrature nodes and
weights on the whole real line</em>. :arXiv:<code>1410.5286</code>.
.. [townsend.trogdon.olver-2015]
Townsend, A. and Trogdon, T. and Olver, S. (2015)
<em>Fast computation of Gauss quadrature nodes and
weights on the whole real line</em>.
IMA Journal of Numerical Analysis
:doi:<code>10.1093/imanum/drv002</code>.
.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_hermitenorm</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Hermite (statistician's) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Hermite
quadrature. The sample points are the roots of the n-th degree
Hermite polynomial, :math:<code>He_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[-\infty, \infty]</code> with weight
function :math:<code>w(x) = e^{-x^2/2}</code>. See 22.2.15 in [AS]_ for more
details.</p>
<h2 id="parameters_207">Parameters<a class="headerlink" href="#parameters_207" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_227">Returns<a class="headerlink" href="#returns_227" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="notes_130">Notes<a class="headerlink" href="#notes_130" title="Permanent link">&para;</a></h2>
<p>For small n up to 150 a modified version of the Golub-Welsch
algorithm is used. Nodes are computed from the eigenvalue
problem and improved by one step of a Newton iteration.
The weights are computed from the well-known analytical formula.</p>
<p>For n larger than 150 an optimal asymptotic algorithm is used
which computes nodes and weights in a numerical stable manner.
The algorithm has linear runtime making computation for very
large n (several thousand or more) feasible.</p>
<h2 id="see-also_163">See Also<a class="headerlink" href="#see-also_163" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.hermite_e.hermegauss</p>
<h2 id="references_159">References<a class="headerlink" href="#references_159" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">beta</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Jacobi quadrature.</p>
<p>Compute the sample points and weights for Gauss-Jacobi
quadrature. The sample points are the roots of the n-th degree
Jacobi polynomial, :math:<code>P^{\alpha, \beta}_n(x)</code>. These sample
points and weights correctly integrate polynomials of degree
:math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code> with
weight function :math:<code>w(x) = (1 - x)^{\alpha} (1 +
x)^{\beta}</code>. See 22.2.1 in [AS]_ for details.</p>
<h2 id="parameters_208">Parameters<a class="headerlink" href="#parameters_208" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
alpha : float
alpha must be &gt; -1
beta : float
beta must be &gt; -1
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_228">Returns<a class="headerlink" href="#returns_228" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_164">See Also<a class="headerlink" href="#see-also_164" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_160">References<a class="headerlink" href="#references_160" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_laguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Laguerre quadrature.</p>
<p>Compute the sample points and weights for Gauss-Laguerre
quadrature. The sample points are the roots of the n-th degree
Laguerre polynomial, :math:<code>L_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[0, \infty]</code> with weight function
:math:<code>w(x) = e^{-x}</code>. See 22.2.13 in [AS]_ for details.</p>
<h2 id="parameters_209">Parameters<a class="headerlink" href="#parameters_209" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_229">Returns<a class="headerlink" href="#returns_229" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_165">See Also<a class="headerlink" href="#see-also_165" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.laguerre.laggauss</p>
<h2 id="references_161">References<a class="headerlink" href="#references_161" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Legendre quadrature.</p>
<p>Compute the sample points and weights for Gauss-Legendre
quadrature. The sample points are the roots of the n-th degree
Legendre polynomial :math:<code>P_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[-1, 1]</code> with weight function
:math:<code>w(x) = 1.0</code>. See 2.2.10 in [AS]_ for more details.</p>
<h2 id="parameters_210">Parameters<a class="headerlink" href="#parameters_210" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_230">Returns<a class="headerlink" href="#returns_230" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_166">See Also<a class="headerlink" href="#see-also_166" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.legendre.leggauss</p>
<h2 id="references_162">References<a class="headerlink" href="#references_162" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_sh_chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (first kind, shifted) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
shifted Chebyshev polynomial of the first kind, :math:<code>T_n(x)</code>.
These sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[0, 1]</code>
with weight function :math:<code>w(x) = 1/\sqrt{x - x^2}</code>. See 22.2.8
in [AS]_ for more details.</p>
<h2 id="parameters_211">Parameters<a class="headerlink" href="#parameters_211" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_231">Returns<a class="headerlink" href="#returns_231" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_167">See Also<a class="headerlink" href="#see-also_167" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_163">References<a class="headerlink" href="#references_163" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_sh_chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (second kind, shifted) quadrature.</p>
<p>Computes the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
shifted Chebyshev polynomial of the second kind, :math:<code>U_n(x)</code>.
These sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[0, 1]</code>
with weight function :math:<code>w(x) = \sqrt{x - x^2}</code>. See 22.2.9 in
[AS]_ for more details.</p>
<h2 id="parameters_212">Parameters<a class="headerlink" href="#parameters_212" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_232">Returns<a class="headerlink" href="#returns_232" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_168">See Also<a class="headerlink" href="#see-also_168" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_164">References<a class="headerlink" href="#references_164" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_sh_jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">p1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">q1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Jacobi (shifted) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Jacobi (shifted)
quadrature. The sample points are the roots of the n-th degree
shifted Jacobi polynomial, :math:<code>G^{p,q}_n(x)</code>. These sample
points and weights correctly integrate polynomials of degree
:math:<code>2n - 1</code> or less over the interval :math:<code>[0, 1]</code> with
weight function :math:<code>w(x) = (1 - x)^{p-q} x^{q-1}</code>. See 22.2.2
in [AS]_ for details.</p>
<h2 id="parameters_213">Parameters<a class="headerlink" href="#parameters_213" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
p1 : float
(p1 - q1) must be &gt; -1
q1 : float
q1 must be &gt; 0
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_233">Returns<a class="headerlink" href="#returns_233" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_169">See Also<a class="headerlink" href="#see-also_169" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_165">References<a class="headerlink" href="#references_165" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_sh_legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Legendre (shifted) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Legendre
quadrature. The sample points are the roots of the n-th degree
shifted Legendre polynomial :math:<code>P^*_n(x)</code>. These sample points
and weights correctly integrate polynomials of degree :math:<code>2n -
1</code> or less over the interval :math:<code>[0, 1]</code> with weight function
:math:<code>w(x) = 1.0</code>. See 2.2.11 in [AS]_ for details.</p>
<h2 id="parameters_214">Parameters<a class="headerlink" href="#parameters_214" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_234">Returns<a class="headerlink" href="#returns_234" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_170">See Also<a class="headerlink" href="#see-also_170" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_166">References<a class="headerlink" href="#references_166" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">s_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (second kind) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the second kind, :math:<code>S_n(x)</code>. These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-2, 2]</code>
with weight function :math:<code>w(x) = \sqrt{1 - (x/2)^2}</code>. See 22.2.7
in [AS]_ for more details.</p>
<h2 id="parameters_215">Parameters<a class="headerlink" href="#parameters_215" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_235">Returns<a class="headerlink" href="#returns_235" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_171">See Also<a class="headerlink" href="#see-also_171" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_167">References<a class="headerlink" href="#references_167" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sh_chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shifted Chebyshev polynomial of the first kind.</p>
<p>Defined as :math:<code>T^*_n(x) = T_n(2x - 1)</code> for :math:<code>T_n</code> the nth
Chebyshev polynomial of the first kind.</p>
<h2 id="parameters_216">Parameters<a class="headerlink" href="#parameters_216" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_236">Returns<a class="headerlink" href="#returns_236" title="Permanent link">&para;</a></h2>
<p>T : orthopoly1d
Shifted Chebyshev polynomial of the first kind.</p>
<h2 id="notes_131">Notes<a class="headerlink" href="#notes_131" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>T^*_n</code> are orthogonal over :math:<code>[0, 1]</code>
with weight function :math:<code>(x - x^2)^{-1/2}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sh_chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shifted Chebyshev polynomial of the second kind.</p>
<p>Defined as :math:<code>U^*_n(x) = U_n(2x - 1)</code> for :math:<code>U_n</code> the nth
Chebyshev polynomial of the second kind.</p>
<h2 id="parameters_217">Parameters<a class="headerlink" href="#parameters_217" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_237">Returns<a class="headerlink" href="#returns_237" title="Permanent link">&para;</a></h2>
<p>U : orthopoly1d
Shifted Chebyshev polynomial of the second kind.</p>
<h2 id="notes_132">Notes<a class="headerlink" href="#notes_132" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>U^*_n</code> are orthogonal over :math:<code>[0, 1]</code>
with weight function :math:<code>(x - x^2)^{1/2}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sh_jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shifted Jacobi polynomial.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>G_n^{(p, q)}(x)
= \binom{2n + p - 1}{n}^{-1}P_n^{(p - q, q - 1)}(2x - 1),</p>
<p>where :math:<code>P_n^{(\cdot, \cdot)}</code> is the nth Jacobi polynomial.</p>
<h2 id="parameters_218">Parameters<a class="headerlink" href="#parameters_218" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
p : float
Parameter, must have :math:<code>p &gt; q - 1</code>.
q : float
Parameter, must be greater than 0.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_238">Returns<a class="headerlink" href="#returns_238" title="Permanent link">&para;</a></h2>
<p>G : orthopoly1d
Shifted Jacobi polynomial.</p>
<h2 id="notes_133">Notes<a class="headerlink" href="#notes_133" title="Permanent link">&para;</a></h2>
<p>For fixed :math:<code>p, q</code>, the polynomials :math:<code>G_n^{(p, q)}</code> are
orthogonal over :math:<code>[0, 1]</code> with weight function :math:<code>(1 -
x)^{p - q}x^{q - 1}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sh_legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shifted Legendre polynomial.</p>
<p>Defined as :math:<code>P^*_n(x) = P_n(2x - 1)</code> for :math:<code>P_n</code> the nth
Legendre polynomial.</p>
<h2 id="parameters_219">Parameters<a class="headerlink" href="#parameters_219" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_239">Returns<a class="headerlink" href="#returns_239" title="Permanent link">&para;</a></h2>
<p>P : orthopoly1d
Shifted Legendre polynomial.</p>
<h2 id="notes_134">Notes<a class="headerlink" href="#notes_134" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>P^*_n</code> are orthogonal over :math:<code>[0, 1]</code>
with weight function 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sin</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Trigonometric sine, element-wise.</p>
<h2 id="parameters_220">Parameters<a class="headerlink" href="#parameters_220" title="Permanent link">&para;</a></h2>
<p>x : array_like
Angle, in radians (:math:<code>2 \pi</code> rad equals 360 degrees).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_240">Returns<a class="headerlink" href="#returns_240" title="Permanent link">&para;</a></h2>
<p>y : array_like
The sine of each element of x.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_172">See Also<a class="headerlink" href="#see-also_172" title="Permanent link">&para;</a></h2>
<p>arcsin, sinh, cos</p>
<h2 id="notes_135">Notes<a class="headerlink" href="#notes_135" title="Permanent link">&para;</a></h2>
<p>The sine is one of the fundamental functions of trigonometry (the
mathematical study of triangles).  Consider a circle of radius 1
centered on the origin.  A ray comes in from the :math:<code>+x</code> axis, makes
an angle at the origin (measured counter-clockwise from that axis), and
departs from the origin.  The :math:<code>y</code> coordinate of the outgoing
ray's intersection with the unit circle is the sine of that angle.  It
ranges from -1 for :math:<code>x=3\pi / 2</code> to +1 for :math:<code>\pi / 2.</code>  The
function has zeroes where the angle is a multiple of :math:<code>\pi</code>.
Sines of angles between :math:<code>\pi</code> and :math:<code>2\pi</code> are negative.
The numerous properties of the sine and related functions are included
in any standard trigonometry text.</p>
<h2 id="examples_73">Examples<a class="headerlink" href="#examples_73" title="Permanent link">&para;</a></h2>
<p>Print sine of one angle:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sin(np.pi/2.)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Print sines of an array of angles given in degrees:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )
array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the sine function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pylab as plt
x = np.linspace(-np.pi, np.pi, 201)
plt.plot(x, np.sin(x))
plt.xlabel('Angle [rad]')
plt.ylabel('sin(x)')
plt.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the non-negative square-root of an array, element-wise.</p>
<h2 id="parameters_221">Parameters<a class="headerlink" href="#parameters_221" title="Permanent link">&para;</a></h2>
<p>x : array_like
The values whose square-roots are required.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_241">Returns<a class="headerlink" href="#returns_241" title="Permanent link">&para;</a></h2>
<p>y : ndarray
An array of the same shape as <code>x</code>, containing the positive
square-root of each element in <code>x</code>.  If any element in <code>x</code> is
complex, a complex array is returned (and the square-roots of
negative reals are calculated).  If all of the elements in <code>x</code>
are real, so is <code>y</code>, with negative elements returning <code>nan</code>.
If <code>out</code> was provided, <code>y</code> is a reference to it.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_173">See Also<a class="headerlink" href="#see-also_173" title="Permanent link">&para;</a></h2>
<p>lib.scimath.sqrt
A version which returns complex numbers when given negative reals.</p>
<h2 id="notes_136">Notes<a class="headerlink" href="#notes_136" title="Permanent link">&para;</a></h2>
<p><em>sqrt</em> has--consistent with common convention--as its branch cut the
real 'interval' [<code>-inf</code>, 0), and is continuous from above on it.
A branch cut is a curve in the complex plane across which a given
complex function fails to be continuous.</p>
<h2 id="examples_74">Examples<a class="headerlink" href="#examples_74" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.sqrt([1,4,9])
array([ 1.,  2.,  3.])</p>
<p>np.sqrt([4, -1, -3+4J])
array([ 2.+0.j,  0.+1.j,  1.+2.j])</p>
<p>np.sqrt([4, -1, np.inf])
array([ 2., nan, inf])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">t_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (first kind) quadrature.</p>
<p>Computes the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the first kind, :math:<code>T_n(x)</code>.  These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code>
with weight function :math:<code>w(x) = 1/\sqrt{1 - x^2}</code>. See 22.2.4
in [AS]_ for more details.</p>
<h2 id="parameters_222">Parameters<a class="headerlink" href="#parameters_222" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_242">Returns<a class="headerlink" href="#returns_242" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_174">See Also<a class="headerlink" href="#see-also_174" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.chebyshev.chebgauss</p>
<h2 id="references_168">References<a class="headerlink" href="#references_168" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ts_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (first kind, shifted) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
shifted Chebyshev polynomial of the first kind, :math:<code>T_n(x)</code>.
These sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[0, 1]</code>
with weight function :math:<code>w(x) = 1/\sqrt{x - x^2}</code>. See 22.2.8
in [AS]_ for more details.</p>
<h2 id="parameters_223">Parameters<a class="headerlink" href="#parameters_223" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_243">Returns<a class="headerlink" href="#returns_243" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_175">See Also<a class="headerlink" href="#see-also_175" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_169">References<a class="headerlink" href="#references_169" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">u_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (second kind) quadrature.</p>
<p>Computes the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the second kind, :math:<code>U_n(x)</code>. These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code>
with weight function :math:<code>w(x) = \sqrt{1 - x^2}</code>. See 22.2.5 in
[AS]_ for details.</p>
<h2 id="parameters_224">Parameters<a class="headerlink" href="#parameters_224" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_244">Returns<a class="headerlink" href="#returns_244" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_176">See Also<a class="headerlink" href="#see-also_176" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_170">References<a class="headerlink" href="#references_170" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">us_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (second kind, shifted) quadrature.</p>
<p>Computes the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
shifted Chebyshev polynomial of the second kind, :math:<code>U_n(x)</code>.
These sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[0, 1]</code>
with weight function :math:<code>w(x) = \sqrt{x - x^2}</code>. See 22.2.9 in
[AS]_ for more details.</p>
<h2 id="parameters_225">Parameters<a class="headerlink" href="#parameters_225" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_245">Returns<a class="headerlink" href="#returns_245" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_177">See Also<a class="headerlink" href="#see-also_177" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_171">References<a class="headerlink" href="#references_171" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Sf_error</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>



<span class="k">module</span> <span class="nc">Specfun</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">herzo</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>x,w = herzo(n)</p>
<p>Wrapper for <code>herzo</code>.</p>
<h2 id="parameters_226">Parameters<a class="headerlink" href="#parameters_226" title="Permanent link">&para;</a></h2>
<p>n : input int</p>
<h2 id="returns_246">Returns<a class="headerlink" href="#returns_246" title="Permanent link">&para;</a></h2>
<p>x : rank-1 array('d') with bounds (n)
w : rank-1 array('d') with bounds (n)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lagzo</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>x,w = lagzo(n)</p>
<p>Wrapper for <code>lagzo</code>.</p>
<h2 id="parameters_227">Parameters<a class="headerlink" href="#parameters_227" title="Permanent link">&para;</a></h2>
<p>n : input int</p>
<h2 id="returns_247">Returns<a class="headerlink" href="#returns_247" title="Permanent link">&para;</a></h2>
<p>x : rank-1 array('d') with bounds (n)
w : rank-1 array('d') with bounds (n)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">legzo</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>x,w = legzo(n)</p>
<p>Wrapper for <code>legzo</code>.</p>
<h2 id="parameters_228">Parameters<a class="headerlink" href="#parameters_228" title="Permanent link">&para;</a></h2>
<p>n : input int</p>
<h2 id="returns_248">Returns<a class="headerlink" href="#returns_248" title="Permanent link">&para;</a></h2>
<p>x : rank-1 array('d') with bounds (n)
w : rank-1 array('d') with bounds (n)</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Spfun_stats</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">loggam</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gammaln(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gammaln(x, out=None)</p>
<p>Logarithm of the absolute value of the Gamma function.</p>
<p>Defined as</p>
<p>.. math::</p>
<p>\ln(\lvert\Gamma(x)\rvert)</p>
<p>where :math:<code>\Gamma</code> is the Gamma function. For more details on
the Gamma function, see [dlmf]_.</p>
<h2 id="parameters_229">Parameters<a class="headerlink" href="#parameters_229" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real argument
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_249">Returns<a class="headerlink" href="#returns_249" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the log of the absolute value of Gamma</p>
<h2 id="see-also_178">See Also<a class="headerlink" href="#see-also_178" title="Permanent link">&para;</a></h2>
<p>gammasgn : sign of the gamma function
loggamma : principal branch of the logarithm of the gamma function</p>
<h2 id="notes_137">Notes<a class="headerlink" href="#notes_137" title="Permanent link">&para;</a></h2>
<p>It is the same function as the Python standard library function
:func:<code>math.lgamma</code>.</p>
<p>When used in conjunction with <code>gammasgn</code>, this function is useful
for working in logspace on the real axis without having to deal
with complex numbers via the relation <code>exp(gammaln(x)) =
gammasgn(x) * gamma(x)</code>.</p>
<p>For complex-valued log-gamma, use <code>loggamma</code> instead of <code>gammaln</code>.</p>
<h2 id="references_172">References<a class="headerlink" href="#references_172" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/5</p>
<h2 id="examples_75">Examples<a class="headerlink" href="#examples_75" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has two positive zeros.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammaln([1, 2])
array([0., 0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has poles at nonpositive integers.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammaln([0, -1, -2, -3, -4])
array([inf, inf, inf, inf, inf])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It asymptotically approaches <code>x * log(x)</code> (Stirling's formula).</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1e10, 1e20, 1e40, 1e80])
sc.gammaln(x)
array([2.20258509e+11, 4.50517019e+21, 9.11034037e+41, 1.83206807e+82])
x * np.log(x)
array([2.30258509e+11, 4.60517019e+21, 9.21034037e+41, 1.84206807e+82])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">multigammaln</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the log of multivariate gamma, also sometimes called the
generalized gamma.</p>
<h2 id="parameters_230">Parameters<a class="headerlink" href="#parameters_230" title="Permanent link">&para;</a></h2>
<p>a : ndarray
The multivariate gamma is computed for each item of <code>a</code>.
d : int
The dimension of the space of integration.</p>
<h2 id="returns_250">Returns<a class="headerlink" href="#returns_250" title="Permanent link">&para;</a></h2>
<p>res : ndarray
The values of the log multivariate gamma at the given points <code>a</code>.</p>
<h2 id="notes_138">Notes<a class="headerlink" href="#notes_138" title="Permanent link">&para;</a></h2>
<p>The formal definition of the multivariate gamma of dimension d for a real
<code>a</code> is</p>
<p>.. math::</p>
<p>\Gamma_d(a) = \int_{A&gt;0} e^{-tr(A)} |A|^{a - (d+1)/2} dA</p>
<p>with the condition :math:<code>a &gt; (d-1)/2</code>, and :math:<code>A &gt; 0</code> being the set of
all the positive definite matrices of dimension <code>d</code>.  Note that <code>a</code> is a
scalar: the integrand only is multivariate, the argument is not (the
function is defined over a subset of the real set).</p>
<p>This can be proven to be equal to the much friendlier equation</p>
<p>.. math::</p>
<p>\Gamma_d(a) = \pi^{d(d-1)/4} \prod_{i=1}^{d} \Gamma(a - (i-1)/2).</p>
<h2 id="references_173">References<a class="headerlink" href="#references_173" title="Permanent link">&para;</a></h2>
<p>R. J. Muirhead, Aspects of multivariate statistical theory (Wiley Series in
probability and mathematical statistics).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">agm</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>agm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>agm(a, b)</p>
<p>Compute the arithmetic-geometric mean of <code>a</code> and <code>b</code>.</p>
<p>Start with a_0 = a and b_0 = b and iteratively compute::</p>
<p>a_{n+1} = (a_n + b_n)/2
b_{n+1} = sqrt(a_n*b_n)</p>
<p>a_n and b_n converge to the same limit as n increases; their common
limit is agm(a, b).</p>
<h2 id="parameters_231">Parameters<a class="headerlink" href="#parameters_231" title="Permanent link">&para;</a></h2>
<p>a, b : array_like
Real values only.  If the values are both negative, the result
is negative.  If one value is negative and the other is positive,
<code>nan</code> is returned.</p>
<h2 id="returns_251">Returns<a class="headerlink" href="#returns_251" title="Permanent link">&para;</a></h2>
<p>float
The arithmetic-geometric mean of <code>a</code> and <code>b</code>.</p>
<h2 id="examples_76">Examples<a class="headerlink" href="#examples_76" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import agm
a, b = 24.0, 6.0
agm(a, b)
13.458171481725614</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare that result to the iteration:</p>
<blockquote>
<blockquote>
<blockquote>
<p>while a != b:
...     a, b = (a + b)/2, np.sqrt(a*b)
...     print('a = %19.16f  b=%19.16f' % (a, b))
...
a = 15.0000000000000000  b=12.0000000000000000
a = 13.5000000000000000  b=13.4164078649987388
a = 13.4582039324993694  b=13.4581390309909850
a = 13.4581714817451772  b=13.4581714817060547
a = 13.4581714817256159  b=13.4581714817256159</p>
</blockquote>
</blockquote>
</blockquote>
<p>When array-like arguments are given, broadcasting applies:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1.5], [3], [6]])  # a has shape (3, 1).
b = np.array([6, 12, 24, 48])    # b has shape (4,).
agm(a, b)
array([[  3.36454287,   5.42363427,   9.05798751,  15.53650756],
[  4.37037309,   6.72908574,  10.84726853,  18.11597502],
[  6.        ,   8.74074619,  13.45817148,  21.69453707]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ai_zeros</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute <code>nt</code> zeros and values of the Airy function Ai and its derivative.</p>
<p>Computes the first <code>nt</code> zeros, <code>a</code>, of the Airy function Ai(x);
first <code>nt</code> zeros, <code>ap</code>, of the derivative of the Airy function Ai'(x);
the corresponding values Ai(a');
and the corresponding values Ai'(a).</p>
<h2 id="parameters_232">Parameters<a class="headerlink" href="#parameters_232" title="Permanent link">&para;</a></h2>
<p>nt : int
Number of zeros to compute</p>
<h2 id="returns_252">Returns<a class="headerlink" href="#returns_252" title="Permanent link">&para;</a></h2>
<p>a : ndarray
First <code>nt</code> zeros of Ai(x)
ap : ndarray
First <code>nt</code> zeros of Ai'(x)
ai : ndarray
Values of Ai(x) evaluated at first <code>nt</code> zeros of Ai'(x)
aip : ndarray
Values of Ai'(x) evaluated at first <code>nt</code> zeros of Ai(x)</p>
<h2 id="examples_77">Examples<a class="headerlink" href="#examples_77" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
a, ap, ai, aip = special.ai_zeros(3)
a
array([-2.33810741, -4.08794944, -5.52055983])
ap
array([-1.01879297, -3.24819758, -4.82009921])
ai
array([ 0.53565666, -0.41901548,  0.38040647])
aip
array([ 0.70121082, -0.80311137,  0.86520403])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_174">References<a class="headerlink" href="#references_174" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">airy</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>airy(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>airy(z)</p>
<p>Airy functions and their derivatives.</p>
<h2 id="parameters_233">Parameters<a class="headerlink" href="#parameters_233" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex argument.</p>
<h2 id="returns_253">Returns<a class="headerlink" href="#returns_253" title="Permanent link">&para;</a></h2>
<p>Ai, Aip, Bi, Bip : ndarrays
Airy functions Ai and Bi, and their derivatives Aip and Bip.</p>
<h2 id="notes_139">Notes<a class="headerlink" href="#notes_139" title="Permanent link">&para;</a></h2>
<p>The Airy functions Ai and Bi are two independent solutions of</p>
<p>.. math:: y''(x) = x y(x).</p>
<p>For real <code>z</code> in [-10, 10], the computation is carried out by calling
the Cephes [1]_ <code>airy</code> routine, which uses power series summation
for small <code>z</code> and rational minimax approximations for large <code>z</code>.</p>
<p>Outside this range, the AMOS [2]_ <code>zairy</code> and <code>zbiry</code> routines are
employed.  They are computed using power series for :math:<code>|z| &lt; 1</code> and
the following relations to modified Bessel functions for larger <code>z</code>
(where :math:<code>t \equiv 2 z^{3/2}/3</code>):</p>
<p>.. math::</p>
<p>Ai(z) = \frac{1}{\pi \sqrt{3}} K_{1/3}(t)</p>
<p>Ai'(z) = -\frac{z}{\pi \sqrt{3}} K_{2/3}(t)</p>
<p>Bi(z) = \sqrt{\frac{z}{3}} \left(I_{-1/3}(t) + I_{1/3}(t) \right)</p>
<p>Bi'(z) = \frac{z}{\sqrt{3}} \left(I_{-2/3}(t) + I_{2/3}(t)\right)</p>
<h2 id="see-also_179">See also<a class="headerlink" href="#see-also_179" title="Permanent link">&para;</a></h2>
<p>airye : exponentially scaled Airy functions.</p>
<h2 id="references_175">References<a class="headerlink" href="#references_175" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/
.. [2] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<h2 id="examples_78">Examples<a class="headerlink" href="#examples_78" title="Permanent link">&para;</a></h2>
<p>Compute the Airy functions on the interval [-15, 5].</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
x = np.linspace(-15, 5, 201)
ai, aip, bi, bip = special.airy(x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot Ai(x) and Bi(x).</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.plot(x, ai, 'r', label='Ai(x)')
plt.plot(x, bi, 'b--', label='Bi(x)')
plt.ylim(-0.5, 1.0)
plt.grid()
plt.legend(loc='upper left')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">airye</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>airye(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>airye(z)</p>
<p>Exponentially scaled Airy functions and their derivatives.</p>
<p>Scaling::</p>
<p>eAi  = Ai  * exp(2.0/3.0<em>z</em>sqrt(z))
eAip = Aip * exp(2.0/3.0<em>z</em>sqrt(z))
eBi  = Bi  * exp(-abs(2.0/3.0<em>(z</em>sqrt(z)).real))
eBip = Bip * exp(-abs(2.0/3.0<em>(z</em>sqrt(z)).real))</p>
<h2 id="parameters_234">Parameters<a class="headerlink" href="#parameters_234" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex argument.</p>
<h2 id="returns_254">Returns<a class="headerlink" href="#returns_254" title="Permanent link">&para;</a></h2>
<p>eAi, eAip, eBi, eBip : array_like
Airy functions Ai and Bi, and their derivatives Aip and Bip</p>
<h2 id="notes_140">Notes<a class="headerlink" href="#notes_140" title="Permanent link">&para;</a></h2>
<p>Wrapper for the AMOS [1]_ routines <code>zairy</code> and <code>zbiry</code>.</p>
<h2 id="see-also_180">See also<a class="headerlink" href="#see-also_180" title="Permanent link">&para;</a></h2>
<p>airy</p>
<h2 id="references_176">References<a class="headerlink" href="#references_176" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">assoc_laguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the generalized (associated) Laguerre polynomial of degree n and order k.</p>
<p>The polynomial :math:<code>L^{(k)}_n(x)</code> is orthogonal over <code>[0, inf)</code>,
with weighting function <code>exp(-x) * x**k</code> with <code>k &gt; -1</code>.</p>
<h2 id="notes_141">Notes<a class="headerlink" href="#notes_141" title="Permanent link">&para;</a></h2>
<p><code>assoc_laguerre</code> is a simple wrapper around <code>eval_genlaguerre</code>, with
reversed argument order <code>(x, n, k=0.0) --&gt; (n, k, x)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>bdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>bdtr(k, n, p)</p>
<p>Binomial distribution cumulative distribution function.</p>
<p>Sum of the terms 0 through <code>k</code> of the Binomial probability density.</p>
<p>.. math::
\mathrm{bdtr}(k, n, p) = \sum_{j=0}^k {{n}\choose{j}} p^j (1-p)^{n-j}</p>
<h2 id="parameters_235">Parameters<a class="headerlink" href="#parameters_235" title="Permanent link">&para;</a></h2>
<p>k : array_like
Number of successes (int).
n : array_like
Number of events (int).
p : array_like
Probability of success in a single event (float).</p>
<h2 id="returns_255">Returns<a class="headerlink" href="#returns_255" title="Permanent link">&para;</a></h2>
<p>y : ndarray
Probability of <code>k</code> or fewer successes in <code>n</code> independent events with
success probabilities of <code>p</code>.</p>
<h2 id="notes_142">Notes<a class="headerlink" href="#notes_142" title="Permanent link">&para;</a></h2>
<p>The terms are not summed directly; instead the regularized incomplete beta
function is employed, according to the formula,</p>
<p>.. math::
\mathrm{bdtr}(k, n, p) = I_{1 - p}(n - k, k + 1).</p>
<p>Wrapper for the Cephes [1]_ routine <code>bdtr</code>.</p>
<h2 id="references_177">References<a class="headerlink" href="#references_177" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bdtrc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>bdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>bdtrc(k, n, p)</p>
<p>Binomial distribution survival function.</p>
<p>Sum of the terms <code>k + 1</code> through <code>n</code> of the binomial probability density,</p>
<p>.. math::
\mathrm{bdtrc}(k, n, p) = \sum_{j=k+1}^n {{n}\choose{j}} p^j (1-p)^{n-j}</p>
<h2 id="parameters_236">Parameters<a class="headerlink" href="#parameters_236" title="Permanent link">&para;</a></h2>
<p>k : array_like
Number of successes (int).
n : array_like
Number of events (int)
p : array_like
Probability of success in a single event.</p>
<h2 id="returns_256">Returns<a class="headerlink" href="#returns_256" title="Permanent link">&para;</a></h2>
<p>y : ndarray
Probability of <code>k + 1</code> or more successes in <code>n</code> independent events
with success probabilities of <code>p</code>.</p>
<h2 id="see-also_181">See also<a class="headerlink" href="#see-also_181" title="Permanent link">&para;</a></h2>
<p>bdtr
betainc</p>
<h2 id="notes_143">Notes<a class="headerlink" href="#notes_143" title="Permanent link">&para;</a></h2>
<p>The terms are not summed directly; instead the regularized incomplete beta
function is employed, according to the formula,</p>
<p>.. math::
\mathrm{bdtrc}(k, n, p) = I_{p}(k + 1, n - k).</p>
<p>Wrapper for the Cephes [1]_ routine <code>bdtrc</code>.</p>
<h2 id="references_178">References<a class="headerlink" href="#references_178" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>bdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>bdtri(k, n, y)</p>
<p>Inverse function to <code>bdtr</code> with respect to <code>p</code>.</p>
<p>Finds the event probability <code>p</code> such that the sum of the terms 0 through
<code>k</code> of the binomial probability density is equal to the given cumulative
probability <code>y</code>.</p>
<h2 id="parameters_237">Parameters<a class="headerlink" href="#parameters_237" title="Permanent link">&para;</a></h2>
<p>k : array_like
Number of successes (float).
n : array_like
Number of events (float)
y : array_like
Cumulative probability (probability of <code>k</code> or fewer successes in <code>n</code>
events).</p>
<h2 id="returns_257">Returns<a class="headerlink" href="#returns_257" title="Permanent link">&para;</a></h2>
<p>p : ndarray
The event probability such that <code>bdtr(k, n, p) = y</code>.</p>
<h2 id="see-also_182">See also<a class="headerlink" href="#see-also_182" title="Permanent link">&para;</a></h2>
<p>bdtr
betaincinv</p>
<h2 id="notes_144">Notes<a class="headerlink" href="#notes_144" title="Permanent link">&para;</a></h2>
<p>The computation is carried out using the inverse beta integral function
and the relation,::</p>
<p>1 - p = betaincinv(n - k, k + 1, y).</p>
<p>Wrapper for the Cephes [1]_ routine <code>bdtri</code>.</p>
<h2 id="references_179">References<a class="headerlink" href="#references_179" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bdtrik</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>bdtrik(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>bdtrik(y, n, p)</p>
<p>Inverse function to <code>bdtr</code> with respect to <code>k</code>.</p>
<p>Finds the number of successes <code>k</code> such that the sum of the terms 0 through
<code>k</code> of the Binomial probability density for <code>n</code> events with probability
<code>p</code> is equal to the given cumulative probability <code>y</code>.</p>
<h2 id="parameters_238">Parameters<a class="headerlink" href="#parameters_238" title="Permanent link">&para;</a></h2>
<p>y : array_like
Cumulative probability (probability of <code>k</code> or fewer successes in <code>n</code>
events).
n : array_like
Number of events (float).
p : array_like
Success probability (float).</p>
<h2 id="returns_258">Returns<a class="headerlink" href="#returns_258" title="Permanent link">&para;</a></h2>
<p>k : ndarray
The number of successes <code>k</code> such that <code>bdtr(k, n, p) = y</code>.</p>
<h2 id="see-also_183">See also<a class="headerlink" href="#see-also_183" title="Permanent link">&para;</a></h2>
<p>bdtr</p>
<h2 id="notes_145">Notes<a class="headerlink" href="#notes_145" title="Permanent link">&para;</a></h2>
<p>Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the
cumulative incomplete beta distribution.</p>
<p>Computation of <code>k</code> involves a search for a value that produces the desired
value of <code>y</code>.  The search relies on the monotonicity of <code>y</code> with <code>k</code>.</p>
<p>Wrapper for the CDFLIB [2]_ Fortran routine <code>cdfbin</code>.</p>
<h2 id="references_180">References<a class="headerlink" href="#references_180" title="Permanent link">&para;</a></h2>
<p>.. [1] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.
.. [2] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bdtrin</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>bdtrin(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>bdtrin(k, y, p)</p>
<p>Inverse function to <code>bdtr</code> with respect to <code>n</code>.</p>
<p>Finds the number of events <code>n</code> such that the sum of the terms 0 through
<code>k</code> of the Binomial probability density for events with probability <code>p</code> is
equal to the given cumulative probability <code>y</code>.</p>
<h2 id="parameters_239">Parameters<a class="headerlink" href="#parameters_239" title="Permanent link">&para;</a></h2>
<p>k : array_like
Number of successes (float).
y : array_like
Cumulative probability (probability of <code>k</code> or fewer successes in <code>n</code>
events).
p : array_like
Success probability (float).</p>
<h2 id="returns_259">Returns<a class="headerlink" href="#returns_259" title="Permanent link">&para;</a></h2>
<p>n : ndarray
The number of events <code>n</code> such that <code>bdtr(k, n, p) = y</code>.</p>
<h2 id="see-also_184">See also<a class="headerlink" href="#see-also_184" title="Permanent link">&para;</a></h2>
<p>bdtr</p>
<h2 id="notes_146">Notes<a class="headerlink" href="#notes_146" title="Permanent link">&para;</a></h2>
<p>Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the
cumulative incomplete beta distribution.</p>
<p>Computation of <code>n</code> involves a search for a value that produces the desired
value of <code>y</code>.  The search relies on the monotonicity of <code>y</code> with <code>n</code>.</p>
<p>Wrapper for the CDFLIB [2]_ Fortran routine <code>cdfbin</code>.</p>
<h2 id="references_181">References<a class="headerlink" href="#references_181" title="Permanent link">&para;</a></h2>
<p>.. [1] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.
.. [2] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bei</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>bei(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>bei(x)</p>
<p>Kelvin function bei</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bei_zeros</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nt zeros of the Kelvin function bei(x).</p>
<h2 id="references_182">References<a class="headerlink" href="#references_182" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">beip</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>beip(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>beip(x)</p>
<p>Derivative of the Kelvin function <code>bei</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">beip_zeros</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nt zeros of the Kelvin function bei'(x).</p>
<h2 id="references_183">References<a class="headerlink" href="#references_183" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ber</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ber(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ber(x)</p>
<p>Kelvin function ber.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ber_zeros</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nt zeros of the Kelvin function ber(x).</p>
<h2 id="references_184">References<a class="headerlink" href="#references_184" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bernoulli</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Bernoulli numbers B0..Bn (inclusive).</p>
<h2 id="references_185">References<a class="headerlink" href="#references_185" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">berp</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>berp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>berp(x)</p>
<p>Derivative of the Kelvin function <code>ber</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">berp_zeros</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nt zeros of the Kelvin function ber'(x).</p>
<h2 id="references_186">References<a class="headerlink" href="#references_186" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">besselpoly</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>besselpoly(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>besselpoly(a, lmb, nu)</p>
<p>Weighted integral of a Bessel function.</p>
<p>.. math::</p>
<p>\int_0^1 x^\lambda J_\nu(2 a x) \, dx</p>
<p>where :math:<code>J_\nu</code> is a Bessel function and :math:<code>\lambda=lmb</code>,
:math:<code>\nu=nu</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">beta</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>beta(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>beta(a, b, out=None)</p>
<p>Beta function.</p>
<p>This function is defined in [1]_ as</p>
<p>.. math::</p>
<p>B(a, b) = \int_0^1 t^{a-1}(1-t)^{b-1}dt
= \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)},</p>
<p>where :math:<code>\Gamma</code> is the gamma function.</p>
<h2 id="parameters_240">Parameters<a class="headerlink" href="#parameters_240" title="Permanent link">&para;</a></h2>
<p>a, b : array-like
Real-valued arguments
out : ndarray, optional
Optional output array for the function result</p>
<h2 id="returns_260">Returns<a class="headerlink" href="#returns_260" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Value of the beta function</p>
<h2 id="see-also_185">See Also<a class="headerlink" href="#see-also_185" title="Permanent link">&para;</a></h2>
<p>gamma : the gamma function
betainc :  the incomplete beta function
betaln : the natural logarithm of the absolute
value of the beta function</p>
<h2 id="references_187">References<a class="headerlink" href="#references_187" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions,
Eq. 5.12.1. https://dlmf.nist.gov/5.12</p>
<h2 id="examples_79">Examples<a class="headerlink" href="#examples_79" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>The beta function relates to the gamma function by the
definition given above:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.beta(2, 3)
0.08333333333333333
sc.gamma(2)*sc.gamma(3)/sc.gamma(2 + 3)
0.08333333333333333</p>
</blockquote>
</blockquote>
</blockquote>
<p>As this relationship demonstrates, the beta function
is symmetric:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.beta(1.7, 2.4)
0.16567527689031739
sc.beta(2.4, 1.7)
0.16567527689031739</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function satisfies :math:<code>B(1, b) = 1/b</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.beta(1, 4)
0.25</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">betainc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>betainc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>betainc(a, b, x, out=None)</p>
<p>Incomplete beta function.</p>
<p>Computes the incomplete beta function, defined as [1]_:</p>
<p>.. math::</p>
<p>I_x(a, b) = \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)} \int_0^x
t^{a-1}(1-t)^{b-1}dt,</p>
<p>for :math:<code>0 \leq x \leq 1</code>.</p>
<h2 id="parameters_241">Parameters<a class="headerlink" href="#parameters_241" title="Permanent link">&para;</a></h2>
<p>a, b : array-like
Positive, real-valued parameters
x : array-like
Real-valued such that :math:<code>0 \leq x \leq 1</code>,
the upper limit of integration
out : ndarray, optional
Optional output array for the function values</p>
<h2 id="returns_261">Returns<a class="headerlink" href="#returns_261" title="Permanent link">&para;</a></h2>
<p>array-like
Value of the incomplete beta function</p>
<h2 id="see-also_186">See Also<a class="headerlink" href="#see-also_186" title="Permanent link">&para;</a></h2>
<p>beta : beta function
betaincinv : inverse of the incomplete beta function</p>
<h2 id="notes_147">Notes<a class="headerlink" href="#notes_147" title="Permanent link">&para;</a></h2>
<p>The incomplete beta function is also sometimes defined
without the <code>gamma</code> terms, in which case the above
definition is the so-called regularized incomplete beta
function. Under this definition, you can get the incomplete
beta function by multiplying the result of the SciPy
function by <code>beta</code>.</p>
<h2 id="references_188">References<a class="headerlink" href="#references_188" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/8.17</p>
<h2 id="examples_80">Examples<a class="headerlink" href="#examples_80" title="Permanent link">&para;</a></h2>
<p>Let :math:<code>B(a, b)</code> be the <code>beta</code> function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>The coefficient in terms of <code>gamma</code> is equal to
:math:<code>1/B(a, b)</code>. Also, when :math:<code>x=1</code>
the integral is equal to :math:<code>B(a, b)</code>.
Therefore, :math:<code>I_{x=1}(a, b) = 1</code> for any :math:<code>a, b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.betainc(0.2, 3.5, 1.0)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>It satisfies
:math:<code>I_x(a, b) = x^a F(a, 1-b, a+1, x)/ (aB(a, b))</code>,
where :math:<code>F</code> is the hypergeometric function <code>hyp2f1</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, b, x = 1.4, 3.1, 0.5
x**a * sc.hyp2f1(a, 1 - b, a + 1, x)/(a * sc.beta(a, b))
0.8148904036225295
sc.betainc(a, b, x)
0.8148904036225296</p>
</blockquote>
</blockquote>
</blockquote>
<p>This functions satisfies the relationship
:math:<code>I_x(a, b) = 1 - I_{1-x}(b, a)</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.betainc(2.2, 3.1, 0.4)
0.49339638807619446
1 - sc.betainc(3.1, 2.2, 1 - 0.4)
0.49339638807619446</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">betaincinv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>betaincinv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>betaincinv(a, b, y, out=None)</p>
<p>Inverse of the incomplete beta function.</p>
<p>Computes :math:<code>x</code> such that:</p>
<p>.. math::</p>
<p>y = I_x(a, b) = \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}
\int_0^x t^{a-1}(1-t)^{b-1}dt,</p>
<p>where :math:<code>I_x</code> is the normalized incomplete beta
function <code>betainc</code> and
:math:<code>\Gamma</code> is the <code>gamma</code> function [1]_.</p>
<h2 id="parameters_242">Parameters<a class="headerlink" href="#parameters_242" title="Permanent link">&para;</a></h2>
<p>a, b : array-like
Positive, real-valued parameters
y : array-like
Real-valued input
out : ndarray, optional
Optional output array for function values</p>
<h2 id="returns_262">Returns<a class="headerlink" href="#returns_262" title="Permanent link">&para;</a></h2>
<p>array-like
Value of the inverse of the incomplete beta function</p>
<h2 id="see-also_187">See Also<a class="headerlink" href="#see-also_187" title="Permanent link">&para;</a></h2>
<p>betainc : incomplete beta function
gamma : gamma function</p>
<h2 id="references_189">References<a class="headerlink" href="#references_189" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/8.17</p>
<h2 id="examples_81">Examples<a class="headerlink" href="#examples_81" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function is the inverse of <code>betainc</code> for fixed
values of :math:<code>a</code> and :math:<code>b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, b = 1.2, 3.1
y = sc.betainc(a, b, 0.2)
sc.betaincinv(a, b, y)
0.2</p>
<p>a, b = 7.5, 0.4
x = sc.betaincinv(a, b, 0.5)
sc.betainc(a, b, x)
0.5</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">betaln</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>betaln(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>betaln(a, b)</p>
<p>Natural logarithm of absolute value of beta function.</p>
<p>Computes <code>ln(abs(beta(a, b)))</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bi_zeros</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute <code>nt</code> zeros and values of the Airy function Bi and its derivative.</p>
<p>Computes the first <code>nt</code> zeros, b, of the Airy function Bi(x);
first <code>nt</code> zeros, b', of the derivative of the Airy function Bi'(x);
the corresponding values Bi(b');
and the corresponding values Bi'(b).</p>
<h2 id="parameters_243">Parameters<a class="headerlink" href="#parameters_243" title="Permanent link">&para;</a></h2>
<p>nt : int
Number of zeros to compute</p>
<h2 id="returns_263">Returns<a class="headerlink" href="#returns_263" title="Permanent link">&para;</a></h2>
<p>b : ndarray
First <code>nt</code> zeros of Bi(x)
bp : ndarray
First <code>nt</code> zeros of Bi'(x)
bi : ndarray
Values of Bi(x) evaluated at first <code>nt</code> zeros of Bi'(x)
bip : ndarray
Values of Bi'(x) evaluated at first <code>nt</code> zeros of Bi(x)</p>
<h2 id="examples_82">Examples<a class="headerlink" href="#examples_82" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
b, bp, bi, bip = special.bi_zeros(3)
b
array([-1.17371322, -3.2710933 , -4.83073784])
bp
array([-2.29443968, -4.07315509, -5.51239573])
bi
array([-0.45494438,  0.39652284, -0.36796916])
bip
array([ 0.60195789, -0.76031014,  0.83699101])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_190">References<a class="headerlink" href="#references_190" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binom</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>binom(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>binom(n, k)</p>
<p>Binomial coefficient</p>
<h2 id="see-also_188">See Also<a class="headerlink" href="#see-also_188" title="Permanent link">&para;</a></h2>
<p>comb : The number of combinations of N things taken k at a time.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">boxcox</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>boxcox(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>boxcox(x, lmbda)</p>
<p>Compute the Box-Cox transformation.</p>
<p>The Box-Cox transformation is::</p>
<p>y = (x**lmbda - 1) / lmbda  if lmbda != 0
log(x)                  if lmbda == 0</p>
<p>Returns <code>nan</code> if <code>x &lt; 0</code>.
Returns <code>-inf</code> if <code>x == 0</code> and <code>lmbda &lt; 0</code>.</p>
<h2 id="parameters_244">Parameters<a class="headerlink" href="#parameters_244" title="Permanent link">&para;</a></h2>
<p>x : array_like
Data to be transformed.
lmbda : array_like
Power parameter of the Box-Cox transform.</p>
<h2 id="returns_264">Returns<a class="headerlink" href="#returns_264" title="Permanent link">&para;</a></h2>
<p>y : array
Transformed data.</p>
<h2 id="notes_148">Notes<a class="headerlink" href="#notes_148" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.14.0</p>
<h2 id="examples_83">Examples<a class="headerlink" href="#examples_83" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import boxcox
boxcox([1, 4, 10], 2.5)
array([   0.        ,   12.4       ,  126.09110641])
boxcox(2, [0, 1, 2])
array([ 0.69314718,  1.        ,  1.5       ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">boxcox1p</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>boxcox1p(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>boxcox1p(x, lmbda)</p>
<p>Compute the Box-Cox transformation of 1 + <code>x</code>.</p>
<p>The Box-Cox transformation computed by <code>boxcox1p</code> is::</p>
<p>y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0
log(1+x)                    if lmbda == 0</p>
<p>Returns <code>nan</code> if <code>x &lt; -1</code>.
Returns <code>-inf</code> if <code>x == -1</code> and <code>lmbda &lt; 0</code>.</p>
<h2 id="parameters_245">Parameters<a class="headerlink" href="#parameters_245" title="Permanent link">&para;</a></h2>
<p>x : array_like
Data to be transformed.
lmbda : array_like
Power parameter of the Box-Cox transform.</p>
<h2 id="returns_265">Returns<a class="headerlink" href="#returns_265" title="Permanent link">&para;</a></h2>
<p>y : array
Transformed data.</p>
<h2 id="notes_149">Notes<a class="headerlink" href="#notes_149" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.14.0</p>
<h2 id="examples_84">Examples<a class="headerlink" href="#examples_84" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import boxcox1p
boxcox1p(1e-4, [0, 0.5, 1])
array([  9.99950003e-05,   9.99975001e-05,   1.00000000e-04])
boxcox1p([0.01, 0.1], 0.25)
array([ 0.00996272,  0.09645476])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">btdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>btdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>btdtr(a, b, x)</p>
<p>Cumulative distribution function of the beta distribution.</p>
<p>Returns the integral from zero to <code>x</code> of the beta probability density
function,</p>
<p>.. math::
I = \int_0^x \frac{\Gamma(a + b)}{\Gamma(a)\Gamma(b)} t^{a-1} (1-t)^{b-1}\,dt</p>
<p>where :math:<code>\Gamma</code> is the gamma function.</p>
<h2 id="parameters_246">Parameters<a class="headerlink" href="#parameters_246" title="Permanent link">&para;</a></h2>
<p>a : array_like
Shape parameter (a &gt; 0).
b : array_like
Shape parameter (b &gt; 0).
x : array_like
Upper limit of integration, in [0, 1].</p>
<h2 id="returns_266">Returns<a class="headerlink" href="#returns_266" title="Permanent link">&para;</a></h2>
<p>I : ndarray
Cumulative distribution function of the beta distribution with
parameters <code>a</code> and <code>b</code> at <code>x</code>.</p>
<h2 id="see-also_189">See Also<a class="headerlink" href="#see-also_189" title="Permanent link">&para;</a></h2>
<p>betainc</p>
<h2 id="notes_150">Notes<a class="headerlink" href="#notes_150" title="Permanent link">&para;</a></h2>
<p>This function is identical to the incomplete beta integral function
<code>betainc</code>.</p>
<p>Wrapper for the Cephes [1]_ routine <code>btdtr</code>.</p>
<h2 id="references_191">References<a class="headerlink" href="#references_191" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">btdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>btdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>btdtri(a, b, p)</p>
<p>The <code>p</code>-th quantile of the beta distribution.</p>
<p>This function is the inverse of the beta cumulative distribution function,
<code>btdtr</code>, returning the value of <code>x</code> for which <code>btdtr(a, b, x) = p</code>, or</p>
<p>.. math::
p = \int_0^x \frac{\Gamma(a + b)}{\Gamma(a)\Gamma(b)} t^{a-1} (1-t)^{b-1}\,dt</p>
<h2 id="parameters_247">Parameters<a class="headerlink" href="#parameters_247" title="Permanent link">&para;</a></h2>
<p>a : array_like
Shape parameter (<code>a</code> &gt; 0).
b : array_like
Shape parameter (<code>b</code> &gt; 0).
p : array_like
Cumulative probability, in [0, 1].</p>
<h2 id="returns_267">Returns<a class="headerlink" href="#returns_267" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The quantile corresponding to <code>p</code>.</p>
<h2 id="see-also_190">See Also<a class="headerlink" href="#see-also_190" title="Permanent link">&para;</a></h2>
<p>betaincinv
btdtr</p>
<h2 id="notes_151">Notes<a class="headerlink" href="#notes_151" title="Permanent link">&para;</a></h2>
<p>The value of <code>x</code> is found by interval halving or Newton iterations.</p>
<p>Wrapper for the Cephes [1]_ routine <code>incbi</code>, which solves the equivalent
problem of finding the inverse of the incomplete beta integral.</p>
<h2 id="references_192">References<a class="headerlink" href="#references_192" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">btdtria</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>btdtria(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>btdtria(p, b, x)</p>
<p>Inverse of <code>btdtr</code> with respect to <code>a</code>.</p>
<p>This is the inverse of the beta cumulative distribution function, <code>btdtr</code>,
considered as a function of <code>a</code>, returning the value of <code>a</code> for which
<code>btdtr(a, b, x) = p</code>, or</p>
<p>.. math::
p = \int_0^x \frac{\Gamma(a + b)}{\Gamma(a)\Gamma(b)} t^{a-1} (1-t)^{b-1}\,dt</p>
<h2 id="parameters_248">Parameters<a class="headerlink" href="#parameters_248" title="Permanent link">&para;</a></h2>
<p>p : array_like
Cumulative probability, in [0, 1].
b : array_like
Shape parameter (<code>b</code> &gt; 0).
x : array_like
The quantile, in [0, 1].</p>
<h2 id="returns_268">Returns<a class="headerlink" href="#returns_268" title="Permanent link">&para;</a></h2>
<p>a : ndarray
The value of the shape parameter <code>a</code> such that <code>btdtr(a, b, x) = p</code>.</p>
<h2 id="see-also_191">See Also<a class="headerlink" href="#see-also_191" title="Permanent link">&para;</a></h2>
<p>btdtr : Cumulative distribution function of the beta distribution.
btdtri : Inverse with respect to <code>x</code>.
btdtrib : Inverse with respect to <code>b</code>.</p>
<h2 id="notes_152">Notes<a class="headerlink" href="#notes_152" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfbet</code>.</p>
<p>The cumulative distribution function <code>p</code> is computed using a routine by
DiDinato and Morris [2]_.  Computation of <code>a</code> involves a search for a value
that produces the desired value of <code>p</code>.  The search relies on the
monotonicity of <code>p</code> with <code>a</code>.</p>
<h2 id="references_193">References<a class="headerlink" href="#references_193" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] DiDinato, A. R. and Morris, A. H.,
Algorithm 708: Significant Digit Computation of the Incomplete Beta
Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">btdtrib</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>btdtrib(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>btdtria(a, p, x)</p>
<p>Inverse of <code>btdtr</code> with respect to <code>b</code>.</p>
<p>This is the inverse of the beta cumulative distribution function, <code>btdtr</code>,
considered as a function of <code>b</code>, returning the value of <code>b</code> for which
<code>btdtr(a, b, x) = p</code>, or</p>
<p>.. math::
p = \int_0^x \frac{\Gamma(a + b)}{\Gamma(a)\Gamma(b)} t^{a-1} (1-t)^{b-1}\,dt</p>
<h2 id="parameters_249">Parameters<a class="headerlink" href="#parameters_249" title="Permanent link">&para;</a></h2>
<p>a : array_like
Shape parameter (<code>a</code> &gt; 0).
p : array_like
Cumulative probability, in [0, 1].
x : array_like
The quantile, in [0, 1].</p>
<h2 id="returns_269">Returns<a class="headerlink" href="#returns_269" title="Permanent link">&para;</a></h2>
<p>b : ndarray
The value of the shape parameter <code>b</code> such that <code>btdtr(a, b, x) = p</code>.</p>
<h2 id="see-also_192">See Also<a class="headerlink" href="#see-also_192" title="Permanent link">&para;</a></h2>
<p>btdtr : Cumulative distribution function of the beta distribution.
btdtri : Inverse with respect to <code>x</code>.
btdtria : Inverse with respect to <code>a</code>.</p>
<h2 id="notes_153">Notes<a class="headerlink" href="#notes_153" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfbet</code>.</p>
<p>The cumulative distribution function <code>p</code> is computed using a routine by
DiDinato and Morris [2]_.  Computation of <code>b</code> involves a search for a value
that produces the desired value of <code>p</code>.  The search relies on the
monotonicity of <code>p</code> with <code>b</code>.</p>
<h2 id="references_194">References<a class="headerlink" href="#references_194" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] DiDinato, A. R. and Morris, A. H.,
Algorithm 708: Significant Digit Computation of the Incomplete Beta
Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">c_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (first kind) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the first kind, :math:<code>C_n(x)</code>. These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-2, 2]</code>
with weight function :math:<code>w(x) = 1 / \sqrt{1 - (x/2)^2}</code>. See
22.2.6 in [AS]_ for more details.</p>
<h2 id="parameters_250">Parameters<a class="headerlink" href="#parameters_250" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_270">Returns<a class="headerlink" href="#returns_270" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_193">See Also<a class="headerlink" href="#see-also_193" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_195">References<a class="headerlink" href="#references_195" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cbrt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>cbrt(x)</p>
<p>Element-wise cube root of <code>x</code>.</p>
<h2 id="parameters_251">Parameters<a class="headerlink" href="#parameters_251" title="Permanent link">&para;</a></h2>
<p>x : array_like
<code>x</code> must contain real numbers.</p>
<h2 id="returns_271">Returns<a class="headerlink" href="#returns_271" title="Permanent link">&para;</a></h2>
<p>float
The cube root of each value in <code>x</code>.</p>
<h2 id="examples_85">Examples<a class="headerlink" href="#examples_85" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import cbrt</p>
<p>cbrt(8)
2.0
cbrt([-8, -3, 0.125, 1.331])
array([-2.        , -1.44224957,  0.5       ,  1.1       ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cg_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Gegenbauer quadrature.</p>
<p>Compute the sample points and weights for Gauss-Gegenbauer
quadrature. The sample points are the roots of the n-th degree
Gegenbauer polynomial, :math:<code>C^{\alpha}_n(x)</code>. These sample
points and weights correctly integrate polynomials of degree
:math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code> with
weight function :math:<code>w(x) = (1 - x^2)^{\alpha - 1/2}</code>. See
22.2.3 in [AS]_ for more details.</p>
<h2 id="parameters_252">Parameters<a class="headerlink" href="#parameters_252" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
alpha : float
alpha must be &gt; -0.5
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_272">Returns<a class="headerlink" href="#returns_272" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_194">See Also<a class="headerlink" href="#see-also_194" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_196">References<a class="headerlink" href="#references_196" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chdtr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chdtr(v, x)</p>
<p>Chi square cumulative distribution function</p>
<p>Returns the area under the left hand tail (from 0 to <code>x</code>) of the Chi
square probability density function with <code>v</code> degrees of freedom::</p>
<p>1/(2<strong>(v/2) * gamma(v/2)) * integral(t</strong>(v/2-1) * exp(-t/2), t=0..x)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chdtrc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chdtrc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chdtrc(v, x)</p>
<p>Chi square survival function</p>
<p>Returns the area under the right hand tail (from <code>x</code> to
infinity) of the Chi square probability density function with <code>v</code>
degrees of freedom::</p>
<p>1/(2<strong>(v/2) * gamma(v/2)) * integral(t</strong>(v/2-1) * exp(-t/2), t=x..inf)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chdtri(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chdtri(v, p)</p>
<p>Inverse to <code>chdtrc</code></p>
<p>Returns the argument x such that <code>chdtrc(v, x) == p</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chdtriv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chdtriv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chdtriv(p, x)</p>
<p>Inverse to <code>chdtr</code> vs <code>v</code></p>
<p>Returns the argument v such that <code>chdtr(v, x) == p</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chebyc</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Chebyshev polynomial of the first kind on :math:<code>[-2, 2]</code>.</p>
<p>Defined as :math:<code>C_n(x) = 2T_n(x/2)</code>, where :math:<code>T_n</code> is the
nth Chebychev polynomial of the first kind.</p>
<h2 id="parameters_253">Parameters<a class="headerlink" href="#parameters_253" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_273">Returns<a class="headerlink" href="#returns_273" title="Permanent link">&para;</a></h2>
<p>C : orthopoly1d
Chebyshev polynomial of the first kind on :math:<code>[-2, 2]</code>.</p>
<h2 id="notes_154">Notes<a class="headerlink" href="#notes_154" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>C_n(x)</code> are orthogonal over :math:<code>[-2, 2]</code>
with weight function :math:<code>1/\sqrt{1 - (x/2)^2}</code>.</p>
<h2 id="see-also_195">See Also<a class="headerlink" href="#see-also_195" title="Permanent link">&para;</a></h2>
<p>chebyt : Chebyshev polynomial of the first kind.</p>
<h2 id="references_197">References<a class="headerlink" href="#references_197" title="Permanent link">&para;</a></h2>
<p>.. [1] Abramowitz and Stegun, 'Handbook of Mathematical Functions'
Section 22. National Bureau of Standards, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chebys</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Chebyshev polynomial of the second kind on :math:<code>[-2, 2]</code>.</p>
<p>Defined as :math:<code>S_n(x) = U_n(x/2)</code> where :math:<code>U_n</code> is the
nth Chebychev polynomial of the second kind.</p>
<h2 id="parameters_254">Parameters<a class="headerlink" href="#parameters_254" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_274">Returns<a class="headerlink" href="#returns_274" title="Permanent link">&para;</a></h2>
<p>S : orthopoly1d
Chebyshev polynomial of the second kind on :math:<code>[-2, 2]</code>.</p>
<h2 id="notes_155">Notes<a class="headerlink" href="#notes_155" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>S_n(x)</code> are orthogonal over :math:<code>[-2, 2]</code>
with weight function :math:<code>\sqrt{1 - (x/2)}^2</code>.</p>
<h2 id="see-also_196">See Also<a class="headerlink" href="#see-also_196" title="Permanent link">&para;</a></h2>
<p>chebyu : Chebyshev polynomial of the second kind</p>
<h2 id="references_198">References<a class="headerlink" href="#references_198" title="Permanent link">&para;</a></h2>
<p>.. [1] Abramowitz and Stegun, 'Handbook of Mathematical Functions'
Section 22. National Bureau of Standards, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Chebyshev polynomial of the first kind.</p>
<p>Defined to be the solution of</p>
<p>.. math::
(1 - x^2)\frac{d^2}{dx^2}T_n - x\frac{d}{dx}T_n + n^2T_n = 0;</p>
<p>:math:<code>T_n</code> is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_255">Parameters<a class="headerlink" href="#parameters_255" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_275">Returns<a class="headerlink" href="#returns_275" title="Permanent link">&para;</a></h2>
<p>T : orthopoly1d
Chebyshev polynomial of the first kind.</p>
<h2 id="notes_156">Notes<a class="headerlink" href="#notes_156" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>T_n</code> are orthogonal over :math:<code>[-1, 1]</code>
with weight function :math:<code>(1 - x^2)^{-1/2}</code>.</p>
<h2 id="see-also_197">See Also<a class="headerlink" href="#see-also_197" title="Permanent link">&para;</a></h2>
<p>chebyu : Chebyshev polynomial of the second kind.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Chebyshev polynomial of the second kind.</p>
<p>Defined to be the solution of</p>
<p>.. math::
(1 - x^2)\frac{d^2}{dx^2}U_n - 3x\frac{d}{dx}U_n
+ n(n + 2)U_n = 0;</p>
<p>:math:<code>U_n</code> is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_256">Parameters<a class="headerlink" href="#parameters_256" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_276">Returns<a class="headerlink" href="#returns_276" title="Permanent link">&para;</a></h2>
<p>U : orthopoly1d
Chebyshev polynomial of the second kind.</p>
<h2 id="notes_157">Notes<a class="headerlink" href="#notes_157" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>U_n</code> are orthogonal over :math:<code>[-1, 1]</code>
with weight function :math:<code>(1 - x^2)^{1/2}</code>.</p>
<h2 id="see-also_198">See Also<a class="headerlink" href="#see-also_198" title="Permanent link">&para;</a></h2>
<p>chebyt : Chebyshev polynomial of the first kind.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chndtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chndtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chndtr(x, df, nc)</p>
<p>Non-central chi square cumulative distribution function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chndtridf</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chndtridf(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chndtridf(x, p, nc)</p>
<p>Inverse to <code>chndtr</code> vs <code>df</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chndtrinc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chndtrinc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chndtrinc(x, df, p)</p>
<p>Inverse to <code>chndtr</code> vs <code>nc</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chndtrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>chndtrix(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>chndtrix(p, df, nc)</p>
<p>Inverse to <code>chndtr</code> vs <code>x</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">clpmn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complex</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Associated Legendre function of the first kind for complex arguments.</p>
<p>Computes the associated Legendre function of the first kind of order m and
degree n, <code>Pmn(z)</code> = :math:<code>P_n^m(z)</code>, and its derivative, <code>Pmn'(z)</code>.
Returns two arrays of size <code>(m+1, n+1)</code> containing <code>Pmn(z)</code> and
<code>Pmn'(z)</code> for all orders from <code>0..m</code> and degrees from <code>0..n</code>.</p>
<h2 id="parameters_257">Parameters<a class="headerlink" href="#parameters_257" title="Permanent link">&para;</a></h2>
<p>m : int
<code>|m| &lt;= n</code>; the order of the Legendre function.
n : int
where <code>n &gt;= 0</code>; the degree of the Legendre function.  Often
called <code>l</code> (lower case L) in descriptions of the associated
Legendre function
z : float or complex
Input value.
type : int, optional
takes values 2 or 3
2: cut on the real axis <code>|x| &gt; 1</code>
3: cut on the real axis <code>-1 &lt; x &lt; 1</code> (default)</p>
<h2 id="returns_277">Returns<a class="headerlink" href="#returns_277" title="Permanent link">&para;</a></h2>
<p>Pmn_z : (m+1, n+1) array
Values for all orders <code>0..m</code> and degrees <code>0..n</code>
Pmn_d_z : (m+1, n+1) array
Derivatives for all orders <code>0..m</code> and degrees <code>0..n</code></p>
<h2 id="see-also_199">See Also<a class="headerlink" href="#see-also_199" title="Permanent link">&para;</a></h2>
<p>lpmn: associated Legendre functions of the first kind for real z</p>
<h2 id="notes_158">Notes<a class="headerlink" href="#notes_158" title="Permanent link">&para;</a></h2>
<p>By default, i.e. for <code>type=3</code>, phase conventions are chosen according
to [1]_ such that the function is analytic. The cut lies on the interval
(-1, 1). Approaching the cut from above or below in general yields a phase
factor with respect to Ferrer's function of the first kind
(cf. <code>lpmn</code>).</p>
<p>For <code>type=2</code> a cut at <code>|x| &gt; 1</code> is chosen. Approaching the real values
on the interval (-1, 1) in the complex plane yields Ferrer's function
of the first kind.</p>
<h2 id="references_199">References<a class="headerlink" href="#references_199" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html
.. [2] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/14.21</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">comb</span> <span class="o">:</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">repetition</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The number of combinations of N things taken k at a time.</p>
<p>This is often expressed as 'N choose k'.</p>
<h2 id="parameters_258">Parameters<a class="headerlink" href="#parameters_258" title="Permanent link">&para;</a></h2>
<p>N : int, ndarray
Number of things.
k : int, ndarray
Number of elements taken.
exact : bool, optional
If <code>exact</code> is False, then floating point precision is used, otherwise
exact long integer is computed.
repetition : bool, optional
If <code>repetition</code> is True, then the number of combinations with
repetition is computed.</p>
<h2 id="returns_278">Returns<a class="headerlink" href="#returns_278" title="Permanent link">&para;</a></h2>
<p>val : int, float, ndarray
The total number of combinations.</p>
<h2 id="see-also_200">See Also<a class="headerlink" href="#see-also_200" title="Permanent link">&para;</a></h2>
<p>binom : Binomial coefficient ufunc</p>
<h2 id="notes_159">Notes<a class="headerlink" href="#notes_159" title="Permanent link">&para;</a></h2>
<ul>
<li>Array arguments accepted only for exact=False case.</li>
<li>If N &lt; 0, or k &lt; 0, then 0 is returned.</li>
<li>If k &gt; N and repetition=False, then 0 is returned.</li>
</ul>
<h2 id="examples_86">Examples<a class="headerlink" href="#examples_86" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import comb
k = np.array([3, 4])
n = np.array([10, 10])
comb(n, k, exact=False)
array([ 120.,  210.])
comb(10, 3, exact=True)
120L
comb(10, 3, exact=True, repetition=True)
220L</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosdg</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cosdg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>cosdg(x)</p>
<p>Cosine of the angle <code>x</code> given in degrees.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosm1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cosm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>cosm1(x)</p>
<p>cos(x) - 1 for use when <code>x</code> is near zero.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cotdg</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cotdg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>cotdg(x)</p>
<p>Cotangent of the angle <code>x</code> given in degrees.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dawsn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>dawsn(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>dawsn(x)</p>
<p>Dawson's integral.</p>
<p>Computes::</p>
<p>exp(-x<strong>2) * integral(exp(t</strong>2), t=0..x).</p>
<h2 id="see-also_201">See Also<a class="headerlink" href="#see-also_201" title="Permanent link">&para;</a></h2>
<p>wofz, erf, erfc, erfcx, erfi</p>
<h2 id="references_200">References<a class="headerlink" href="#references_200" title="Permanent link">&para;</a></h2>
<p>.. [1] Steven G. Johnson, Faddeeva W function implementation.
http://ab-initio.mit.edu/Faddeeva</p>
<h2 id="examples_87">Examples<a class="headerlink" href="#examples_87" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
import matplotlib.pyplot as plt
x = np.linspace(-15, 15, num=1000)
plt.plot(x, special.dawsn(x))
plt.xlabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>')
plt.ylabel('<span><span class="MathJax_Preview">dawsn(x)</span><script type="math/tex">dawsn(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">digamma</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>psi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>psi(z, out=None)</p>
<p>The digamma function.</p>
<p>The logarithmic derivative of the gamma function evaluated at <code>z</code>.</p>
<h2 id="parameters_259">Parameters<a class="headerlink" href="#parameters_259" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex argument.
out : ndarray, optional
Array for the computed values of <code>psi</code>.</p>
<h2 id="returns_279">Returns<a class="headerlink" href="#returns_279" title="Permanent link">&para;</a></h2>
<p>digamma : ndarray
Computed values of <code>psi</code>.</p>
<h2 id="notes_160">Notes<a class="headerlink" href="#notes_160" title="Permanent link">&para;</a></h2>
<p>For large values not close to the negative real axis <code>psi</code> is
computed using the asymptotic series (5.11.2) from [1]<em>. For small
arguments not close to the negative real axis the recurrence
relation (5.5.2) from [1]</em> is used until the argument is large
enough to use the asymptotic series. For values close to the
negative real axis the reflection formula (5.5.4) from [1]<em> is
used first.  Note that <code>psi</code> has a family of zeros on the
negative real axis which occur between the poles at nonpositive
integers. Around the zeros the reflection formula suffers from
cancellation and the implementation loses precision. The sole
positive zero and the first negative zero, however, are handled
separately by precomputing series expansions using [2]</em>, so the
function should maintain full accuracy around the origin.</p>
<h2 id="references_201">References<a class="headerlink" href="#references_201" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/5
.. [2] Fredrik Johansson and others.
'mpmath: a Python library for arbitrary-precision floating-point arithmetic'
(Version 0.19) http://mpmath.org/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diric</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Periodic sinc function, also called the Dirichlet function.</p>
<p>The Dirichlet function is defined as::</p>
<p>diric(x, n) = sin(x * n/2) / (n * sin(x / 2)),</p>
<p>where <code>n</code> is a positive integer.</p>
<h2 id="parameters_260">Parameters<a class="headerlink" href="#parameters_260" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input data
n : int
Integer defining the periodicity.</p>
<h2 id="returns_280">Returns<a class="headerlink" href="#returns_280" title="Permanent link">&para;</a></h2>
<p>diric : ndarray</p>
<h2 id="examples_88">Examples<a class="headerlink" href="#examples_88" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
import matplotlib.pyplot as plt</p>
<p>x = np.linspace(-8<em>np.pi, 8</em>np.pi, num=201)
plt.figure(figsize=(8, 8));
for idx, n in enumerate([2, 3, 4, 9]):
...     plt.subplot(2, 2, idx+1)
...     plt.plot(x, special.diric(x, n))
...     plt.title('diric, n={}'.format(n))
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>The following example demonstrates that <code>diric</code> gives the magnitudes
(modulo the sign and scaling) of the Fourier coefficients of a
rectangular pulse.</p>
<p>Suppress output of values that are effectively 0:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.set_printoptions(suppress=True)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create a signal <code>x</code> of length <code>m</code> with <code>k</code> ones:</p>
<blockquote>
<blockquote>
<blockquote>
<p>m = 8
k = 3
x = np.zeros(m)
x[:k] = 1</p>
</blockquote>
</blockquote>
</blockquote>
<p>Use the FFT to compute the Fourier transform of <code>x</code>, and
inspect the magnitudes of the coefficients:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.abs(np.fft.fft(x))
array([ 3.        ,  2.41421356,  1.        ,  0.41421356,  1.        ,
0.41421356,  1.        ,  2.41421356])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now find the same values (up to sign) using <code>diric</code>.  We multiply
by <code>k</code> to account for the different scaling conventions of
<code>numpy.fft.fft</code> and <code>diric</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>theta = np.linspace(0, 2*np.pi, m, endpoint=False)
k * special.diric(theta, k)
array([ 3.        ,  2.41421356,  1.        , -0.41421356, -1.        ,
-0.41421356,  1.        ,  2.41421356])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellip_harm</span> <span class="o">:</span> <span class="o">?</span><span class="n">signm</span><span class="o">:[`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_1</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">signn</span><span class="o">:[`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_1</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">h2</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">k2</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Ellipsoidal harmonic functions E^p_n(l)</p>
<p>These are also known as Lame functions of the first kind, and are
solutions to the Lame equation:</p>
<p>.. math:: (s^2 - h^2)(s^2 - k^2)E''(s) + s(2s^2 - h^2 - k^2)E'(s) + (a - q s^2)E(s) = 0</p>
<p>where :math:<code>q = (n+1)n</code> and :math:<code>a</code> is the eigenvalue (not
returned) corresponding to the solutions.</p>
<h2 id="parameters_261">Parameters<a class="headerlink" href="#parameters_261" title="Permanent link">&para;</a></h2>
<p>h2 : float
<code>h**2</code>
k2 : float
<code>k**2</code>; should be larger than <code>h**2</code>
n : int
Degree
s : float
Coordinate
p : int
Order, can range between [1,2n+1]
signm : {1, -1}, optional
Sign of prefactor of functions. Can be +/-1. See Notes.
signn : {1, -1}, optional
Sign of prefactor of functions. Can be +/-1. See Notes.</p>
<h2 id="returns_281">Returns<a class="headerlink" href="#returns_281" title="Permanent link">&para;</a></h2>
<p>E : float
the harmonic :math:<code>E^p_n(s)</code></p>
<h2 id="see-also_202">See Also<a class="headerlink" href="#see-also_202" title="Permanent link">&para;</a></h2>
<p>ellip_harm_2, ellip_normal</p>
<h2 id="notes_161">Notes<a class="headerlink" href="#notes_161" title="Permanent link">&para;</a></h2>
<p>The geometric interpretation of the ellipsoidal functions is
explained in [2]<em>, [3]</em>, [4]_.  The <code>signm</code> and <code>signn</code> arguments control the
sign of prefactors for functions according to their type::</p>
<p>K : +1
L : signm
M : signn
N : signm*signn</p>
<p>.. versionadded:: 0.15.0</p>
<h2 id="references_202">References<a class="headerlink" href="#references_202" title="Permanent link">&para;</a></h2>
<p>.. [1] Digital Library of Mathematical Functions 29.12
https://dlmf.nist.gov/29.12
.. [2] Bardhan and Knepley, 'Computational science and
re-discovery: open-source implementations of
ellipsoidal harmonics for problems in potential theory',
Comput. Sci. Disc. 5, 014006 (2012)
:doi:<code>10.1088/1749-4699/5/1/014006</code>.
.. [3] David J.and Dechambre P, 'Computation of Ellipsoidal
Gravity Field Harmonics for small solar system bodies'
pp. 30-36, 2000
.. [4] George Dassios, 'Ellipsoidal Harmonics: Theory and Applications'
pp. 418, 2012</p>
<h2 id="examples_89">Examples<a class="headerlink" href="#examples_89" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import ellip_harm
w = ellip_harm(5,8,1,1,2.5)
w
2.5</p>
</blockquote>
</blockquote>
</blockquote>
<p>Check that the functions indeed are solutions to the Lame equation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.interpolate import UnivariateSpline
def eigenvalue(f, df, ddf):
...     r = ((s<strong>2 - h</strong>2)<em>(s</em><em>2 - k</em><em>2)</em>ddf + s<em>(2</em>s<strong>2 - h</strong>2 - k<strong>2)<em>df - n</em>(n+1)*s</strong>2<em>f)/f
...     return -r.mean(), r.std()
s = np.linspace(0.1, 10, 200)
k, h, n, p = 8.0, 2.2, 3, 2
E = ellip_harm(h</em><em>2, k</em>*2, n, p, s)
E_spl = UnivariateSpline(s, E)
a, a_err = eigenvalue(E_spl(s), E_spl(s,1), E_spl(s,2))
a, a_err
(583.44366156701483, 6.4580890640310646e-11)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellip_harm_2</span> <span class="o">:</span> <span class="n">h2</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">k2</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Ellipsoidal harmonic functions F^p_n(l)</p>
<p>These are also known as Lame functions of the second kind, and are
solutions to the Lame equation:</p>
<p>.. math:: (s^2 - h^2)(s^2 - k^2)F''(s) + s(2s^2 - h^2 - k^2)F'(s) + (a - q s^2)F(s) = 0</p>
<p>where :math:<code>q = (n+1)n</code> and :math:<code>a</code> is the eigenvalue (not
returned) corresponding to the solutions.</p>
<h2 id="parameters_262">Parameters<a class="headerlink" href="#parameters_262" title="Permanent link">&para;</a></h2>
<p>h2 : float
<code>h**2</code>
k2 : float
<code>k**2</code>; should be larger than <code>h**2</code>
n : int
Degree.
p : int
Order, can range between [1,2n+1].
s : float
Coordinate</p>
<h2 id="returns_282">Returns<a class="headerlink" href="#returns_282" title="Permanent link">&para;</a></h2>
<p>F : float
The harmonic :math:<code>F^p_n(s)</code></p>
<h2 id="notes_162">Notes<a class="headerlink" href="#notes_162" title="Permanent link">&para;</a></h2>
<p>Lame functions of the second kind are related to the functions of the first kind:</p>
<p>.. math::</p>
<p>F^p_n(s)=(2n + 1)E^p_n(s)\int_{0}^{1/s}\frac{du}{(E^p_n(1/u))^2\sqrt{(1-u^2k^2)(1-u^2h^2)}}</p>
<p>.. versionadded:: 0.15.0</p>
<h2 id="see-also_203">See Also<a class="headerlink" href="#see-also_203" title="Permanent link">&para;</a></h2>
<p>ellip_harm, ellip_normal</p>
<h2 id="examples_90">Examples<a class="headerlink" href="#examples_90" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import ellip_harm_2
w = ellip_harm_2(5,8,2,1,10)
w
0.00108056853382</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellip_normal</span> <span class="o">:</span> <span class="n">h2</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">k2</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Ellipsoidal harmonic normalization constants gamma^p_n</p>
<p>The normalization constant is defined as</p>
<p>.. math::</p>
<p>\gamma^p_n=8\int_{0}^{h}dx\int_{h}^{k}dy\frac{(y^2-x^2)(E^p_n(y)E^p_n(x))^2}{\sqrt((k^2-y^2)(y^2-h^2)(h^2-x^2)(k^2-x^2)}</p>
<h2 id="parameters_263">Parameters<a class="headerlink" href="#parameters_263" title="Permanent link">&para;</a></h2>
<p>h2 : float
<code>h**2</code>
k2 : float
<code>k**2</code>; should be larger than <code>h**2</code>
n : int
Degree.
p : int
Order, can range between [1,2n+1].</p>
<h2 id="returns_283">Returns<a class="headerlink" href="#returns_283" title="Permanent link">&para;</a></h2>
<p>gamma : float
The normalization constant :math:<code>\gamma^p_n</code></p>
<h2 id="see-also_204">See Also<a class="headerlink" href="#see-also_204" title="Permanent link">&para;</a></h2>
<p>ellip_harm, ellip_harm_2</p>
<h2 id="notes_163">Notes<a class="headerlink" href="#notes_163" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.15.0</p>
<h2 id="examples_91">Examples<a class="headerlink" href="#examples_91" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import ellip_normal
w = ellip_normal(5,8,3,7)
w
1723.38796997</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipe</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ellipe(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ellipe(m)</p>
<p>Complete elliptic integral of the second kind</p>
<p>This function is defined as</p>
<p>.. math:: E(m) = \int_0^{\pi/2} [1 - m \sin(t)^2]^{1/2} dt</p>
<h2 id="parameters_264">Parameters<a class="headerlink" href="#parameters_264" title="Permanent link">&para;</a></h2>
<p>m : array_like
Defines the parameter of the elliptic integral.</p>
<h2 id="returns_284">Returns<a class="headerlink" href="#returns_284" title="Permanent link">&para;</a></h2>
<p>E : ndarray
Value of the elliptic integral.</p>
<h2 id="notes_164">Notes<a class="headerlink" href="#notes_164" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>ellpe</code>.</p>
<p>For <code>m &gt; 0</code> the computation uses the approximation,</p>
<p>.. math:: E(m) \approx P(1-m) - (1-m) \log(1-m) Q(1-m),</p>
<p>where :math:<code>P</code> and :math:<code>Q</code> are tenth-order polynomials.  For
<code>m &lt; 0</code>, the relation</p>
<p>.. math:: E(m) = E(m/(m - 1)) \sqrt(1-m)</p>
<p>is used.</p>
<p>The parameterization in terms of :math:<code>m</code> follows that of section
17.2 in [2]_. Other parameterizations in terms of the
complementary parameter :math:<code>1 - m</code>, modular angle
:math:<code>\sin^2(\alpha) = m</code>, or modulus :math:<code>k^2 = m</code> are also
used, so be careful that you choose the correct parameter.</p>
<h2 id="see-also_205">See Also<a class="headerlink" href="#see-also_205" title="Permanent link">&para;</a></h2>
<p>ellipkm1 : Complete elliptic integral of the first kind, near <code>m</code> = 1
ellipk : Complete elliptic integral of the first kind
ellipkinc : Incomplete elliptic integral of the first kind
ellipeinc : Incomplete elliptic integral of the second kind</p>
<h2 id="references_203">References<a class="headerlink" href="#references_203" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<h2 id="examples_92">Examples<a class="headerlink" href="#examples_92" title="Permanent link">&para;</a></h2>
<p>This function is used in finding the circumference of an
ellipse with semi-major axis <code>a</code> and semi-minor axis <code>b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special</p>
<p>a = 3.5
b = 2.1
e_sq = 1.0 - b<strong>2/a</strong>2  # eccentricity squared</p>
</blockquote>
</blockquote>
</blockquote>
<p>Then the circumference is found using the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>C = 4<em>a</em>special.ellipe(e_sq)  # circumference formula
C
17.868899204378693</p>
</blockquote>
</blockquote>
</blockquote>
<p>When <code>a</code> and <code>b</code> are the same (meaning eccentricity is 0),
this reduces to the circumference of a circle.</p>
<blockquote>
<blockquote>
<blockquote>
<p>4<em>a</em>special.ellipe(0.0)  # formula for ellipse with a = b
21.991148575128552
2<em>np.pi</em>a  # formula for circle of radius a
21.991148575128552</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipeinc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ellipeinc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ellipeinc(phi, m)</p>
<p>Incomplete elliptic integral of the second kind</p>
<p>This function is defined as</p>
<p>.. math:: E(\phi, m) = \int_0^{\phi} [1 - m \sin(t)^2]^{1/2} dt</p>
<h2 id="parameters_265">Parameters<a class="headerlink" href="#parameters_265" title="Permanent link">&para;</a></h2>
<p>phi : array_like
amplitude of the elliptic integral.</p>
<p>m : array_like
parameter of the elliptic integral.</p>
<h2 id="returns_285">Returns<a class="headerlink" href="#returns_285" title="Permanent link">&para;</a></h2>
<p>E : ndarray
Value of the elliptic integral.</p>
<h2 id="notes_165">Notes<a class="headerlink" href="#notes_165" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>ellie</code>.</p>
<p>Computation uses arithmetic-geometric means algorithm.</p>
<p>The parameterization in terms of :math:<code>m</code> follows that of section
17.2 in [2]_. Other parameterizations in terms of the
complementary parameter :math:<code>1 - m</code>, modular angle
:math:<code>\sin^2(\alpha) = m</code>, or modulus :math:<code>k^2 = m</code> are also
used, so be careful that you choose the correct parameter.</p>
<h2 id="see-also_206">See Also<a class="headerlink" href="#see-also_206" title="Permanent link">&para;</a></h2>
<p>ellipkm1 : Complete elliptic integral of the first kind, near <code>m</code> = 1
ellipk : Complete elliptic integral of the first kind
ellipkinc : Incomplete elliptic integral of the first kind
ellipe : Complete elliptic integral of the second kind</p>
<h2 id="references_204">References<a class="headerlink" href="#references_204" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipj</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ellipj(x1, x2[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ellipj(u, m)</p>
<p>Jacobian elliptic functions</p>
<p>Calculates the Jacobian elliptic functions of parameter <code>m</code> between
0 and 1, and real argument <code>u</code>.</p>
<h2 id="parameters_266">Parameters<a class="headerlink" href="#parameters_266" title="Permanent link">&para;</a></h2>
<p>m : array_like
Parameter.
u : array_like
Argument.</p>
<h2 id="returns_286">Returns<a class="headerlink" href="#returns_286" title="Permanent link">&para;</a></h2>
<p>sn, cn, dn, ph : ndarrays
The returned functions::</p>
<p>sn(u|m), cn(u|m), dn(u|m)</p>
<p>The value <code>ph</code> is such that if <code>u = ellipkinc(ph, m)</code>,
then <code>sn(u|m) = sin(ph)</code> and <code>cn(u|m) = cos(ph)</code>.</p>
<h2 id="notes_166">Notes<a class="headerlink" href="#notes_166" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>ellpj</code>.</p>
<p>These functions are periodic, with quarter-period on the real axis
equal to the complete elliptic integral <code>ellipk(m)</code>.</p>
<p>Relation to incomplete elliptic integral: If <code>u = ellipkinc(phi,m)</code>, then
<code>sn(u|m) = sin(phi)</code>, and <code>cn(u|m) = cos(phi)</code>.  The <code>phi</code> is called
the amplitude of <code>u</code>.</p>
<p>Computation is by means of the arithmetic-geometric mean algorithm,
except when <code>m</code> is within 1e-9 of 0 or 1.  In the latter case with <code>m</code>
close to 1, the approximation applies only for <code>phi &lt; pi/2</code>.</p>
<h2 id="see-also_207">See also<a class="headerlink" href="#see-also_207" title="Permanent link">&para;</a></h2>
<p>ellipk : Complete elliptic integral of the first kind
ellipkinc : Incomplete elliptic integral of the first kind</p>
<h2 id="references_205">References<a class="headerlink" href="#references_205" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipk</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ellipk(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ellipk(m)</p>
<p>Complete elliptic integral of the first kind.</p>
<p>This function is defined as</p>
<p>.. math:: K(m) = \int_0^{\pi/2} [1 - m \sin(t)^2]^{-1/2} dt</p>
<h2 id="parameters_267">Parameters<a class="headerlink" href="#parameters_267" title="Permanent link">&para;</a></h2>
<p>m : array_like
The parameter of the elliptic integral.</p>
<h2 id="returns_287">Returns<a class="headerlink" href="#returns_287" title="Permanent link">&para;</a></h2>
<p>K : array_like
Value of the elliptic integral.</p>
<h2 id="notes_167">Notes<a class="headerlink" href="#notes_167" title="Permanent link">&para;</a></h2>
<p>For more precision around point m = 1, use <code>ellipkm1</code>, which this
function calls.</p>
<p>The parameterization in terms of :math:<code>m</code> follows that of section
17.2 in [1]_. Other parameterizations in terms of the
complementary parameter :math:<code>1 - m</code>, modular angle
:math:<code>\sin^2(\alpha) = m</code>, or modulus :math:<code>k^2 = m</code> are also
used, so be careful that you choose the correct parameter.</p>
<h2 id="see-also_208">See Also<a class="headerlink" href="#see-also_208" title="Permanent link">&para;</a></h2>
<p>ellipkm1 : Complete elliptic integral of the first kind around m = 1
ellipkinc : Incomplete elliptic integral of the first kind
ellipe : Complete elliptic integral of the second kind
ellipeinc : Incomplete elliptic integral of the second kind</p>
<h2 id="references_206">References<a class="headerlink" href="#references_206" title="Permanent link">&para;</a></h2>
<p>.. [1] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipkinc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ellipkinc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ellipkinc(phi, m)</p>
<p>Incomplete elliptic integral of the first kind</p>
<p>This function is defined as</p>
<p>.. math:: K(\phi, m) = \int_0^{\phi} [1 - m \sin(t)^2]^{-1/2} dt</p>
<p>This function is also called <code>F(phi, m)</code>.</p>
<h2 id="parameters_268">Parameters<a class="headerlink" href="#parameters_268" title="Permanent link">&para;</a></h2>
<p>phi : array_like
amplitude of the elliptic integral</p>
<p>m : array_like
parameter of the elliptic integral</p>
<h2 id="returns_288">Returns<a class="headerlink" href="#returns_288" title="Permanent link">&para;</a></h2>
<p>K : ndarray
Value of the elliptic integral</p>
<h2 id="notes_168">Notes<a class="headerlink" href="#notes_168" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>ellik</code>.  The computation is
carried out using the arithmetic-geometric mean algorithm.</p>
<p>The parameterization in terms of :math:<code>m</code> follows that of section
17.2 in [2]_. Other parameterizations in terms of the
complementary parameter :math:<code>1 - m</code>, modular angle
:math:<code>\sin^2(\alpha) = m</code>, or modulus :math:<code>k^2 = m</code> are also
used, so be careful that you choose the correct parameter.</p>
<h2 id="see-also_209">See Also<a class="headerlink" href="#see-also_209" title="Permanent link">&para;</a></h2>
<p>ellipkm1 : Complete elliptic integral of the first kind, near <code>m</code> = 1
ellipk : Complete elliptic integral of the first kind
ellipe : Complete elliptic integral of the second kind
ellipeinc : Incomplete elliptic integral of the second kind</p>
<h2 id="references_207">References<a class="headerlink" href="#references_207" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipkm1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ellipkm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ellipkm1(p)</p>
<p>Complete elliptic integral of the first kind around <code>m</code> = 1</p>
<p>This function is defined as</p>
<p>.. math:: K(p) = \int_0^{\pi/2} [1 - m \sin(t)^2]^{-1/2} dt</p>
<p>where <code>m = 1 - p</code>.</p>
<h2 id="parameters_269">Parameters<a class="headerlink" href="#parameters_269" title="Permanent link">&para;</a></h2>
<p>p : array_like
Defines the parameter of the elliptic integral as <code>m = 1 - p</code>.</p>
<h2 id="returns_289">Returns<a class="headerlink" href="#returns_289" title="Permanent link">&para;</a></h2>
<p>K : ndarray
Value of the elliptic integral.</p>
<h2 id="notes_169">Notes<a class="headerlink" href="#notes_169" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>ellpk</code>.</p>
<p>For <code>p &lt;= 1</code>, computation uses the approximation,</p>
<p>.. math:: K(p) \approx P(p) - \log(p) Q(p),</p>
<p>where :math:<code>P</code> and :math:<code>Q</code> are tenth-order polynomials.  The
argument <code>p</code> is used internally rather than <code>m</code> so that the logarithmic
singularity at <code>m = 1</code> will be shifted to the origin; this preserves
maximum accuracy.  For <code>p &gt; 1</code>, the identity</p>
<p>.. math:: K(p) = K(1/p)/\sqrt(p)</p>
<p>is used.</p>
<h2 id="see-also_210">See Also<a class="headerlink" href="#see-also_210" title="Permanent link">&para;</a></h2>
<p>ellipk : Complete elliptic integral of the first kind
ellipkinc : Incomplete elliptic integral of the first kind
ellipe : Complete elliptic integral of the second kind
ellipeinc : Incomplete elliptic integral of the second kind</p>
<h2 id="references_208">References<a class="headerlink" href="#references_208" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">entr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>entr(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>entr(x)</p>
<p>Elementwise function for computing entropy.</p>
<p>.. math:: \text{entr}(x) = \begin{cases} - x \log(x) &amp; x &gt; 0  \ 0 &amp; x = 0 \ -\infty &amp; \text{otherwise} \end{cases}</p>
<h2 id="parameters_270">Parameters<a class="headerlink" href="#parameters_270" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Input array.</p>
<h2 id="returns_290">Returns<a class="headerlink" href="#returns_290" title="Permanent link">&para;</a></h2>
<p>res : ndarray
The value of the elementwise entropy function at the given points <code>x</code>.</p>
<h2 id="see-also_211">See Also<a class="headerlink" href="#see-also_211" title="Permanent link">&para;</a></h2>
<p>kl_div, rel_entr</p>
<h2 id="notes_170">Notes<a class="headerlink" href="#notes_170" title="Permanent link">&para;</a></h2>
<p>This function is concave.</p>
<p>.. versionadded:: 0.15.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">erf</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>erf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>erf(z)</p>
<p>Returns the error function of complex argument.</p>
<p>It is defined as <code>2/sqrt(pi)*integral(exp(-t**2), t=0..z)</code>.</p>
<h2 id="parameters_271">Parameters<a class="headerlink" href="#parameters_271" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Input array.</p>
<h2 id="returns_291">Returns<a class="headerlink" href="#returns_291" title="Permanent link">&para;</a></h2>
<p>res : ndarray
The values of the error function at the given points <code>x</code>.</p>
<h2 id="see-also_212">See Also<a class="headerlink" href="#see-also_212" title="Permanent link">&para;</a></h2>
<p>erfc, erfinv, erfcinv, wofz, erfcx, erfi</p>
<h2 id="notes_171">Notes<a class="headerlink" href="#notes_171" title="Permanent link">&para;</a></h2>
<p>The cumulative of the unit normal distribution is given by
<code>Phi(z) = 1/2[1 + erf(z/sqrt(2))]</code>.</p>
<h2 id="references_209">References<a class="headerlink" href="#references_209" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Error_function
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover,
1972. http://www.math.sfu.ca/~cbm/aands/page_297.htm
.. [3] Steven G. Johnson, Faddeeva W function implementation.
http://ab-initio.mit.edu/Faddeeva</p>
<h2 id="examples_93">Examples<a class="headerlink" href="#examples_93" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
import matplotlib.pyplot as plt
x = np.linspace(-3, 3)
plt.plot(x, special.erf(x))
plt.xlabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>')
plt.ylabel('<span><span class="MathJax_Preview">erf(x)</span><script type="math/tex">erf(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">erf_zeros</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the first nt zero in the first quadrant, ordered by absolute value.</p>
<p>Zeros in the other quadrants can be obtained by using the symmetries erf(-z) = erf(z) and
erf(conj(z)) = conj(erf(z)).</p>
<h2 id="parameters_272">Parameters<a class="headerlink" href="#parameters_272" title="Permanent link">&para;</a></h2>
<p>nt : int
The number of zeros to compute</p>
<h2 id="returns_292">Returns<a class="headerlink" href="#returns_292" title="Permanent link">&para;</a></h2>
<p>The locations of the zeros of erf : ndarray (complex)
Complex values at which zeros of erf(z)</p>
<h2 id="examples_94">Examples<a class="headerlink" href="#examples_94" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
special.erf_zeros(1)
array([1.45061616+1.880943j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Check that erf is (close to) zero for the value returned by erf_zeros</p>
<blockquote>
<blockquote>
<blockquote>
<p>special.erf(special.erf_zeros(1))
array([4.95159469e-14-1.16407394e-16j])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_210">References<a class="headerlink" href="#references_210" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">erfc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>erfc(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>erfc(x, out=None)</p>
<p>Complementary error function, <code>1 - erf(x)</code>.</p>
<h2 id="parameters_273">Parameters<a class="headerlink" href="#parameters_273" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real or complex valued argument
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_293">Returns<a class="headerlink" href="#returns_293" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the complementary error function</p>
<h2 id="see-also_213">See Also<a class="headerlink" href="#see-also_213" title="Permanent link">&para;</a></h2>
<p>erf, erfi, erfcx, dawsn, wofz</p>
<h2 id="references_211">References<a class="headerlink" href="#references_211" title="Permanent link">&para;</a></h2>
<p>.. [1] Steven G. Johnson, Faddeeva W function implementation.
http://ab-initio.mit.edu/Faddeeva</p>
<h2 id="examples_95">Examples<a class="headerlink" href="#examples_95" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
import matplotlib.pyplot as plt
x = np.linspace(-3, 3)
plt.plot(x, special.erfc(x))
plt.xlabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>')
plt.ylabel('<span><span class="MathJax_Preview">erfc(x)</span><script type="math/tex">erfc(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">erfcinv</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Inverse of the complementary error function erfc.</p>
<p>Computes the inverse of the complementary error function erfc.</p>
<p>In complex domain, there is no unique complex number w satisfying erfc(w)=z.
This indicates a true inverse function would have multi-value. When the domain restricts to the real, 0 &lt; x &lt; 2,
there is a unique real number satisfying erfc(erfcinv(x)) = erfcinv(erfc(x)).</p>
<p>It is related to inverse of the error function by erfcinv(1-x) = erfinv(x)</p>
<h2 id="parameters_274">Parameters<a class="headerlink" href="#parameters_274" title="Permanent link">&para;</a></h2>
<p>y : ndarray
Argument at which to evaluate. Domain: [0, 2]</p>
<h2 id="returns_294">Returns<a class="headerlink" href="#returns_294" title="Permanent link">&para;</a></h2>
<p>erfcinv : ndarray
The inverse of erfc of y, element-wise</p>
<h2 id="examples_96">Examples<a class="headerlink" href="#examples_96" title="Permanent link">&para;</a></h2>
<p>1) evaluating a float number</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
special.erfcinv(0.5)
0.4769362762044698</p>
</blockquote>
</blockquote>
</blockquote>
<p>2) evaluating a ndarray</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
y = np.linspace(0.0, 2.0, num=11)
special.erfcinv(y)
array([        inf,  0.9061938 ,  0.59511608,  0.37080716,  0.17914345,
-0.        , -0.17914345, -0.37080716, -0.59511608, -0.9061938 ,
-inf])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">erfcx</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>erfcx(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>erfcx(x, out=None)</p>
<p>Scaled complementary error function, <code>exp(x**2) * erfc(x)</code>.</p>
<h2 id="parameters_275">Parameters<a class="headerlink" href="#parameters_275" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real or complex valued argument
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_295">Returns<a class="headerlink" href="#returns_295" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the scaled complementary error function</p>
<h2 id="see-also_214">See Also<a class="headerlink" href="#see-also_214" title="Permanent link">&para;</a></h2>
<p>erf, erfc, erfi, dawsn, wofz</p>
<h2 id="notes_172">Notes<a class="headerlink" href="#notes_172" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.12.0</p>
<h2 id="references_212">References<a class="headerlink" href="#references_212" title="Permanent link">&para;</a></h2>
<p>.. [1] Steven G. Johnson, Faddeeva W function implementation.
http://ab-initio.mit.edu/Faddeeva</p>
<h2 id="examples_97">Examples<a class="headerlink" href="#examples_97" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
import matplotlib.pyplot as plt
x = np.linspace(-3, 3)
plt.plot(x, special.erfcx(x))
plt.xlabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>')
plt.ylabel('<span><span class="MathJax_Preview">erfcx(x)</span><script type="math/tex">erfcx(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">erfi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>erfi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>erfi(z, out=None)</p>
<p>Imaginary error function, <code>-i erf(i z)</code>.</p>
<h2 id="parameters_276">Parameters<a class="headerlink" href="#parameters_276" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex valued argument
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_296">Returns<a class="headerlink" href="#returns_296" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the imaginary error function</p>
<h2 id="see-also_215">See Also<a class="headerlink" href="#see-also_215" title="Permanent link">&para;</a></h2>
<p>erf, erfc, erfcx, dawsn, wofz</p>
<h2 id="notes_173">Notes<a class="headerlink" href="#notes_173" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.12.0</p>
<h2 id="references_213">References<a class="headerlink" href="#references_213" title="Permanent link">&para;</a></h2>
<p>.. [1] Steven G. Johnson, Faddeeva W function implementation.
http://ab-initio.mit.edu/Faddeeva</p>
<h2 id="examples_98">Examples<a class="headerlink" href="#examples_98" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
import matplotlib.pyplot as plt
x = np.linspace(-3, 3)
plt.plot(x, special.erfi(x))
plt.xlabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>')
plt.ylabel('<span><span class="MathJax_Preview">erfi(x)</span><script type="math/tex">erfi(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">erfinv</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Inverse of the error function erf.</p>
<p>Computes the inverse of the error function.</p>
<p>In complex domain, there is no unique complex number w satisfying erf(w)=z.
This indicates a true inverse function would have multi-value. When the domain restricts to the real, -1 &lt; x &lt; 1,
there is a unique real number satisfying erf(erfinv(x)) = x.</p>
<h2 id="parameters_277">Parameters<a class="headerlink" href="#parameters_277" title="Permanent link">&para;</a></h2>
<p>y : ndarray
Argument at which to evaluate. Domain: [-1, 1]</p>
<h2 id="returns_297">Returns<a class="headerlink" href="#returns_297" title="Permanent link">&para;</a></h2>
<p>erfinv : ndarray
The inverse of erf of y, element-wise</p>
<h2 id="examples_99">Examples<a class="headerlink" href="#examples_99" title="Permanent link">&para;</a></h2>
<p>1) evaluating a float number</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
special.erfinv(0.5)
0.4769362762044698</p>
</blockquote>
</blockquote>
</blockquote>
<p>2) evaluating a ndarray</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
y = np.linspace(-1.0, 1.0, num=10)
special.erfinv(y)
array([       -inf, -0.86312307, -0.5407314 , -0.30457019, -0.0987901 ,
0.0987901 ,  0.30457019,  0.5407314 ,  0.86312307,         inf])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">euler</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Euler numbers E(0), E(1), ..., E(n).</p>
<p>The Euler numbers [1]_ are also known as the secant numbers.</p>
<p>Because <code>euler(n)</code> returns floating point values, it does not give
exact values for large <code>n</code>.  The first inexact value is E(22).</p>
<h2 id="parameters_278">Parameters<a class="headerlink" href="#parameters_278" title="Permanent link">&para;</a></h2>
<p>n : int
The highest index of the Euler number to be returned.</p>
<h2 id="returns_298">Returns<a class="headerlink" href="#returns_298" title="Permanent link">&para;</a></h2>
<p>ndarray
The Euler numbers [E(0), E(1), ..., E(n)].
The odd Euler numbers, which are all zero, are included.</p>
<h2 id="references_214">References<a class="headerlink" href="#references_214" title="Permanent link">&para;</a></h2>
<p>.. [1] Sequence A122045, The On-Line Encyclopedia of Integer Sequences,
https://oeis.org/A122045
.. [2] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<h2 id="examples_100">Examples<a class="headerlink" href="#examples_100" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import euler
euler(6)
array([  1.,   0.,  -1.,   0.,   5.,   0., -61.])</p>
<p>euler(13).astype(np.int64)
array([      1,       0,      -1,       0,       5,       0,     -61,
0,    1385,       0,  -50521,       0, 2702765,       0])</p>
<p>euler(22)[-1]  # Exact value of E(22) is -69348874393137901.
-69348874393137976.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_chebyc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_chebyc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_chebyc(n, x, out=None)</p>
<p>Evaluate Chebyshev polynomial of the first kind on [-2, 2] at a
point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>C_n(x) = 2 T_n(x/2)</p>
<p>where :math:<code>T_n</code> is a Chebyshev polynomial of the first kind. See
22.5.11 in [AS]_ for details.</p>
<h2 id="parameters_279">Parameters<a class="headerlink" href="#parameters_279" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>eval_chebyt</code>.
x : array_like
Points at which to evaluate the Chebyshev polynomial</p>
<h2 id="returns_299">Returns<a class="headerlink" href="#returns_299" title="Permanent link">&para;</a></h2>
<p>C : ndarray
Values of the Chebyshev polynomial</p>
<h2 id="see-also_216">See Also<a class="headerlink" href="#see-also_216" title="Permanent link">&para;</a></h2>
<p>roots_chebyc : roots and quadrature weights of Chebyshev
polynomials of the first kind on [-2, 2]
chebyc : Chebyshev polynomial object
numpy.polynomial.chebyshev.Chebyshev : Chebyshev series
eval_chebyt : evaluate Chebycshev polynomials of the first kind</p>
<h2 id="references_215">References<a class="headerlink" href="#references_215" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<h2 id="examples_101">Examples<a class="headerlink" href="#examples_101" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>They are a scaled version of the Chebyshev polynomials of the
first kind.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-2, 2, 6)
sc.eval_chebyc(3, x)
array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])
2 * sc.eval_chebyt(3, x / 2)
array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_chebys</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_chebys(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_chebys(n, x, out=None)</p>
<p>Evaluate Chebyshev polynomial of the second kind on [-2, 2] at a
point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>S_n(x) = U_n(x/2)</p>
<p>where :math:<code>U_n</code> is a Chebyshev polynomial of the second
kind. See 22.5.13 in [AS]_ for details.</p>
<h2 id="parameters_280">Parameters<a class="headerlink" href="#parameters_280" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>eval_chebyu</code>.
x : array_like
Points at which to evaluate the Chebyshev polynomial</p>
<h2 id="returns_300">Returns<a class="headerlink" href="#returns_300" title="Permanent link">&para;</a></h2>
<p>S : ndarray
Values of the Chebyshev polynomial</p>
<h2 id="see-also_217">See Also<a class="headerlink" href="#see-also_217" title="Permanent link">&para;</a></h2>
<p>roots_chebys : roots and quadrature weights of Chebyshev
polynomials of the second kind on [-2, 2]
chebys : Chebyshev polynomial object
eval_chebyu : evaluate Chebyshev polynomials of the second kind</p>
<h2 id="references_216">References<a class="headerlink" href="#references_216" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<h2 id="examples_102">Examples<a class="headerlink" href="#examples_102" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>They are a scaled version of the Chebyshev polynomials of the
second kind.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-2, 2, 6)
sc.eval_chebys(3, x)
array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])
sc.eval_chebyu(3, x / 2)
array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_chebyt(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_chebyt(n, x, out=None)</p>
<p>Evaluate Chebyshev polynomial of the first kind at a point.</p>
<p>The Chebyshev polynomials of the first kind can be defined via the
Gauss hypergeometric function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>T_n(x) = {}_2F_1(n, -n; 1/2; (1 - x)/2).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.47 in [AS]_ for details.</p>
<h2 id="parameters_281">Parameters<a class="headerlink" href="#parameters_281" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to the Gauss hypergeometric
function.
x : array_like
Points at which to evaluate the Chebyshev polynomial</p>
<h2 id="returns_301">Returns<a class="headerlink" href="#returns_301" title="Permanent link">&para;</a></h2>
<p>T : ndarray
Values of the Chebyshev polynomial</p>
<h2 id="see-also_218">See Also<a class="headerlink" href="#see-also_218" title="Permanent link">&para;</a></h2>
<p>roots_chebyt : roots and quadrature weights of Chebyshev
polynomials of the first kind
chebyu : Chebychev polynomial object
eval_chebyu : evaluate Chebyshev polynomials of the second kind
hyp2f1 : Gauss hypergeometric function
numpy.polynomial.chebyshev.Chebyshev : Chebyshev series</p>
<h2 id="notes_174">Notes<a class="headerlink" href="#notes_174" title="Permanent link">&para;</a></h2>
<p>This routine is numerically stable for <code>x</code> in <code>[-1, 1]</code> at least
up to order <code>10000</code>.</p>
<h2 id="references_217">References<a class="headerlink" href="#references_217" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_chebyu(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_chebyu(n, x, out=None)</p>
<p>Evaluate Chebyshev polynomial of the second kind at a point.</p>
<p>The Chebyshev polynomials of the second kind can be defined via
the Gauss hypergeometric function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>U_n(x) = (n + 1) {}_2F_1(-n, n + 2; 3/2; (1 - x)/2).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.48 in [AS]_ for details.</p>
<h2 id="parameters_282">Parameters<a class="headerlink" href="#parameters_282" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to the Gauss hypergeometric
function.
x : array_like
Points at which to evaluate the Chebyshev polynomial</p>
<h2 id="returns_302">Returns<a class="headerlink" href="#returns_302" title="Permanent link">&para;</a></h2>
<p>U : ndarray
Values of the Chebyshev polynomial</p>
<h2 id="see-also_219">See Also<a class="headerlink" href="#see-also_219" title="Permanent link">&para;</a></h2>
<p>roots_chebyu : roots and quadrature weights of Chebyshev
polynomials of the second kind
chebyu : Chebyshev polynomial object
eval_chebyt : evaluate Chebyshev polynomials of the first kind
hyp2f1 : Gauss hypergeometric function</p>
<h2 id="references_218">References<a class="headerlink" href="#references_218" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_gegenbauer</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_gegenbauer(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_gegenbauer(n, alpha, x, out=None)</p>
<p>Evaluate Gegenbauer polynomial at a point.</p>
<p>The Gegenbauer polynomials can be defined via the Gauss
hypergeometric function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>C_n^{(\alpha)} = \frac{(2\alpha)_n}{\Gamma(n + 1)}
{}_2F_1(-n, 2\alpha + n; \alpha + 1/2; (1 - z)/2).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.46 in [AS]_ for details.</p>
<h2 id="parameters_283">Parameters<a class="headerlink" href="#parameters_283" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to the Gauss hypergeometric
function.
alpha : array_like
Parameter
x : array_like
Points at which to evaluate the Gegenbauer polynomial</p>
<h2 id="returns_303">Returns<a class="headerlink" href="#returns_303" title="Permanent link">&para;</a></h2>
<p>C : ndarray
Values of the Gegenbauer polynomial</p>
<h2 id="see-also_220">See Also<a class="headerlink" href="#see-also_220" title="Permanent link">&para;</a></h2>
<p>roots_gegenbauer : roots and quadrature weights of Gegenbauer
polynomials
gegenbauer : Gegenbauer polynomial object
hyp2f1 : Gauss hypergeometric function</p>
<h2 id="references_219">References<a class="headerlink" href="#references_219" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_genlaguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_genlaguerre(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_genlaguerre(n, alpha, x, out=None)</p>
<p>Evaluate generalized Laguerre polynomial at a point.</p>
<p>The generalized Laguerre polynomials can be defined via the
confluent hypergeometric function :math:<code>{}_1F_1</code> as</p>
<p>.. math::</p>
<p>L_n^{(\alpha)}(x) = \binom{n + \alpha}{n}
{}_1F_1(-n, \alpha + 1, x).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.54 in [AS]_ for details. The Laguerre
polynomials are the special case where :math:<code>\alpha = 0</code>.</p>
<h2 id="parameters_284">Parameters<a class="headerlink" href="#parameters_284" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer the result is
determined via the relation to the confluent hypergeometric
function.
alpha : array_like
Parameter; must have <code>alpha &gt; -1</code>
x : array_like
Points at which to evaluate the generalized Laguerre
polynomial</p>
<h2 id="returns_304">Returns<a class="headerlink" href="#returns_304" title="Permanent link">&para;</a></h2>
<p>L : ndarray
Values of the generalized Laguerre polynomial</p>
<h2 id="see-also_221">See Also<a class="headerlink" href="#see-also_221" title="Permanent link">&para;</a></h2>
<p>roots_genlaguerre : roots and quadrature weights of generalized
Laguerre polynomials
genlaguerre : generalized Laguerre polynomial object
hyp1f1 : confluent hypergeometric function
eval_laguerre : evaluate Laguerre polynomials</p>
<h2 id="references_220">References<a class="headerlink" href="#references_220" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_hermite</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_hermite(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_hermite(n, x, out=None)</p>
<p>Evaluate physicist's Hermite polynomial at a point.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n} e^{-x^2};</p>
<p>:math:<code>H_n</code> is a polynomial of degree :math:<code>n</code>. See 22.11.7 in
[AS]_ for details.</p>
<h2 id="parameters_285">Parameters<a class="headerlink" href="#parameters_285" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial
x : array_like
Points at which to evaluate the Hermite polynomial</p>
<h2 id="returns_305">Returns<a class="headerlink" href="#returns_305" title="Permanent link">&para;</a></h2>
<p>H : ndarray
Values of the Hermite polynomial</p>
<h2 id="see-also_222">See Also<a class="headerlink" href="#see-also_222" title="Permanent link">&para;</a></h2>
<p>roots_hermite : roots and quadrature weights of physicist's
Hermite polynomials
hermite : physicist's Hermite polynomial object
numpy.polynomial.hermite.Hermite : Physicist's Hermite series
eval_hermitenorm : evaluate Probabilist's Hermite polynomials</p>
<h2 id="references_221">References<a class="headerlink" href="#references_221" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_hermitenorm</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_hermitenorm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_hermitenorm(n, x, out=None)</p>
<p>Evaluate probabilist's (normalized) Hermite polynomial at a
point.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>He_n(x) = (-1)^n e^{x^2/2} \frac{d^n}{dx^n} e^{-x^2/2};</p>
<p>:math:<code>He_n</code> is a polynomial of degree :math:<code>n</code>. See 22.11.8 in
[AS]_ for details.</p>
<h2 id="parameters_286">Parameters<a class="headerlink" href="#parameters_286" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial
x : array_like
Points at which to evaluate the Hermite polynomial</p>
<h2 id="returns_306">Returns<a class="headerlink" href="#returns_306" title="Permanent link">&para;</a></h2>
<p>He : ndarray
Values of the Hermite polynomial</p>
<h2 id="see-also_223">See Also<a class="headerlink" href="#see-also_223" title="Permanent link">&para;</a></h2>
<p>roots_hermitenorm : roots and quadrature weights of probabilist's
Hermite polynomials
hermitenorm : probabilist's Hermite polynomial object
numpy.polynomial.hermite_e.HermiteE : Probabilist's Hermite series
eval_hermite : evaluate physicist's Hermite polynomials</p>
<h2 id="references_222">References<a class="headerlink" href="#references_222" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_jacobi(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_jacobi(n, alpha, beta, x, out=None)</p>
<p>Evaluate Jacobi polynomial at a point.</p>
<p>The Jacobi polynomials can be defined via the Gauss hypergeometric
function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>P_n^{(\alpha, \beta)}(x) = \frac{(\alpha + 1)_n}{\Gamma(n + 1)}
{}_2F_1(-n, 1 + \alpha + \beta + n; \alpha + 1; (1 - z)/2)</p>
<p>where :math:<code>(\cdot)_n</code> is the Pochhammer symbol; see <code>poch</code>. When
:math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.42 in [AS]_ for details.</p>
<h2 id="parameters_287">Parameters<a class="headerlink" href="#parameters_287" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer the result is
determined via the relation to the Gauss hypergeometric
function.
alpha : array_like
Parameter
beta : array_like
Parameter
x : array_like
Points at which to evaluate the polynomial</p>
<h2 id="returns_307">Returns<a class="headerlink" href="#returns_307" title="Permanent link">&para;</a></h2>
<p>P : ndarray
Values of the Jacobi polynomial</p>
<h2 id="see-also_224">See Also<a class="headerlink" href="#see-also_224" title="Permanent link">&para;</a></h2>
<p>roots_jacobi : roots and quadrature weights of Jacobi polynomials
jacobi : Jacobi polynomial object
hyp2f1 : Gauss hypergeometric function</p>
<h2 id="references_223">References<a class="headerlink" href="#references_223" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_laguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_laguerre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_laguerre(n, x, out=None)</p>
<p>Evaluate Laguerre polynomial at a point.</p>
<p>The Laguerre polynomials can be defined via the confluent
hypergeometric function :math:<code>{}_1F_1</code> as</p>
<p>.. math::</p>
<p>L_n(x) = {}_1F_1(-n, 1, x).</p>
<p>See 22.5.16 and 22.5.54 in [AS]_ for details. When :math:<code>n</code> is an
integer the result is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_288">Parameters<a class="headerlink" href="#parameters_288" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer the result is
determined via the relation to the confluent hypergeometric
function.
x : array_like
Points at which to evaluate the Laguerre polynomial</p>
<h2 id="returns_308">Returns<a class="headerlink" href="#returns_308" title="Permanent link">&para;</a></h2>
<p>L : ndarray
Values of the Laguerre polynomial</p>
<h2 id="see-also_225">See Also<a class="headerlink" href="#see-also_225" title="Permanent link">&para;</a></h2>
<p>roots_laguerre : roots and quadrature weights of Laguerre
polynomials
laguerre : Laguerre polynomial object
numpy.polynomial.laguerre.Laguerre : Laguerre series
eval_genlaguerre : evaluate generalized Laguerre polynomials</p>
<h2 id="references_224">References<a class="headerlink" href="#references_224" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_legendre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_legendre(n, x, out=None)</p>
<p>Evaluate Legendre polynomial at a point.</p>
<p>The Legendre polynomials can be defined via the Gauss
hypergeometric function :math:<code>{}_2F_1</code> as</p>
<p>.. math::</p>
<p>P_n(x) = {}_2F_1(-n, n + 1; 1; (1 - x)/2).</p>
<p>When :math:<code>n</code> is an integer the result is a polynomial of degree
:math:<code>n</code>. See 22.5.49 in [AS]_ for details.</p>
<h2 id="parameters_289">Parameters<a class="headerlink" href="#parameters_289" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to the Gauss hypergeometric
function.
x : array_like
Points at which to evaluate the Legendre polynomial</p>
<h2 id="returns_309">Returns<a class="headerlink" href="#returns_309" title="Permanent link">&para;</a></h2>
<p>P : ndarray
Values of the Legendre polynomial</p>
<h2 id="see-also_226">See Also<a class="headerlink" href="#see-also_226" title="Permanent link">&para;</a></h2>
<p>roots_legendre : roots and quadrature weights of Legendre
polynomials
legendre : Legendre polynomial object
hyp2f1 : Gauss hypergeometric function
numpy.polynomial.legendre.Legendre : Legendre series</p>
<h2 id="references_225">References<a class="headerlink" href="#references_225" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_sh_chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_sh_chebyt(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_sh_chebyt(n, x, out=None)</p>
<p>Evaluate shifted Chebyshev polynomial of the first kind at a
point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>T_n^*(x) = T_n(2x - 1)</p>
<p>where :math:<code>T_n</code> is a Chebyshev polynomial of the first kind. See
22.5.14 in [AS]_ for details.</p>
<h2 id="parameters_290">Parameters<a class="headerlink" href="#parameters_290" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>eval_chebyt</code>.
x : array_like
Points at which to evaluate the shifted Chebyshev polynomial</p>
<h2 id="returns_310">Returns<a class="headerlink" href="#returns_310" title="Permanent link">&para;</a></h2>
<p>T : ndarray
Values of the shifted Chebyshev polynomial</p>
<h2 id="see-also_227">See Also<a class="headerlink" href="#see-also_227" title="Permanent link">&para;</a></h2>
<p>roots_sh_chebyt : roots and quadrature weights of shifted
Chebyshev polynomials of the first kind
sh_chebyt : shifted Chebyshev polynomial object
eval_chebyt : evaluate Chebyshev polynomials of the first kind
numpy.polynomial.chebyshev.Chebyshev : Chebyshev series</p>
<h2 id="references_226">References<a class="headerlink" href="#references_226" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_sh_chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_sh_chebyu(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_sh_chebyu(n, x, out=None)</p>
<p>Evaluate shifted Chebyshev polynomial of the second kind at a
point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>U_n^*(x) = U_n(2x - 1)</p>
<p>where :math:<code>U_n</code> is a Chebyshev polynomial of the first kind. See
22.5.15 in [AS]_ for details.</p>
<h2 id="parameters_291">Parameters<a class="headerlink" href="#parameters_291" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>eval_chebyu</code>.
x : array_like
Points at which to evaluate the shifted Chebyshev polynomial</p>
<h2 id="returns_311">Returns<a class="headerlink" href="#returns_311" title="Permanent link">&para;</a></h2>
<p>U : ndarray
Values of the shifted Chebyshev polynomial</p>
<h2 id="see-also_228">See Also<a class="headerlink" href="#see-also_228" title="Permanent link">&para;</a></h2>
<p>roots_sh_chebyu : roots and quadrature weights of shifted
Chebychev polynomials of the second kind
sh_chebyu : shifted Chebyshev polynomial object
eval_chebyu : evaluate Chebyshev polynomials of the second kind</p>
<h2 id="references_227">References<a class="headerlink" href="#references_227" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_sh_jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_sh_jacobi(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_sh_jacobi(n, p, q, x, out=None)</p>
<p>Evaluate shifted Jacobi polynomial at a point.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>G_n^{(p, q)}(x)
= \binom{2n + p - 1}{n}^{-1} P_n^{(p - q, q - 1)}(2x - 1),</p>
<p>where :math:<code>P_n^{(\cdot, \cdot)}</code> is the n-th Jacobi
polynomial. See 22.5.2 in [AS]_ for details.</p>
<h2 id="parameters_292">Parameters<a class="headerlink" href="#parameters_292" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial. If not an integer, the result is
determined via the relation to <code>binom</code> and <code>eval_jacobi</code>.
p : float
Parameter
q : float
Parameter</p>
<h2 id="returns_312">Returns<a class="headerlink" href="#returns_312" title="Permanent link">&para;</a></h2>
<p>G : ndarray
Values of the shifted Jacobi polynomial.</p>
<h2 id="see-also_229">See Also<a class="headerlink" href="#see-also_229" title="Permanent link">&para;</a></h2>
<p>roots_sh_jacobi : roots and quadrature weights of shifted Jacobi
polynomials
sh_jacobi : shifted Jacobi polynomial object
eval_jacobi : evaluate Jacobi polynomials</p>
<h2 id="references_228">References<a class="headerlink" href="#references_228" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eval_sh_legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>eval_sh_legendre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>eval_sh_legendre(n, x, out=None)</p>
<p>Evaluate shifted Legendre polynomial at a point.</p>
<p>These polynomials are defined as</p>
<p>.. math::</p>
<p>P_n^*(x) = P_n(2x - 1)</p>
<p>where :math:<code>P_n</code> is a Legendre polynomial. See 2.2.11 in [AS]_
for details.</p>
<h2 id="parameters_293">Parameters<a class="headerlink" href="#parameters_293" title="Permanent link">&para;</a></h2>
<p>n : array_like
Degree of the polynomial. If not an integer, the value is
determined via the relation to <code>eval_legendre</code>.
x : array_like
Points at which to evaluate the shifted Legendre polynomial</p>
<h2 id="returns_313">Returns<a class="headerlink" href="#returns_313" title="Permanent link">&para;</a></h2>
<p>P : ndarray
Values of the shifted Legendre polynomial</p>
<h2 id="see-also_230">See Also<a class="headerlink" href="#see-also_230" title="Permanent link">&para;</a></h2>
<p>roots_sh_legendre : roots and quadrature weights of shifted
Legendre polynomials
sh_legendre : shifted Legendre polynomial object
eval_legendre : evaluate Legendre polynomials
numpy.polynomial.legendre.Legendre : Legendre series</p>
<h2 id="references_229">References<a class="headerlink" href="#references_229" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exp1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>exp1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>exp1(z, out=None)</p>
<p>Exponential integral E1.</p>
<p>For complex :math:<code>z \ne 0</code> the exponential integral can be defined as
[1]_</p>
<p>.. math::</p>
<p>E_1(z) = \int_z^\infty \frac{e^{-t}}{t} dt,</p>
<p>where the path of the integral does not cross the negative real
axis or pass through the origin.</p>
<h2 id="parameters_294">Parameters<a class="headerlink" href="#parameters_294" title="Permanent link">&para;</a></h2>
<p>z: array_like
Real or complex argument.
out: ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_314">Returns<a class="headerlink" href="#returns_314" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the exponential integral E1</p>
<h2 id="see-also_231">See Also<a class="headerlink" href="#see-also_231" title="Permanent link">&para;</a></h2>
<p>expi : exponential integral :math:<code>Ei</code>
expn : generalization of :math:<code>E_1</code></p>
<h2 id="notes_175">Notes<a class="headerlink" href="#notes_175" title="Permanent link">&para;</a></h2>
<p>For :math:<code>x &gt; 0</code> it is related to the exponential integral
:math:<code>Ei</code> (see <code>expi</code>) via the relation</p>
<p>.. math::</p>
<p>E_1(x) = -Ei(-x).</p>
<h2 id="references_230">References<a class="headerlink" href="#references_230" title="Permanent link">&para;</a></h2>
<p>.. [1] Digital Library of Mathematical Functions, 6.2.1
https://dlmf.nist.gov/6.2#E1</p>
<h2 id="examples_103">Examples<a class="headerlink" href="#examples_103" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has a pole at 0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.exp1(0)
inf</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has a branch cut on the negative real axis.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.exp1(-1)
nan
sc.exp1(complex(-1, 0))
(-1.8951178163559368-3.141592653589793j)
sc.exp1(complex(-1, -0.0))
(-1.8951178163559368+3.141592653589793j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>It approaches 0 along the positive real axis.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.exp1([1, 10, 100, 1000])
array([2.19383934e-01, 4.15696893e-06, 3.68359776e-46, 0.00000000e+00])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is related to <code>expi</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3, 4])
sc.exp1(x)
array([0.21938393, 0.04890051, 0.01304838, 0.00377935])
-sc.expi(-x)
array([0.21938393, 0.04890051, 0.01304838, 0.00377935])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exp10</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>exp10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>exp10(x)</p>
<p>Compute <code>10**x</code> element-wise.</p>
<h2 id="parameters_295">Parameters<a class="headerlink" href="#parameters_295" title="Permanent link">&para;</a></h2>
<p>x : array_like
<code>x</code> must contain real numbers.</p>
<h2 id="returns_315">Returns<a class="headerlink" href="#returns_315" title="Permanent link">&para;</a></h2>
<p>float
<code>10**x</code>, computed element-wise.</p>
<h2 id="examples_104">Examples<a class="headerlink" href="#examples_104" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import exp10</p>
<p>exp10(3)
1000.0
x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]])
exp10(x)
array([[  0.1       ,   0.31622777,   1.        ],
[  3.16227766,  10.        ,  31.6227766 ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exp2</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>exp2(x)</p>
<p>Compute <code>2**x</code> element-wise.</p>
<h2 id="parameters_296">Parameters<a class="headerlink" href="#parameters_296" title="Permanent link">&para;</a></h2>
<p>x : array_like
<code>x</code> must contain real numbers.</p>
<h2 id="returns_316">Returns<a class="headerlink" href="#returns_316" title="Permanent link">&para;</a></h2>
<p>float
<code>2**x</code>, computed element-wise.</p>
<h2 id="examples_105">Examples<a class="headerlink" href="#examples_105" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import exp2</p>
<p>exp2(3)
8.0
x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]])
exp2(x)
array([[ 0.5       ,  0.70710678,  1.        ],
[ 1.41421356,  2.        ,  2.82842712]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>expi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>expi(x, out=None)</p>
<p>Exponential integral Ei.</p>
<p>For real :math:<code>x</code>, the exponential integral is defined as [1]_</p>
<p>.. math::</p>
<p>Ei(x) = \int_{-\infty}^x \frac{e^t}{t} dt.</p>
<p>For :math:<code>x &gt; 0</code> the integral is understood as a Cauchy principle
value.</p>
<p>It is extended to the complex plane by analytic continuation of
the function on the interval :math:<code>(0, \infty)</code>. The complex
variant has a branch cut on the negative real axis.</p>
<h2 id="parameters_297">Parameters<a class="headerlink" href="#parameters_297" title="Permanent link">&para;</a></h2>
<p>x: array_like
Real or complex valued argument
out: ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_317">Returns<a class="headerlink" href="#returns_317" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the exponential integral</p>
<h2 id="notes_176">Notes<a class="headerlink" href="#notes_176" title="Permanent link">&para;</a></h2>
<p>The exponential integrals :math:<code>E_1</code> and :math:<code>Ei</code> satisfy the
relation</p>
<p>.. math::</p>
<p>E_1(x) = -Ei(-x)</p>
<p>for :math:<code>x &gt; 0</code>.</p>
<h2 id="see-also_232">See Also<a class="headerlink" href="#see-also_232" title="Permanent link">&para;</a></h2>
<p>exp1 : Exponential integral :math:<code>E_1</code>
expn : Generalized exponential integral :math:<code>E_n</code></p>
<h2 id="references_231">References<a class="headerlink" href="#references_231" title="Permanent link">&para;</a></h2>
<p>.. [1] Digital Library of Mathematical Functions, 6.2.5
https://dlmf.nist.gov/6.2#E5</p>
<h2 id="examples_106">Examples<a class="headerlink" href="#examples_106" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is related to <code>exp1</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3, 4])
-sc.expi(-x)
array([0.21938393, 0.04890051, 0.01304838, 0.00377935])
sc.exp1(x)
array([0.21938393, 0.04890051, 0.01304838, 0.00377935])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The complex variant has a branch cut on the negative real axis.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc
sc.expi(-1 + 1e-12j)
(-0.21938393439552062+3.1415926535894254j)
sc.expi(-1 - 1e-12j)
(-0.21938393439552062-3.1415926535894254j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>As the complex variant approaches the branch cut, the real parts
approach the value of the real variant.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.expi(-1)
-0.21938393439552062</p>
</blockquote>
</blockquote>
</blockquote>
<p>The SciPy implementation returns the real variant for complex
values on the branch cut.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.expi(complex(-1, 0.0))
(-0.21938393439552062-0j)
sc.expi(complex(-1, -0.0))
(-0.21938393439552062-0j)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expit</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>expit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>expit(x)</p>
<p>Expit (a.k.a. logistic sigmoid) ufunc for ndarrays.</p>
<p>The expit function, also known as the logistic sigmoid function, is
defined as <code>expit(x) = 1/(1+exp(-x))</code>.  It is the inverse of the
logit function.</p>
<h2 id="parameters_298">Parameters<a class="headerlink" href="#parameters_298" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The ndarray to apply expit to element-wise.</p>
<h2 id="returns_318">Returns<a class="headerlink" href="#returns_318" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An ndarray of the same shape as x. Its entries
are <code>expit</code> of the corresponding entry of x.</p>
<h2 id="see-also_233">See Also<a class="headerlink" href="#see-also_233" title="Permanent link">&para;</a></h2>
<p>logit</p>
<h2 id="notes_177">Notes<a class="headerlink" href="#notes_177" title="Permanent link">&para;</a></h2>
<p>As a ufunc expit takes a number of optional
keyword arguments. For more information
see <code>ufuncs &lt;https://docs.scipy.org/doc/numpy/reference/ufuncs.html&gt;</code>_</p>
<p>.. versionadded:: 0.10.0</p>
<h2 id="examples_107">Examples<a class="headerlink" href="#examples_107" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import expit, logit</p>
<p>expit([-np.inf, -1.5, 0, 1.5, np.inf])
array([ 0.        ,  0.18242552,  0.5       ,  0.81757448,  1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>logit</code> is the inverse of <code>expit</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>logit(expit([-2.5, 0, 3.1, 5.0]))
array([-2.5,  0. ,  3.1,  5. ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot expit(x) for x in [-6, 6]:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
x = np.linspace(-6, 6, 121)
y = expit(x)
plt.plot(x, y)
plt.grid()
plt.xlim(-6, 6)
plt.xlabel('x')
plt.title('expit(x)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>expm1(x)</p>
<p>Compute <code>exp(x) - 1</code>.</p>
<p>When <code>x</code> is near zero, <code>exp(x)</code> is near 1, so the numerical calculation
of <code>exp(x) - 1</code> can suffer from catastrophic loss of precision.
<code>expm1(x)</code> is implemented to avoid the loss of precision that occurs when
<code>x</code> is near zero.</p>
<h2 id="parameters_299">Parameters<a class="headerlink" href="#parameters_299" title="Permanent link">&para;</a></h2>
<p>x : array_like
<code>x</code> must contain real numbers.</p>
<h2 id="returns_319">Returns<a class="headerlink" href="#returns_319" title="Permanent link">&para;</a></h2>
<p>float
<code>exp(x) - 1</code> computed element-wise.</p>
<h2 id="examples_108">Examples<a class="headerlink" href="#examples_108" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import expm1</p>
<p>expm1(1.0)
1.7182818284590451
expm1([-0.2, -0.1, 0, 0.1, 0.2])
array([-0.18126925, -0.09516258,  0.        ,  0.10517092,  0.22140276])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The exact value of <code>exp(7.5e-13) - 1</code> is::</p>
<p>7.5000000000028125000000007031250000001318...<em>10</em>*-13.</p>
<p>Here is what <code>expm1(7.5e-13)</code> gives:</p>
<blockquote>
<blockquote>
<blockquote>
<p>expm1(7.5e-13)
7.5000000000028135e-13</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare that to <code>exp(7.5e-13) - 1</code>, where the subtraction results in
a 'catastrophic' loss of precision:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.exp(7.5e-13) - 1
7.5006667543675576e-13</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>expn(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>expn(n, x, out=None)</p>
<p>Generalized exponential integral En.</p>
<p>For integer :math:<code>n \geq 0</code> and real :math:<code>x \geq 0</code> the
generalized exponential integral is defined as [dlmf]_</p>
<p>.. math::</p>
<p>E_n(x) = x^{n - 1} \int_x^\infty \frac{e^{-t}}{t^n} dt.</p>
<h2 id="parameters_300">Parameters<a class="headerlink" href="#parameters_300" title="Permanent link">&para;</a></h2>
<p>n: array_like
Non-negative integers
x: array_like
Real argument
out: ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_320">Returns<a class="headerlink" href="#returns_320" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the generalized exponential integral</p>
<h2 id="see-also_234">See Also<a class="headerlink" href="#see-also_234" title="Permanent link">&para;</a></h2>
<p>exp1 : special case of :math:<code>E_n</code> for :math:<code>n = 1</code>
expi : related to :math:<code>E_n</code> when :math:<code>n = 1</code></p>
<h2 id="references_232">References<a class="headerlink" href="#references_232" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] Digital Library of Mathematical Functions, 8.19.2
https://dlmf.nist.gov/8.19#E2</p>
<h2 id="examples_109">Examples<a class="headerlink" href="#examples_109" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>Its domain is nonnegative n and x.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.expn(-1, 1.0), sc.expn(1, -1.0)
(nan, nan)</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has a pole at <code>x = 0</code> for <code>n = 1, 2</code>; for larger <code>n</code> it
is equal to <code>1 / (n - 1)</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.expn([0, 1, 2, 3, 4], 0)
array([       inf,        inf, 1.        , 0.5       , 0.33333333])</p>
</blockquote>
</blockquote>
</blockquote>
<p>For n equal to 0 it reduces to <code>exp(-x) / x</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3, 4])
sc.expn(0, x)
array([0.36787944, 0.06766764, 0.01659569, 0.00457891])
np.exp(-x) / x
array([0.36787944, 0.06766764, 0.01659569, 0.00457891])</p>
</blockquote>
</blockquote>
</blockquote>
<p>For n equal to 1 it reduces to <code>exp1</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.expn(1, x)
array([0.21938393, 0.04890051, 0.01304838, 0.00377935])
sc.exp1(x)
array([0.21938393, 0.04890051, 0.01304838, 0.00377935])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exprel</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>exprel(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>exprel(x)</p>
<p>Relative error exponential, <code>(exp(x) - 1)/x</code>.</p>
<p>When <code>x</code> is near zero, <code>exp(x)</code> is near 1, so the numerical calculation
of <code>exp(x) - 1</code> can suffer from catastrophic loss of precision.
<code>exprel(x)</code> is implemented to avoid the loss of precision that occurs when
<code>x</code> is near zero.</p>
<h2 id="parameters_301">Parameters<a class="headerlink" href="#parameters_301" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Input array.  <code>x</code> must contain real numbers.</p>
<h2 id="returns_321">Returns<a class="headerlink" href="#returns_321" title="Permanent link">&para;</a></h2>
<p>float
<code>(exp(x) - 1)/x</code>, computed element-wise.</p>
<h2 id="see-also_235">See Also<a class="headerlink" href="#see-also_235" title="Permanent link">&para;</a></h2>
<p>expm1</p>
<h2 id="notes_178">Notes<a class="headerlink" href="#notes_178" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.17.0</p>
<h2 id="examples_110">Examples<a class="headerlink" href="#examples_110" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import exprel</p>
<p>exprel(0.01)
1.0050167084168056
exprel([-0.25, -0.1, 0, 0.1, 0.25])
array([ 0.88479687,  0.95162582,  1.        ,  1.05170918,  1.13610167])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare <code>exprel(5e-9)</code> to the naive calculation.  The exact value
is <code>1.00000000250000000416...</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>exprel(5e-9)
1.0000000025</p>
<p>(np.exp(5e-9) - 1)/5e-9
0.99999999392252903</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">factorial</span> <span class="o">:</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The factorial of a number or array of numbers.</p>
<p>The factorial of non-negative integer <code>n</code> is the product of all
positive integers less than or equal to <code>n</code>::</p>
<p>n! = n * (n - 1) * (n - 2) * ... * 1</p>
<h2 id="parameters_302">Parameters<a class="headerlink" href="#parameters_302" title="Permanent link">&para;</a></h2>
<p>n : int or array_like of ints
Input values.  If <code>n &lt; 0</code>, the return value is 0.
exact : bool, optional
If True, calculate the answer exactly using long integer arithmetic.
If False, result is approximated in floating point rapidly using the
<code>gamma</code> function.
Default is False.</p>
<h2 id="returns_322">Returns<a class="headerlink" href="#returns_322" title="Permanent link">&para;</a></h2>
<p>nf : float or int or ndarray
Factorial of <code>n</code>, as integer or float depending on <code>exact</code>.</p>
<h2 id="notes_179">Notes<a class="headerlink" href="#notes_179" title="Permanent link">&para;</a></h2>
<p>For arrays with <code>exact=True</code>, the factorial is computed only once, for
the largest input, with each other result computed in the process.
The output dtype is increased to <code>int64</code> or <code>object</code> if necessary.</p>
<p>With <code>exact=False</code> the factorial is approximated using the gamma
function:</p>
<p>.. math:: n! = \Gamma(n+1)</p>
<h2 id="examples_111">Examples<a class="headerlink" href="#examples_111" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import factorial
arr = np.array([3, 4, 5])
factorial(arr, exact=False)
array([   6.,   24.,  120.])
factorial(arr, exact=True)
array([  6,  24, 120])
factorial(5, exact=True)
120L</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">factorial2</span> <span class="o">:</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span>
</code></pre></div>

<p>Double factorial.</p>
<p>This is the factorial with every second value skipped.  E.g., <code>7!! = 7 * 5
* 3 * 1</code>.  It can be approximated numerically as::</p>
<p>n!! = special.gamma(n/2+1)<em>2</em><em>((m+1)/2)/sqrt(pi)  n odd
= 2</em>*(n/2) * (n/2)!                           n even</p>
<h2 id="parameters_303">Parameters<a class="headerlink" href="#parameters_303" title="Permanent link">&para;</a></h2>
<p>n : int or array_like
Calculate <code>n!!</code>.  Arrays are only supported with <code>exact</code> set
to False.  If <code>n &lt; 0</code>, the return value is 0.
exact : bool, optional
The result can be approximated rapidly using the gamma-formula
above (default).  If <code>exact</code> is set to True, calculate the
answer exactly using integer arithmetic.</p>
<h2 id="returns_323">Returns<a class="headerlink" href="#returns_323" title="Permanent link">&para;</a></h2>
<p>nff : float or int
Double factorial of <code>n</code>, as an int or a float depending on
<code>exact</code>.</p>
<h2 id="examples_112">Examples<a class="headerlink" href="#examples_112" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import factorial2
factorial2(7, exact=False)
array(105.00000000000001)
factorial2(7, exact=True)
105L</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">factorialk</span> <span class="o">:</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Multifactorial of n of order k, n(!!...!).</p>
<p>This is the multifactorial of n skipping k values.  For example,</p>
<p>factorialk(17, 4) = 17!!!! = 17 * 13 * 9 * 5 * 1</p>
<p>In particular, for any integer <code>n</code>, we have</p>
<p>factorialk(n, 1) = factorial(n)</p>
<p>factorialk(n, 2) = factorial2(n)</p>
<h2 id="parameters_304">Parameters<a class="headerlink" href="#parameters_304" title="Permanent link">&para;</a></h2>
<p>n : int
Calculate multifactorial. If <code>n</code> &lt; 0, the return value is 0.
k : int
Order of multifactorial.
exact : bool, optional
If exact is set to True, calculate the answer exactly using
integer arithmetic.</p>
<h2 id="returns_324">Returns<a class="headerlink" href="#returns_324" title="Permanent link">&para;</a></h2>
<p>val : int
Multifactorial of <code>n</code>.</p>
<h2 id="raises">Raises<a class="headerlink" href="#raises" title="Permanent link">&para;</a></h2>
<p>NotImplementedError
Raises when exact is False</p>
<h2 id="examples_113">Examples<a class="headerlink" href="#examples_113" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import factorialk
factorialk(5, 1, exact=True)
120L
factorialk(5, 3, exact=True)
10L</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>fdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>fdtr(dfn, dfd, x)</p>
<p>F cumulative distribution function.</p>
<p>Returns the value of the cumulative distribution function of the
F-distribution, also known as Snedecor's F-distribution or the
Fisher-Snedecor distribution.</p>
<p>The F-distribution with parameters :math:<code>d_n</code> and :math:<code>d_d</code> is the
distribution of the random variable,</p>
<p>.. math::
X = \frac{U_n/d_n}{U_d/d_d},</p>
<p>where :math:<code>U_n</code> and :math:<code>U_d</code> are random variables distributed
:math:<code>\chi^2</code>, with :math:<code>d_n</code> and :math:<code>d_d</code> degrees of freedom,
respectively.</p>
<h2 id="parameters_305">Parameters<a class="headerlink" href="#parameters_305" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
First parameter (positive float).
dfd : array_like
Second parameter (positive float).
x : array_like
Argument (nonnegative float).</p>
<h2 id="returns_325">Returns<a class="headerlink" href="#returns_325" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The CDF of the F-distribution with parameters <code>dfn</code> and <code>dfd</code> at <code>x</code>.</p>
<h2 id="notes_180">Notes<a class="headerlink" href="#notes_180" title="Permanent link">&para;</a></h2>
<p>The regularized incomplete beta function is used, according to the
formula,</p>
<p>.. math::
F(d_n, d_d; x) = I_{xd_n/(d_d + xd_n)}(d_n/2, d_d/2).</p>
<p>Wrapper for the Cephes [1]_ routine <code>fdtr</code>.</p>
<h2 id="references_233">References<a class="headerlink" href="#references_233" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fdtrc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>fdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>fdtrc(dfn, dfd, x)</p>
<p>F survival function.</p>
<p>Returns the complemented F-distribution function (the integral of the
density from <code>x</code> to infinity).</p>
<h2 id="parameters_306">Parameters<a class="headerlink" href="#parameters_306" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
First parameter (positive float).
dfd : array_like
Second parameter (positive float).
x : array_like
Argument (nonnegative float).</p>
<h2 id="returns_326">Returns<a class="headerlink" href="#returns_326" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The complemented F-distribution function with parameters <code>dfn</code> and
<code>dfd</code> at <code>x</code>.</p>
<h2 id="see-also_236">See also<a class="headerlink" href="#see-also_236" title="Permanent link">&para;</a></h2>
<p>fdtr</p>
<h2 id="notes_181">Notes<a class="headerlink" href="#notes_181" title="Permanent link">&para;</a></h2>
<p>The regularized incomplete beta function is used, according to the
formula,</p>
<p>.. math::
F(d_n, d_d; x) = I_{d_d/(d_d + xd_n)}(d_d/2, d_n/2).</p>
<p>Wrapper for the Cephes [1]_ routine <code>fdtrc</code>.</p>
<h2 id="references_234">References<a class="headerlink" href="#references_234" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>fdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>fdtri(dfn, dfd, p)</p>
<p>The <code>p</code>-th quantile of the F-distribution.</p>
<p>This function is the inverse of the F-distribution CDF, <code>fdtr</code>, returning
the <code>x</code> such that <code>fdtr(dfn, dfd, x) = p</code>.</p>
<h2 id="parameters_307">Parameters<a class="headerlink" href="#parameters_307" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
First parameter (positive float).
dfd : array_like
Second parameter (positive float).
p : array_like
Cumulative probability, in [0, 1].</p>
<h2 id="returns_327">Returns<a class="headerlink" href="#returns_327" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The quantile corresponding to <code>p</code>.</p>
<h2 id="notes_182">Notes<a class="headerlink" href="#notes_182" title="Permanent link">&para;</a></h2>
<p>The computation is carried out using the relation to the inverse
regularized beta function, :math:<code>I^{-1}_x(a, b)</code>.  Let
:math:<code>z = I^{-1}_p(d_d/2, d_n/2).</code>  Then,</p>
<p>.. math::
x = \frac{d_d (1 - z)}{d_n z}.</p>
<p>If <code>p</code> is such that :math:<code>x &lt; 0.5</code>, the following relation is used
instead for improved stability: let
:math:<code>z' = I^{-1}_{1 - p}(d_n/2, d_d/2).</code> Then,</p>
<p>.. math::
x = \frac{d_d z'}{d_n (1 - z')}.</p>
<p>Wrapper for the Cephes [1]_ routine <code>fdtri</code>.</p>
<h2 id="references_235">References<a class="headerlink" href="#references_235" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fdtridfd</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>fdtridfd(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>fdtridfd(dfn, p, x)</p>
<p>Inverse to <code>fdtr</code> vs dfd</p>
<p>Finds the F density argument dfd such that <code>fdtr(dfn, dfd, x) == p</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fresnel</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>fresnel(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>fresnel(z, out=None)</p>
<p>Fresnel integrals.</p>
<p>The Fresnel integrals are defined as</p>
<p>.. math::</p>
<p>S(z) &amp;= \int_0^z \cos(\pi t^2 /2) dt \
C(z) &amp;= \int_0^z \sin(\pi t^2 /2) dt.</p>
<p>See [dlmf]_ for details.</p>
<h2 id="parameters_308">Parameters<a class="headerlink" href="#parameters_308" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex valued argument
out : 2-tuple of ndarrays, optional
Optional output arrays for the function results</p>
<h2 id="returns_328">Returns<a class="headerlink" href="#returns_328" title="Permanent link">&para;</a></h2>
<p>S, C : 2-tuple of scalar or ndarray
Values of the Fresnel integrals</p>
<h2 id="see-also_237">See Also<a class="headerlink" href="#see-also_237" title="Permanent link">&para;</a></h2>
<p>fresnel_zeros : zeros of the Fresnel integrals</p>
<h2 id="references_236">References<a class="headerlink" href="#references_236" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/7.2#iii</p>
<h2 id="examples_114">Examples<a class="headerlink" href="#examples_114" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>As z goes to infinity along the real axis, S and C converge to 0.5.</p>
<blockquote>
<blockquote>
<blockquote>
<p>S, C = sc.fresnel([0.1, 1, 10, 100, np.inf])
S
array([0.00052359, 0.43825915, 0.46816998, 0.4968169 , 0.5       ])
C
array([0.09999753, 0.7798934 , 0.49989869, 0.4999999 , 0.5       ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>They are related to the error function <code>erf</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>z = np.array([1, 2, 3, 4])
zeta = 0.5 * np.sqrt(np.pi) * (1 - 1j) * z
S, C = sc.fresnel(z)
C + 1j*S
array([0.7798934 +0.43825915j, 0.48825341+0.34341568j,
0.60572079+0.496313j  , 0.49842603+0.42051575j])
0.5 * (1 + 1j) * sc.erf(zeta)
array([0.7798934 +0.43825915j, 0.48825341+0.34341568j,
0.60572079+0.496313j  , 0.49842603+0.42051575j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fresnel_zeros</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nt complex zeros of sine and cosine Fresnel integrals S(z) and C(z).</p>
<h2 id="references_237">References<a class="headerlink" href="#references_237" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fresnelc_zeros</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nt complex zeros of cosine Fresnel integral C(z).</p>
<h2 id="references_238">References<a class="headerlink" href="#references_238" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fresnels_zeros</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nt complex zeros of sine Fresnel integral S(z).</p>
<h2 id="references_239">References<a class="headerlink" href="#references_239" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gamma</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gamma(z)</p>
<p>Gamma function.</p>
<p>The Gamma function is defined as</p>
<p>.. math::</p>
<p>\Gamma(z) = \int_0^\infty t^{z-1} e^{-t} dt</p>
<p>for :math:<code>\Re(z) &gt; 0</code> and is extended to the rest of the complex
plane by analytic continuation. See [dlmf]_ for more details.</p>
<h2 id="parameters_309">Parameters<a class="headerlink" href="#parameters_309" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex valued argument</p>
<h2 id="returns_329">Returns<a class="headerlink" href="#returns_329" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the Gamma function</p>
<h2 id="notes_183">Notes<a class="headerlink" href="#notes_183" title="Permanent link">&para;</a></h2>
<p>The Gamma function is often referred to as the generalized
factorial since :math:<code>\Gamma(n + 1) = n!</code> for natural numbers
:math:<code>n</code>. More generally it satisfies the recurrence relation
:math:<code>\Gamma(z + 1) = z \cdot \Gamma(z)</code> for complex :math:<code>z</code>,
which, combined with the fact that :math:<code>\Gamma(1) = 1</code>, implies
the above identity for :math:<code>z = n</code>.</p>
<h2 id="references_240">References<a class="headerlink" href="#references_240" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/5.2#E1</p>
<h2 id="examples_115">Examples<a class="headerlink" href="#examples_115" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import gamma, factorial</p>
<p>gamma([0, 0.5, 1, 5])
array([         inf,   1.77245385,   1.        ,  24.        ])</p>
<p>z = 2.5 + 1j
gamma(z)
(0.77476210455108352+0.70763120437959293j)
gamma(z+1), z*gamma(z)  # Recurrence property
((1.2292740569981171+2.5438401155000685j),
(1.2292740569981158+2.5438401155000658j))</p>
<p>gamma(0.5)**2  # gamma(0.5) = sqrt(pi)
3.1415926535897927</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot gamma(x) for real x</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-3.5, 5.5, 2251)
y = gamma(x)</p>
<p>import matplotlib.pyplot as plt
plt.plot(x, y, 'b', alpha=0.6, label='gamma(x)')
k = np.arange(1, 7)
plt.plot(k, factorial(k-1), 'k*', alpha=0.6,
...          label='(x-1)!, x = 1, 2, ...')
plt.xlim(-3.5, 5.5)
plt.ylim(-10, 25)
plt.grid()
plt.xlabel('x')
plt.legend(loc='lower right')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gammainc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gammainc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gammainc(a, x)</p>
<p>Regularized lower incomplete gamma function.</p>
<p>It is defined as</p>
<p>.. math::</p>
<p>P(a, x) = \frac{1}{\Gamma(a)} \int_0^x t^{a - 1}e^{-t} dt</p>
<p>for :math:<code>a &gt; 0</code> and :math:<code>x \geq 0</code>. See [dlmf]_ for details.</p>
<h2 id="parameters_310">Parameters<a class="headerlink" href="#parameters_310" title="Permanent link">&para;</a></h2>
<p>a : array_like
Positive parameter
x : array_like
Nonnegative argument</p>
<h2 id="returns_330">Returns<a class="headerlink" href="#returns_330" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the lower incomplete gamma function</p>
<h2 id="notes_184">Notes<a class="headerlink" href="#notes_184" title="Permanent link">&para;</a></h2>
<p>The function satisfies the relation <code>gammainc(a, x) +
gammaincc(a, x) = 1</code> where <code>gammaincc</code> is the regularized upper
incomplete gamma function.</p>
<p>The implementation largely follows that of [boost]_.</p>
<h2 id="see-also_238">See also<a class="headerlink" href="#see-also_238" title="Permanent link">&para;</a></h2>
<p>gammaincc : regularized upper incomplete gamma function
gammaincinv : inverse of the regularized lower incomplete gamma
function with respect to <code>x</code>
gammainccinv : inverse of the regularized upper incomplete gamma
function with respect to <code>x</code></p>
<h2 id="references_241">References<a class="headerlink" href="#references_241" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical functions
https://dlmf.nist.gov/8.2#E4
.. [boost] Maddock et. al., 'Incomplete Gamma Functions',
https://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html</p>
<h2 id="examples_116">Examples<a class="headerlink" href="#examples_116" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is the CDF of the gamma distribution, so it starts at 0 and
monotonically increases to 1.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammainc(0.5, [0, 1, 10, 100])
array([0.        , 0.84270079, 0.99999226, 1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is equal to one minus the upper incomplete gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, x = 0.5, 0.4
sc.gammainc(a, x)
0.6289066304773024
1 - sc.gammaincc(a, x)
0.6289066304773024</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gammaincc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gammaincc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gammaincc(a, x)</p>
<p>Regularized upper incomplete gamma function.</p>
<p>It is defined as</p>
<p>.. math::</p>
<p>Q(a, x) = \frac{1}{\Gamma(a)} \int_x^\infty t^{a - 1}e^{-t} dt</p>
<p>for :math:<code>a &gt; 0</code> and :math:<code>x \geq 0</code>. See [dlmf]_ for details.</p>
<h2 id="parameters_311">Parameters<a class="headerlink" href="#parameters_311" title="Permanent link">&para;</a></h2>
<p>a : array_like
Positive parameter
x : array_like
Nonnegative argument</p>
<h2 id="returns_331">Returns<a class="headerlink" href="#returns_331" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the upper incomplete gamma function</p>
<h2 id="notes_185">Notes<a class="headerlink" href="#notes_185" title="Permanent link">&para;</a></h2>
<p>The function satisfies the relation <code>gammainc(a, x) +
gammaincc(a, x) = 1</code> where <code>gammainc</code> is the regularized lower
incomplete gamma function.</p>
<p>The implementation largely follows that of [boost]_.</p>
<h2 id="see-also_239">See also<a class="headerlink" href="#see-also_239" title="Permanent link">&para;</a></h2>
<p>gammainc : regularized lower incomplete gamma function
gammaincinv : inverse of the regularized lower incomplete gamma
function with respect to <code>x</code>
gammainccinv : inverse to of the regularized upper incomplete
gamma function with respect to <code>x</code></p>
<h2 id="references_242">References<a class="headerlink" href="#references_242" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical functions
https://dlmf.nist.gov/8.2#E4
.. [boost] Maddock et. al., 'Incomplete Gamma Functions',
https://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html</p>
<h2 id="examples_117">Examples<a class="headerlink" href="#examples_117" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is the survival function of the gamma distribution, so it
starts at 1 and monotonically decreases to 0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammaincc(0.5, [0, 1, 10, 100, 1000])
array([1.00000000e+00, 1.57299207e-01, 7.74421643e-06, 2.08848758e-45,
0.00000000e+00])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is equal to one minus the lower incomplete gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, x = 0.5, 0.4
sc.gammaincc(a, x)
0.37109336952269756
1 - sc.gammainc(a, x)
0.37109336952269756</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gammainccinv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gammainccinv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gammainccinv(a, y)</p>
<p>Inverse of the upper incomplete gamma function with respect to <code>x</code></p>
<p>Given an input :math:<code>y</code> between 0 and 1, returns :math:<code>x</code> such
that :math:<code>y = Q(a, x)</code>. Here :math:<code>Q</code> is the upper incomplete
gamma function; see <code>gammaincc</code>. This is well-defined because the
upper incomplete gamma function is monotonic as can be seen from
its definition in [dlmf]_.</p>
<h2 id="parameters_312">Parameters<a class="headerlink" href="#parameters_312" title="Permanent link">&para;</a></h2>
<p>a : array_like
Positive parameter
y : array_like
Argument between 0 and 1, inclusive</p>
<h2 id="returns_332">Returns<a class="headerlink" href="#returns_332" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the inverse of the upper incomplete gamma function</p>
<h2 id="see-also_240">See Also<a class="headerlink" href="#see-also_240" title="Permanent link">&para;</a></h2>
<p>gammaincc : regularized upper incomplete gamma function
gammainc : regularized lower incomplete gamma function
gammaincinv : inverse of the regularized lower incomplete gamma
function with respect to <code>x</code></p>
<h2 id="references_243">References<a class="headerlink" href="#references_243" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/8.2#E4</p>
<h2 id="examples_118">Examples<a class="headerlink" href="#examples_118" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It starts at infinity and monotonically decreases to 0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammainccinv(0.5, [0, 0.1, 0.5, 1])
array([       inf, 1.35277173, 0.22746821, 0.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It inverts the upper incomplete gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, x = 0.5, [0, 0.1, 0.5, 1]
sc.gammaincc(a, sc.gammainccinv(a, x))
array([0. , 0.1, 0.5, 1. ])</p>
<p>a, x = 0.5, [0, 10, 50]
sc.gammainccinv(a, sc.gammaincc(a, x))
array([ 0., 10., 50.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gammaincinv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gammaincinv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gammaincinv(a, y)</p>
<p>Inverse to the lower incomplete gamma function with respect to <code>x</code>.</p>
<p>Given an input :math:<code>y</code> between 0 and 1, returns :math:<code>x</code> such
that :math:<code>y = P(a, x)</code>. Here :math:<code>P</code> is the regularized lower
incomplete gamma function; see <code>gammainc</code>. This is well-defined
because the lower incomplete gamma function is monotonic as can be
seen from its definition in [dlmf]_.</p>
<h2 id="parameters_313">Parameters<a class="headerlink" href="#parameters_313" title="Permanent link">&para;</a></h2>
<p>a : array_like
Positive parameter
y : array_like
Parameter between 0 and 1, inclusive</p>
<h2 id="returns_333">Returns<a class="headerlink" href="#returns_333" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the inverse of the lower incomplete gamma function</p>
<h2 id="see-also_241">See Also<a class="headerlink" href="#see-also_241" title="Permanent link">&para;</a></h2>
<p>gammainc : regularized lower incomplete gamma function
gammaincc : regularized upper incomplete gamma function
gammainccinv : inverse of the regualizred upper incomplete gamma
function with respect to <code>x</code></p>
<h2 id="references_244">References<a class="headerlink" href="#references_244" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/8.2#E4</p>
<h2 id="examples_119">Examples<a class="headerlink" href="#examples_119" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It starts at 0 and monotonically increases to infinity.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammaincinv(0.5, [0, 0.1 ,0.5, 1])
array([0.        , 0.00789539, 0.22746821,        inf])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It inverts the lower incomplete gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, x = 0.5, [0, 0.1, 0.5, 1]
sc.gammainc(a, sc.gammaincinv(a, x))
array([0. , 0.1, 0.5, 1. ])</p>
<p>a, x = 0.5, [0, 10, 25]
sc.gammaincinv(a, sc.gammainc(a, x))
array([ 0.        , 10.        , 25.00001465])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gammaln</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gammaln(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gammaln(x, out=None)</p>
<p>Logarithm of the absolute value of the Gamma function.</p>
<p>Defined as</p>
<p>.. math::</p>
<p>\ln(\lvert\Gamma(x)\rvert)</p>
<p>where :math:<code>\Gamma</code> is the Gamma function. For more details on
the Gamma function, see [dlmf]_.</p>
<h2 id="parameters_314">Parameters<a class="headerlink" href="#parameters_314" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real argument
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_334">Returns<a class="headerlink" href="#returns_334" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the log of the absolute value of Gamma</p>
<h2 id="see-also_242">See Also<a class="headerlink" href="#see-also_242" title="Permanent link">&para;</a></h2>
<p>gammasgn : sign of the gamma function
loggamma : principal branch of the logarithm of the gamma function</p>
<h2 id="notes_186">Notes<a class="headerlink" href="#notes_186" title="Permanent link">&para;</a></h2>
<p>It is the same function as the Python standard library function
:func:<code>math.lgamma</code>.</p>
<p>When used in conjunction with <code>gammasgn</code>, this function is useful
for working in logspace on the real axis without having to deal
with complex numbers via the relation <code>exp(gammaln(x)) =
gammasgn(x) * gamma(x)</code>.</p>
<p>For complex-valued log-gamma, use <code>loggamma</code> instead of <code>gammaln</code>.</p>
<h2 id="references_245">References<a class="headerlink" href="#references_245" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/5</p>
<h2 id="examples_120">Examples<a class="headerlink" href="#examples_120" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has two positive zeros.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammaln([1, 2])
array([0., 0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has poles at nonpositive integers.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammaln([0, -1, -2, -3, -4])
array([inf, inf, inf, inf, inf])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It asymptotically approaches <code>x * log(x)</code> (Stirling's formula).</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1e10, 1e20, 1e40, 1e80])
sc.gammaln(x)
array([2.20258509e+11, 4.50517019e+21, 9.11034037e+41, 1.83206807e+82])
x * np.log(x)
array([2.30258509e+11, 4.60517019e+21, 9.21034037e+41, 1.84206807e+82])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gammasgn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gammasgn(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gammasgn(x)</p>
<p>Sign of the gamma function.</p>
<p>It is defined as</p>
<p>.. math::</p>
<p>\text{gammasgn}(x) =
\begin{cases}
+1 &amp; \Gamma(x) &gt; 0 \
-1 &amp; \Gamma(x) &lt; 0
\end{cases}</p>
<p>where :math:<code>\Gamma</code> is the Gamma function; see <code>gamma</code>. This
definition is complete since the Gamma function is never zero;
see the discussion after [dlmf]_.</p>
<h2 id="parameters_315">Parameters<a class="headerlink" href="#parameters_315" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real argument</p>
<h2 id="returns_335">Returns<a class="headerlink" href="#returns_335" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Sign of the Gamma function</p>
<h2 id="notes_187">Notes<a class="headerlink" href="#notes_187" title="Permanent link">&para;</a></h2>
<p>The Gamma function can be computed as <code>gammasgn(x) *
np.exp(gammaln(x))</code>.</p>
<h2 id="see-also_243">See Also<a class="headerlink" href="#see-also_243" title="Permanent link">&para;</a></h2>
<p>gamma : the Gamma function
gammaln : log of the absolute value of the Gamma function
loggamma : analytic continuation of the log of the Gamma function</p>
<h2 id="references_246">References<a class="headerlink" href="#references_246" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/5.2#E1</p>
<h2 id="examples_121">Examples<a class="headerlink" href="#examples_121" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is 1 for <code>x &gt; 0</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammasgn([1, 2, 3, 4])
array([1., 1., 1., 1.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It alternates between -1 and 1 for negative integers.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.gammasgn([-0.5, -1.5, -2.5, -3.5])
array([-1.,  1., -1.,  1.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It can be used to compute the Gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = [1.5, 0.5, -0.5, -1.5]
sc.gammasgn(x) * np.exp(sc.gammaln(x))
array([ 0.88622693,  1.77245385, -3.5449077 ,  2.3632718 ])
sc.gamma(x)
array([ 0.88622693,  1.77245385, -3.5449077 ,  2.3632718 ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gdtr(a, b, x)</p>
<p>Gamma distribution cumulative distribution function.</p>
<p>Returns the integral from zero to <code>x</code> of the gamma probability density
function,</p>
<p>.. math::</p>
<p>F = \int_0^x \frac{a^b}{\Gamma(b)} t^{b-1} e^{-at}\,dt,</p>
<p>where :math:<code>\Gamma</code> is the gamma function.</p>
<h2 id="parameters_316">Parameters<a class="headerlink" href="#parameters_316" title="Permanent link">&para;</a></h2>
<p>a : array_like
The rate parameter of the gamma distribution, sometimes denoted
:math:<code>\beta</code> (float).  It is also the reciprocal of the scale
parameter :math:<code>\theta</code>.
b : array_like
The shape parameter of the gamma distribution, sometimes denoted
:math:<code>\alpha</code> (float).
x : array_like
The quantile (upper limit of integration; float).</p>
<h2 id="see-also_244">See also<a class="headerlink" href="#see-also_244" title="Permanent link">&para;</a></h2>
<p>gdtrc : 1 - CDF of the gamma distribution.</p>
<h2 id="returns_336">Returns<a class="headerlink" href="#returns_336" title="Permanent link">&para;</a></h2>
<p>F : ndarray
The CDF of the gamma distribution with parameters <code>a</code> and <code>b</code>
evaluated at <code>x</code>.</p>
<h2 id="notes_188">Notes<a class="headerlink" href="#notes_188" title="Permanent link">&para;</a></h2>
<p>The evaluation is carried out using the relation to the incomplete gamma
integral (regularized gamma function).</p>
<p>Wrapper for the Cephes [1]_ routine <code>gdtr</code>.</p>
<h2 id="references_247">References<a class="headerlink" href="#references_247" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gdtrc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gdtrc(a, b, x)</p>
<p>Gamma distribution survival function.</p>
<p>Integral from <code>x</code> to infinity of the gamma probability density function,</p>
<p>.. math::</p>
<p>F = \int_x^\infty \frac{a^b}{\Gamma(b)} t^{b-1} e^{-at}\,dt,</p>
<p>where :math:<code>\Gamma</code> is the gamma function.</p>
<h2 id="parameters_317">Parameters<a class="headerlink" href="#parameters_317" title="Permanent link">&para;</a></h2>
<p>a : array_like
The rate parameter of the gamma distribution, sometimes denoted
:math:<code>\beta</code> (float).  It is also the reciprocal of the scale
parameter :math:<code>\theta</code>.
b : array_like
The shape parameter of the gamma distribution, sometimes denoted
:math:<code>\alpha</code> (float).
x : array_like
The quantile (lower limit of integration; float).</p>
<h2 id="returns_337">Returns<a class="headerlink" href="#returns_337" title="Permanent link">&para;</a></h2>
<p>F : ndarray
The survival function of the gamma distribution with parameters <code>a</code>
and <code>b</code> evaluated at <code>x</code>.</p>
<h2 id="see-also_245">See Also<a class="headerlink" href="#see-also_245" title="Permanent link">&para;</a></h2>
<p>gdtr, gdtrix</p>
<h2 id="notes_189">Notes<a class="headerlink" href="#notes_189" title="Permanent link">&para;</a></h2>
<p>The evaluation is carried out using the relation to the incomplete gamma
integral (regularized gamma function).</p>
<p>Wrapper for the Cephes [1]_ routine <code>gdtrc</code>.</p>
<h2 id="references_248">References<a class="headerlink" href="#references_248" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gdtria</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gdtria(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gdtria(p, b, x, out=None)</p>
<p>Inverse of <code>gdtr</code> vs a.</p>
<p>Returns the inverse with respect to the parameter <code>a</code> of <code>p =
gdtr(a, b, x)</code>, the cumulative distribution function of the gamma
distribution.</p>
<h2 id="parameters_318">Parameters<a class="headerlink" href="#parameters_318" title="Permanent link">&para;</a></h2>
<p>p : array_like
Probability values.
b : array_like
<code>b</code> parameter values of <code>gdtr(a, b, x)</code>.  <code>b</code> is the 'shape' parameter
of the gamma distribution.
x : array_like
Nonnegative real values, from the domain of the gamma distribution.
out : ndarray, optional
If a fourth argument is given, it must be a numpy.ndarray whose size
matches the broadcast result of <code>a</code>, <code>b</code> and <code>x</code>.  <code>out</code> is then the
array returned by the function.</p>
<h2 id="returns_338">Returns<a class="headerlink" href="#returns_338" title="Permanent link">&para;</a></h2>
<p>a : ndarray
Values of the <code>a</code> parameter such that <code>p = gdtr(a, b, x)</code>.  <code>1/a</code>
is the 'scale' parameter of the gamma distribution.</p>
<h2 id="see-also_246">See Also<a class="headerlink" href="#see-also_246" title="Permanent link">&para;</a></h2>
<p>gdtr : CDF of the gamma distribution.
gdtrib : Inverse with respect to <code>b</code> of <code>gdtr(a, b, x)</code>.
gdtrix : Inverse with respect to <code>x</code> of <code>gdtr(a, b, x)</code>.</p>
<h2 id="notes_190">Notes<a class="headerlink" href="#notes_190" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfgam</code>.</p>
<p>The cumulative distribution function <code>p</code> is computed using a routine by
DiDinato and Morris [2]_.  Computation of <code>a</code> involves a search for a value
that produces the desired value of <code>p</code>.  The search relies on the
monotonicity of <code>p</code> with <code>a</code>.</p>
<h2 id="references_249">References<a class="headerlink" href="#references_249" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] DiDinato, A. R. and Morris, A. H.,
Computation of the incomplete gamma function ratios and their
inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.</p>
<h2 id="examples_122">Examples<a class="headerlink" href="#examples_122" title="Permanent link">&para;</a></h2>
<p>First evaluate <code>gdtr</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import gdtr, gdtria
p = gdtr(1.2, 3.4, 5.6)
print(p)
0.94378087442</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify the inverse.</p>
<blockquote>
<blockquote>
<blockquote>
<p>gdtria(p, 3.4, 5.6)
1.2</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gdtrib</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gdtrib(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gdtrib(a, p, x, out=None)</p>
<p>Inverse of <code>gdtr</code> vs b.</p>
<p>Returns the inverse with respect to the parameter <code>b</code> of <code>p =
gdtr(a, b, x)</code>, the cumulative distribution function of the gamma
distribution.</p>
<h2 id="parameters_319">Parameters<a class="headerlink" href="#parameters_319" title="Permanent link">&para;</a></h2>
<p>a : array_like
<code>a</code> parameter values of <code>gdtr(a, b, x)</code>. <code>1/a</code> is the 'scale'
parameter of the gamma distribution.
p : array_like
Probability values.
x : array_like
Nonnegative real values, from the domain of the gamma distribution.
out : ndarray, optional
If a fourth argument is given, it must be a numpy.ndarray whose size
matches the broadcast result of <code>a</code>, <code>b</code> and <code>x</code>.  <code>out</code> is then the
array returned by the function.</p>
<h2 id="returns_339">Returns<a class="headerlink" href="#returns_339" title="Permanent link">&para;</a></h2>
<p>b : ndarray
Values of the <code>b</code> parameter such that <code>p = gdtr(a, b, x)</code>.  <code>b</code> is
the 'shape' parameter of the gamma distribution.</p>
<h2 id="see-also_247">See Also<a class="headerlink" href="#see-also_247" title="Permanent link">&para;</a></h2>
<p>gdtr : CDF of the gamma distribution.
gdtria : Inverse with respect to <code>a</code> of <code>gdtr(a, b, x)</code>.
gdtrix : Inverse with respect to <code>x</code> of <code>gdtr(a, b, x)</code>.</p>
<h2 id="notes_191">Notes<a class="headerlink" href="#notes_191" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfgam</code>.</p>
<p>The cumulative distribution function <code>p</code> is computed using a routine by
DiDinato and Morris [2]_.  Computation of <code>b</code> involves a search for a value
that produces the desired value of <code>p</code>.  The search relies on the
monotonicity of <code>p</code> with <code>b</code>.</p>
<h2 id="references_250">References<a class="headerlink" href="#references_250" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] DiDinato, A. R. and Morris, A. H.,
Computation of the incomplete gamma function ratios and their
inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.</p>
<h2 id="examples_123">Examples<a class="headerlink" href="#examples_123" title="Permanent link">&para;</a></h2>
<p>First evaluate <code>gdtr</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import gdtr, gdtrib
p = gdtr(1.2, 3.4, 5.6)
print(p)
0.94378087442</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify the inverse.</p>
<blockquote>
<blockquote>
<blockquote>
<p>gdtrib(1.2, p, 5.6)
3.3999999999723882</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gdtrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gdtrix(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gdtrix(a, b, p, out=None)</p>
<p>Inverse of <code>gdtr</code> vs x.</p>
<p>Returns the inverse with respect to the parameter <code>x</code> of <code>p =
gdtr(a, b, x)</code>, the cumulative distribution function of the gamma
distribution. This is also known as the p'th quantile of the
distribution.</p>
<h2 id="parameters_320">Parameters<a class="headerlink" href="#parameters_320" title="Permanent link">&para;</a></h2>
<p>a : array_like
<code>a</code> parameter values of <code>gdtr(a, b, x)</code>.  <code>1/a</code> is the 'scale'
parameter of the gamma distribution.
b : array_like
<code>b</code> parameter values of <code>gdtr(a, b, x)</code>.  <code>b</code> is the 'shape' parameter
of the gamma distribution.
p : array_like
Probability values.
out : ndarray, optional
If a fourth argument is given, it must be a numpy.ndarray whose size
matches the broadcast result of <code>a</code>, <code>b</code> and <code>x</code>.  <code>out</code> is then the
array returned by the function.</p>
<h2 id="returns_340">Returns<a class="headerlink" href="#returns_340" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Values of the <code>x</code> parameter such that <code>p = gdtr(a, b, x)</code>.</p>
<h2 id="see-also_248">See Also<a class="headerlink" href="#see-also_248" title="Permanent link">&para;</a></h2>
<p>gdtr : CDF of the gamma distribution.
gdtria : Inverse with respect to <code>a</code> of <code>gdtr(a, b, x)</code>.
gdtrib : Inverse with respect to <code>b</code> of <code>gdtr(a, b, x)</code>.</p>
<h2 id="notes_192">Notes<a class="headerlink" href="#notes_192" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfgam</code>.</p>
<p>The cumulative distribution function <code>p</code> is computed using a routine by
DiDinato and Morris [2]_.  Computation of <code>x</code> involves a search for a value
that produces the desired value of <code>p</code>.  The search relies on the
monotonicity of <code>p</code> with <code>x</code>.</p>
<h2 id="references_251">References<a class="headerlink" href="#references_251" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] DiDinato, A. R. and Morris, A. H.,
Computation of the incomplete gamma function ratios and their
inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.</p>
<h2 id="examples_124">Examples<a class="headerlink" href="#examples_124" title="Permanent link">&para;</a></h2>
<p>First evaluate <code>gdtr</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import gdtr, gdtrix
p = gdtr(1.2, 3.4, 5.6)
print(p)
0.94378087442</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify the inverse.</p>
<blockquote>
<blockquote>
<blockquote>
<p>gdtrix(1.2, 3.4, p)
5.5999999999999996</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gegenbauer</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Gegenbauer (ultraspherical) polynomial.</p>
<p>Defined to be the solution of</p>
<p>.. math::
(1 - x^2)\frac{d^2}{dx^2}C_n^{(\alpha)}
- (2\alpha + 1)x\frac{d}{dx}C_n^{(\alpha)}
+ n(n + 2\alpha)C_n^{(\alpha)} = 0</p>
<p>for :math:<code>\alpha &gt; -1/2</code>; :math:<code>C_n^{(\alpha)}</code> is a polynomial
of degree :math:<code>n</code>.</p>
<h2 id="parameters_321">Parameters<a class="headerlink" href="#parameters_321" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_341">Returns<a class="headerlink" href="#returns_341" title="Permanent link">&para;</a></h2>
<p>C : orthopoly1d
Gegenbauer polynomial.</p>
<h2 id="notes_193">Notes<a class="headerlink" href="#notes_193" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>C_n^{(\alpha)}</code> are orthogonal over
:math:<code>[-1,1]</code> with weight function :math:<code>(1 - x^2)^{(\alpha -
1/2)}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">genlaguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Generalized (associated) Laguerre polynomial.</p>
<p>Defined to be the solution of</p>
<p>.. math::
x\frac{d^2}{dx^2}L_n^{(\alpha)}
+ (\alpha + 1 - x)\frac{d}{dx}L_n^{(\alpha)}
+ nL_n^{(\alpha)} = 0,</p>
<p>where :math:<code>\alpha &gt; -1</code>; :math:<code>L_n^{(\alpha)}</code> is a polynomial
of degree :math:<code>n</code>.</p>
<h2 id="parameters_322">Parameters<a class="headerlink" href="#parameters_322" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
alpha : float
Parameter, must be greater than -1.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_342">Returns<a class="headerlink" href="#returns_342" title="Permanent link">&para;</a></h2>
<p>L : orthopoly1d
Generalized Laguerre polynomial.</p>
<h2 id="notes_194">Notes<a class="headerlink" href="#notes_194" title="Permanent link">&para;</a></h2>
<p>For fixed :math:<code>\alpha</code>, the polynomials :math:<code>L_n^{(\alpha)}</code>
are orthogonal over :math:<code>[0, \infty)</code> with weight function
:math:<code>e^{-x}x^\alpha</code>.</p>
<p>The Laguerre polynomials are the special case where :math:<code>\alpha
= 0</code>.</p>
<h2 id="see-also_249">See Also<a class="headerlink" href="#see-also_249" title="Permanent link">&para;</a></h2>
<p>laguerre : Laguerre polynomial.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">h1vp</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nth derivative of Hankel function H1v(z) with respect to <code>z</code>.</p>
<h2 id="parameters_323">Parameters<a class="headerlink" href="#parameters_323" title="Permanent link">&para;</a></h2>
<p>v : float
Order of Hankel function
z : complex
Argument at which to evaluate the derivative
n : int, default 1
Order of derivative</p>
<h2 id="notes_195">Notes<a class="headerlink" href="#notes_195" title="Permanent link">&para;</a></h2>
<p>The derivative is computed using the relation DLFM 10.6.7 [2]_.</p>
<h2 id="references_252">References<a class="headerlink" href="#references_252" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 5.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html
.. [2] NIST Digital Library of Mathematical Functions.
https://dlmf.nist.gov/10.6.E7</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">h2vp</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nth derivative of Hankel function H2v(z) with respect to <code>z</code>.</p>
<h2 id="parameters_324">Parameters<a class="headerlink" href="#parameters_324" title="Permanent link">&para;</a></h2>
<p>v : float
Order of Hankel function
z : complex
Argument at which to evaluate the derivative
n : int, default 1
Order of derivative</p>
<h2 id="notes_196">Notes<a class="headerlink" href="#notes_196" title="Permanent link">&para;</a></h2>
<p>The derivative is computed using the relation DLFM 10.6.7 [2]_.</p>
<h2 id="references_253">References<a class="headerlink" href="#references_253" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 5.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html
.. [2] NIST Digital Library of Mathematical Functions.
https://dlmf.nist.gov/10.6.E7</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">h_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Hermite (physicst's) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Hermite
quadrature. The sample points are the roots of the n-th degree
Hermite polynomial, :math:<code>H_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[-\infty, \infty]</code> with weight
function :math:<code>w(x) = e^{-x^2}</code>. See 22.2.14 in [AS]_ for
details.</p>
<h2 id="parameters_325">Parameters<a class="headerlink" href="#parameters_325" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_343">Returns<a class="headerlink" href="#returns_343" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="notes_197">Notes<a class="headerlink" href="#notes_197" title="Permanent link">&para;</a></h2>
<p>For small n up to 150 a modified version of the Golub-Welsch
algorithm is used. Nodes are computed from the eigenvalue
problem and improved by one step of a Newton iteration.
The weights are computed from the well-known analytical formula.</p>
<p>For n larger than 150 an optimal asymptotic algorithm is applied
which computes nodes and weights in a numerically stable manner.
The algorithm has linear runtime making computation for very
large n (several thousand or more) feasible.</p>
<h2 id="see-also_250">See Also<a class="headerlink" href="#see-also_250" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.hermite.hermgauss
roots_hermitenorm</p>
<h2 id="references_254">References<a class="headerlink" href="#references_254" title="Permanent link">&para;</a></h2>
<p>.. [townsend.trogdon.olver-2014]
Townsend, A. and Trogdon, T. and Olver, S. (2014)
<em>Fast computation of Gauss quadrature nodes and
weights on the whole real line</em>. :arXiv:<code>1410.5286</code>.
.. [townsend.trogdon.olver-2015]
Townsend, A. and Trogdon, T. and Olver, S. (2015)
<em>Fast computation of Gauss quadrature nodes and
weights on the whole real line</em>.
IMA Journal of Numerical Analysis
:doi:<code>10.1093/imanum/drv002</code>.
.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hankel1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hankel1(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hankel1(v, z)</p>
<p>Hankel function of the first kind</p>
<h2 id="parameters_326">Parameters<a class="headerlink" href="#parameters_326" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_344">Returns<a class="headerlink" href="#returns_344" title="Permanent link">&para;</a></h2>
<p>out : Values of the Hankel function of the first kind.</p>
<h2 id="notes_198">Notes<a class="headerlink" href="#notes_198" title="Permanent link">&para;</a></h2>
<p>A wrapper for the AMOS [1]_ routine <code>zbesh</code>, which carries out the
computation using the relation,</p>
<p>.. math:: H^{(1)}_v(z) = \frac{2}{\imath\pi} \exp(-\imath \pi v/2) K_v(z \exp(-\imath\pi/2))</p>
<p>where :math:<code>K_v</code> is the modified Bessel function of the second kind.
For negative orders, the relation</p>
<p>.. math:: H^{(1)}_{-v}(z) = H^{(1)}_v(z) \exp(\imath\pi v)</p>
<p>is used.</p>
<h2 id="see-also_251">See also<a class="headerlink" href="#see-also_251" title="Permanent link">&para;</a></h2>
<p>hankel1e : this function with leading exponential behavior stripped off.</p>
<h2 id="references_255">References<a class="headerlink" href="#references_255" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hankel1e</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hankel1e(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hankel1e(v, z)</p>
<p>Exponentially scaled Hankel function of the first kind</p>
<p>Defined as::</p>
<p>hankel1e(v, z) = hankel1(v, z) * exp(-1j * z)</p>
<h2 id="parameters_327">Parameters<a class="headerlink" href="#parameters_327" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_345">Returns<a class="headerlink" href="#returns_345" title="Permanent link">&para;</a></h2>
<p>out : Values of the exponentially scaled Hankel function.</p>
<h2 id="notes_199">Notes<a class="headerlink" href="#notes_199" title="Permanent link">&para;</a></h2>
<p>A wrapper for the AMOS [1]_ routine <code>zbesh</code>, which carries out the
computation using the relation,</p>
<p>.. math:: H^{(1)}_v(z) = \frac{2}{\imath\pi} \exp(-\imath \pi v/2) K_v(z \exp(-\imath\pi/2))</p>
<p>where :math:<code>K_v</code> is the modified Bessel function of the second kind.
For negative orders, the relation</p>
<p>.. math:: H^{(1)}_{-v}(z) = H^{(1)}_v(z) \exp(\imath\pi v)</p>
<p>is used.</p>
<h2 id="references_256">References<a class="headerlink" href="#references_256" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hankel2</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hankel2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hankel2(v, z)</p>
<p>Hankel function of the second kind</p>
<h2 id="parameters_328">Parameters<a class="headerlink" href="#parameters_328" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_346">Returns<a class="headerlink" href="#returns_346" title="Permanent link">&para;</a></h2>
<p>out : Values of the Hankel function of the second kind.</p>
<h2 id="notes_200">Notes<a class="headerlink" href="#notes_200" title="Permanent link">&para;</a></h2>
<p>A wrapper for the AMOS [1]_ routine <code>zbesh</code>, which carries out the
computation using the relation,</p>
<p>.. math:: H^{(2)}_v(z) = -\frac{2}{\imath\pi} \exp(\imath \pi v/2) K_v(z \exp(\imath\pi/2))</p>
<p>where :math:<code>K_v</code> is the modified Bessel function of the second kind.
For negative orders, the relation</p>
<p>.. math:: H^{(2)}_{-v}(z) = H^{(2)}_v(z) \exp(-\imath\pi v)</p>
<p>is used.</p>
<h2 id="see-also_252">See also<a class="headerlink" href="#see-also_252" title="Permanent link">&para;</a></h2>
<p>hankel2e : this function with leading exponential behavior stripped off.</p>
<h2 id="references_257">References<a class="headerlink" href="#references_257" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hankel2e</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hankel2e(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hankel2e(v, z)</p>
<p>Exponentially scaled Hankel function of the second kind</p>
<p>Defined as::</p>
<p>hankel2e(v, z) = hankel2(v, z) * exp(1j * z)</p>
<h2 id="parameters_329">Parameters<a class="headerlink" href="#parameters_329" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_347">Returns<a class="headerlink" href="#returns_347" title="Permanent link">&para;</a></h2>
<p>out : Values of the exponentially scaled Hankel function of the second kind.</p>
<h2 id="notes_201">Notes<a class="headerlink" href="#notes_201" title="Permanent link">&para;</a></h2>
<p>A wrapper for the AMOS [1]_ routine <code>zbesh</code>, which carries out the
computation using the relation,</p>
<p>.. math:: H^{(2)}_v(z) = -\frac{2}{\imath\pi} \exp(\frac{\imath \pi v}{2}) K_v(z exp(\frac{\imath\pi}{2}))</p>
<p>where :math:<code>K_v</code> is the modified Bessel function of the second kind.
For negative orders, the relation</p>
<p>.. math:: H^{(2)}_{-v}(z) = H^{(2)}_v(z) \exp(-\imath\pi v)</p>
<p>is used.</p>
<h2 id="references_258">References<a class="headerlink" href="#references_258" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">he_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Hermite (statistician's) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Hermite
quadrature. The sample points are the roots of the n-th degree
Hermite polynomial, :math:<code>He_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[-\infty, \infty]</code> with weight
function :math:<code>w(x) = e^{-x^2/2}</code>. See 22.2.15 in [AS]_ for more
details.</p>
<h2 id="parameters_330">Parameters<a class="headerlink" href="#parameters_330" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_348">Returns<a class="headerlink" href="#returns_348" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="notes_202">Notes<a class="headerlink" href="#notes_202" title="Permanent link">&para;</a></h2>
<p>For small n up to 150 a modified version of the Golub-Welsch
algorithm is used. Nodes are computed from the eigenvalue
problem and improved by one step of a Newton iteration.
The weights are computed from the well-known analytical formula.</p>
<p>For n larger than 150 an optimal asymptotic algorithm is used
which computes nodes and weights in a numerical stable manner.
The algorithm has linear runtime making computation for very
large n (several thousand or more) feasible.</p>
<h2 id="see-also_253">See Also<a class="headerlink" href="#see-also_253" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.hermite_e.hermegauss</p>
<h2 id="references_259">References<a class="headerlink" href="#references_259" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hermite</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Physicist's Hermite polynomial.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>H_n(x) = (-1)^ne^{x^2}\frac{d^n}{dx^n}e^{-x^2};</p>
<p>:math:<code>H_n</code> is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_331">Parameters<a class="headerlink" href="#parameters_331" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_349">Returns<a class="headerlink" href="#returns_349" title="Permanent link">&para;</a></h2>
<p>H : orthopoly1d
Hermite polynomial.</p>
<h2 id="notes_203">Notes<a class="headerlink" href="#notes_203" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>H_n</code> are orthogonal over :math:<code>(-\infty,
\infty)</code> with weight function :math:<code>e^{-x^2}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hermitenorm</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Normalized (probabilist's) Hermite polynomial.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>He_n(x) = (-1)^ne^{x^2/2}\frac{d^n}{dx^n}e^{-x^2/2};</p>
<p>:math:<code>He_n</code> is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_332">Parameters<a class="headerlink" href="#parameters_332" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_350">Returns<a class="headerlink" href="#returns_350" title="Permanent link">&para;</a></h2>
<p>He : orthopoly1d
Hermite polynomial.</p>
<h2 id="notes_204">Notes<a class="headerlink" href="#notes_204" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>He_n</code> are orthogonal over :math:<code>(-\infty,
\infty)</code> with weight function :math:<code>e^{-x^2/2}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">huber</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>huber(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>huber(delta, r)</p>
<p>Huber loss function.</p>
<p>.. math:: \text{huber}(\delta, r) = \begin{cases} \infty &amp; \delta &lt; 0  \ \frac{1}{2}r^2 &amp; 0 \le \delta, | r | \le \delta \ \delta ( |r| - \frac{1}{2}\delta ) &amp; \text{otherwise} \end{cases}</p>
<h2 id="parameters_333">Parameters<a class="headerlink" href="#parameters_333" title="Permanent link">&para;</a></h2>
<p>delta : ndarray
Input array, indicating the quadratic vs. linear loss changepoint.
r : ndarray
Input array, possibly representing residuals.</p>
<h2 id="returns_351">Returns<a class="headerlink" href="#returns_351" title="Permanent link">&para;</a></h2>
<p>res : ndarray
The computed Huber loss function values.</p>
<h2 id="notes_205">Notes<a class="headerlink" href="#notes_205" title="Permanent link">&para;</a></h2>
<p>This function is convex in r.</p>
<p>.. versionadded:: 0.15.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hyp0f1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hyp0f1(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hyp0f1(v, z, out=None)</p>
<p>Confluent hypergeometric limit function 0F1.</p>
<h2 id="parameters_334">Parameters<a class="headerlink" href="#parameters_334" title="Permanent link">&para;</a></h2>
<p>v : array_like
Real valued parameter
z : array_like
Real or complex valued argument
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_352">Returns<a class="headerlink" href="#returns_352" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
The confluent hypergeometric limit function</p>
<h2 id="notes_206">Notes<a class="headerlink" href="#notes_206" title="Permanent link">&para;</a></h2>
<p>This function is defined as:</p>
<p>.. math:: <em>0F_1(v, z) = \sum</em>{k=0}^{\infty}\frac{z^k}{(v)_k k!}.</p>
<p>It's also the limit as :math:<code>q \to \infty</code> of :math:<code>_1F_1(q; v; z/q)</code>,
and satisfies the differential equation :math:<code>f''(z) + vf'(z) =
f(z)</code>. See [1]_ for more information.</p>
<h2 id="references_260">References<a class="headerlink" href="#references_260" title="Permanent link">&para;</a></h2>
<p>.. [1] Wolfram MathWorld, 'Confluent Hypergeometric Limit Function',
http://mathworld.wolfram.com/ConfluentHypergeometricLimitFunction.html</p>
<h2 id="examples_125">Examples<a class="headerlink" href="#examples_125" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is one when <code>z</code> is zero.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.hyp0f1(1, 0)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is the limit of the confluent hypergeometric function as <code>q</code>
goes to infinity.</p>
<blockquote>
<blockquote>
<blockquote>
<p>q = np.array([1, 10, 100, 1000])
v = 1
z = 1
sc.hyp1f1(q, v, z / q)
array([2.71828183, 2.31481985, 2.28303778, 2.27992985])
sc.hyp0f1(v, z)
2.2795853023360673</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is related to Bessel functions.</p>
<blockquote>
<blockquote>
<blockquote>
<p>n = 1
x = np.linspace(0, 1, 5)
sc.jv(n, x)
array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059])
(0.5 * x)<strong>n / sc.factorial(n) * sc.hyp0f1(n + 1, -0.25 * x</strong>2)
array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hyp1f1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hyp1f1(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hyp1f1(a, b, x, out=None)</p>
<p>Confluent hypergeometric function 1F1.</p>
<p>The confluent hypergeometric function is defined by the series</p>
<p>.. math::</p>
<p>{}<em>1F_1(a; b; x) = \sum</em>{k = 0}^\infty \frac{(a)_k}{(b)_k k!} x^k.</p>
<p>See [dlmf]_ for more details. Here :math:<code>(\cdot)_k</code> is the
Pochhammer symbol; see <code>poch</code>.</p>
<h2 id="parameters_335">Parameters<a class="headerlink" href="#parameters_335" title="Permanent link">&para;</a></h2>
<p>a, b : array_like
Real parameters
x : array_like
Real or complex argument
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_353">Returns<a class="headerlink" href="#returns_353" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the confluent hypergeometric function</p>
<h2 id="see-also_254">See also<a class="headerlink" href="#see-also_254" title="Permanent link">&para;</a></h2>
<p>hyperu : another confluent hypergeometric function
hyp0f1 : confluent hypergeometric limit function
hyp2f1 : Gaussian hypergeometric function</p>
<h2 id="references_261">References<a class="headerlink" href="#references_261" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/13.2#E2</p>
<h2 id="examples_126">Examples<a class="headerlink" href="#examples_126" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is one when <code>x</code> is zero:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.hyp1f1(0.5, 0.5, 0)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is singular when <code>b</code> is a nonpositive integer.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.hyp1f1(0.5, -1, 0)
inf</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is a polynomial when <code>a</code> is a nonpositive integer.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, b, x = -1, 0.5, np.array([1.0, 2.0, 3.0, 4.0])
sc.hyp1f1(a, b, x)
array([-1., -3., -5., -7.])
1 + (a / b) * x
array([-1., -3., -5., -7.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It reduces to the exponential function when <code>a = b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.hyp1f1(2, 2, [1, 2, 3, 4])
array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003])
np.exp([1, 2, 3, 4])
array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hyp2f1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hyp2f1(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hyp2f1(a, b, c, z)</p>
<p>Gauss hypergeometric function 2F1(a, b; c; z)</p>
<h2 id="parameters_336">Parameters<a class="headerlink" href="#parameters_336" title="Permanent link">&para;</a></h2>
<p>a, b, c : array_like
Arguments, should be real-valued.
z : array_like
Argument, real or complex.</p>
<h2 id="returns_354">Returns<a class="headerlink" href="#returns_354" title="Permanent link">&para;</a></h2>
<p>hyp2f1 : scalar or ndarray
The values of the gaussian hypergeometric function.</p>
<h2 id="see-also_255">See also<a class="headerlink" href="#see-also_255" title="Permanent link">&para;</a></h2>
<p>hyp0f1 : confluent hypergeometric limit function.
hyp1f1 : Kummer's (confluent hypergeometric) function.</p>
<h2 id="notes_207">Notes<a class="headerlink" href="#notes_207" title="Permanent link">&para;</a></h2>
<p>This function is defined for :math:<code>|z| &lt; 1</code> as</p>
<p>.. math::</p>
<p>\mathrm{hyp2f1}(a, b, c, z) = \sum_{n=0}^\infty
\frac{(a)_n (b)_n}{(c)_n}\frac{z^n}{n!},</p>
<p>and defined on the rest of the complex z-plane by analytic
continuation [1]_.
Here :math:<code>(\cdot)_n</code> is the Pochhammer symbol; see <code>poch</code>. When
:math:<code>n</code> is an integer the result is a polynomial of degree :math:<code>n</code>.</p>
<p>The implementation for complex values of <code>z</code> is described in [2]_.</p>
<h2 id="references_262">References<a class="headerlink" href="#references_262" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/15.2
.. [2] S. Zhang and J.M. Jin, 'Computation of Special Functions', Wiley 1996
.. [3] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<h2 id="examples_127">Examples<a class="headerlink" href="#examples_127" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has poles when <code>c</code> is a negative integer.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.hyp2f1(1, 1, -2, 1)
inf</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is a polynomial when <code>a</code> or <code>b</code> is a negative integer.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, b, c = -1, 1, 1.5
z = np.linspace(0, 1, 5)
sc.hyp2f1(a, b, c, z)
array([1.        , 0.83333333, 0.66666667, 0.5       , 0.33333333])
1 + a * b * z / c
array([1.        , 0.83333333, 0.66666667, 0.5       , 0.33333333])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is symmetric in <code>a</code> and <code>b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.linspace(0, 1, 5)
b = np.linspace(0, 1, 5)
sc.hyp2f1(a, b, 1, 0.5)
array([1.        , 1.03997334, 1.1803406 , 1.47074441, 2.        ])
sc.hyp2f1(b, a, 1, 0.5)
array([1.        , 1.03997334, 1.1803406 , 1.47074441, 2.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It contains many other functions as special cases.</p>
<blockquote>
<blockquote>
<blockquote>
<p>z = 0.5
sc.hyp2f1(1, 1, 2, z)
1.3862943611198901
-np.log(1 - z) / z
1.3862943611198906</p>
<p>sc.hyp2f1(0.5, 1, 1.5, z**2)
1.098612288668109
np.log((1 + z) / (1 - z)) / (2 * z)
1.0986122886681098</p>
<p>sc.hyp2f1(0.5, 1, 1.5, -z**2)
0.9272952180016117
np.arctan(z) / z
0.9272952180016123</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hyperu</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>hyperu(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>hyperu(a, b, x, out=None)</p>
<p>Confluent hypergeometric function U</p>
<p>It is defined as the solution to the equation</p>
<p>.. math::</p>
<p>x \frac{d^2w}{dx^2} + (b - x) \frac{dw}{dx} - aw = 0</p>
<p>which satisfies the property</p>
<p>.. math::</p>
<p>U(a, b, x) \sim x^{-a}</p>
<p>as :math:<code>x \to \infty</code>. See [dlmf]_ for more details.</p>
<h2 id="parameters_337">Parameters<a class="headerlink" href="#parameters_337" title="Permanent link">&para;</a></h2>
<p>a, b : array_like
Real valued parameters
x : array_like
Real valued argument
out : ndarray
Optional output array for the function values</p>
<h2 id="returns_355">Returns<a class="headerlink" href="#returns_355" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of <code>U</code></p>
<h2 id="references_263">References<a class="headerlink" href="#references_263" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematics Functions
https://dlmf.nist.gov/13.2#E6</p>
<h2 id="examples_128">Examples<a class="headerlink" href="#examples_128" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It has a branch cut along the negative <code>x</code> axis.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-0.1, -10, 5)
sc.hyperu(1, 1, x)
array([nan, nan, nan, nan, nan])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It approaches zero as <code>x</code> goes to infinity.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 10, 100])
sc.hyperu(1, 1, x)
array([0.59634736, 0.09156333, 0.00990194])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It satisfies Kummer's transformation.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a, b, x = 2, 1, 1
sc.hyperu(a, b, x)
0.1926947246463881
x**(1 - b) * sc.hyperu(a - b + 1, 2 - b, x)
0.1926947246463881</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">i0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>i0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>i0(x)</p>
<p>Modified Bessel function of order 0.</p>
<p>Defined as,</p>
<p>.. math::
I_0(x) = \sum_{k=0}^\infty \frac{(x^2/4)^k}{(k!)^2} = J_0(\imath x),</p>
<p>where :math:<code>J_0</code> is the Bessel function of the first kind of order 0.</p>
<h2 id="parameters_338">Parameters<a class="headerlink" href="#parameters_338" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_356">Returns<a class="headerlink" href="#returns_356" title="Permanent link">&para;</a></h2>
<p>I : ndarray
Value of the modified Bessel function of order 0 at <code>x</code>.</p>
<h2 id="notes_208">Notes<a class="headerlink" href="#notes_208" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 8] and (8, infinity).
Chebyshev polynomial expansions are employed in each interval.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>i0</code>.</p>
<h2 id="see-also_256">See also<a class="headerlink" href="#see-also_256" title="Permanent link">&para;</a></h2>
<p>iv
i0e</p>
<h2 id="references_264">References<a class="headerlink" href="#references_264" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">i0e</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>i0e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>i0e(x)</p>
<p>Exponentially scaled modified Bessel function of order 0.</p>
<p>Defined as::</p>
<p>i0e(x) = exp(-abs(x)) * i0(x).</p>
<h2 id="parameters_339">Parameters<a class="headerlink" href="#parameters_339" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_357">Returns<a class="headerlink" href="#returns_357" title="Permanent link">&para;</a></h2>
<p>I : ndarray
Value of the exponentially scaled modified Bessel function of order 0
at <code>x</code>.</p>
<h2 id="notes_209">Notes<a class="headerlink" href="#notes_209" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 8] and (8, infinity).
Chebyshev polynomial expansions are employed in each interval.  The
polynomial expansions used are the same as those in <code>i0</code>, but
they are not multiplied by the dominant exponential factor.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>i0e</code>.</p>
<h2 id="see-also_257">See also<a class="headerlink" href="#see-also_257" title="Permanent link">&para;</a></h2>
<p>iv
i0</p>
<h2 id="references_265">References<a class="headerlink" href="#references_265" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">i1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>i1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>i1(x)</p>
<p>Modified Bessel function of order 1.</p>
<p>Defined as,</p>
<p>.. math::
I_1(x) = \frac{1}{2}x \sum_{k=0}^\infty \frac{(x^2/4)^k}{k! (k + 1)!}
= -\imath J_1(\imath x),</p>
<p>where :math:<code>J_1</code> is the Bessel function of the first kind of order 1.</p>
<h2 id="parameters_340">Parameters<a class="headerlink" href="#parameters_340" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_358">Returns<a class="headerlink" href="#returns_358" title="Permanent link">&para;</a></h2>
<p>I : ndarray
Value of the modified Bessel function of order 1 at <code>x</code>.</p>
<h2 id="notes_210">Notes<a class="headerlink" href="#notes_210" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 8] and (8, infinity).
Chebyshev polynomial expansions are employed in each interval.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>i1</code>.</p>
<h2 id="see-also_258">See also<a class="headerlink" href="#see-also_258" title="Permanent link">&para;</a></h2>
<p>iv
i1e</p>
<h2 id="references_266">References<a class="headerlink" href="#references_266" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">i1e</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>i1e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>i1e(x)</p>
<p>Exponentially scaled modified Bessel function of order 1.</p>
<p>Defined as::</p>
<p>i1e(x) = exp(-abs(x)) * i1(x)</p>
<h2 id="parameters_341">Parameters<a class="headerlink" href="#parameters_341" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_359">Returns<a class="headerlink" href="#returns_359" title="Permanent link">&para;</a></h2>
<p>I : ndarray
Value of the exponentially scaled modified Bessel function of order 1
at <code>x</code>.</p>
<h2 id="notes_211">Notes<a class="headerlink" href="#notes_211" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 8] and (8, infinity).
Chebyshev polynomial expansions are employed in each interval. The
polynomial expansions used are the same as those in <code>i1</code>, but
they are not multiplied by the dominant exponential factor.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>i1e</code>.</p>
<h2 id="see-also_259">See also<a class="headerlink" href="#see-also_259" title="Permanent link">&para;</a></h2>
<p>iv
i1</p>
<h2 id="references_267">References<a class="headerlink" href="#references_267" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv_boxcox</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>inv_boxcox(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>inv_boxcox(y, lmbda)</p>
<p>Compute the inverse of the Box-Cox transformation.</p>
<p>Find <code>x</code> such that::</p>
<p>y = (x**lmbda - 1) / lmbda  if lmbda != 0
log(x)                  if lmbda == 0</p>
<h2 id="parameters_342">Parameters<a class="headerlink" href="#parameters_342" title="Permanent link">&para;</a></h2>
<p>y : array_like
Data to be transformed.
lmbda : array_like
Power parameter of the Box-Cox transform.</p>
<h2 id="returns_360">Returns<a class="headerlink" href="#returns_360" title="Permanent link">&para;</a></h2>
<p>x : array
Transformed data.</p>
<h2 id="notes_212">Notes<a class="headerlink" href="#notes_212" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.16.0</p>
<h2 id="examples_129">Examples<a class="headerlink" href="#examples_129" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import boxcox, inv_boxcox
y = boxcox([1, 4, 10], 2.5)
inv_boxcox(y, 2.5)
array([1., 4., 10.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv_boxcox1p</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>inv_boxcox1p(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>inv_boxcox1p(y, lmbda)</p>
<p>Compute the inverse of the Box-Cox transformation.</p>
<p>Find <code>x</code> such that::</p>
<p>y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0
log(1+x)                    if lmbda == 0</p>
<h2 id="parameters_343">Parameters<a class="headerlink" href="#parameters_343" title="Permanent link">&para;</a></h2>
<p>y : array_like
Data to be transformed.
lmbda : array_like
Power parameter of the Box-Cox transform.</p>
<h2 id="returns_361">Returns<a class="headerlink" href="#returns_361" title="Permanent link">&para;</a></h2>
<p>x : array
Transformed data.</p>
<h2 id="notes_213">Notes<a class="headerlink" href="#notes_213" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.16.0</p>
<h2 id="examples_130">Examples<a class="headerlink" href="#examples_130" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import boxcox1p, inv_boxcox1p
y = boxcox1p([1, 4, 10], 2.5)
inv_boxcox1p(y, 2.5)
array([1., 4., 10.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">it2i0k0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>it2i0k0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>it2i0k0(x)</p>
<p>Integrals related to modified Bessel functions of order 0</p>
<h2 id="returns_362">Returns<a class="headerlink" href="#returns_362" title="Permanent link">&para;</a></h2>
<p>ii0
<code>integral((i0(t)-1)/t, t=0..x)</code>
ik0
<code>integral(k0(t)/t, t=x..inf)</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">it2j0y0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>it2j0y0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>it2j0y0(x)</p>
<p>Integrals related to Bessel functions of order 0</p>
<h2 id="returns_363">Returns<a class="headerlink" href="#returns_363" title="Permanent link">&para;</a></h2>
<p>ij0
<code>integral((1-j0(t))/t, t=0..x)</code>
iy0
<code>integral(y0(t)/t, t=x..inf)</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">it2struve0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>it2struve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>it2struve0(x)</p>
<p>Integral related to the Struve function of order 0.</p>
<p>Returns the integral,</p>
<p>.. math::
\int_x^\infty \frac{H_0(t)}{t}\,dt</p>
<p>where :math:<code>H_0</code> is the Struve function of order 0.</p>
<h2 id="parameters_344">Parameters<a class="headerlink" href="#parameters_344" title="Permanent link">&para;</a></h2>
<p>x : array_like
Lower limit of integration.</p>
<h2 id="returns_364">Returns<a class="headerlink" href="#returns_364" title="Permanent link">&para;</a></h2>
<p>I : ndarray
The value of the integral.</p>
<h2 id="see-also_260">See also<a class="headerlink" href="#see-also_260" title="Permanent link">&para;</a></h2>
<p>struve</p>
<h2 id="notes_214">Notes<a class="headerlink" href="#notes_214" title="Permanent link">&para;</a></h2>
<p>Wrapper for a Fortran routine created by Shanjie Zhang and Jianming
Jin [1]_.</p>
<h2 id="references_268">References<a class="headerlink" href="#references_268" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itairy</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>itairy(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>itairy(x)</p>
<p>Integrals of Airy functions</p>
<p>Calculates the integrals of Airy functions from 0 to <code>x</code>.</p>
<h2 id="parameters_345">Parameters<a class="headerlink" href="#parameters_345" title="Permanent link">&para;</a></h2>
<p>x: array_like
Upper limit of integration (float).</p>
<h2 id="returns_365">Returns<a class="headerlink" href="#returns_365" title="Permanent link">&para;</a></h2>
<p>Apt
Integral of Ai(t) from 0 to x.
Bpt
Integral of Bi(t) from 0 to x.
Ant
Integral of Ai(-t) from 0 to x.
Bnt
Integral of Bi(-t) from 0 to x.</p>
<h2 id="notes_215">Notes<a class="headerlink" href="#notes_215" title="Permanent link">&para;</a></h2>
<p>Wrapper for a Fortran routine created by Shanjie Zhang and Jianming
Jin [1]_.</p>
<h2 id="references_269">References<a class="headerlink" href="#references_269" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iti0k0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>iti0k0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>iti0k0(x)</p>
<p>Integrals of modified Bessel functions of order 0</p>
<p>Returns simple integrals from 0 to <code>x</code> of the zeroth order modified
Bessel functions <code>i0</code> and <code>k0</code>.</p>
<h2 id="returns_366">Returns<a class="headerlink" href="#returns_366" title="Permanent link">&para;</a></h2>
<p>ii0, ik0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itj0y0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>itj0y0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>itj0y0(x)</p>
<p>Integrals of Bessel functions of order 0</p>
<p>Returns simple integrals from 0 to <code>x</code> of the zeroth order Bessel
functions <code>j0</code> and <code>y0</code>.</p>
<h2 id="returns_367">Returns<a class="headerlink" href="#returns_367" title="Permanent link">&para;</a></h2>
<p>ij0, iy0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itmodstruve0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>itmodstruve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>itmodstruve0(x)</p>
<p>Integral of the modified Struve function of order 0.</p>
<p>.. math::
I = \int_0^x L_0(t)\,dt</p>
<h2 id="parameters_346">Parameters<a class="headerlink" href="#parameters_346" title="Permanent link">&para;</a></h2>
<p>x : array_like
Upper limit of integration (float).</p>
<h2 id="returns_368">Returns<a class="headerlink" href="#returns_368" title="Permanent link">&para;</a></h2>
<p>I : ndarray
The integral of :math:<code>L_0</code> from 0 to <code>x</code>.</p>
<h2 id="notes_216">Notes<a class="headerlink" href="#notes_216" title="Permanent link">&para;</a></h2>
<p>Wrapper for a Fortran routine created by Shanjie Zhang and Jianming
Jin [1]_.</p>
<h2 id="references_270">References<a class="headerlink" href="#references_270" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itstruve0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>itstruve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>itstruve0(x)</p>
<p>Integral of the Struve function of order 0.</p>
<p>.. math::
I = \int_0^x H_0(t)\,dt</p>
<h2 id="parameters_347">Parameters<a class="headerlink" href="#parameters_347" title="Permanent link">&para;</a></h2>
<p>x : array_like
Upper limit of integration (float).</p>
<h2 id="returns_369">Returns<a class="headerlink" href="#returns_369" title="Permanent link">&para;</a></h2>
<p>I : ndarray
The integral of :math:<code>H_0</code> from 0 to <code>x</code>.</p>
<h2 id="see-also_261">See also<a class="headerlink" href="#see-also_261" title="Permanent link">&para;</a></h2>
<p>struve</p>
<h2 id="notes_217">Notes<a class="headerlink" href="#notes_217" title="Permanent link">&para;</a></h2>
<p>Wrapper for a Fortran routine created by Shanjie Zhang and Jianming
Jin [1]_.</p>
<h2 id="references_271">References<a class="headerlink" href="#references_271" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>iv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>iv(v, z)</p>
<p>Modified Bessel function of the first kind of real order.</p>
<h2 id="parameters_348">Parameters<a class="headerlink" href="#parameters_348" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order. If <code>z</code> is of real type and negative, <code>v</code> must be integer
valued.
z : array_like of float or complex
Argument.</p>
<h2 id="returns_370">Returns<a class="headerlink" href="#returns_370" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Values of the modified Bessel function.</p>
<h2 id="notes_218">Notes<a class="headerlink" href="#notes_218" title="Permanent link">&para;</a></h2>
<p>For real <code>z</code> and :math:<code>v \in [-50, 50]</code>, the evaluation is carried out
using Temme's method [1]_.  For larger orders, uniform asymptotic
expansions are applied.</p>
<p>For complex <code>z</code> and positive <code>v</code>, the AMOS [2]_ <code>zbesi</code> routine is
called. It uses a power series for small <code>z</code>, the asymptotic expansion
for large <code>abs(z)</code>, the Miller algorithm normalized by the Wronskian
and a Neumann series for intermediate magnitudes, and the uniform
asymptotic expansions for :math:<code>I_v(z)</code> and :math:<code>J_v(z)</code> for large
orders.  Backward recurrence is used to generate sequences or reduce
orders when necessary.</p>
<p>The calculations above are done in the right half plane and continued
into the left half plane by the formula,</p>
<p>.. math:: I_v(z \exp(\pm\imath\pi)) = \exp(\pm\pi v) I_v(z)</p>
<p>(valid when the real part of <code>z</code> is positive).  For negative <code>v</code>, the
formula</p>
<p>.. math:: I_{-v}(z) = I_v(z) + \frac{2}{\pi} \sin(\pi v) K_v(z)</p>
<p>is used, where :math:<code>K_v(z)</code> is the modified Bessel function of the
second kind, evaluated using the AMOS routine <code>zbesk</code>.</p>
<h2 id="see-also_262">See also<a class="headerlink" href="#see-also_262" title="Permanent link">&para;</a></h2>
<p>kve : This function with leading exponential behavior stripped off.</p>
<h2 id="references_272">References<a class="headerlink" href="#references_272" title="Permanent link">&para;</a></h2>
<p>.. [1] Temme, Journal of Computational Physics, vol 21, 343 (1976)
.. [2] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ive</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ive(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ive(v, z)</p>
<p>Exponentially scaled modified Bessel function of the first kind</p>
<p>Defined as::</p>
<p>ive(v, z) = iv(v, z) * exp(-abs(z.real))</p>
<h2 id="parameters_349">Parameters<a class="headerlink" href="#parameters_349" title="Permanent link">&para;</a></h2>
<p>v : array_like of float
Order.
z : array_like of float or complex
Argument.</p>
<h2 id="returns_371">Returns<a class="headerlink" href="#returns_371" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Values of the exponentially scaled modified Bessel function.</p>
<h2 id="notes_219">Notes<a class="headerlink" href="#notes_219" title="Permanent link">&para;</a></h2>
<p>For positive <code>v</code>, the AMOS [1]_ <code>zbesi</code> routine is called. It uses a
power series for small <code>z</code>, the asymptotic expansion for large
<code>abs(z)</code>, the Miller algorithm normalized by the Wronskian and a
Neumann series for intermediate magnitudes, and the uniform asymptotic
expansions for :math:<code>I_v(z)</code> and :math:<code>J_v(z)</code> for large orders.
Backward recurrence is used to generate sequences or reduce orders when
necessary.</p>
<p>The calculations above are done in the right half plane and continued
into the left half plane by the formula,</p>
<p>.. math:: I_v(z \exp(\pm\imath\pi)) = \exp(\pm\pi v) I_v(z)</p>
<p>(valid when the real part of <code>z</code> is positive).  For negative <code>v</code>, the
formula</p>
<p>.. math:: I_{-v}(z) = I_v(z) + \frac{2}{\pi} \sin(\pi v) K_v(z)</p>
<p>is used, where :math:<code>K_v(z)</code> is the modified Bessel function of the
second kind, evaluated using the AMOS routine <code>zbesk</code>.</p>
<h2 id="references_273">References<a class="headerlink" href="#references_273" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ivp</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nth derivative of modified Bessel function Iv(z) with respect
to <code>z</code>.</p>
<h2 id="parameters_350">Parameters<a class="headerlink" href="#parameters_350" title="Permanent link">&para;</a></h2>
<p>v : array_like of float
Order of Bessel function
z : array_like of complex
Argument at which to evaluate the derivative
n : int, default 1
Order of derivative</p>
<h2 id="notes_220">Notes<a class="headerlink" href="#notes_220" title="Permanent link">&para;</a></h2>
<p>The derivative is computed using the relation DLFM 10.29.5 [2]_.</p>
<h2 id="references_274">References<a class="headerlink" href="#references_274" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 6.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html
.. [2] NIST Digital Library of Mathematical Functions.
https://dlmf.nist.gov/10.29.E5</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">j0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>j0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>j0(x)</p>
<p>Bessel function of the first kind of order 0.</p>
<h2 id="parameters_351">Parameters<a class="headerlink" href="#parameters_351" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float).</p>
<h2 id="returns_372">Returns<a class="headerlink" href="#returns_372" title="Permanent link">&para;</a></h2>
<p>J : ndarray
Value of the Bessel function of the first kind of order 0 at <code>x</code>.</p>
<h2 id="notes_221">Notes<a class="headerlink" href="#notes_221" title="Permanent link">&para;</a></h2>
<p>The domain is divided into the intervals [0, 5] and (5, infinity). In the
first interval the following rational approximation is used:</p>
<p>.. math::</p>
<p>J_0(x) \approx (w - r_1^2)(w - r_2^2) \frac{P_3(w)}{Q_8(w)},</p>
<p>where :math:<code>w = x^2</code> and :math:<code>r_1</code>, :math:<code>r_2</code> are the zeros of
:math:<code>J_0</code>, and :math:<code>P_3</code> and :math:<code>Q_8</code> are polynomials of degrees 3
and 8, respectively.</p>
<p>In the second interval, the Hankel asymptotic expansion is employed with
two rational functions of degree 6/6 and 7/7.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>j0</code>.
It should not be confused with the spherical Bessel functions (see
<code>spherical_jn</code>).</p>
<h2 id="see-also_263">See also<a class="headerlink" href="#see-also_263" title="Permanent link">&para;</a></h2>
<p>jv : Bessel function of real order and complex argument.
spherical_jn : spherical Bessel functions.</p>
<h2 id="references_275">References<a class="headerlink" href="#references_275" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">j1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>j1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>j1(x)</p>
<p>Bessel function of the first kind of order 1.</p>
<h2 id="parameters_352">Parameters<a class="headerlink" href="#parameters_352" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float).</p>
<h2 id="returns_373">Returns<a class="headerlink" href="#returns_373" title="Permanent link">&para;</a></h2>
<p>J : ndarray
Value of the Bessel function of the first kind of order 1 at <code>x</code>.</p>
<h2 id="notes_222">Notes<a class="headerlink" href="#notes_222" title="Permanent link">&para;</a></h2>
<p>The domain is divided into the intervals [0, 8] and (8, infinity). In the
first interval a 24 term Chebyshev expansion is used. In the second, the
asymptotic trigonometric representation is employed using two rational
functions of degree 5/5.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>j1</code>.
It should not be confused with the spherical Bessel functions (see
<code>spherical_jn</code>).</p>
<h2 id="see-also_264">See also<a class="headerlink" href="#see-also_264" title="Permanent link">&para;</a></h2>
<p>jv
spherical_jn : spherical Bessel functions.</p>
<h2 id="references_276">References<a class="headerlink" href="#references_276" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">j_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">beta</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Jacobi quadrature.</p>
<p>Compute the sample points and weights for Gauss-Jacobi
quadrature. The sample points are the roots of the n-th degree
Jacobi polynomial, :math:<code>P^{\alpha, \beta}_n(x)</code>. These sample
points and weights correctly integrate polynomials of degree
:math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code> with
weight function :math:<code>w(x) = (1 - x)^{\alpha} (1 +
x)^{\beta}</code>. See 22.2.1 in [AS]_ for details.</p>
<h2 id="parameters_353">Parameters<a class="headerlink" href="#parameters_353" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
alpha : float
alpha must be &gt; -1
beta : float
beta must be &gt; -1
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_374">Returns<a class="headerlink" href="#returns_374" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_265">See Also<a class="headerlink" href="#see-also_265" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_277">References<a class="headerlink" href="#references_277" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">beta</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Jacobi polynomial.</p>
<p>Defined to be the solution of</p>
<p>.. math::
(1 - x^2)\frac{d^2}{dx^2}P_n^{(\alpha, \beta)}
+ (\beta - \alpha - (\alpha + \beta + 2)x)
\frac{d}{dx}P_n^{(\alpha, \beta)}
+ n(n + \alpha + \beta + 1)P_n^{(\alpha, \beta)} = 0</p>
<p>for :math:<code>\alpha, \beta &gt; -1</code>; :math:<code>P_n^{(\alpha, \beta)}</code> is a
polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_354">Parameters<a class="headerlink" href="#parameters_354" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
alpha : float
Parameter, must be greater than -1.
beta : float
Parameter, must be greater than -1.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_375">Returns<a class="headerlink" href="#returns_375" title="Permanent link">&para;</a></h2>
<p>P : orthopoly1d
Jacobi polynomial.</p>
<h2 id="notes_223">Notes<a class="headerlink" href="#notes_223" title="Permanent link">&para;</a></h2>
<p>For fixed :math:<code>\alpha, \beta</code>, the polynomials
:math:<code>P_n^{(\alpha, \beta)}</code> are orthogonal over :math:<code>[-1, 1]</code>
with weight function :math:<code>(1 - x)^\alpha(1 + x)^\beta</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>jv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>jv(v, z)</p>
<p>Bessel function of the first kind of real order and complex argument.</p>
<h2 id="parameters_355">Parameters<a class="headerlink" href="#parameters_355" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_376">Returns<a class="headerlink" href="#returns_376" title="Permanent link">&para;</a></h2>
<p>J : ndarray
Value of the Bessel function, :math:<code>J_v(z)</code>.</p>
<h2 id="notes_224">Notes<a class="headerlink" href="#notes_224" title="Permanent link">&para;</a></h2>
<p>For positive <code>v</code> values, the computation is carried out using the AMOS
[1]_ <code>zbesj</code> routine, which exploits the connection to the modified
Bessel function :math:<code>I_v</code>,</p>
<p>.. math::
J_v(z) = \exp(v\pi\imath/2) I_v(-\imath z)\qquad (\Im z &gt; 0)</p>
<p>J_v(z) = \exp(-v\pi\imath/2) I_v(\imath z)\qquad (\Im z &lt; 0)</p>
<p>For negative <code>v</code> values the formula,</p>
<p>.. math:: J_{-v}(z) = J_v(z) \cos(\pi v) - Y_v(z) \sin(\pi v)</p>
<p>is used, where :math:<code>Y_v(z)</code> is the Bessel function of the second
kind, computed using the AMOS routine <code>zbesy</code>.  Note that the second
term is exactly zero for integer <code>v</code>; to improve accuracy the second
term is explicitly omitted for <code>v</code> values such that <code>v = floor(v)</code>.</p>
<p>Not to be confused with the spherical Bessel functions (see <code>spherical_jn</code>).</p>
<h2 id="see-also_266">See also<a class="headerlink" href="#see-also_266" title="Permanent link">&para;</a></h2>
<p>jve : :math:<code>J_v</code> with leading exponential behavior stripped off.
spherical_jn : spherical Bessel functions.</p>
<h2 id="references_278">References<a class="headerlink" href="#references_278" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jn_zeros</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">nt</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute zeros of integer-order Bessel function Jn(x).</p>
<h2 id="parameters_356">Parameters<a class="headerlink" href="#parameters_356" title="Permanent link">&para;</a></h2>
<p>n : int
Order of Bessel function
nt : int
Number of zeros to return</p>
<h2 id="references_279">References<a class="headerlink" href="#references_279" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 5.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jnjnp_zeros</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute zeros of integer-order Bessel functions Jn and Jn'.</p>
<p>Results are arranged in order of the magnitudes of the zeros.</p>
<h2 id="parameters_357">Parameters<a class="headerlink" href="#parameters_357" title="Permanent link">&para;</a></h2>
<p>nt : int
Number (&lt;=1200) of zeros to compute</p>
<h2 id="returns_377">Returns<a class="headerlink" href="#returns_377" title="Permanent link">&para;</a></h2>
<p>zo[l-1] : ndarray
Value of the lth zero of Jn(x) and Jn'(x). Of length <code>nt</code>.
n[l-1] : ndarray
Order of the Jn(x) or Jn'(x) associated with lth zero. Of length <code>nt</code>.
m[l-1] : ndarray
Serial number of the zeros of Jn(x) or Jn'(x) associated
with lth zero. Of length <code>nt</code>.
t[l-1] : ndarray
0 if lth zero in zo is zero of Jn(x), 1 if it is a zero of Jn'(x). Of
length <code>nt</code>.</p>
<h2 id="see-also_267">See Also<a class="headerlink" href="#see-also_267" title="Permanent link">&para;</a></h2>
<p>jn_zeros, jnp_zeros : to get separated arrays of zeros.</p>
<h2 id="references_280">References<a class="headerlink" href="#references_280" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 5.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jnp_zeros</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">nt</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute zeros of integer-order Bessel function derivative Jn'(x).</p>
<h2 id="parameters_358">Parameters<a class="headerlink" href="#parameters_358" title="Permanent link">&para;</a></h2>
<p>n : int
Order of Bessel function
nt : int
Number of zeros to return</p>
<h2 id="references_281">References<a class="headerlink" href="#references_281" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 5.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jnyn_zeros</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">nt</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nt zeros of Bessel functions Jn(x), Jn'(x), Yn(x), and Yn'(x).</p>
<p>Returns 4 arrays of length <code>nt</code>, corresponding to the first <code>nt</code> zeros of
Jn(x), Jn'(x), Yn(x), and Yn'(x), respectively.</p>
<h2 id="parameters_359">Parameters<a class="headerlink" href="#parameters_359" title="Permanent link">&para;</a></h2>
<p>n : int
Order of the Bessel functions
nt : int
Number (&lt;=1200) of zeros to compute</p>
<p>See jn_zeros, jnp_zeros, yn_zeros, ynp_zeros to get separate arrays.</p>
<h2 id="references_282">References<a class="headerlink" href="#references_282" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 5.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">js_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">p1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">q1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Jacobi (shifted) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Jacobi (shifted)
quadrature. The sample points are the roots of the n-th degree
shifted Jacobi polynomial, :math:<code>G^{p,q}_n(x)</code>. These sample
points and weights correctly integrate polynomials of degree
:math:<code>2n - 1</code> or less over the interval :math:<code>[0, 1]</code> with
weight function :math:<code>w(x) = (1 - x)^{p-q} x^{q-1}</code>. See 22.2.2
in [AS]_ for details.</p>
<h2 id="parameters_360">Parameters<a class="headerlink" href="#parameters_360" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
p1 : float
(p1 - q1) must be &gt; -1
q1 : float
q1 must be &gt; 0
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_378">Returns<a class="headerlink" href="#returns_378" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_268">See Also<a class="headerlink" href="#see-also_268" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_283">References<a class="headerlink" href="#references_283" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>jv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>jv(v, z)</p>
<p>Bessel function of the first kind of real order and complex argument.</p>
<h2 id="parameters_361">Parameters<a class="headerlink" href="#parameters_361" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_379">Returns<a class="headerlink" href="#returns_379" title="Permanent link">&para;</a></h2>
<p>J : ndarray
Value of the Bessel function, :math:<code>J_v(z)</code>.</p>
<h2 id="notes_225">Notes<a class="headerlink" href="#notes_225" title="Permanent link">&para;</a></h2>
<p>For positive <code>v</code> values, the computation is carried out using the AMOS
[1]_ <code>zbesj</code> routine, which exploits the connection to the modified
Bessel function :math:<code>I_v</code>,</p>
<p>.. math::
J_v(z) = \exp(v\pi\imath/2) I_v(-\imath z)\qquad (\Im z &gt; 0)</p>
<p>J_v(z) = \exp(-v\pi\imath/2) I_v(\imath z)\qquad (\Im z &lt; 0)</p>
<p>For negative <code>v</code> values the formula,</p>
<p>.. math:: J_{-v}(z) = J_v(z) \cos(\pi v) - Y_v(z) \sin(\pi v)</p>
<p>is used, where :math:<code>Y_v(z)</code> is the Bessel function of the second
kind, computed using the AMOS routine <code>zbesy</code>.  Note that the second
term is exactly zero for integer <code>v</code>; to improve accuracy the second
term is explicitly omitted for <code>v</code> values such that <code>v = floor(v)</code>.</p>
<p>Not to be confused with the spherical Bessel functions (see <code>spherical_jn</code>).</p>
<h2 id="see-also_269">See also<a class="headerlink" href="#see-also_269" title="Permanent link">&para;</a></h2>
<p>jve : :math:<code>J_v</code> with leading exponential behavior stripped off.
spherical_jn : spherical Bessel functions.</p>
<h2 id="references_284">References<a class="headerlink" href="#references_284" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jve</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>jve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>jve(v, z)</p>
<p>Exponentially scaled Bessel function of order <code>v</code>.</p>
<p>Defined as::</p>
<p>jve(v, z) = jv(v, z) * exp(-abs(z.imag))</p>
<h2 id="parameters_362">Parameters<a class="headerlink" href="#parameters_362" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_380">Returns<a class="headerlink" href="#returns_380" title="Permanent link">&para;</a></h2>
<p>J : ndarray
Value of the exponentially scaled Bessel function.</p>
<h2 id="notes_226">Notes<a class="headerlink" href="#notes_226" title="Permanent link">&para;</a></h2>
<p>For positive <code>v</code> values, the computation is carried out using the AMOS
[1]_ <code>zbesj</code> routine, which exploits the connection to the modified
Bessel function :math:<code>I_v</code>,</p>
<p>.. math::
J_v(z) = \exp(v\pi\imath/2) I_v(-\imath z)\qquad (\Im z &gt; 0)</p>
<p>J_v(z) = \exp(-v\pi\imath/2) I_v(\imath z)\qquad (\Im z &lt; 0)</p>
<p>For negative <code>v</code> values the formula,</p>
<p>.. math:: J_{-v}(z) = J_v(z) \cos(\pi v) - Y_v(z) \sin(\pi v)</p>
<p>is used, where :math:<code>Y_v(z)</code> is the Bessel function of the second
kind, computed using the AMOS routine <code>zbesy</code>.  Note that the second
term is exactly zero for integer <code>v</code>; to improve accuracy the second
term is explicitly omitted for <code>v</code> values such that <code>v = floor(v)</code>.</p>
<h2 id="references_285">References<a class="headerlink" href="#references_285" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jvp</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nth derivative of Bessel function Jv(z) with respect to <code>z</code>.</p>
<h2 id="parameters_363">Parameters<a class="headerlink" href="#parameters_363" title="Permanent link">&para;</a></h2>
<p>v : float
Order of Bessel function
z : complex
Argument at which to evaluate the derivative
n : int, default 1
Order of derivative</p>
<h2 id="notes_227">Notes<a class="headerlink" href="#notes_227" title="Permanent link">&para;</a></h2>
<p>The derivative is computed using the relation DLFM 10.6.7 [2]_.</p>
<h2 id="references_286">References<a class="headerlink" href="#references_286" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 5.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html
.. [2] NIST Digital Library of Mathematical Functions.
https://dlmf.nist.gov/10.6.E7</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">k0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>k0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>k0(x)</p>
<p>Modified Bessel function of the second kind of order 0, :math:<code>K_0</code>.</p>
<p>This function is also sometimes referred to as the modified Bessel
function of the third kind of order 0.</p>
<h2 id="parameters_364">Parameters<a class="headerlink" href="#parameters_364" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float).</p>
<h2 id="returns_381">Returns<a class="headerlink" href="#returns_381" title="Permanent link">&para;</a></h2>
<p>K : ndarray
Value of the modified Bessel function :math:<code>K_0</code> at <code>x</code>.</p>
<h2 id="notes_228">Notes<a class="headerlink" href="#notes_228" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 2] and (2, infinity).
Chebyshev polynomial expansions are employed in each interval.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>k0</code>.</p>
<h2 id="see-also_270">See also<a class="headerlink" href="#see-also_270" title="Permanent link">&para;</a></h2>
<p>kv
k0e</p>
<h2 id="references_287">References<a class="headerlink" href="#references_287" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">k0e</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>k0e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>k0e(x)</p>
<p>Exponentially scaled modified Bessel function K of order 0</p>
<p>Defined as::</p>
<p>k0e(x) = exp(x) * k0(x).</p>
<h2 id="parameters_365">Parameters<a class="headerlink" href="#parameters_365" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_382">Returns<a class="headerlink" href="#returns_382" title="Permanent link">&para;</a></h2>
<p>K : ndarray
Value of the exponentially scaled modified Bessel function K of order
0 at <code>x</code>.</p>
<h2 id="notes_229">Notes<a class="headerlink" href="#notes_229" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 2] and (2, infinity).
Chebyshev polynomial expansions are employed in each interval.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>k0e</code>.</p>
<h2 id="see-also_271">See also<a class="headerlink" href="#see-also_271" title="Permanent link">&para;</a></h2>
<p>kv
k0</p>
<h2 id="references_288">References<a class="headerlink" href="#references_288" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">k1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>k1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>k1(x)</p>
<p>Modified Bessel function of the second kind of order 1, :math:<code>K_1(x)</code>.</p>
<h2 id="parameters_366">Parameters<a class="headerlink" href="#parameters_366" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_383">Returns<a class="headerlink" href="#returns_383" title="Permanent link">&para;</a></h2>
<p>K : ndarray
Value of the modified Bessel function K of order 1 at <code>x</code>.</p>
<h2 id="notes_230">Notes<a class="headerlink" href="#notes_230" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 2] and (2, infinity).
Chebyshev polynomial expansions are employed in each interval.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>k1</code>.</p>
<h2 id="see-also_272">See also<a class="headerlink" href="#see-also_272" title="Permanent link">&para;</a></h2>
<p>kv
k1e</p>
<h2 id="references_289">References<a class="headerlink" href="#references_289" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">k1e</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>k1e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>k1e(x)</p>
<p>Exponentially scaled modified Bessel function K of order 1</p>
<p>Defined as::</p>
<p>k1e(x) = exp(x) * k1(x)</p>
<h2 id="parameters_367">Parameters<a class="headerlink" href="#parameters_367" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float)</p>
<h2 id="returns_384">Returns<a class="headerlink" href="#returns_384" title="Permanent link">&para;</a></h2>
<p>K : ndarray
Value of the exponentially scaled modified Bessel function K of order
1 at <code>x</code>.</p>
<h2 id="notes_231">Notes<a class="headerlink" href="#notes_231" title="Permanent link">&para;</a></h2>
<p>The range is partitioned into the two intervals [0, 2] and (2, infinity).
Chebyshev polynomial expansions are employed in each interval.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>k1e</code>.</p>
<h2 id="see-also_273">See also<a class="headerlink" href="#see-also_273" title="Permanent link">&para;</a></h2>
<p>kv
k1</p>
<h2 id="references_290">References<a class="headerlink" href="#references_290" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kei</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kei(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kei(x)</p>
<p>Kelvin function ker</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kei_zeros</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nt zeros of the Kelvin function kei(x).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">keip</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>keip(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>keip(x)</p>
<p>Derivative of the Kelvin function kei</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">keip_zeros</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nt zeros of the Kelvin function kei'(x).</p>
<h2 id="references_291">References<a class="headerlink" href="#references_291" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kelvin</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kelvin(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kelvin(x)</p>
<p>Kelvin functions as complex numbers</p>
<h2 id="returns_385">Returns<a class="headerlink" href="#returns_385" title="Permanent link">&para;</a></h2>
<p>Be, Ke, Bep, Kep
The tuple (Be, Ke, Bep, Kep) contains complex numbers
representing the real and imaginary Kelvin functions and their
derivatives evaluated at <code>x</code>.  For example, kelvin(x)[0].real =
ber x and kelvin(x)[0].imag = bei x with similar relationships
for ker and kei.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kelvin_zeros</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nt zeros of all Kelvin functions.</p>
<p>Returned in a length-8 tuple of arrays of length nt.  The tuple contains
the arrays of zeros of (ber, bei, ker, kei, ber', bei', ker', kei').</p>
<h2 id="references_292">References<a class="headerlink" href="#references_292" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ker</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ker(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ker(x)</p>
<p>Kelvin function ker</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ker_zeros</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nt zeros of the Kelvin function ker(x).</p>
<h2 id="references_293">References<a class="headerlink" href="#references_293" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kerp</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kerp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kerp(x)</p>
<p>Derivative of the Kelvin function ker</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kerp_zeros</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nt zeros of the Kelvin function ker'(x).</p>
<h2 id="references_294">References<a class="headerlink" href="#references_294" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kl_div</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kl_div(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kl_div(x, y, out=None)</p>
<p>Elementwise function for computing Kullback-Leibler divergence.</p>
<p>.. math::</p>
<p>\mathrm{kl_div}(x, y) =
\begin{cases}
x \log(x / y) - x + y &amp; x &gt; 0, y &gt; 0 \
y &amp; x = 0, y \ge 0 \
\infty &amp; \text{otherwise}
\end{cases}</p>
<h2 id="parameters_368">Parameters<a class="headerlink" href="#parameters_368" title="Permanent link">&para;</a></h2>
<p>x, y : array_like
Real arguments
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_386">Returns<a class="headerlink" href="#returns_386" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the Kullback-Liebler divergence.</p>
<h2 id="see-also_274">See Also<a class="headerlink" href="#see-also_274" title="Permanent link">&para;</a></h2>
<p>entr, rel_entr</p>
<h2 id="notes_232">Notes<a class="headerlink" href="#notes_232" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.15.0</p>
<p>This function is non-negative and is jointly convex in <code>x</code> and <code>y</code>.</p>
<p>The origin of this function is in convex programming; see [1]_ for
details. This is why the the function contains the extra :math:<code>-x
+ y</code> terms over what might be expected from the Kullback-Leibler
divergence. For a version of the function without the extra terms,
see <code>rel_entr</code>.</p>
<h2 id="references_295">References<a class="headerlink" href="#references_295" title="Permanent link">&para;</a></h2>
<p>.. [1] Grant, Boyd, and Ye, 'CVX: Matlab Software for Disciplined Convex
Programming', http://cvxr.com/cvx/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kn(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kn(n, x)</p>
<p>Modified Bessel function of the second kind of integer order <code>n</code></p>
<p>Returns the modified Bessel function of the second kind for integer order
<code>n</code> at real <code>z</code>.</p>
<p>These are also sometimes called functions of the third kind, Basset
functions, or Macdonald functions.</p>
<h2 id="parameters_369">Parameters<a class="headerlink" href="#parameters_369" title="Permanent link">&para;</a></h2>
<p>n : array_like of int
Order of Bessel functions (floats will truncate with a warning)
z : array_like of float
Argument at which to evaluate the Bessel functions</p>
<h2 id="returns_387">Returns<a class="headerlink" href="#returns_387" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The results</p>
<h2 id="notes_233">Notes<a class="headerlink" href="#notes_233" title="Permanent link">&para;</a></h2>
<p>Wrapper for AMOS [1]<em> routine <code>zbesk</code>.  For a discussion of the
algorithm used, see [2]</em> and the references therein.</p>
<h2 id="see-also_275">See Also<a class="headerlink" href="#see-also_275" title="Permanent link">&para;</a></h2>
<p>kv : Same function, but accepts real order and complex argument
kvp : Derivative of this function</p>
<h2 id="references_296">References<a class="headerlink" href="#references_296" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/
.. [2] Donald E. Amos, 'Algorithm 644: A portable package for Bessel
functions of a complex argument and nonnegative order', ACM
TOMS Vol. 12 Issue 3, Sept. 1986, p. 265</p>
<h2 id="examples_131">Examples<a class="headerlink" href="#examples_131" title="Permanent link">&para;</a></h2>
<p>Plot the function of several orders for real input:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import kn
import matplotlib.pyplot as plt
x = np.linspace(0, 5, 1000)
for N in range(6):
...     plt.plot(x, kn(N, x), label='<span><span class="MathJax_Preview">K_{}(x)</span><script type="math/tex">K_{}(x)</script></span>'.format(N))
plt.ylim(0, 10)
plt.legend()
plt.title(r'Modified Bessel function of the second kind <span><span class="MathJax_Preview">K_n(x)</span><script type="math/tex">K_n(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Calculate for a single value at multiple orders:</p>
<blockquote>
<blockquote>
<blockquote>
<p>kn([4, 5, 6], 1)
array([   44.23241585,   360.9605896 ,  3653.83831186])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kolmogi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kolmogi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kolmogi(p)</p>
<p>Inverse Survival Function of Kolmogorov distribution</p>
<p>It is the inverse function to <code>kolmogorov</code>.
Returns y such that <code>kolmogorov(y) == p</code>.</p>
<h2 id="parameters_370">Parameters<a class="headerlink" href="#parameters_370" title="Permanent link">&para;</a></h2>
<p>p : float array_like
Probability</p>
<h2 id="returns_388">Returns<a class="headerlink" href="#returns_388" title="Permanent link">&para;</a></h2>
<p>float
The value(s) of kolmogi(p)</p>
<h2 id="notes_234">Notes<a class="headerlink" href="#notes_234" title="Permanent link">&para;</a></h2>
<p><code>kolmogorov</code> is used by <code>stats.kstest</code> in the application of the
Kolmogorov-Smirnov Goodness of Fit test. For historial reasons this
function is exposed in <code>scpy.special</code>, but the recommended way to achieve
the most accurate CDF/SF/PDF/PPF/ISF computations is to use the
<code>stats.kstwobign</code> distribution.</p>
<h2 id="see-also_276">See Also<a class="headerlink" href="#see-also_276" title="Permanent link">&para;</a></h2>
<p>kolmogorov : The Survival Function for the distribution
scipy.stats.kstwobign : Provides the functionality as a continuous distribution
smirnov, smirnovi : Functions for the one-sided distribution</p>
<h2 id="examples_132">Examples<a class="headerlink" href="#examples_132" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import kolmogi
kolmogi([0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0])
array([        inf,  1.22384787,  1.01918472,  0.82757356,  0.67644769,
0.57117327,  0.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kolmogorov</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kolmogorov(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kolmogorov(y)</p>
<p>Complementary cumulative distribution (Survival Function) function of
Kolmogorov distribution.</p>
<p>Returns the complementary cumulative distribution function of
Kolmogorov's limiting distribution (<code>D_n*\sqrt(n)</code> as n goes to infinity)
of a two-sided test for equality between an empirical and a theoretical
distribution. It is equal to the (limit as n-&gt;infinity of the)
probability that <code>sqrt(n) * max absolute deviation &gt; y</code>.</p>
<h2 id="parameters_371">Parameters<a class="headerlink" href="#parameters_371" title="Permanent link">&para;</a></h2>
<p>y : float array_like
Absolute deviation between the Empirical CDF (ECDF) and the target CDF,
multiplied by sqrt(n).</p>
<h2 id="returns_389">Returns<a class="headerlink" href="#returns_389" title="Permanent link">&para;</a></h2>
<p>float
The value(s) of kolmogorov(y)</p>
<h2 id="notes_235">Notes<a class="headerlink" href="#notes_235" title="Permanent link">&para;</a></h2>
<p><code>kolmogorov</code> is used by <code>stats.kstest</code> in the application of the
Kolmogorov-Smirnov Goodness of Fit test. For historial reasons this
function is exposed in <code>scpy.special</code>, but the recommended way to achieve
the most accurate CDF/SF/PDF/PPF/ISF computations is to use the
<code>stats.kstwobign</code> distribution.</p>
<h2 id="see-also_277">See Also<a class="headerlink" href="#see-also_277" title="Permanent link">&para;</a></h2>
<p>kolmogi : The Inverse Survival Function for the distribution
scipy.stats.kstwobign : Provides the functionality as a continuous distribution
smirnov, smirnovi : Functions for the one-sided distribution</p>
<h2 id="examples_133">Examples<a class="headerlink" href="#examples_133" title="Permanent link">&para;</a></h2>
<p>Show the probability of a gap at least as big as 0, 0.5 and 1.0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import kolmogorov
from scipy.stats import kstwobign
kolmogorov([0, 0.5, 1.0])
array([ 1.        ,  0.96394524,  0.26999967])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare a sample of size 1000 drawn from a Laplace(0, 1) distribution against
the target distribution, a Normal(0, 1) distribution.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.stats import norm, laplace
n = 1000
np.random.seed(seed=233423)
lap01 = laplace(0, 1)
x = np.sort(lap01.rvs(n))
np.mean(x), np.std(x)
(-0.083073685397609842, 1.3676426568399822)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Construct the Empirical CDF and the K-S statistic Dn.</p>
<blockquote>
<blockquote>
<blockquote>
<p>target = norm(0,1)  # Normal mean 0, stddev 1
cdfs = target.cdf(x)
ecdfs = np.arange(n+1, dtype=float)/n
gaps = np.column_stack([cdfs - ecdfs[:n], ecdfs[1:] - cdfs])
Dn = np.max(gaps)
Kn = np.sqrt(n) * Dn
print('Dn=%f, sqrt(n)<em>Dn=%f' % (Dn, Kn))
Dn=0.058286, sqrt(n)</em>Dn=1.843153
print(chr(10).join(['For a sample of size n drawn from a N(0, 1) distribution:',
...   ' the approximate Kolmogorov probability that sqrt(n)<em>Dn&gt;=%f is %f' %  (Kn, kolmogorov(Kn)),
...   ' the approximate Kolmogorov probability that sqrt(n)</em>Dn&lt;=%f is %f' %  (Kn, kstwobign.cdf(Kn))]))
For a sample of size n drawn from a N(0, 1) distribution:
the approximate Kolmogorov probability that sqrt(n)<em>Dn&gt;=1.843153 is 0.002240
the approximate Kolmogorov probability that sqrt(n)</em>Dn&lt;=1.843153 is 0.997760</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the Empirical CDF against the target N(0, 1) CDF.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.step(np.concatenate([[-3], x]), ecdfs, where='post', label='Empirical CDF')
x3 = np.linspace(-3, 3, 100)
plt.plot(x3, target.cdf(x3), label='CDF for N(0, 1)')
plt.ylim([0, 1]); plt.grid(True); plt.legend();</p>
<h1 id="add-vertical-lines-marking-dn-and-dn-_2">Add vertical lines marking Dn+ and Dn-<a class="headerlink" href="#add-vertical-lines-marking-dn-and-dn-_2" title="Permanent link">&para;</a></h1>
<p>iminus, iplus = np.argmax(gaps, axis=0)
plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus], color='r', linestyle='dashed', lw=4)
plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1], color='r', linestyle='dashed', lw=4)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kv(v, z)</p>
<p>Modified Bessel function of the second kind of real order <code>v</code></p>
<p>Returns the modified Bessel function of the second kind for real order
<code>v</code> at complex <code>z</code>.</p>
<p>These are also sometimes called functions of the third kind, Basset
functions, or Macdonald functions.  They are defined as those solutions
of the modified Bessel equation for which,</p>
<p>.. math::
K_v(x) \sim \sqrt{\pi/(2x)} \exp(-x)</p>
<p>as :math:<code>x \to \infty</code> [3]_.</p>
<h2 id="parameters_372">Parameters<a class="headerlink" href="#parameters_372" title="Permanent link">&para;</a></h2>
<p>v : array_like of float
Order of Bessel functions
z : array_like of complex
Argument at which to evaluate the Bessel functions</p>
<h2 id="returns_390">Returns<a class="headerlink" href="#returns_390" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The results. Note that input must be of complex type to get complex
output, e.g. <code>kv(3, -2+0j)</code> instead of <code>kv(3, -2)</code>.</p>
<h2 id="notes_236">Notes<a class="headerlink" href="#notes_236" title="Permanent link">&para;</a></h2>
<p>Wrapper for AMOS [1]<em> routine <code>zbesk</code>.  For a discussion of the
algorithm used, see [2]</em> and the references therein.</p>
<h2 id="see-also_278">See Also<a class="headerlink" href="#see-also_278" title="Permanent link">&para;</a></h2>
<p>kve : This function with leading exponential behavior stripped off.
kvp : Derivative of this function</p>
<h2 id="references_297">References<a class="headerlink" href="#references_297" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/
.. [2] Donald E. Amos, 'Algorithm 644: A portable package for Bessel
functions of a complex argument and nonnegative order', ACM
TOMS Vol. 12 Issue 3, Sept. 1986, p. 265
.. [3] NIST Digital Library of Mathematical Functions,
Eq. 10.25.E3. https://dlmf.nist.gov/10.25.E3</p>
<h2 id="examples_134">Examples<a class="headerlink" href="#examples_134" title="Permanent link">&para;</a></h2>
<p>Plot the function of several orders for real input:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import kv
import matplotlib.pyplot as plt
x = np.linspace(0, 5, 1000)
for N in np.linspace(0, 6, 5):
...     plt.plot(x, kv(N, x), label='<span><span class="MathJax_Preview">K_{{{}}}(x)</span><script type="math/tex">K_{{{}}}(x)</script></span>'.format(N))
plt.ylim(0, 10)
plt.legend()
plt.title(r'Modified Bessel function of the second kind <span><span class="MathJax_Preview">K_\nu(x)</span><script type="math/tex">K_\nu(x)</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Calculate for a single value at multiple orders:</p>
<blockquote>
<blockquote>
<blockquote>
<p>kv([4, 4.5, 5], 1+2j)
array([ 0.1992+2.3892j,  2.3493+3.6j   ,  7.2827+3.8104j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kve</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>kve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>kve(v, z)</p>
<p>Exponentially scaled modified Bessel function of the second kind.</p>
<p>Returns the exponentially scaled, modified Bessel function of the
second kind (sometimes called the third kind) for real order <code>v</code> at
complex <code>z</code>::</p>
<p>kve(v, z) = kv(v, z) * exp(z)</p>
<h2 id="parameters_373">Parameters<a class="headerlink" href="#parameters_373" title="Permanent link">&para;</a></h2>
<p>v : array_like of float
Order of Bessel functions
z : array_like of complex
Argument at which to evaluate the Bessel functions</p>
<h2 id="returns_391">Returns<a class="headerlink" href="#returns_391" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The exponentially scaled modified Bessel function of the second kind.</p>
<h2 id="notes_237">Notes<a class="headerlink" href="#notes_237" title="Permanent link">&para;</a></h2>
<p>Wrapper for AMOS [1]<em> routine <code>zbesk</code>.  For a discussion of the
algorithm used, see [2]</em> and the references therein.</p>
<h2 id="references_298">References<a class="headerlink" href="#references_298" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/
.. [2] Donald E. Amos, 'Algorithm 644: A portable package for Bessel
functions of a complex argument and nonnegative order', ACM
TOMS Vol. 12 Issue 3, Sept. 1986, p. 265</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kvp</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nth derivative of real-order modified Bessel function Kv(z)</p>
<p>Kv(z) is the modified Bessel function of the second kind.
Derivative is calculated with respect to <code>z</code>.</p>
<h2 id="parameters_374">Parameters<a class="headerlink" href="#parameters_374" title="Permanent link">&para;</a></h2>
<p>v : array_like of float
Order of Bessel function
z : array_like of complex
Argument at which to evaluate the derivative
n : int
Order of derivative.  Default is first derivative.</p>
<h2 id="returns_392">Returns<a class="headerlink" href="#returns_392" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The results</p>
<h2 id="examples_135">Examples<a class="headerlink" href="#examples_135" title="Permanent link">&para;</a></h2>
<p>Calculate multiple values at order 5:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import kvp
kvp(5, (1, 2, 3+5j))
array([-1.84903536e+03+0.j        , -2.57735387e+01+0.j        ,
-3.06627741e-02+0.08750845j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Calculate for a single value at multiple orders:</p>
<blockquote>
<blockquote>
<blockquote>
<p>kvp((4, 4.5, 5), 1)
array([ -184.0309,  -568.9585, -1849.0354])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="notes_238">Notes<a class="headerlink" href="#notes_238" title="Permanent link">&para;</a></h2>
<p>The derivative is computed using the relation DLFM 10.29.5 [2]_.</p>
<h2 id="references_299">References<a class="headerlink" href="#references_299" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 6.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html
.. [2] NIST Digital Library of Mathematical Functions.
https://dlmf.nist.gov/10.29.E5</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">l_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Laguerre quadrature.</p>
<p>Compute the sample points and weights for Gauss-Laguerre
quadrature. The sample points are the roots of the n-th degree
Laguerre polynomial, :math:<code>L_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[0, \infty]</code> with weight function
:math:<code>w(x) = e^{-x}</code>. See 22.2.13 in [AS]_ for details.</p>
<h2 id="parameters_375">Parameters<a class="headerlink" href="#parameters_375" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_393">Returns<a class="headerlink" href="#returns_393" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_279">See Also<a class="headerlink" href="#see-also_279" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.laguerre.laggauss</p>
<h2 id="references_300">References<a class="headerlink" href="#references_300" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">la_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-generalized Laguerre quadrature.</p>
<p>Compute the sample points and weights for Gauss-generalized
Laguerre quadrature. The sample points are the roots of the n-th
degree generalized Laguerre polynomial, :math:<code>L^{\alpha}_n(x)</code>.
These sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[0,
\infty]</code> with weight function :math:<code>w(x) = x^{\alpha}
e^{-x}</code>. See 22.3.9 in [AS]_ for details.</p>
<h2 id="parameters_376">Parameters<a class="headerlink" href="#parameters_376" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
alpha : float
alpha must be &gt; -1
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_394">Returns<a class="headerlink" href="#returns_394" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_280">See Also<a class="headerlink" href="#see-also_280" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_301">References<a class="headerlink" href="#references_301" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">laguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Laguerre polynomial.</p>
<p>Defined to be the solution of</p>
<p>.. math::
x\frac{d^2}{dx^2}L_n + (1 - x)\frac{d}{dx}L_n + nL_n = 0;</p>
<p>:math:<code>L_n</code> is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_377">Parameters<a class="headerlink" href="#parameters_377" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_395">Returns<a class="headerlink" href="#returns_395" title="Permanent link">&para;</a></h2>
<p>L : orthopoly1d
Laguerre Polynomial.</p>
<h2 id="notes_239">Notes<a class="headerlink" href="#notes_239" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>L_n</code> are orthogonal over :math:<code>[0,
\infty)</code> with weight function :math:<code>e^{-x}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lambertw</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>lambertw(z, k=0, tol=1e-8)</p>
<p>Lambert W function.</p>
<p>The Lambert W function <code>W(z)</code> is defined as the inverse function
of <code>w * exp(w)</code>. In other words, the value of <code>W(z)</code> is
such that <code>z = W(z) * exp(W(z))</code> for any complex number
<code>z</code>.</p>
<p>The Lambert W function is a multivalued function with infinitely
many branches. Each branch gives a separate solution of the
equation <code>z = w exp(w)</code>. Here, the branches are indexed by the
integer <code>k</code>.</p>
<h2 id="parameters_378">Parameters<a class="headerlink" href="#parameters_378" title="Permanent link">&para;</a></h2>
<p>z : array_like
Input argument.
k : int, optional
Branch index.
tol : float, optional
Evaluation tolerance.</p>
<h2 id="returns_396">Returns<a class="headerlink" href="#returns_396" title="Permanent link">&para;</a></h2>
<p>w : array
<code>w</code> will have the same shape as <code>z</code>.</p>
<h2 id="notes_240">Notes<a class="headerlink" href="#notes_240" title="Permanent link">&para;</a></h2>
<p>All branches are supported by <code>lambertw</code>:</p>
<ul>
<li><code>lambertw(z)</code> gives the principal solution (branch 0)</li>
<li><code>lambertw(z, k)</code> gives the solution on branch <code>k</code></li>
</ul>
<p>The Lambert W function has two partially real branches: the
principal branch (<code>k = 0</code>) is real for real <code>z &gt; -1/e</code>, and the
<code>k = -1</code> branch is real for <code>-1/e &lt; z &lt; 0</code>. All branches except
<code>k = 0</code> have a logarithmic singularity at <code>z = 0</code>.</p>
<p><strong>Possible issues</strong></p>
<p>The evaluation can become inaccurate very close to the branch point
at <code>-1/e</code>. In some corner cases, <code>lambertw</code> might currently
fail to converge, or can end up on the wrong branch.</p>
<p><strong>Algorithm</strong></p>
<p>Halley's iteration is used to invert <code>w * exp(w)</code>, using a first-order
asymptotic approximation (O(log(w)) or <code>O(w)</code>) as the initial estimate.</p>
<p>The definition, implementation and choice of branches is based on [2]_.</p>
<h2 id="see-also_281">See Also<a class="headerlink" href="#see-also_281" title="Permanent link">&para;</a></h2>
<p>wrightomega : the Wright Omega function</p>
<h2 id="references_302">References<a class="headerlink" href="#references_302" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Lambert_W_function
.. [2] Corless et al, 'On the Lambert W function', Adv. Comp. Math. 5
(1996) 329-359.
http://www.apmaths.uwo.ca/~djeffrey/Offprints/W-adv-cm.pdf</p>
<h2 id="examples_136">Examples<a class="headerlink" href="#examples_136" title="Permanent link">&para;</a></h2>
<p>The Lambert W function is the inverse of <code>w exp(w)</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import lambertw
w = lambertw(1)
w
(0.56714329040978384+0j)
w * np.exp(w)
(1.0+0j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Any branch gives a valid inverse:</p>
<blockquote>
<blockquote>
<blockquote>
<p>w = lambertw(1, k=3)
w
(-2.8535817554090377+17.113535539412148j)
w*np.exp(w)
(1.0000000000000002+1.609823385706477e-15j)</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Applications to equation-solving</strong></p>
<p>The Lambert W function may be used to solve various kinds of
equations, such as finding the value of the infinite power
tower :math:<code>z^{z^{z^{\ldots}}}</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def tower(z, n):
...     if n == 0:
...         return z
...     return z ** tower(z, n-1)
...
tower(0.5, 100)
0.641185744504986
-lambertw(-np.log(0.5)) / np.log(0.5)
(0.64118574450498589+0j)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Legendre polynomial.</p>
<p>Defined to be the solution of</p>
<p>.. math::
\frac{d}{dx}\left[(1 - x^2)\frac{d}{dx}P_n(x)\right]
+ n(n + 1)P_n(x) = 0;</p>
<p>:math:<code>P_n(x)</code> is a polynomial of degree :math:<code>n</code>.</p>
<h2 id="parameters_379">Parameters<a class="headerlink" href="#parameters_379" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_397">Returns<a class="headerlink" href="#returns_397" title="Permanent link">&para;</a></h2>
<p>P : orthopoly1d
Legendre polynomial.</p>
<h2 id="notes_241">Notes<a class="headerlink" href="#notes_241" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>P_n</code> are orthogonal over :math:<code>[-1, 1]</code>
with weight function 1.</p>
<h2 id="examples_137">Examples<a class="headerlink" href="#examples_137" title="Permanent link">&para;</a></h2>
<p>Generate the 3rd-order Legendre polynomial 1/2*(5x^3 + 0x^2 - 3x + 0):</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import legendre
legendre(3)
poly1d([ 2.5,  0. , -1.5,  0. ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lmbda</span> <span class="o">:</span> <span class="n">v</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Jahnke-Emden Lambda function, Lambdav(x).</p>
<p>This function is defined as [2]_,</p>
<p>.. math:: \Lambda_v(x) = \Gamma(v+1) \frac{J_v(x)}{(x/2)^v},</p>
<p>where :math:<code>\Gamma</code> is the gamma function and :math:<code>J_v</code> is the
Bessel function of the first kind.</p>
<h2 id="parameters_380">Parameters<a class="headerlink" href="#parameters_380" title="Permanent link">&para;</a></h2>
<p>v : float
Order of the Lambda function
x : float
Value at which to evaluate the function and derivatives</p>
<h2 id="returns_398">Returns<a class="headerlink" href="#returns_398" title="Permanent link">&para;</a></h2>
<p>vl : ndarray
Values of Lambda_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.
dl : ndarray
Derivatives Lambda_vi'(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</p>
<h2 id="references_303">References<a class="headerlink" href="#references_303" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html
.. [2] Jahnke, E. and Emde, F. 'Tables of Functions with Formulae and
Curves' (4th ed.), Dover, 1945</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">log1p</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>log1p(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>log1p(x)</p>
<p>Calculates log(1+x) for use when <code>x</code> is near zero</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">log_ndtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>log_ndtr(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>log_ndtr(x)</p>
<p>Logarithm of Gaussian cumulative distribution function.</p>
<p>Returns the log of the area under the standard Gaussian probability
density function, integrated from minus infinity to <code>x</code>::</p>
<p>log(1/sqrt(2<em>pi) * integral(exp(-t</em>*2 / 2), t=-inf..x))</p>
<h2 id="parameters_381">Parameters<a class="headerlink" href="#parameters_381" title="Permanent link">&para;</a></h2>
<p>x : array_like, real or complex
Argument</p>
<h2 id="returns_399">Returns<a class="headerlink" href="#returns_399" title="Permanent link">&para;</a></h2>
<p>ndarray
The value of the log of the normal CDF evaluated at <code>x</code></p>
<h2 id="see-also_282">See Also<a class="headerlink" href="#see-also_282" title="Permanent link">&para;</a></h2>
<p>erf
erfc
scipy.stats.norm
ndtr</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">loggamma</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>loggamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>loggamma(z, out=None)</p>
<p>Principal branch of the logarithm of the Gamma function.</p>
<p>Defined to be :math:<code>\log(\Gamma(x))</code> for :math:<code>x &gt; 0</code> and
extended to the complex plane by analytic continuation. The
function has a single branch cut on the negative real axis.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="parameters_382">Parameters<a class="headerlink" href="#parameters_382" title="Permanent link">&para;</a></h2>
<p>z : array-like
Values in the complex plain at which to compute <code>loggamma</code>
out : ndarray, optional
Output array for computed values of <code>loggamma</code></p>
<h2 id="returns_400">Returns<a class="headerlink" href="#returns_400" title="Permanent link">&para;</a></h2>
<p>loggamma : ndarray
Values of <code>loggamma</code> at z.</p>
<h2 id="notes_242">Notes<a class="headerlink" href="#notes_242" title="Permanent link">&para;</a></h2>
<p>It is not generally true that :math:<code>\log\Gamma(z) =
\log(\Gamma(z))</code>, though the real parts of the functions do
agree. The benefit of not defining <code>loggamma</code> as
:math:<code>\log(\Gamma(z))</code> is that the latter function has a
complicated branch cut structure whereas <code>loggamma</code> is analytic
except for on the negative real axis.</p>
<p>The identities</p>
<p>.. math::
\exp(\log\Gamma(z)) &amp;= \Gamma(z) \
\log\Gamma(z + 1) &amp;= \log(z) + \log\Gamma(z)</p>
<p>make <code>loggamma</code> useful for working in complex logspace.</p>
<p>On the real line <code>loggamma</code> is related to <code>gammaln</code> via
<code>exp(loggamma(x + 0j)) = gammasgn(x)*exp(gammaln(x))</code>, up to
rounding error.</p>
<p>The implementation here is based on [hare1997]_.</p>
<h2 id="see-also_283">See also<a class="headerlink" href="#see-also_283" title="Permanent link">&para;</a></h2>
<p>gammaln : logarithm of the absolute value of the Gamma function
gammasgn : sign of the gamma function</p>
<h2 id="references_304">References<a class="headerlink" href="#references_304" title="Permanent link">&para;</a></h2>
<p>.. [hare1997] D.E.G. Hare,
<em>Computing the Principal Branch of log-Gamma</em>,
Journal of Algorithms, Volume 25, Issue 2, November 1997, pages 221-236.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">logit</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>logit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>logit(x)</p>
<p>Logit ufunc for ndarrays.</p>
<p>The logit function is defined as logit(p) = log(p/(1-p)).
Note that logit(0) = -inf, logit(1) = inf, and logit(p)
for p&lt;0 or p&gt;1 yields nan.</p>
<h2 id="parameters_383">Parameters<a class="headerlink" href="#parameters_383" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The ndarray to apply logit to element-wise.</p>
<h2 id="returns_401">Returns<a class="headerlink" href="#returns_401" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An ndarray of the same shape as x. Its entries
are logit of the corresponding entry of x.</p>
<h2 id="see-also_284">See Also<a class="headerlink" href="#see-also_284" title="Permanent link">&para;</a></h2>
<p>expit</p>
<h2 id="notes_243">Notes<a class="headerlink" href="#notes_243" title="Permanent link">&para;</a></h2>
<p>As a ufunc logit takes a number of optional
keyword arguments. For more information
see <code>ufuncs &lt;https://docs.scipy.org/doc/numpy/reference/ufuncs.html&gt;</code>_</p>
<p>.. versionadded:: 0.10.0</p>
<h2 id="examples_138">Examples<a class="headerlink" href="#examples_138" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import logit, expit</p>
<p>logit([0, 0.25, 0.5, 0.75, 1])
array([       -inf, -1.09861229,  0.        ,  1.09861229,         inf])</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>expit</code> is the inverse of <code>logit</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>expit(logit([0.1, 0.75, 0.999]))
array([ 0.1  ,  0.75 ,  0.999])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot logit(x) for x in [0, 1]:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
x = np.linspace(0, 1, 501)
y = logit(x)
plt.plot(x, y)
plt.grid()
plt.ylim(-6, 6)
plt.xlabel('x')
plt.title('logit(x)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">logsumexp</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_sign</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the log of the sum of exponentials of input elements.</p>
<h2 id="parameters_384">Parameters<a class="headerlink" href="#parameters_384" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array.
axis : None or int or tuple of ints, optional
Axis or axes over which the sum is taken. By default <code>axis</code> is None,
and all elements are summed.</p>
<p>.. versionadded:: 0.11.0
keepdims : bool, optional
If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the original array.</p>
<p>.. versionadded:: 0.15.0
b : array-like, optional
Scaling factor for exp(<code>a</code>) must be of the same shape as <code>a</code> or
broadcastable to <code>a</code>. These values may be negative in order to
implement subtraction.</p>
<p>.. versionadded:: 0.12.0
return_sign : bool, optional
If this is set to True, the result will be a pair containing sign
information; if False, results that are negative will be returned
as NaN. Default is False (no sign information).</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="returns_402">Returns<a class="headerlink" href="#returns_402" title="Permanent link">&para;</a></h2>
<p>res : ndarray
The result, <code>np.log(np.sum(np.exp(a)))</code> calculated in a numerically
more stable way. If <code>b</code> is given then <code>np.log(np.sum(b*np.exp(a)))</code>
is returned.
sgn : ndarray
If return_sign is True, this will be an array of floating-point
numbers matching res and +1, 0, or -1 depending on the sign
of the result. If False, only one result is returned.</p>
<h2 id="see-also_285">See Also<a class="headerlink" href="#see-also_285" title="Permanent link">&para;</a></h2>
<p>numpy.logaddexp, numpy.logaddexp2</p>
<h2 id="notes_244">Notes<a class="headerlink" href="#notes_244" title="Permanent link">&para;</a></h2>
<p>NumPy has a logaddexp function which is very similar to <code>logsumexp</code>, but
only handles two arguments. <code>logaddexp.reduce</code> is similar to this
function, but may be less stable.</p>
<h2 id="examples_139">Examples<a class="headerlink" href="#examples_139" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import logsumexp
a = np.arange(10)
np.log(np.sum(np.exp(a)))
9.4586297444267107
logsumexp(a)
9.4586297444267107</p>
</blockquote>
</blockquote>
</blockquote>
<p>With weights</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.arange(10)
b = np.arange(10, 0, -1)
logsumexp(a, b=b)
9.9170178533034665
np.log(np.sum(b*np.exp(a)))
9.9170178533034647</p>
</blockquote>
</blockquote>
</blockquote>
<p>Returning a sign flag</p>
<blockquote>
<blockquote>
<blockquote>
<p>logsumexp([1,2],b=[1,-1],return_sign=True)
(1.5413248546129181, -1.0)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice that <code>logsumexp</code> does not directly support masked arrays. To use it
on a masked array, convert the mask into zero weights:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.ma.array([np.log(2), 2, np.log(3)],
...                  mask=[False, True, False])
b = (~a.mask).astype(int)
logsumexp(a.data, b=b), np.log(5)
1.6094379124341005, 1.6094379124341005</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lpmn</span> <span class="o">:</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Sequence of associated Legendre functions of the first kind.</p>
<p>Computes the associated Legendre function of the first kind of order m and
degree n, <code>Pmn(z)</code> = :math:<code>P_n^m(z)</code>, and its derivative, <code>Pmn'(z)</code>.
Returns two arrays of size <code>(m+1, n+1)</code> containing <code>Pmn(z)</code> and
<code>Pmn'(z)</code> for all orders from <code>0..m</code> and degrees from <code>0..n</code>.</p>
<p>This function takes a real argument <code>z</code>. For complex arguments <code>z</code>
use clpmn instead.</p>
<h2 id="parameters_385">Parameters<a class="headerlink" href="#parameters_385" title="Permanent link">&para;</a></h2>
<p>m : int
<code>|m| &lt;= n</code>; the order of the Legendre function.
n : int
where <code>n &gt;= 0</code>; the degree of the Legendre function.  Often
called <code>l</code> (lower case L) in descriptions of the associated
Legendre function
z : float
Input value.</p>
<h2 id="returns_403">Returns<a class="headerlink" href="#returns_403" title="Permanent link">&para;</a></h2>
<p>Pmn_z : (m+1, n+1) array
Values for all orders 0..m and degrees 0..n
Pmn_d_z : (m+1, n+1) array
Derivatives for all orders 0..m and degrees 0..n</p>
<h2 id="see-also_286">See Also<a class="headerlink" href="#see-also_286" title="Permanent link">&para;</a></h2>
<p>clpmn: associated Legendre functions of the first kind for complex z</p>
<h2 id="notes_245">Notes<a class="headerlink" href="#notes_245" title="Permanent link">&para;</a></h2>
<p>In the interval (-1, 1), Ferrer's function of the first kind is
returned. The phase convention used for the intervals (1, inf)
and (-inf, -1) is such that the result is always real.</p>
<h2 id="references_305">References<a class="headerlink" href="#references_305" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html
.. [2] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/14.3</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lpmv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>lpmv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>lpmv(m, v, x)</p>
<p>Associated Legendre function of integer order and real degree.</p>
<p>Defined as</p>
<p>.. math::</p>
<p>P_v^m = (-1)^m (1 - x^2)^{m/2} \frac{d^m}{dx^m} P_v(x)</p>
<p>where</p>
<p>.. math::</p>
<p>P_v = \sum_{k = 0}^\infty \frac{(-v)_k (v + 1)_k}{(k!)^2}
\left(\frac{1 - x}{2}\right)^k</p>
<p>is the Legendre function of the first kind. Here :math:<code>(\cdot)_k</code>
is the Pochhammer symbol; see <code>poch</code>.</p>
<h2 id="parameters_386">Parameters<a class="headerlink" href="#parameters_386" title="Permanent link">&para;</a></h2>
<p>m : array_like
Order (int or float). If passed a float not equal to an
integer the function returns NaN.
v : array_like
Degree (float).
x : array_like
Argument (float). Must have <code>|x| &lt;= 1</code>.</p>
<h2 id="returns_404">Returns<a class="headerlink" href="#returns_404" title="Permanent link">&para;</a></h2>
<p>pmv : ndarray
Value of the associated Legendre function.</p>
<h2 id="see-also_287">See Also<a class="headerlink" href="#see-also_287" title="Permanent link">&para;</a></h2>
<p>lpmn : Compute the associated Legendre function for all orders
<code>0, ..., m</code> and degrees <code>0, ..., n</code>.
clpmn : Compute the associated Legendre function at complex
arguments.</p>
<h2 id="notes_246">Notes<a class="headerlink" href="#notes_246" title="Permanent link">&para;</a></h2>
<p>Note that this implementation includes the Condon-Shortley phase.</p>
<h2 id="references_306">References<a class="headerlink" href="#references_306" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Jin, 'Computation of Special Functions', John Wiley
and Sons, Inc, 1996.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lpn</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Legendre function of the first kind.</p>
<p>Compute sequence of Legendre functions of the first kind (polynomials),
Pn(z) and derivatives for all degrees from 0 to n (inclusive).</p>
<p>See also special.legendre for polynomial class.</p>
<h2 id="references_307">References<a class="headerlink" href="#references_307" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lqmn</span> <span class="o">:</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Sequence of associated Legendre functions of the second kind.</p>
<p>Computes the associated Legendre function of the second kind of order m and
degree n, <code>Qmn(z)</code> = :math:<code>Q_n^m(z)</code>, and its derivative, <code>Qmn'(z)</code>.
Returns two arrays of size <code>(m+1, n+1)</code> containing <code>Qmn(z)</code> and
<code>Qmn'(z)</code> for all orders from <code>0..m</code> and degrees from <code>0..n</code>.</p>
<h2 id="parameters_387">Parameters<a class="headerlink" href="#parameters_387" title="Permanent link">&para;</a></h2>
<p>m : int
<code>|m| &lt;= n</code>; the order of the Legendre function.
n : int
where <code>n &gt;= 0</code>; the degree of the Legendre function.  Often
called <code>l</code> (lower case L) in descriptions of the associated
Legendre function
z : complex
Input value.</p>
<h2 id="returns_405">Returns<a class="headerlink" href="#returns_405" title="Permanent link">&para;</a></h2>
<p>Qmn_z : (m+1, n+1) array
Values for all orders 0..m and degrees 0..n
Qmn_d_z : (m+1, n+1) array
Derivatives for all orders 0..m and degrees 0..n</p>
<h2 id="references_308">References<a class="headerlink" href="#references_308" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lqn</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Legendre function of the second kind.</p>
<p>Compute sequence of Legendre functions of the second kind, Qn(z) and
derivatives for all degrees from 0 to n (inclusive).</p>
<h2 id="references_309">References<a class="headerlink" href="#references_309" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_a</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>mathieu_a(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_a(m, q)</p>
<p>Characteristic value of even Mathieu functions</p>
<p>Returns the characteristic value for the even solution,
<code>ce_m(z, q)</code>, of Mathieu's equation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_b</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>mathieu_b(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_b(m, q)</p>
<p>Characteristic value of odd Mathieu functions</p>
<p>Returns the characteristic value for the odd solution,
<code>se_m(z, q)</code>, of Mathieu's equation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_cem</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>mathieu_cem(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_cem(m, q, x)</p>
<p>Even Mathieu function and its derivative</p>
<p>Returns the even Mathieu function, <code>ce_m(x, q)</code>, of order <code>m</code> and
parameter <code>q</code> evaluated at <code>x</code> (given in degrees).  Also returns the
derivative with respect to <code>x</code> of ce_m(x, q)</p>
<h2 id="parameters_388">Parameters<a class="headerlink" href="#parameters_388" title="Permanent link">&para;</a></h2>
<p>m
Order of the function
q
Parameter of the function
x
Argument of the function, <em>given in degrees, not radians</em></p>
<h2 id="returns_406">Returns<a class="headerlink" href="#returns_406" title="Permanent link">&para;</a></h2>
<p>y
Value of the function
yp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_even_coef</span> <span class="o">:</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Fourier coefficients for even Mathieu and modified Mathieu functions.</p>
<p>The Fourier series of the even solutions of the Mathieu differential
equation are of the form</p>
<p>.. math:: \mathrm{ce}<em>{2n}(z, q) = \sum</em>{k=0}^{\infty} A_{(2n)}^{(2k)} \cos 2kz</p>
<p>.. math:: \mathrm{ce}<em>{2n+1}(z, q) = \sum</em>{k=0}^{\infty} A_{(2n+1)}^{(2k+1)} \cos (2k+1)z</p>
<p>This function returns the coefficients :math:<code>A_{(2n)}^{(2k)}</code> for even
input m=2n, and the coefficients :math:<code>A_{(2n+1)}^{(2k+1)}</code> for odd input
m=2n+1.</p>
<h2 id="parameters_389">Parameters<a class="headerlink" href="#parameters_389" title="Permanent link">&para;</a></h2>
<p>m : int
Order of Mathieu functions.  Must be non-negative.
q : float (&gt;=0)
Parameter of Mathieu functions.  Must be non-negative.</p>
<h2 id="returns_407">Returns<a class="headerlink" href="#returns_407" title="Permanent link">&para;</a></h2>
<p>Ak : ndarray
Even or odd Fourier coefficients, corresponding to even or odd m.</p>
<h2 id="references_310">References<a class="headerlink" href="#references_310" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html
.. [2] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/28.4#i</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_modcem1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>mathieu_modcem1(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_modcem1(m, q, x)</p>
<p>Even modified Mathieu function of the first kind and its derivative</p>
<p>Evaluates the even modified Mathieu function of the first kind,
<code>Mc1m(x, q)</code>, and its derivative at <code>x</code> for order <code>m</code> and parameter
<code>q</code>.</p>
<h2 id="returns_408">Returns<a class="headerlink" href="#returns_408" title="Permanent link">&para;</a></h2>
<p>y
Value of the function
yp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_modcem2</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>mathieu_modcem2(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_modcem2(m, q, x)</p>
<p>Even modified Mathieu function of the second kind and its derivative</p>
<p>Evaluates the even modified Mathieu function of the second kind,
Mc2m(x, q), and its derivative at <code>x</code> (given in degrees) for order <code>m</code>
and parameter <code>q</code>.</p>
<h2 id="returns_409">Returns<a class="headerlink" href="#returns_409" title="Permanent link">&para;</a></h2>
<p>y
Value of the function
yp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_modsem1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>mathieu_modsem1(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_modsem1(m, q, x)</p>
<p>Odd modified Mathieu function of the first kind and its derivative</p>
<p>Evaluates the odd modified Mathieu function of the first kind,
Ms1m(x, q), and its derivative at <code>x</code> (given in degrees) for order <code>m</code>
and parameter <code>q</code>.</p>
<h2 id="returns_410">Returns<a class="headerlink" href="#returns_410" title="Permanent link">&para;</a></h2>
<p>y
Value of the function
yp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_modsem2</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>mathieu_modsem2(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_modsem2(m, q, x)</p>
<p>Odd modified Mathieu function of the second kind and its derivative</p>
<p>Evaluates the odd modified Mathieu function of the second kind,
Ms2m(x, q), and its derivative at <code>x</code> (given in degrees) for order <code>m</code>
and parameter q.</p>
<h2 id="returns_411">Returns<a class="headerlink" href="#returns_411" title="Permanent link">&para;</a></h2>
<p>y
Value of the function
yp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_odd_coef</span> <span class="o">:</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Fourier coefficients for even Mathieu and modified Mathieu functions.</p>
<p>The Fourier series of the odd solutions of the Mathieu differential
equation are of the form</p>
<p>.. math:: \mathrm{se}<em>{2n+1}(z, q) = \sum</em>{k=0}^{\infty} B_{(2n+1)}^{(2k+1)} \sin (2k+1)z</p>
<p>.. math:: \mathrm{se}<em>{2n+2}(z, q) = \sum</em>{k=0}^{\infty} B_{(2n+2)}^{(2k+2)} \sin (2k+2)z</p>
<p>This function returns the coefficients :math:<code>B_{(2n+2)}^{(2k+2)}</code> for even
input m=2n+2, and the coefficients :math:<code>B_{(2n+1)}^{(2k+1)}</code> for odd
input m=2n+1.</p>
<h2 id="parameters_390">Parameters<a class="headerlink" href="#parameters_390" title="Permanent link">&para;</a></h2>
<p>m : int
Order of Mathieu functions.  Must be non-negative.
q : float (&gt;=0)
Parameter of Mathieu functions.  Must be non-negative.</p>
<h2 id="returns_412">Returns<a class="headerlink" href="#returns_412" title="Permanent link">&para;</a></h2>
<p>Bk : ndarray
Even or odd Fourier coefficients, corresponding to even or odd m.</p>
<h2 id="references_311">References<a class="headerlink" href="#references_311" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mathieu_sem</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>mathieu_sem(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>mathieu_sem(m, q, x)</p>
<p>Odd Mathieu function and its derivative</p>
<p>Returns the odd Mathieu function, se_m(x, q), of order <code>m</code> and
parameter <code>q</code> evaluated at <code>x</code> (given in degrees).  Also returns the
derivative with respect to <code>x</code> of se_m(x, q).</p>
<h2 id="parameters_391">Parameters<a class="headerlink" href="#parameters_391" title="Permanent link">&para;</a></h2>
<p>m
Order of the function
q
Parameter of the function
x
Argument of the function, <em>given in degrees, not radians</em>.</p>
<h2 id="returns_413">Returns<a class="headerlink" href="#returns_413" title="Permanent link">&para;</a></h2>
<p>y
Value of the function
yp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">modfresnelm</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>modfresnelm(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>modfresnelm(x)</p>
<p>Modified Fresnel negative integrals</p>
<h2 id="returns_414">Returns<a class="headerlink" href="#returns_414" title="Permanent link">&para;</a></h2>
<p>fm
Integral <code>F_-(x)</code>: <code>integral(exp(-1j*t*t), t=x..inf)</code>
km
Integral <code>K_-(x)</code>: <code>1/sqrt(pi)*exp(1j*(x*x+pi/4))*fp</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">modfresnelp</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>modfresnelp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>modfresnelp(x)</p>
<p>Modified Fresnel positive integrals</p>
<h2 id="returns_415">Returns<a class="headerlink" href="#returns_415" title="Permanent link">&para;</a></h2>
<p>fp
Integral <code>F_+(x)</code>: <code>integral(exp(1j*t*t), t=x..inf)</code>
kp
Integral <code>K_+(x)</code>: <code>1/sqrt(pi)*exp(-1j*(x*x+pi/4))*fp</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">modstruve</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>modstruve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>modstruve(v, x)</p>
<p>Modified Struve function.</p>
<p>Return the value of the modified Struve function of order <code>v</code> at <code>x</code>.  The
modified Struve function is defined as,</p>
<p>.. math::
L_v(x) = -\imath \exp(-\pi\imath v/2) H_v(\imath x),</p>
<p>where :math:<code>H_v</code> is the Struve function.</p>
<h2 id="parameters_392">Parameters<a class="headerlink" href="#parameters_392" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order of the modified Struve function (float).
x : array_like
Argument of the Struve function (float; must be positive unless <code>v</code> is
an integer).</p>
<h2 id="returns_416">Returns<a class="headerlink" href="#returns_416" title="Permanent link">&para;</a></h2>
<p>L : ndarray
Value of the modified Struve function of order <code>v</code> at <code>x</code>.</p>
<h2 id="notes_247">Notes<a class="headerlink" href="#notes_247" title="Permanent link">&para;</a></h2>
<p>Three methods discussed in [1]_ are used to evaluate the function:</p>
<ul>
<li>power series</li>
<li>expansion in Bessel functions (if :math:<code>|x| &lt; |v| + 20</code>)</li>
<li>asymptotic large-x expansion (if :math:<code>x \geq 0.7v + 12</code>)</li>
</ul>
<p>Rounding errors are estimated based on the largest terms in the sums, and
the result associated with the smallest error is returned.</p>
<h2 id="see-also_288">See also<a class="headerlink" href="#see-also_288" title="Permanent link">&para;</a></h2>
<p>struve</p>
<h2 id="references_312">References<a class="headerlink" href="#references_312" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/11</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">multigammaln</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the log of multivariate gamma, also sometimes called the
generalized gamma.</p>
<h2 id="parameters_393">Parameters<a class="headerlink" href="#parameters_393" title="Permanent link">&para;</a></h2>
<p>a : ndarray
The multivariate gamma is computed for each item of <code>a</code>.
d : int
The dimension of the space of integration.</p>
<h2 id="returns_417">Returns<a class="headerlink" href="#returns_417" title="Permanent link">&para;</a></h2>
<p>res : ndarray
The values of the log multivariate gamma at the given points <code>a</code>.</p>
<h2 id="notes_248">Notes<a class="headerlink" href="#notes_248" title="Permanent link">&para;</a></h2>
<p>The formal definition of the multivariate gamma of dimension d for a real
<code>a</code> is</p>
<p>.. math::</p>
<p>\Gamma_d(a) = \int_{A&gt;0} e^{-tr(A)} |A|^{a - (d+1)/2} dA</p>
<p>with the condition :math:<code>a &gt; (d-1)/2</code>, and :math:<code>A &gt; 0</code> being the set of
all the positive definite matrices of dimension <code>d</code>.  Note that <code>a</code> is a
scalar: the integrand only is multivariate, the argument is not (the
function is defined over a subset of the real set).</p>
<p>This can be proven to be equal to the much friendlier equation</p>
<p>.. math::</p>
<p>\Gamma_d(a) = \pi^{d(d-1)/4} \prod_{i=1}^{d} \Gamma(a - (i-1)/2).</p>
<h2 id="references_313">References<a class="headerlink" href="#references_313" title="Permanent link">&para;</a></h2>
<p>R. J. Muirhead, Aspects of multivariate statistical theory (Wiley Series in
probability and mathematical statistics).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nbdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nbdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nbdtr(k, n, p)</p>
<p>Negative binomial cumulative distribution function.</p>
<p>Returns the sum of the terms 0 through <code>k</code> of the negative binomial
distribution probability mass function,</p>
<p>.. math::</p>
<p>F = \sum_{j=0}^k {{n + j - 1}\choose{j}} p^n (1 - p)^j.</p>
<p>In a sequence of Bernoulli trials with individual success probabilities
<code>p</code>, this is the probability that <code>k</code> or fewer failures precede the nth
success.</p>
<h2 id="parameters_394">Parameters<a class="headerlink" href="#parameters_394" title="Permanent link">&para;</a></h2>
<p>k : array_like
The maximum number of allowed failures (nonnegative int).
n : array_like
The target number of successes (positive int).
p : array_like
Probability of success in a single event (float).</p>
<h2 id="returns_418">Returns<a class="headerlink" href="#returns_418" title="Permanent link">&para;</a></h2>
<p>F : ndarray
The probability of <code>k</code> or fewer failures before <code>n</code> successes in a
sequence of events with individual success probability <code>p</code>.</p>
<h2 id="see-also_289">See also<a class="headerlink" href="#see-also_289" title="Permanent link">&para;</a></h2>
<p>nbdtrc</p>
<h2 id="notes_249">Notes<a class="headerlink" href="#notes_249" title="Permanent link">&para;</a></h2>
<p>If floating point values are passed for <code>k</code> or <code>n</code>, they will be truncated
to integers.</p>
<p>The terms are not summed directly; instead the regularized incomplete beta
function is employed, according to the formula,</p>
<p>.. math::
\mathrm{nbdtr}(k, n, p) = I_{p}(n, k + 1).</p>
<p>Wrapper for the Cephes [1]_ routine <code>nbdtr</code>.</p>
<h2 id="references_314">References<a class="headerlink" href="#references_314" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nbdtrc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nbdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nbdtrc(k, n, p)</p>
<p>Negative binomial survival function.</p>
<p>Returns the sum of the terms <code>k + 1</code> to infinity of the negative binomial
distribution probability mass function,</p>
<p>.. math::</p>
<p>F = \sum_{j=k + 1}^\infty {{n + j - 1}\choose{j}} p^n (1 - p)^j.</p>
<p>In a sequence of Bernoulli trials with individual success probabilities
<code>p</code>, this is the probability that more than <code>k</code> failures precede the nth
success.</p>
<h2 id="parameters_395">Parameters<a class="headerlink" href="#parameters_395" title="Permanent link">&para;</a></h2>
<p>k : array_like
The maximum number of allowed failures (nonnegative int).
n : array_like
The target number of successes (positive int).
p : array_like
Probability of success in a single event (float).</p>
<h2 id="returns_419">Returns<a class="headerlink" href="#returns_419" title="Permanent link">&para;</a></h2>
<p>F : ndarray
The probability of <code>k + 1</code> or more failures before <code>n</code> successes in a
sequence of events with individual success probability <code>p</code>.</p>
<h2 id="notes_250">Notes<a class="headerlink" href="#notes_250" title="Permanent link">&para;</a></h2>
<p>If floating point values are passed for <code>k</code> or <code>n</code>, they will be truncated
to integers.</p>
<p>The terms are not summed directly; instead the regularized incomplete beta
function is employed, according to the formula,</p>
<p>.. math::
\mathrm{nbdtrc}(k, n, p) = I_{1 - p}(k + 1, n).</p>
<p>Wrapper for the Cephes [1]_ routine <code>nbdtrc</code>.</p>
<h2 id="references_315">References<a class="headerlink" href="#references_315" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nbdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nbdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nbdtri(k, n, y)</p>
<p>Inverse of <code>nbdtr</code> vs <code>p</code>.</p>
<p>Returns the inverse with respect to the parameter <code>p</code> of
<code>y = nbdtr(k, n, p)</code>, the negative binomial cumulative distribution
function.</p>
<h2 id="parameters_396">Parameters<a class="headerlink" href="#parameters_396" title="Permanent link">&para;</a></h2>
<p>k : array_like
The maximum number of allowed failures (nonnegative int).
n : array_like
The target number of successes (positive int).
y : array_like
The probability of <code>k</code> or fewer failures before <code>n</code> successes (float).</p>
<h2 id="returns_420">Returns<a class="headerlink" href="#returns_420" title="Permanent link">&para;</a></h2>
<p>p : ndarray
Probability of success in a single event (float) such that
<code>nbdtr(k, n, p) = y</code>.</p>
<h2 id="see-also_290">See also<a class="headerlink" href="#see-also_290" title="Permanent link">&para;</a></h2>
<p>nbdtr : Cumulative distribution function of the negative binomial.
nbdtrik : Inverse with respect to <code>k</code> of <code>nbdtr(k, n, p)</code>.
nbdtrin : Inverse with respect to <code>n</code> of <code>nbdtr(k, n, p)</code>.</p>
<h2 id="notes_251">Notes<a class="headerlink" href="#notes_251" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>nbdtri</code>.</p>
<h2 id="references_316">References<a class="headerlink" href="#references_316" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nbdtrik</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nbdtrik(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nbdtrik(y, n, p)</p>
<p>Inverse of <code>nbdtr</code> vs <code>k</code>.</p>
<p>Returns the inverse with respect to the parameter <code>k</code> of
<code>y = nbdtr(k, n, p)</code>, the negative binomial cumulative distribution
function.</p>
<h2 id="parameters_397">Parameters<a class="headerlink" href="#parameters_397" title="Permanent link">&para;</a></h2>
<p>y : array_like
The probability of <code>k</code> or fewer failures before <code>n</code> successes (float).
n : array_like
The target number of successes (positive int).
p : array_like
Probability of success in a single event (float).</p>
<h2 id="returns_421">Returns<a class="headerlink" href="#returns_421" title="Permanent link">&para;</a></h2>
<p>k : ndarray
The maximum number of allowed failures such that <code>nbdtr(k, n, p) = y</code>.</p>
<h2 id="see-also_291">See also<a class="headerlink" href="#see-also_291" title="Permanent link">&para;</a></h2>
<p>nbdtr : Cumulative distribution function of the negative binomial.
nbdtri : Inverse with respect to <code>p</code> of <code>nbdtr(k, n, p)</code>.
nbdtrin : Inverse with respect to <code>n</code> of <code>nbdtr(k, n, p)</code>.</p>
<h2 id="notes_252">Notes<a class="headerlink" href="#notes_252" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfnbn</code>.</p>
<p>Formula 26.5.26 of [2]_,</p>
<p>.. math::
\sum_{j=k + 1}^\infty {{n + j - 1}\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),</p>
<p>is used to reduce calculation of the cumulative distribution function to
that of a regularized incomplete beta :math:<code>I</code>.</p>
<p>Computation of <code>k</code> involves a search for a value that produces the desired
value of <code>y</code>.  The search relies on the monotonicity of <code>y</code> with <code>k</code>.</p>
<h2 id="references_317">References<a class="headerlink" href="#references_317" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nbdtrin</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nbdtrin(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nbdtrin(k, y, p)</p>
<p>Inverse of <code>nbdtr</code> vs <code>n</code>.</p>
<p>Returns the inverse with respect to the parameter <code>n</code> of
<code>y = nbdtr(k, n, p)</code>, the negative binomial cumulative distribution
function.</p>
<h2 id="parameters_398">Parameters<a class="headerlink" href="#parameters_398" title="Permanent link">&para;</a></h2>
<p>k : array_like
The maximum number of allowed failures (nonnegative int).
y : array_like
The probability of <code>k</code> or fewer failures before <code>n</code> successes (float).
p : array_like
Probability of success in a single event (float).</p>
<h2 id="returns_422">Returns<a class="headerlink" href="#returns_422" title="Permanent link">&para;</a></h2>
<p>n : ndarray
The number of successes <code>n</code> such that <code>nbdtr(k, n, p) = y</code>.</p>
<h2 id="see-also_292">See also<a class="headerlink" href="#see-also_292" title="Permanent link">&para;</a></h2>
<p>nbdtr : Cumulative distribution function of the negative binomial.
nbdtri : Inverse with respect to <code>p</code> of <code>nbdtr(k, n, p)</code>.
nbdtrik : Inverse with respect to <code>k</code> of <code>nbdtr(k, n, p)</code>.</p>
<h2 id="notes_253">Notes<a class="headerlink" href="#notes_253" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdfnbn</code>.</p>
<p>Formula 26.5.26 of [2]_,</p>
<p>.. math::
\sum_{j=k + 1}^\infty {{n + j - 1}\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),</p>
<p>is used to reduce calculation of the cumulative distribution function to
that of a regularized incomplete beta :math:<code>I</code>.</p>
<p>Computation of <code>n</code> involves a search for a value that produces the desired
value of <code>y</code>.  The search relies on the monotonicity of <code>y</code> with <code>n</code>.</p>
<h2 id="references_318">References<a class="headerlink" href="#references_318" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ncfdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ncfdtr(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ncfdtr(dfn, dfd, nc, f)</p>
<p>Cumulative distribution function of the non-central F distribution.</p>
<p>The non-central F describes the distribution of,</p>
<p>.. math::
Z = \frac{X/d_n}{Y/d_d}</p>
<p>where :math:<code>X</code> and :math:<code>Y</code> are independently distributed, with
:math:<code>X</code> distributed non-central :math:<code>\chi^2</code> with noncentrality
parameter <code>nc</code> and :math:<code>d_n</code> degrees of freedom, and :math:<code>Y</code>
distributed :math:<code>\chi^2</code> with :math:<code>d_d</code> degrees of freedom.</p>
<h2 id="parameters_399">Parameters<a class="headerlink" href="#parameters_399" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
Degrees of freedom of the numerator sum of squares.  Range (0, inf).
dfd : array_like
Degrees of freedom of the denominator sum of squares.  Range (0, inf).
nc : array_like
Noncentrality parameter.  Should be in range (0, 1e4).
f : array_like
Quantiles, i.e. the upper limit of integration.</p>
<h2 id="returns_423">Returns<a class="headerlink" href="#returns_423" title="Permanent link">&para;</a></h2>
<p>cdf : float or ndarray
The calculated CDF.  If all inputs are scalar, the return will be a
float.  Otherwise it will be an array.</p>
<h2 id="see-also_293">See Also<a class="headerlink" href="#see-also_293" title="Permanent link">&para;</a></h2>
<p>ncfdtri : Quantile function; inverse of <code>ncfdtr</code> with respect to <code>f</code>.
ncfdtridfd : Inverse of <code>ncfdtr</code> with respect to <code>dfd</code>.
ncfdtridfn : Inverse of <code>ncfdtr</code> with respect to <code>dfn</code>.
ncfdtrinc : Inverse of <code>ncfdtr</code> with respect to <code>nc</code>.</p>
<h2 id="notes_254">Notes<a class="headerlink" href="#notes_254" title="Permanent link">&para;</a></h2>
<p>Wrapper for the CDFLIB [1]_ Fortran routine <code>cdffnc</code>.</p>
<p>The cumulative distribution function is computed using Formula 26.6.20 of
[2]_:</p>
<p>.. math::
F(d_n, d_d, n_c, f) = \sum_{j=0}^\infty e^{-n_c/2} \frac{(n_c/2)^j}{j!} I_{x}(\frac{d_n}{2} + j, \frac{d_d}{2}),</p>
<p>where :math:<code>I</code> is the regularized incomplete beta function, and
:math:<code>x = f d_n/(f d_n + d_d)</code>.</p>
<p>The computation time required for this routine is proportional to the
noncentrality parameter <code>nc</code>.  Very large values of this parameter can
consume immense computer resources.  This is why the search range is
bounded by 10,000.</p>
<h2 id="references_319">References<a class="headerlink" href="#references_319" title="Permanent link">&para;</a></h2>
<p>.. [1] Barry Brown, James Lovato, and Kathy Russell,
CDFLIB: Library of Fortran Routines for Cumulative Distribution
Functions, Inverses, and Other Parameters.
.. [2] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<h2 id="examples_140">Examples<a class="headerlink" href="#examples_140" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
from scipy import stats
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the CDF of the non-central F distribution, for nc=0.  Compare with the
F-distribution from scipy.stats:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-1, 8, num=500)
dfn = 3
dfd = 2
ncf_stats = stats.f.cdf(x, dfn, dfd)
ncf_special = special.ncfdtr(dfn, dfd, 0, x)</p>
<p>fig = plt.figure()
ax = fig.add_subplot(111)
ax.plot(x, ncf_stats, 'b-', lw=3)
ax.plot(x, ncf_special, 'r-')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ncfdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>ncfdtri(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ncfdtri(dfn, dfd, nc, p)</p>
<p>Inverse with respect to <code>f</code> of the CDF of the non-central F distribution.</p>
<p>See <code>ncfdtr</code> for more details.</p>
<h2 id="parameters_400">Parameters<a class="headerlink" href="#parameters_400" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
Degrees of freedom of the numerator sum of squares.  Range (0, inf).
dfd : array_like
Degrees of freedom of the denominator sum of squares.  Range (0, inf).
nc : array_like
Noncentrality parameter.  Should be in range (0, 1e4).
p : array_like
Value of the cumulative distribution function.  Must be in the
range [0, 1].</p>
<h2 id="returns_424">Returns<a class="headerlink" href="#returns_424" title="Permanent link">&para;</a></h2>
<p>f : float
Quantiles, i.e. the upper limit of integration.</p>
<h2 id="see-also_294">See Also<a class="headerlink" href="#see-also_294" title="Permanent link">&para;</a></h2>
<p>ncfdtr : CDF of the non-central F distribution.
ncfdtridfd : Inverse of <code>ncfdtr</code> with respect to <code>dfd</code>.
ncfdtridfn : Inverse of <code>ncfdtr</code> with respect to <code>dfn</code>.
ncfdtrinc : Inverse of <code>ncfdtr</code> with respect to <code>nc</code>.</p>
<h2 id="examples_141">Examples<a class="headerlink" href="#examples_141" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import ncfdtr, ncfdtri</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the CDF for several values of <code>f</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>f = [0.5, 1, 1.5]
p = ncfdtr(2, 3, 1.5, f)
p
array([ 0.20782291,  0.36107392,  0.47345752])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the inverse.  We recover the values of <code>f</code>, as expected:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ncfdtri(2, 3, 1.5, p)
array([ 0.5,  1. ,  1.5])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ncfdtridfd</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>ncfdtridfd(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ncfdtridfd(dfn, p, nc, f)</p>
<p>Calculate degrees of freedom (denominator) for the noncentral F-distribution.</p>
<p>This is the inverse with respect to <code>dfd</code> of <code>ncfdtr</code>.
See <code>ncfdtr</code> for more details.</p>
<h2 id="parameters_401">Parameters<a class="headerlink" href="#parameters_401" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
Degrees of freedom of the numerator sum of squares.  Range (0, inf).
p : array_like
Value of the cumulative distribution function.  Must be in the
range [0, 1].
nc : array_like
Noncentrality parameter.  Should be in range (0, 1e4).
f : array_like
Quantiles, i.e. the upper limit of integration.</p>
<h2 id="returns_425">Returns<a class="headerlink" href="#returns_425" title="Permanent link">&para;</a></h2>
<p>dfd : float
Degrees of freedom of the denominator sum of squares.</p>
<h2 id="see-also_295">See Also<a class="headerlink" href="#see-also_295" title="Permanent link">&para;</a></h2>
<p>ncfdtr : CDF of the non-central F distribution.
ncfdtri : Quantile function; inverse of <code>ncfdtr</code> with respect to <code>f</code>.
ncfdtridfn : Inverse of <code>ncfdtr</code> with respect to <code>dfn</code>.
ncfdtrinc : Inverse of <code>ncfdtr</code> with respect to <code>nc</code>.</p>
<h2 id="notes_255">Notes<a class="headerlink" href="#notes_255" title="Permanent link">&para;</a></h2>
<p>The value of the cumulative noncentral F distribution is not necessarily
monotone in either degrees of freedom.  There thus may be two values that
provide a given CDF value.  This routine assumes monotonicity and will
find an arbitrary one of the two values.</p>
<h2 id="examples_142">Examples<a class="headerlink" href="#examples_142" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import ncfdtr, ncfdtridfd</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the CDF for several values of <code>dfd</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>dfd = [1, 2, 3]
p = ncfdtr(2, dfd, 0.25, 15)
p
array([ 0.8097138 ,  0.93020416,  0.96787852])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the inverse.  We recover the values of <code>dfd</code>, as expected:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ncfdtridfd(2, p, 0.25, 15)
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ncfdtridfn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>ncfdtridfn(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ncfdtridfn(p, dfd, nc, f)</p>
<p>Calculate degrees of freedom (numerator) for the noncentral F-distribution.</p>
<p>This is the inverse with respect to <code>dfn</code> of <code>ncfdtr</code>.
See <code>ncfdtr</code> for more details.</p>
<h2 id="parameters_402">Parameters<a class="headerlink" href="#parameters_402" title="Permanent link">&para;</a></h2>
<p>p : array_like
Value of the cumulative distribution function.  Must be in the
range [0, 1].
dfd : array_like
Degrees of freedom of the denominator sum of squares.  Range (0, inf).
nc : array_like
Noncentrality parameter.  Should be in range (0, 1e4).
f : float
Quantiles, i.e. the upper limit of integration.</p>
<h2 id="returns_426">Returns<a class="headerlink" href="#returns_426" title="Permanent link">&para;</a></h2>
<p>dfn : float
Degrees of freedom of the numerator sum of squares.</p>
<h2 id="see-also_296">See Also<a class="headerlink" href="#see-also_296" title="Permanent link">&para;</a></h2>
<p>ncfdtr : CDF of the non-central F distribution.
ncfdtri : Quantile function; inverse of <code>ncfdtr</code> with respect to <code>f</code>.
ncfdtridfd : Inverse of <code>ncfdtr</code> with respect to <code>dfd</code>.
ncfdtrinc : Inverse of <code>ncfdtr</code> with respect to <code>nc</code>.</p>
<h2 id="notes_256">Notes<a class="headerlink" href="#notes_256" title="Permanent link">&para;</a></h2>
<p>The value of the cumulative noncentral F distribution is not necessarily
monotone in either degrees of freedom.  There thus may be two values that
provide a given CDF value.  This routine assumes monotonicity and will
find an arbitrary one of the two values.</p>
<h2 id="examples_143">Examples<a class="headerlink" href="#examples_143" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import ncfdtr, ncfdtridfn</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the CDF for several values of <code>dfn</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>dfn = [1, 2, 3]
p = ncfdtr(dfn, 2, 0.25, 15)
p
array([ 0.92562363,  0.93020416,  0.93188394])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the inverse.  We recover the values of <code>dfn</code>, as expected:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ncfdtridfn(p, 2, 0.25, 15)
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ncfdtrinc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>ncfdtrinc(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ncfdtrinc(dfn, dfd, p, f)</p>
<p>Calculate non-centrality parameter for non-central F distribution.</p>
<p>This is the inverse with respect to <code>nc</code> of <code>ncfdtr</code>.
See <code>ncfdtr</code> for more details.</p>
<h2 id="parameters_403">Parameters<a class="headerlink" href="#parameters_403" title="Permanent link">&para;</a></h2>
<p>dfn : array_like
Degrees of freedom of the numerator sum of squares.  Range (0, inf).
dfd : array_like
Degrees of freedom of the denominator sum of squares.  Range (0, inf).
p : array_like
Value of the cumulative distribution function.  Must be in the
range [0, 1].
f : array_like
Quantiles, i.e. the upper limit of integration.</p>
<h2 id="returns_427">Returns<a class="headerlink" href="#returns_427" title="Permanent link">&para;</a></h2>
<p>nc : float
Noncentrality parameter.</p>
<h2 id="see-also_297">See Also<a class="headerlink" href="#see-also_297" title="Permanent link">&para;</a></h2>
<p>ncfdtr : CDF of the non-central F distribution.
ncfdtri : Quantile function; inverse of <code>ncfdtr</code> with respect to <code>f</code>.
ncfdtridfd : Inverse of <code>ncfdtr</code> with respect to <code>dfd</code>.
ncfdtridfn : Inverse of <code>ncfdtr</code> with respect to <code>dfn</code>.</p>
<h2 id="examples_144">Examples<a class="headerlink" href="#examples_144" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import ncfdtr, ncfdtrinc</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the CDF for several values of <code>nc</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>nc = [0.5, 1.5, 2.0]
p = ncfdtr(2, 3, nc, 15)
p
array([ 0.96309246,  0.94327955,  0.93304098])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the inverse.  We recover the values of <code>nc</code>, as expected:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ncfdtrinc(2, 3, p, 15)
array([ 0.5,  1.5,  2. ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nctdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nctdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nctdtr(df, nc, t)</p>
<p>Cumulative distribution function of the non-central <code>t</code> distribution.</p>
<h2 id="parameters_404">Parameters<a class="headerlink" href="#parameters_404" title="Permanent link">&para;</a></h2>
<p>df : array_like
Degrees of freedom of the distribution.  Should be in range (0, inf).
nc : array_like
Noncentrality parameter.  Should be in range (-1e6, 1e6).
t : array_like
Quantiles, i.e. the upper limit of integration.</p>
<h2 id="returns_428">Returns<a class="headerlink" href="#returns_428" title="Permanent link">&para;</a></h2>
<p>cdf : float or ndarray
The calculated CDF.  If all inputs are scalar, the return will be a
float.  Otherwise it will be an array.</p>
<h2 id="see-also_298">See Also<a class="headerlink" href="#see-also_298" title="Permanent link">&para;</a></h2>
<p>nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.
nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.
nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.</p>
<h2 id="examples_145">Examples<a class="headerlink" href="#examples_145" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
from scipy import stats
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the CDF of the non-central t distribution, for nc=0.  Compare with the
t-distribution from scipy.stats:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-5, 5, num=500)
df = 3
nct_stats = stats.t.cdf(x, df)
nct_special = special.nctdtr(df, 0, x)</p>
<p>fig = plt.figure()
ax = fig.add_subplot(111)
ax.plot(x, nct_stats, 'b-', lw=3)
ax.plot(x, nct_special, 'r-')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nctdtridf</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nctdtridf(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nctdtridf(p, nc, t)</p>
<p>Calculate degrees of freedom for non-central t distribution.</p>
<p>See <code>nctdtr</code> for more details.</p>
<h2 id="parameters_405">Parameters<a class="headerlink" href="#parameters_405" title="Permanent link">&para;</a></h2>
<p>p : array_like
CDF values, in range (0, 1].
nc : array_like
Noncentrality parameter.  Should be in range (-1e6, 1e6).
t : array_like
Quantiles, i.e. the upper limit of integration.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nctdtrinc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nctdtrinc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nctdtrinc(df, p, t)</p>
<p>Calculate non-centrality parameter for non-central t distribution.</p>
<p>See <code>nctdtr</code> for more details.</p>
<h2 id="parameters_406">Parameters<a class="headerlink" href="#parameters_406" title="Permanent link">&para;</a></h2>
<p>df : array_like
Degrees of freedom of the distribution.  Should be in range (0, inf).
p : array_like
CDF values, in range (0, 1].
t : array_like
Quantiles, i.e. the upper limit of integration.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nctdtrit</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nctdtrit(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nctdtrit(df, nc, p)</p>
<p>Inverse cumulative distribution function of the non-central t distribution.</p>
<p>See <code>nctdtr</code> for more details.</p>
<h2 id="parameters_407">Parameters<a class="headerlink" href="#parameters_407" title="Permanent link">&para;</a></h2>
<p>df : array_like
Degrees of freedom of the distribution.  Should be in range (0, inf).
nc : array_like
Noncentrality parameter.  Should be in range (-1e6, 1e6).
p : array_like
CDF values, in range (0, 1].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ndtr(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ndtr(x)</p>
<p>Gaussian cumulative distribution function.</p>
<p>Returns the area under the standard Gaussian probability
density function, integrated from minus infinity to <code>x</code></p>
<p>.. math::</p>
<p>\frac{1}{\sqrt{2\pi}} \int_{-\infty}^x \exp(-t^2/2) dt</p>
<h2 id="parameters_408">Parameters<a class="headerlink" href="#parameters_408" title="Permanent link">&para;</a></h2>
<p>x : array_like, real or complex
Argument</p>
<h2 id="returns_429">Returns<a class="headerlink" href="#returns_429" title="Permanent link">&para;</a></h2>
<p>ndarray
The value of the normal CDF evaluated at <code>x</code></p>
<h2 id="see-also_299">See Also<a class="headerlink" href="#see-also_299" title="Permanent link">&para;</a></h2>
<p>erf
erfc
scipy.stats.norm
log_ndtr</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ndtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ndtri(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>ndtri(y)</p>
<p>Inverse of <code>ndtr</code> vs x</p>
<p>Returns the argument x for which the area under the Gaussian
probability density function (integrated from minus infinity to <code>x</code>)
is equal to y.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nrdtrimn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nrdtrimn(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nrdtrimn(p, x, std)</p>
<p>Calculate mean of normal distribution given other params.</p>
<h2 id="parameters_409">Parameters<a class="headerlink" href="#parameters_409" title="Permanent link">&para;</a></h2>
<p>p : array_like
CDF values, in range (0, 1].
x : array_like
Quantiles, i.e. the upper limit of integration.
std : array_like
Standard deviation.</p>
<h2 id="returns_430">Returns<a class="headerlink" href="#returns_430" title="Permanent link">&para;</a></h2>
<p>mn : float or ndarray
The mean of the normal distribution.</p>
<h2 id="see-also_300">See Also<a class="headerlink" href="#see-also_300" title="Permanent link">&para;</a></h2>
<p>nrdtrimn, ndtr</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nrdtrisd</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>nrdtrisd(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>nrdtrisd(p, x, mn)</p>
<p>Calculate standard deviation of normal distribution given other params.</p>
<h2 id="parameters_410">Parameters<a class="headerlink" href="#parameters_410" title="Permanent link">&para;</a></h2>
<p>p : array_like
CDF values, in range (0, 1].
x : array_like
Quantiles, i.e. the upper limit of integration.
mn : float or ndarray
The mean of the normal distribution.</p>
<h2 id="returns_431">Returns<a class="headerlink" href="#returns_431" title="Permanent link">&para;</a></h2>
<p>std : array_like
Standard deviation.</p>
<h2 id="see-also_301">See Also<a class="headerlink" href="#see-also_301" title="Permanent link">&para;</a></h2>
<p>ndtr</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_ang1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>obl_ang1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_ang1(m, n, c, x)</p>
<p>Oblate spheroidal angular function of the first kind and its derivative</p>
<p>Computes the oblate spheroidal angular function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>.</p>
<h2 id="returns_432">Returns<a class="headerlink" href="#returns_432" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_ang1_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>obl_ang1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_ang1_cv(m, n, c, cv, x)</p>
<p>Oblate spheroidal angular function obl_ang1 for precomputed characteristic value</p>
<p>Computes the oblate spheroidal angular function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>. Requires
pre-computed characteristic value.</p>
<h2 id="returns_433">Returns<a class="headerlink" href="#returns_433" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>obl_cv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_cv(m, n, c)</p>
<p>Characteristic value of oblate spheroidal function</p>
<p>Computes the characteristic value of oblate spheroidal wave
functions of order <code>m</code>, <code>n</code> (n&gt;=m) and spheroidal parameter <code>c</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_cv_seq</span> <span class="o">:</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Characteristic values for oblate spheroidal wave functions.</p>
<p>Compute a sequence of characteristic values for the oblate
spheroidal wave functions for mode m and n'=m..n and spheroidal
parameter c.</p>
<h2 id="references_320">References<a class="headerlink" href="#references_320" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_rad1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>obl_rad1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_rad1(m, n, c, x)</p>
<p>Oblate spheroidal radial function of the first kind and its derivative</p>
<p>Computes the oblate spheroidal radial function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>.</p>
<h2 id="returns_434">Returns<a class="headerlink" href="#returns_434" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_rad1_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>obl_rad1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_rad1_cv(m, n, c, cv, x)</p>
<p>Oblate spheroidal radial function obl_rad1 for precomputed characteristic value</p>
<p>Computes the oblate spheroidal radial function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>. Requires
pre-computed characteristic value.</p>
<h2 id="returns_435">Returns<a class="headerlink" href="#returns_435" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_rad2</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>obl_rad2(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_rad2(m, n, c, x)</p>
<p>Oblate spheroidal radial function of the second kind and its derivative.</p>
<p>Computes the oblate spheroidal radial function of the second kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>.</p>
<h2 id="returns_436">Returns<a class="headerlink" href="#returns_436" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">obl_rad2_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>obl_rad2_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>obl_rad2_cv(m, n, c, cv, x)</p>
<p>Oblate spheroidal radial function obl_rad2 for precomputed characteristic value</p>
<p>Computes the oblate spheroidal radial function of the second kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>. Requires
pre-computed characteristic value.</p>
<h2 id="returns_437">Returns<a class="headerlink" href="#returns_437" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">owens_t</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>owens_t(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>owens_t(h, a)</p>
<p>Owen's T Function.</p>
<p>The function T(h, a) gives the probability of the event
(X &gt; h and 0 &lt; Y &lt; a * X) where X and Y are independent
standard normal random variables.</p>
<h2 id="parameters_411">Parameters<a class="headerlink" href="#parameters_411" title="Permanent link">&para;</a></h2>
<p>h: array_like
Input value.
a: array_like
Input value.</p>
<h2 id="returns_438">Returns<a class="headerlink" href="#returns_438" title="Permanent link">&para;</a></h2>
<p>t: scalar or ndarray
Probability of the event (X &gt; h and 0 &lt; Y &lt; a * X),
where X and Y are independent standard normal random variables.</p>
<h2 id="examples_146">Examples<a class="headerlink" href="#examples_146" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
a = 3.5
h = 0.78
special.owens_t(h, a)
0.10877216734852274</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_321">References<a class="headerlink" href="#references_321" title="Permanent link">&para;</a></h2>
<p>.. [1] M. Patefield and D. Tandy, 'Fast and accurate calculation of
Owen's T Function', Statistical Software vol. 5, pp. 1-25, 2000.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">p_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Legendre quadrature.</p>
<p>Compute the sample points and weights for Gauss-Legendre
quadrature. The sample points are the roots of the n-th degree
Legendre polynomial :math:<code>P_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[-1, 1]</code> with weight function
:math:<code>w(x) = 1.0</code>. See 2.2.10 in [AS]_ for more details.</p>
<h2 id="parameters_412">Parameters<a class="headerlink" href="#parameters_412" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_439">Returns<a class="headerlink" href="#returns_439" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_302">See Also<a class="headerlink" href="#see-also_302" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.legendre.leggauss</p>
<h2 id="references_322">References<a class="headerlink" href="#references_322" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pbdn_seq</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Parabolic cylinder functions Dn(z) and derivatives.</p>
<h2 id="parameters_413">Parameters<a class="headerlink" href="#parameters_413" title="Permanent link">&para;</a></h2>
<p>n : int
Order of the parabolic cylinder function
z : complex
Value at which to evaluate the function and derivatives</p>
<h2 id="returns_440">Returns<a class="headerlink" href="#returns_440" title="Permanent link">&para;</a></h2>
<p>dv : ndarray
Values of D_i(z), for i=0, ..., i=n.
dp : ndarray
Derivatives D_i'(z), for i=0, ..., i=n.</p>
<h2 id="references_323">References<a class="headerlink" href="#references_323" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 13.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pbdv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pbdv(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pbdv(v, x)</p>
<p>Parabolic cylinder function D</p>
<p>Returns (d, dp) the parabolic cylinder function Dv(x) in d and the
derivative, Dv'(x) in dp.</p>
<h2 id="returns_441">Returns<a class="headerlink" href="#returns_441" title="Permanent link">&para;</a></h2>
<p>d
Value of the function
dp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pbdv_seq</span> <span class="o">:</span> <span class="n">v</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Parabolic cylinder functions Dv(x) and derivatives.</p>
<h2 id="parameters_414">Parameters<a class="headerlink" href="#parameters_414" title="Permanent link">&para;</a></h2>
<p>v : float
Order of the parabolic cylinder function
x : float
Value at which to evaluate the function and derivatives</p>
<h2 id="returns_442">Returns<a class="headerlink" href="#returns_442" title="Permanent link">&para;</a></h2>
<p>dv : ndarray
Values of D_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.
dp : ndarray
Derivatives D_vi'(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</p>
<h2 id="references_324">References<a class="headerlink" href="#references_324" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 13.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pbvv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pbvv(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pbvv(v, x)</p>
<p>Parabolic cylinder function V</p>
<p>Returns the parabolic cylinder function Vv(x) in v and the
derivative, Vv'(x) in vp.</p>
<h2 id="returns_443">Returns<a class="headerlink" href="#returns_443" title="Permanent link">&para;</a></h2>
<p>v
Value of the function
vp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pbvv_seq</span> <span class="o">:</span> <span class="n">v</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Parabolic cylinder functions Vv(x) and derivatives.</p>
<h2 id="parameters_415">Parameters<a class="headerlink" href="#parameters_415" title="Permanent link">&para;</a></h2>
<p>v : float
Order of the parabolic cylinder function
x : float
Value at which to evaluate the function and derivatives</p>
<h2 id="returns_444">Returns<a class="headerlink" href="#returns_444" title="Permanent link">&para;</a></h2>
<p>dv : ndarray
Values of V_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.
dp : ndarray
Derivatives V_vi'(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</p>
<h2 id="references_325">References<a class="headerlink" href="#references_325" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 13.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pbwa</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pbwa(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pbwa(a, x)</p>
<p>Parabolic cylinder function W.</p>
<p>The function is a particular solution to the differential equation</p>
<p>.. math::</p>
<p>y'' + \left(\frac{1}{4}x^2 - a\right)y = 0,</p>
<p>for a full definition see section 12.14 in [1]_.</p>
<h2 id="parameters_416">Parameters<a class="headerlink" href="#parameters_416" title="Permanent link">&para;</a></h2>
<p>a : array_like
Real parameter
x : array_like
Real argument</p>
<h2 id="returns_445">Returns<a class="headerlink" href="#returns_445" title="Permanent link">&para;</a></h2>
<p>w : scalar or ndarray
Value of the function
wp : scalar or ndarray
Value of the derivative in x</p>
<h2 id="notes_257">Notes<a class="headerlink" href="#notes_257" title="Permanent link">&para;</a></h2>
<p>The function is a wrapper for a Fortran routine by Zhang and Jin
[2]_. The implementation is accurate only for <code>|a|, |x| &lt; 5</code> and
returns NaN outside that range.</p>
<h2 id="references_326">References<a class="headerlink" href="#references_326" title="Permanent link">&para;</a></h2>
<p>.. [1] Digital Library of Mathematical Functions, 14.30.
https://dlmf.nist.gov/14.30
.. [2] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>pdtr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pdtr(k, m, out=None)</p>
<p>Poisson cumulative distribution function.</p>
<p>Defined as the probability that a Poisson-distributed random
variable with event rate :math:<code>m</code> is less than or equal to
:math:<code>k</code>. More concretely, this works out to be [1]_</p>
<p>.. math::</p>
<p>\exp(-m) \sum_{j = 0}^{\lfloor{k}\rfloor} \frac{m^j}{m!}.</p>
<h2 id="parameters_417">Parameters<a class="headerlink" href="#parameters_417" title="Permanent link">&para;</a></h2>
<p>k : array_like
Nonnegative real argument
m : array_like
Nonnegative real shape parameter
out : ndarray
Optional output array for the function results</p>
<h2 id="see-also_303">See Also<a class="headerlink" href="#see-also_303" title="Permanent link">&para;</a></h2>
<p>pdtrc : Poisson survival function
pdtrik : inverse of <code>pdtr</code> with respect to <code>k</code>
pdtri : inverse of <code>pdtr</code> with respect to <code>m</code></p>
<h2 id="returns_446">Returns<a class="headerlink" href="#returns_446" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the Poisson cumulative distribution function</p>
<h2 id="references_327">References<a class="headerlink" href="#references_327" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Poisson_distribution</p>
<h2 id="examples_147">Examples<a class="headerlink" href="#examples_147" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is a cumulative distribution function, so it converges to 1
monotonically as <code>k</code> goes to infinity.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.pdtr([1, 10, 100, np.inf], 1)
array([0.73575888, 0.99999999, 1.        , 1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is discontinuous at integers and constant between integers.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.pdtr([1, 1.5, 1.9, 2], 1)
array([0.73575888, 0.73575888, 0.73575888, 0.9196986 ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pdtrc</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>pdtrc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pdtrc(k, m)</p>
<p>Poisson survival function</p>
<p>Returns the sum of the terms from k+1 to infinity of the Poisson
distribution: sum(exp(-m) * m**j / j!, j=k+1..inf) = gammainc(
k+1, m).  Arguments must both be non-negative doubles.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pdtri</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>pdtri(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pdtri(k, y)</p>
<p>Inverse to <code>pdtr</code> vs m</p>
<p>Returns the Poisson variable <code>m</code> such that the sum from 0 to <code>k</code> of
the Poisson density is equal to the given probability <code>y</code>:
calculated by gammaincinv(k+1, y). <code>k</code> must be a nonnegative
integer and <code>y</code> between 0 and 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pdtrik</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>pdtrik(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pdtrik(p, m)</p>
<p>Inverse to <code>pdtr</code> vs k</p>
<p>Returns the quantile k such that <code>pdtr(k, m) = p</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">perm</span> <span class="o">:</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Permutations of N things taken k at a time, i.e., k-permutations of N.</p>
<p>It's also known as 'partial permutations'.</p>
<h2 id="parameters_418">Parameters<a class="headerlink" href="#parameters_418" title="Permanent link">&para;</a></h2>
<p>N : int, ndarray
Number of things.
k : int, ndarray
Number of elements taken.
exact : bool, optional
If <code>exact</code> is False, then floating point precision is used, otherwise
exact long integer is computed.</p>
<h2 id="returns_447">Returns<a class="headerlink" href="#returns_447" title="Permanent link">&para;</a></h2>
<p>val : int, ndarray
The number of k-permutations of N.</p>
<h2 id="notes_258">Notes<a class="headerlink" href="#notes_258" title="Permanent link">&para;</a></h2>
<ul>
<li>Array arguments accepted only for exact=False case.</li>
<li>If k &gt; N, N &lt; 0, or k &lt; 0, then a 0 is returned.</li>
</ul>
<h2 id="examples_148">Examples<a class="headerlink" href="#examples_148" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import perm
k = np.array([3, 4])
n = np.array([10, 10])
perm(n, k)
array([  720.,  5040.])
perm(10, 3, exact=True)
720</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">poch</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>poch(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>poch(z, m)</p>
<p>Pochhammer symbol.</p>
<p>The Pochhammer symbol (rising factorial) is defined as</p>
<p>.. math::</p>
<p>(z)_m = \frac{\Gamma(z + m)}{\Gamma(z)}</p>
<p>For positive integer <code>m</code> it reads</p>
<p>.. math::</p>
<p>(z)_m = z (z + 1) ... (z + m - 1)</p>
<p>See [dlmf]_ for more details.</p>
<h2 id="parameters_419">Parameters<a class="headerlink" href="#parameters_419" title="Permanent link">&para;</a></h2>
<p>z, m : array_like
Real-valued arguments.</p>
<h2 id="returns_448">Returns<a class="headerlink" href="#returns_448" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
The value of the function.</p>
<h2 id="references_328">References<a class="headerlink" href="#references_328" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] Nist, Digital Library of Mathematical Functions
https://dlmf.nist.gov/5.2#iii</p>
<h2 id="examples_149">Examples<a class="headerlink" href="#examples_149" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is 1 when m is 0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.poch([1, 2, 3, 4], 0)
array([1., 1., 1., 1.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>For z equal to 1 it reduces to the factorial function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.poch(1, 5)
120.0
1 * 2 * 3 * 4 * 5
120</p>
</blockquote>
</blockquote>
</blockquote>
<p>It can be expressed in terms of the Gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>z, m = 3.7, 2.1
sc.poch(z, m)
20.529581933776953
sc.gamma(z + m) / sc.gamma(z)
20.52958193377696</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">polygamma</span> <span class="o">:</span> <span class="n">n</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Polygamma functions.</p>
<p>Defined as :math:<code>\psi^{(n)}(x)</code> where :math:<code>\psi</code> is the
<code>digamma</code> function. See [dlmf]_ for details.</p>
<h2 id="parameters_420">Parameters<a class="headerlink" href="#parameters_420" title="Permanent link">&para;</a></h2>
<p>n : array_like
The order of the derivative of the digamma function; must be
integral
x : array_like
Real valued input</p>
<h2 id="returns_449">Returns<a class="headerlink" href="#returns_449" title="Permanent link">&para;</a></h2>
<p>ndarray
Function results</p>
<h2 id="see-also_304">See Also<a class="headerlink" href="#see-also_304" title="Permanent link">&para;</a></h2>
<p>digamma</p>
<h2 id="references_329">References<a class="headerlink" href="#references_329" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST, Digital Library of Mathematical Functions,
https://dlmf.nist.gov/5.15</p>
<h2 id="examples_150">Examples<a class="headerlink" href="#examples_150" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
x = [2, 3, 25.5]
special.polygamma(1, x)
array([ 0.64493407,  0.39493407,  0.03999467])
special.polygamma(0, x) == special.psi(x)
array([ True,  True,  True], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_ang1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pro_ang1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_ang1(m, n, c, x)</p>
<p>Prolate spheroidal angular function of the first kind and its derivative</p>
<p>Computes the prolate spheroidal angular function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>.</p>
<h2 id="returns_450">Returns<a class="headerlink" href="#returns_450" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_ang1_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pro_ang1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_ang1_cv(m, n, c, cv, x)</p>
<p>Prolate spheroidal angular function pro_ang1 for precomputed characteristic value</p>
<p>Computes the prolate spheroidal angular function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>. Requires
pre-computed characteristic value.</p>
<h2 id="returns_451">Returns<a class="headerlink" href="#returns_451" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>pro_cv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_cv(m, n, c)</p>
<p>Characteristic value of prolate spheroidal function</p>
<p>Computes the characteristic value of prolate spheroidal wave
functions of order <code>m</code>, <code>n</code> (n&gt;=m) and spheroidal parameter <code>c</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_cv_seq</span> <span class="o">:</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Characteristic values for prolate spheroidal wave functions.</p>
<p>Compute a sequence of characteristic values for the prolate
spheroidal wave functions for mode m and n'=m..n and spheroidal
parameter c.</p>
<h2 id="references_330">References<a class="headerlink" href="#references_330" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_rad1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pro_rad1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_rad1(m, n, c, x)</p>
<p>Prolate spheroidal radial function of the first kind and its derivative</p>
<p>Computes the prolate spheroidal radial function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>.</p>
<h2 id="returns_452">Returns<a class="headerlink" href="#returns_452" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_rad1_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pro_rad1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_rad1_cv(m, n, c, cv, x)</p>
<p>Prolate spheroidal radial function pro_rad1 for precomputed characteristic value</p>
<p>Computes the prolate spheroidal radial function of the first kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>. Requires
pre-computed characteristic value.</p>
<h2 id="returns_453">Returns<a class="headerlink" href="#returns_453" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_rad2</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pro_rad2(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_rad2(m, n, c, x)</p>
<p>Prolate spheroidal radial function of the second kind and its derivative</p>
<p>Computes the prolate spheroidal radial function of the second kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>.</p>
<h2 id="returns_454">Returns<a class="headerlink" href="#returns_454" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pro_rad2_cv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>pro_rad2_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pro_rad2_cv(m, n, c, cv, x)</p>
<p>Prolate spheroidal radial function pro_rad2 for precomputed characteristic value</p>
<p>Computes the prolate spheroidal radial function of the second kind
and its derivative (with respect to <code>x</code>) for mode parameters m&gt;=0
and n&gt;=m, spheroidal parameter <code>c</code> and <code>|x| &lt; 1.0</code>. Requires
pre-computed characteristic value.</p>
<h2 id="returns_455">Returns<a class="headerlink" href="#returns_455" title="Permanent link">&para;</a></h2>
<p>s
Value of the function
sp
Value of the derivative vs x</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ps_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Legendre (shifted) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Legendre
quadrature. The sample points are the roots of the n-th degree
shifted Legendre polynomial :math:<code>P^*_n(x)</code>. These sample points
and weights correctly integrate polynomials of degree :math:<code>2n -
1</code> or less over the interval :math:<code>[0, 1]</code> with weight function
:math:<code>w(x) = 1.0</code>. See 2.2.11 in [AS]_ for details.</p>
<h2 id="parameters_421">Parameters<a class="headerlink" href="#parameters_421" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_456">Returns<a class="headerlink" href="#returns_456" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_305">See Also<a class="headerlink" href="#see-also_305" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_331">References<a class="headerlink" href="#references_331" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pseudo_huber</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>pseudo_huber(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>pseudo_huber(delta, r)</p>
<p>Pseudo-Huber loss function.</p>
<p>.. math:: \mathrm{pseudo_huber}(\delta, r) = \delta^2 \left( \sqrt{ 1 + \left( \frac{r}{\delta} \right)^2 } - 1 \right)</p>
<h2 id="parameters_422">Parameters<a class="headerlink" href="#parameters_422" title="Permanent link">&para;</a></h2>
<p>delta : ndarray
Input array, indicating the soft quadratic vs. linear loss changepoint.
r : ndarray
Input array, possibly representing residuals.</p>
<h2 id="returns_457">Returns<a class="headerlink" href="#returns_457" title="Permanent link">&para;</a></h2>
<p>res : ndarray
The computed Pseudo-Huber loss function values.</p>
<h2 id="notes_259">Notes<a class="headerlink" href="#notes_259" title="Permanent link">&para;</a></h2>
<p>This function is convex in :math:<code>r</code>.</p>
<p>.. versionadded:: 0.15.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">psi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>psi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>psi(z, out=None)</p>
<p>The digamma function.</p>
<p>The logarithmic derivative of the gamma function evaluated at <code>z</code>.</p>
<h2 id="parameters_423">Parameters<a class="headerlink" href="#parameters_423" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex argument.
out : ndarray, optional
Array for the computed values of <code>psi</code>.</p>
<h2 id="returns_458">Returns<a class="headerlink" href="#returns_458" title="Permanent link">&para;</a></h2>
<p>digamma : ndarray
Computed values of <code>psi</code>.</p>
<h2 id="notes_260">Notes<a class="headerlink" href="#notes_260" title="Permanent link">&para;</a></h2>
<p>For large values not close to the negative real axis <code>psi</code> is
computed using the asymptotic series (5.11.2) from [1]<em>. For small
arguments not close to the negative real axis the recurrence
relation (5.5.2) from [1]</em> is used until the argument is large
enough to use the asymptotic series. For values close to the
negative real axis the reflection formula (5.5.4) from [1]<em> is
used first.  Note that <code>psi</code> has a family of zeros on the
negative real axis which occur between the poles at nonpositive
integers. Around the zeros the reflection formula suffers from
cancellation and the implementation loses precision. The sole
positive zero and the first negative zero, however, are handled
separately by precomputing series expansions using [2]</em>, so the
function should maintain full accuracy around the origin.</p>
<h2 id="references_332">References<a class="headerlink" href="#references_332" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/5
.. [2] Fredrik Johansson and others.
'mpmath: a Python library for arbitrary-precision floating-point arithmetic'
(Version 0.19) http://mpmath.org/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">radian</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>radian(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>radian(d, m, s)</p>
<p>Convert from degrees to radians</p>
<p>Returns the angle given in (d)egrees, (m)inutes, and (s)econds in
radians.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rel_entr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rel_entr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>rel_entr(x, y, out=None)</p>
<p>Elementwise function for computing relative entropy.</p>
<p>.. math::</p>
<p>\mathrm{rel_entr}(x, y) =
\begin{cases}
x \log(x / y) &amp; x &gt; 0, y &gt; 0 \
0 &amp; x = 0, y \ge 0 \
\infty &amp; \text{otherwise}
\end{cases}</p>
<h2 id="parameters_424">Parameters<a class="headerlink" href="#parameters_424" title="Permanent link">&para;</a></h2>
<p>x, y : array_like
Input arrays
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_459">Returns<a class="headerlink" href="#returns_459" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Relative entropy of the inputs</p>
<h2 id="see-also_306">See Also<a class="headerlink" href="#see-also_306" title="Permanent link">&para;</a></h2>
<p>entr, kl_div</p>
<h2 id="notes_261">Notes<a class="headerlink" href="#notes_261" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.15.0</p>
<p>This function is jointly convex in x and y.</p>
<p>The origin of this function is in convex programming; see
[1]_. Given two discrete probability distributions :math:<code>p_1,
\ldots, p_n</code> and :math:<code>q_1, \ldots, q_n</code>, to get the relative
entropy of statistics compute the sum</p>
<p>.. math::</p>
<p>\sum_{i = 1}^n \mathrm{rel_entr}(p_i, q_i).</p>
<p>See [2]_ for details.</p>
<h2 id="references_333">References<a class="headerlink" href="#references_333" title="Permanent link">&para;</a></h2>
<p>.. [1] Grant, Boyd, and Ye, 'CVX: Matlab Software for Disciplined Convex
Programming', http://cvxr.com/cvx/
.. [2] Kullback-Leibler divergence,
https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rgamma</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rgamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>rgamma(z, out=None)</p>
<p>Reciprocal of the Gamma function.</p>
<p>Defined as :math:<code>1 / \Gamma(z)</code>, where :math:<code>\Gamma</code> is the
Gamma function. For more on the Gamma function see <code>gamma</code>.</p>
<h2 id="parameters_425">Parameters<a class="headerlink" href="#parameters_425" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex valued input
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_460">Returns<a class="headerlink" href="#returns_460" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Function results</p>
<h2 id="notes_262">Notes<a class="headerlink" href="#notes_262" title="Permanent link">&para;</a></h2>
<p>The Gamma function has no zeros and has simple poles at
nonpositive integers, so <code>rgamma</code> is an entire function with zeros
at the nonpositive integers. See the discussion in [dlmf]_ for
more details.</p>
<h2 id="see-also_307">See Also<a class="headerlink" href="#see-also_307" title="Permanent link">&para;</a></h2>
<p>gamma, gammaln, loggamma</p>
<h2 id="references_334">References<a class="headerlink" href="#references_334" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] Nist, Digital Library of Mathematical functions,
https://dlmf.nist.gov/5.2#i</p>
<h2 id="examples_151">Examples<a class="headerlink" href="#examples_151" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.special as sc</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is the reciprocal of the Gamma function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.rgamma([1, 2, 3, 4])
array([1.        , 1.        , 0.5       , 0.16666667])
1 / sc.gamma([1, 2, 3, 4])
array([1.        , 1.        , 0.5       , 0.16666667])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is zero at nonpositive integers.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.rgamma([0, -1, -2, -3])
array([0., 0., 0., 0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It rapidly underflows to zero along the positive real axis.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sc.rgamma([10, 100, 179])
array([2.75573192e-006, 1.07151029e-156, 0.00000000e+000])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">riccati_jn</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute Ricatti-Bessel function of the first kind and its derivative.</p>
<p>The Ricatti-Bessel function of the first kind is defined as :math:<code>x
j_n(x)</code>, where :math:<code>j_n</code> is the spherical Bessel function of the first
kind of order :math:<code>n</code>.</p>
<p>This function computes the value and first derivative of the
Ricatti-Bessel function for all orders up to and including <code>n</code>.</p>
<h2 id="parameters_426">Parameters<a class="headerlink" href="#parameters_426" title="Permanent link">&para;</a></h2>
<p>n : int
Maximum order of function to compute
x : float
Argument at which to evaluate</p>
<h2 id="returns_461">Returns<a class="headerlink" href="#returns_461" title="Permanent link">&para;</a></h2>
<p>jn : ndarray
Value of j0(x), ..., jn(x)
jnp : ndarray
First derivative j0'(x), ..., jn'(x)</p>
<h2 id="notes_263">Notes<a class="headerlink" href="#notes_263" title="Permanent link">&para;</a></h2>
<p>The computation is carried out via backward recurrence, using the
relation DLMF 10.51.1 [2]_.</p>
<p>Wrapper for a Fortran routine created by Shanjie Zhang and Jianming
Jin [1]_.</p>
<h2 id="references_335">References<a class="headerlink" href="#references_335" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html
.. [2] NIST Digital Library of Mathematical Functions.
https://dlmf.nist.gov/10.51.E1</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">riccati_yn</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute Ricatti-Bessel function of the second kind and its derivative.</p>
<p>The Ricatti-Bessel function of the second kind is defined as :math:<code>x
y_n(x)</code>, where :math:<code>y_n</code> is the spherical Bessel function of the second
kind of order :math:<code>n</code>.</p>
<p>This function computes the value and first derivative of the function for
all orders up to and including <code>n</code>.</p>
<h2 id="parameters_427">Parameters<a class="headerlink" href="#parameters_427" title="Permanent link">&para;</a></h2>
<p>n : int
Maximum order of function to compute
x : float
Argument at which to evaluate</p>
<h2 id="returns_462">Returns<a class="headerlink" href="#returns_462" title="Permanent link">&para;</a></h2>
<p>yn : ndarray
Value of y0(x), ..., yn(x)
ynp : ndarray
First derivative y0'(x), ..., yn'(x)</p>
<h2 id="notes_264">Notes<a class="headerlink" href="#notes_264" title="Permanent link">&para;</a></h2>
<p>The computation is carried out via ascending recurrence, using the
relation DLMF 10.51.1 [2]_.</p>
<p>Wrapper for a Fortran routine created by Shanjie Zhang and Jianming
Jin [1]_.</p>
<h2 id="references_336">References<a class="headerlink" href="#references_336" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html
.. [2] NIST Digital Library of Mathematical Functions.
https://dlmf.nist.gov/10.51.E1</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_chebyc</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (first kind) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the first kind, :math:<code>C_n(x)</code>. These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-2, 2]</code>
with weight function :math:<code>w(x) = 1 / \sqrt{1 - (x/2)^2}</code>. See
22.2.6 in [AS]_ for more details.</p>
<h2 id="parameters_428">Parameters<a class="headerlink" href="#parameters_428" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_463">Returns<a class="headerlink" href="#returns_463" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_308">See Also<a class="headerlink" href="#see-also_308" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_337">References<a class="headerlink" href="#references_337" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_chebys</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (second kind) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the second kind, :math:<code>S_n(x)</code>. These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-2, 2]</code>
with weight function :math:<code>w(x) = \sqrt{1 - (x/2)^2}</code>. See 22.2.7
in [AS]_ for more details.</p>
<h2 id="parameters_429">Parameters<a class="headerlink" href="#parameters_429" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_464">Returns<a class="headerlink" href="#returns_464" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_309">See Also<a class="headerlink" href="#see-also_309" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_338">References<a class="headerlink" href="#references_338" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (first kind) quadrature.</p>
<p>Computes the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the first kind, :math:<code>T_n(x)</code>.  These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code>
with weight function :math:<code>w(x) = 1/\sqrt{1 - x^2}</code>. See 22.2.4
in [AS]_ for more details.</p>
<h2 id="parameters_430">Parameters<a class="headerlink" href="#parameters_430" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_465">Returns<a class="headerlink" href="#returns_465" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_310">See Also<a class="headerlink" href="#see-also_310" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.chebyshev.chebgauss</p>
<h2 id="references_339">References<a class="headerlink" href="#references_339" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (second kind) quadrature.</p>
<p>Computes the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the second kind, :math:<code>U_n(x)</code>. These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code>
with weight function :math:<code>w(x) = \sqrt{1 - x^2}</code>. See 22.2.5 in
[AS]_ for details.</p>
<h2 id="parameters_431">Parameters<a class="headerlink" href="#parameters_431" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_466">Returns<a class="headerlink" href="#returns_466" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_311">See Also<a class="headerlink" href="#see-also_311" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_340">References<a class="headerlink" href="#references_340" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_gegenbauer</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Gegenbauer quadrature.</p>
<p>Compute the sample points and weights for Gauss-Gegenbauer
quadrature. The sample points are the roots of the n-th degree
Gegenbauer polynomial, :math:<code>C^{\alpha}_n(x)</code>. These sample
points and weights correctly integrate polynomials of degree
:math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code> with
weight function :math:<code>w(x) = (1 - x^2)^{\alpha - 1/2}</code>. See
22.2.3 in [AS]_ for more details.</p>
<h2 id="parameters_432">Parameters<a class="headerlink" href="#parameters_432" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
alpha : float
alpha must be &gt; -0.5
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_467">Returns<a class="headerlink" href="#returns_467" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_312">See Also<a class="headerlink" href="#see-also_312" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_341">References<a class="headerlink" href="#references_341" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_genlaguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-generalized Laguerre quadrature.</p>
<p>Compute the sample points and weights for Gauss-generalized
Laguerre quadrature. The sample points are the roots of the n-th
degree generalized Laguerre polynomial, :math:<code>L^{\alpha}_n(x)</code>.
These sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[0,
\infty]</code> with weight function :math:<code>w(x) = x^{\alpha}
e^{-x}</code>. See 22.3.9 in [AS]_ for details.</p>
<h2 id="parameters_433">Parameters<a class="headerlink" href="#parameters_433" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
alpha : float
alpha must be &gt; -1
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_468">Returns<a class="headerlink" href="#returns_468" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_313">See Also<a class="headerlink" href="#see-also_313" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_342">References<a class="headerlink" href="#references_342" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_hermite</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Hermite (physicst's) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Hermite
quadrature. The sample points are the roots of the n-th degree
Hermite polynomial, :math:<code>H_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[-\infty, \infty]</code> with weight
function :math:<code>w(x) = e^{-x^2}</code>. See 22.2.14 in [AS]_ for
details.</p>
<h2 id="parameters_434">Parameters<a class="headerlink" href="#parameters_434" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_469">Returns<a class="headerlink" href="#returns_469" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="notes_265">Notes<a class="headerlink" href="#notes_265" title="Permanent link">&para;</a></h2>
<p>For small n up to 150 a modified version of the Golub-Welsch
algorithm is used. Nodes are computed from the eigenvalue
problem and improved by one step of a Newton iteration.
The weights are computed from the well-known analytical formula.</p>
<p>For n larger than 150 an optimal asymptotic algorithm is applied
which computes nodes and weights in a numerically stable manner.
The algorithm has linear runtime making computation for very
large n (several thousand or more) feasible.</p>
<h2 id="see-also_314">See Also<a class="headerlink" href="#see-also_314" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.hermite.hermgauss
roots_hermitenorm</p>
<h2 id="references_343">References<a class="headerlink" href="#references_343" title="Permanent link">&para;</a></h2>
<p>.. [townsend.trogdon.olver-2014]
Townsend, A. and Trogdon, T. and Olver, S. (2014)
<em>Fast computation of Gauss quadrature nodes and
weights on the whole real line</em>. :arXiv:<code>1410.5286</code>.
.. [townsend.trogdon.olver-2015]
Townsend, A. and Trogdon, T. and Olver, S. (2015)
<em>Fast computation of Gauss quadrature nodes and
weights on the whole real line</em>.
IMA Journal of Numerical Analysis
:doi:<code>10.1093/imanum/drv002</code>.
.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_hermitenorm</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Hermite (statistician's) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Hermite
quadrature. The sample points are the roots of the n-th degree
Hermite polynomial, :math:<code>He_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[-\infty, \infty]</code> with weight
function :math:<code>w(x) = e^{-x^2/2}</code>. See 22.2.15 in [AS]_ for more
details.</p>
<h2 id="parameters_435">Parameters<a class="headerlink" href="#parameters_435" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_470">Returns<a class="headerlink" href="#returns_470" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="notes_266">Notes<a class="headerlink" href="#notes_266" title="Permanent link">&para;</a></h2>
<p>For small n up to 150 a modified version of the Golub-Welsch
algorithm is used. Nodes are computed from the eigenvalue
problem and improved by one step of a Newton iteration.
The weights are computed from the well-known analytical formula.</p>
<p>For n larger than 150 an optimal asymptotic algorithm is used
which computes nodes and weights in a numerical stable manner.
The algorithm has linear runtime making computation for very
large n (several thousand or more) feasible.</p>
<h2 id="see-also_315">See Also<a class="headerlink" href="#see-also_315" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.hermite_e.hermegauss</p>
<h2 id="references_344">References<a class="headerlink" href="#references_344" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">beta</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Jacobi quadrature.</p>
<p>Compute the sample points and weights for Gauss-Jacobi
quadrature. The sample points are the roots of the n-th degree
Jacobi polynomial, :math:<code>P^{\alpha, \beta}_n(x)</code>. These sample
points and weights correctly integrate polynomials of degree
:math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code> with
weight function :math:<code>w(x) = (1 - x)^{\alpha} (1 +
x)^{\beta}</code>. See 22.2.1 in [AS]_ for details.</p>
<h2 id="parameters_436">Parameters<a class="headerlink" href="#parameters_436" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
alpha : float
alpha must be &gt; -1
beta : float
beta must be &gt; -1
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_471">Returns<a class="headerlink" href="#returns_471" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_316">See Also<a class="headerlink" href="#see-also_316" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_345">References<a class="headerlink" href="#references_345" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_laguerre</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Laguerre quadrature.</p>
<p>Compute the sample points and weights for Gauss-Laguerre
quadrature. The sample points are the roots of the n-th degree
Laguerre polynomial, :math:<code>L_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[0, \infty]</code> with weight function
:math:<code>w(x) = e^{-x}</code>. See 22.2.13 in [AS]_ for details.</p>
<h2 id="parameters_437">Parameters<a class="headerlink" href="#parameters_437" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_472">Returns<a class="headerlink" href="#returns_472" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_317">See Also<a class="headerlink" href="#see-also_317" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.laguerre.laggauss</p>
<h2 id="references_346">References<a class="headerlink" href="#references_346" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Legendre quadrature.</p>
<p>Compute the sample points and weights for Gauss-Legendre
quadrature. The sample points are the roots of the n-th degree
Legendre polynomial :math:<code>P_n(x)</code>. These sample points and
weights correctly integrate polynomials of degree :math:<code>2n - 1</code>
or less over the interval :math:<code>[-1, 1]</code> with weight function
:math:<code>w(x) = 1.0</code>. See 2.2.10 in [AS]_ for more details.</p>
<h2 id="parameters_438">Parameters<a class="headerlink" href="#parameters_438" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_473">Returns<a class="headerlink" href="#returns_473" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_318">See Also<a class="headerlink" href="#see-also_318" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.legendre.leggauss</p>
<h2 id="references_347">References<a class="headerlink" href="#references_347" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_sh_chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (first kind, shifted) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
shifted Chebyshev polynomial of the first kind, :math:<code>T_n(x)</code>.
These sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[0, 1]</code>
with weight function :math:<code>w(x) = 1/\sqrt{x - x^2}</code>. See 22.2.8
in [AS]_ for more details.</p>
<h2 id="parameters_439">Parameters<a class="headerlink" href="#parameters_439" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_474">Returns<a class="headerlink" href="#returns_474" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_319">See Also<a class="headerlink" href="#see-also_319" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_348">References<a class="headerlink" href="#references_348" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_sh_chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (second kind, shifted) quadrature.</p>
<p>Computes the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
shifted Chebyshev polynomial of the second kind, :math:<code>U_n(x)</code>.
These sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[0, 1]</code>
with weight function :math:<code>w(x) = \sqrt{x - x^2}</code>. See 22.2.9 in
[AS]_ for more details.</p>
<h2 id="parameters_440">Parameters<a class="headerlink" href="#parameters_440" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_475">Returns<a class="headerlink" href="#returns_475" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_320">See Also<a class="headerlink" href="#see-also_320" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_349">References<a class="headerlink" href="#references_349" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_sh_jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">p1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">q1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Jacobi (shifted) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Jacobi (shifted)
quadrature. The sample points are the roots of the n-th degree
shifted Jacobi polynomial, :math:<code>G^{p,q}_n(x)</code>. These sample
points and weights correctly integrate polynomials of degree
:math:<code>2n - 1</code> or less over the interval :math:<code>[0, 1]</code> with
weight function :math:<code>w(x) = (1 - x)^{p-q} x^{q-1}</code>. See 22.2.2
in [AS]_ for details.</p>
<h2 id="parameters_441">Parameters<a class="headerlink" href="#parameters_441" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
p1 : float
(p1 - q1) must be &gt; -1
q1 : float
q1 must be &gt; 0
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_476">Returns<a class="headerlink" href="#returns_476" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_321">See Also<a class="headerlink" href="#see-also_321" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_350">References<a class="headerlink" href="#references_350" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots_sh_legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Legendre (shifted) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Legendre
quadrature. The sample points are the roots of the n-th degree
shifted Legendre polynomial :math:<code>P^*_n(x)</code>. These sample points
and weights correctly integrate polynomials of degree :math:<code>2n -
1</code> or less over the interval :math:<code>[0, 1]</code> with weight function
:math:<code>w(x) = 1.0</code>. See 2.2.11 in [AS]_ for details.</p>
<h2 id="parameters_442">Parameters<a class="headerlink" href="#parameters_442" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_477">Returns<a class="headerlink" href="#returns_477" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_322">See Also<a class="headerlink" href="#see-also_322" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_351">References<a class="headerlink" href="#references_351" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">round</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>round(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>round(x)</p>
<p>Round to nearest integer</p>
<p>Returns the nearest integer to <code>x</code> as a double precision floating
point result.  If <code>x</code> ends in 0.5 exactly, the nearest even integer
is chosen.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">s_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (second kind) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the second kind, :math:<code>S_n(x)</code>. These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-2, 2]</code>
with weight function :math:<code>w(x) = \sqrt{1 - (x/2)^2}</code>. See 22.2.7
in [AS]_ for more details.</p>
<h2 id="parameters_443">Parameters<a class="headerlink" href="#parameters_443" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_478">Returns<a class="headerlink" href="#returns_478" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_323">See Also<a class="headerlink" href="#see-also_323" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_352">References<a class="headerlink" href="#references_352" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sh_chebyt</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shifted Chebyshev polynomial of the first kind.</p>
<p>Defined as :math:<code>T^*_n(x) = T_n(2x - 1)</code> for :math:<code>T_n</code> the nth
Chebyshev polynomial of the first kind.</p>
<h2 id="parameters_444">Parameters<a class="headerlink" href="#parameters_444" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_479">Returns<a class="headerlink" href="#returns_479" title="Permanent link">&para;</a></h2>
<p>T : orthopoly1d
Shifted Chebyshev polynomial of the first kind.</p>
<h2 id="notes_267">Notes<a class="headerlink" href="#notes_267" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>T^*_n</code> are orthogonal over :math:<code>[0, 1]</code>
with weight function :math:<code>(x - x^2)^{-1/2}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sh_chebyu</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shifted Chebyshev polynomial of the second kind.</p>
<p>Defined as :math:<code>U^*_n(x) = U_n(2x - 1)</code> for :math:<code>U_n</code> the nth
Chebyshev polynomial of the second kind.</p>
<h2 id="parameters_445">Parameters<a class="headerlink" href="#parameters_445" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_480">Returns<a class="headerlink" href="#returns_480" title="Permanent link">&para;</a></h2>
<p>U : orthopoly1d
Shifted Chebyshev polynomial of the second kind.</p>
<h2 id="notes_268">Notes<a class="headerlink" href="#notes_268" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>U^*_n</code> are orthogonal over :math:<code>[0, 1]</code>
with weight function :math:<code>(x - x^2)^{1/2}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sh_jacobi</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shifted Jacobi polynomial.</p>
<p>Defined by</p>
<p>.. math::</p>
<p>G_n^{(p, q)}(x)
= \binom{2n + p - 1}{n}^{-1}P_n^{(p - q, q - 1)}(2x - 1),</p>
<p>where :math:<code>P_n^{(\cdot, \cdot)}</code> is the nth Jacobi polynomial.</p>
<h2 id="parameters_446">Parameters<a class="headerlink" href="#parameters_446" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
p : float
Parameter, must have :math:<code>p &gt; q - 1</code>.
q : float
Parameter, must be greater than 0.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_481">Returns<a class="headerlink" href="#returns_481" title="Permanent link">&para;</a></h2>
<p>G : orthopoly1d
Shifted Jacobi polynomial.</p>
<h2 id="notes_269">Notes<a class="headerlink" href="#notes_269" title="Permanent link">&para;</a></h2>
<p>For fixed :math:<code>p, q</code>, the polynomials :math:<code>G_n^{(p, q)}</code> are
orthogonal over :math:<code>[0, 1]</code> with weight function :math:<code>(1 -
x)^{p - q}x^{q - 1}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sh_legendre</span> <span class="o">:</span> <span class="o">?</span><span class="n">monic</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shifted Legendre polynomial.</p>
<p>Defined as :math:<code>P^*_n(x) = P_n(2x - 1)</code> for :math:<code>P_n</code> the nth
Legendre polynomial.</p>
<h2 id="parameters_447">Parameters<a class="headerlink" href="#parameters_447" title="Permanent link">&para;</a></h2>
<p>n : int
Degree of the polynomial.
monic : bool, optional
If <code>True</code>, scale the leading coefficient to be 1. Default is
<code>False</code>.</p>
<h2 id="returns_482">Returns<a class="headerlink" href="#returns_482" title="Permanent link">&para;</a></h2>
<p>P : orthopoly1d
Shifted Legendre polynomial.</p>
<h2 id="notes_270">Notes<a class="headerlink" href="#notes_270" title="Permanent link">&para;</a></h2>
<p>The polynomials :math:<code>P^*_n</code> are orthogonal over :math:<code>[0, 1]</code>
with weight function 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shichi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>shichi(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>shichi(x, out=None)</p>
<p>Hyperbolic sine and cosine integrals.</p>
<p>The hyperbolic sine integral is</p>
<p>.. math::</p>
<p>\int_0^x \frac{\sinh{t}}{t}dt</p>
<p>and the hyperbolic cosine integral is</p>
<p>.. math::</p>
<p>\gamma + \log(x) + \int_0^x \frac{\cosh{t} - 1}{t} dt</p>
<p>where :math:<code>\gamma</code> is Euler's constant and :math:<code>\log</code> is the
principle branch of the logarithm.</p>
<h2 id="parameters_448">Parameters<a class="headerlink" href="#parameters_448" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real or complex points at which to compute the hyperbolic sine
and cosine integrals.</p>
<h2 id="returns_483">Returns<a class="headerlink" href="#returns_483" title="Permanent link">&para;</a></h2>
<p>si : ndarray
Hyperbolic sine integral at <code>x</code>
ci : ndarray
Hyperbolic cosine integral at <code>x</code></p>
<h2 id="notes_271">Notes<a class="headerlink" href="#notes_271" title="Permanent link">&para;</a></h2>
<p>For real arguments with <code>x &lt; 0</code>, <code>chi</code> is the real part of the
hyperbolic cosine integral. For such points <code>chi(x)</code> and <code>chi(x
+ 0j)</code> differ by a factor of <code>1j*pi</code>.</p>
<p>For real arguments the function is computed by calling Cephes'
[1]<em> <em>shichi</em> routine. For complex arguments the algorithm is based
on Mpmath's [2]</em> <em>shi</em> and <em>chi</em> routines.</p>
<h2 id="references_353">References<a class="headerlink" href="#references_353" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/
.. [2] Fredrik Johansson and others.
'mpmath: a Python library for arbitrary-precision floating-point arithmetic'
(Version 0.19) http://mpmath.org/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sici</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>sici(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>sici(x, out=None)</p>
<p>Sine and cosine integrals.</p>
<p>The sine integral is</p>
<p>.. math::</p>
<p>\int_0^x \frac{\sin{t}}{t}dt</p>
<p>and the cosine integral is</p>
<p>.. math::</p>
<p>\gamma + \log(x) + \int_0^x \frac{\cos{t} - 1}{t}dt</p>
<p>where :math:<code>\gamma</code> is Euler's constant and :math:<code>\log</code> is the
principle branch of the logarithm.</p>
<h2 id="parameters_449">Parameters<a class="headerlink" href="#parameters_449" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real or complex points at which to compute the sine and cosine
integrals.</p>
<h2 id="returns_484">Returns<a class="headerlink" href="#returns_484" title="Permanent link">&para;</a></h2>
<p>si : ndarray
Sine integral at <code>x</code>
ci : ndarray
Cosine integral at <code>x</code></p>
<h2 id="notes_272">Notes<a class="headerlink" href="#notes_272" title="Permanent link">&para;</a></h2>
<p>For real arguments with <code>x &lt; 0</code>, <code>ci</code> is the real part of the
cosine integral. For such points <code>ci(x)</code> and <code>ci(x + 0j)</code>
differ by a factor of <code>1j*pi</code>.</p>
<p>For real arguments the function is computed by calling Cephes'
[1]<em> <em>sici</em> routine. For complex arguments the algorithm is based
on Mpmath's [2]</em> <em>si</em> and <em>ci</em> routines.</p>
<h2 id="references_354">References<a class="headerlink" href="#references_354" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/
.. [2] Fredrik Johansson and others.
'mpmath: a Python library for arbitrary-precision floating-point arithmetic'
(Version 0.19) http://mpmath.org/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinc</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the sinc function.</p>
<p>The sinc function is :math:<code>\sin(\pi x)/(\pi x)</code>.</p>
<h2 id="parameters_450">Parameters<a class="headerlink" href="#parameters_450" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Array (possibly multi-dimensional) of values for which to to
calculate <code>sinc(x)</code>.</p>
<h2 id="returns_485">Returns<a class="headerlink" href="#returns_485" title="Permanent link">&para;</a></h2>
<p>out : ndarray
<code>sinc(x)</code>, which has the same shape as the input.</p>
<h2 id="notes_273">Notes<a class="headerlink" href="#notes_273" title="Permanent link">&para;</a></h2>
<p><code>sinc(0)</code> is the limit value 1.</p>
<p>The name sinc is short for 'sine cardinal' or 'sinus cardinalis'.</p>
<p>The sinc function is used in various signal processing applications,
including in anti-aliasing, in the construction of a Lanczos resampling
filter, and in interpolation.</p>
<p>For bandlimited interpolation of discrete-time signals, the ideal
interpolation kernel is proportional to the sinc function.</p>
<h2 id="references_355">References<a class="headerlink" href="#references_355" title="Permanent link">&para;</a></h2>
<p>.. [1] Weisstein, Eric W. 'Sinc Function.' From MathWorld--A Wolfram Web
Resource. http://mathworld.wolfram.com/SincFunction.html
.. [2] Wikipedia, 'Sinc function',
https://en.wikipedia.org/wiki/Sinc_function</p>
<h2 id="examples_152">Examples<a class="headerlink" href="#examples_152" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
x = np.linspace(-4, 4, 41)
np.sinc(x)
array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary
-8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
-1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
-2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
-3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
-5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
-4.92362781e-02,  -3.89804309e-17])</p>
<p>plt.plot(x, np.sinc(x))
[<matplotlib.lines.Line2D object at 0x...>]
plt.title('Sinc Function')
Text(0.5, 1.0, 'Sinc Function')
plt.ylabel('Amplitude')
Text(0, 0.5, 'Amplitude')
plt.xlabel('X')
Text(0.5, 0, 'X')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sindg</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sindg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>sindg(x)</p>
<p>Sine of angle given in degrees</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">smirnov</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>smirnov(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>smirnov(n, d)</p>
<p>Kolmogorov-Smirnov complementary cumulative distribution function</p>
<p>Returns the exact Kolmogorov-Smirnov complementary cumulative
distribution function,(aka the Survival Function) of Dn+ (or Dn-)
for a one-sided test of equality between an empirical and a
theoretical distribution. It is equal to the probability that the
maximum difference between a theoretical distribution and an empirical
one based on <code>n</code> samples is greater than d.</p>
<h2 id="parameters_451">Parameters<a class="headerlink" href="#parameters_451" title="Permanent link">&para;</a></h2>
<p>n : int
Number of samples
d : float array_like
Deviation between the Empirical CDF (ECDF) and the target CDF.</p>
<h2 id="returns_486">Returns<a class="headerlink" href="#returns_486" title="Permanent link">&para;</a></h2>
<p>float
The value(s) of smirnov(n, d), Prob(Dn+ &gt;= d) (Also Prob(Dn- &gt;= d))</p>
<h2 id="notes_274">Notes<a class="headerlink" href="#notes_274" title="Permanent link">&para;</a></h2>
<p><code>smirnov</code> is used by <code>stats.kstest</code> in the application of the
Kolmogorov-Smirnov Goodness of Fit test. For historial reasons this
function is exposed in <code>scpy.special</code>, but the recommended way to achieve
the most accurate CDF/SF/PDF/PPF/ISF computations is to use the
<code>stats.ksone</code> distribution.</p>
<h2 id="see-also_324">See Also<a class="headerlink" href="#see-also_324" title="Permanent link">&para;</a></h2>
<p>smirnovi : The Inverse Survival Function for the distribution
scipy.stats.ksone : Provides the functionality as a continuous distribution
kolmogorov, kolmogi : Functions for the two-sided distribution</p>
<h2 id="examples_153">Examples<a class="headerlink" href="#examples_153" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import smirnov</p>
</blockquote>
</blockquote>
</blockquote>
<p>Show the probability of a gap at least as big as 0, 0.5 and 1.0 for a sample of size 5</p>
<blockquote>
<blockquote>
<blockquote>
<p>smirnov(5, [0, 0.5, 1.0])
array([ 1.   ,  0.056,  0.   ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare a sample of size 5 drawn from a source N(0.5, 1) distribution against
a target N(0, 1) CDF.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.stats import norm
n = 5
gendist = norm(0.5, 1)       # Normal distribution, mean 0.5, stddev 1
np.random.seed(seed=233423)  # Set the seed for reproducibility
x = np.sort(gendist.rvs(size=n))
x
array([-0.20946287,  0.71688765,  0.95164151,  1.44590852,  3.08880533])
target = norm(0, 1)
cdfs = target.cdf(x)
cdfs
array([ 0.41704346,  0.76327829,  0.82936059,  0.92589857,  0.99899518])</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="construct-the-empirical-cdf-and-the-k-s-statistics-dn-dn-dn_1">Construct the Empirical CDF and the K-S statistics (Dn+, Dn-, Dn)<a class="headerlink" href="#construct-the-empirical-cdf-and-the-k-s-statistics-dn-dn-dn_1" title="Permanent link">&para;</a></h1>
<blockquote>
<blockquote>
<blockquote>
<p>ecdfs = np.arange(n+1, dtype=float)/n
cols = np.column_stack([x, ecdfs[1:], cdfs, cdfs - ecdfs[:n], ecdfs[1:] - cdfs])
np.set_printoptions(precision=3)
cols
array([[ -2.095e-01,   2.000e-01,   4.170e-01,   4.170e-01,  -2.170e-01],
[  7.169e-01,   4.000e-01,   7.633e-01,   5.633e-01,  -3.633e-01],
[  9.516e-01,   6.000e-01,   8.294e-01,   4.294e-01,  -2.294e-01],
[  1.446e+00,   8.000e-01,   9.259e-01,   3.259e-01,  -1.259e-01],
[  3.089e+00,   1.000e+00,   9.990e-01,   1.990e-01,   1.005e-03]])
gaps = cols[:, -2:]
Dnpm = np.max(gaps, axis=0)
print('Dn-=%f, Dn+=%f' % (Dnpm[0], Dnpm[1]))
Dn-=0.563278, Dn+=0.001005
probs = smirnov(n, Dnpm)
print(chr(10).join(['For a sample of size %d drawn from a N(0, 1) distribution:' % n,
...      ' Smirnov n=%d: Prob(Dn- &gt;= %f) = %.4f' % (n, Dnpm[0], probs[0]),
...      ' Smirnov n=%d: Prob(Dn+ &gt;= %f) = %.4f' % (n, Dnpm[1], probs[1])]))
For a sample of size 5 drawn from a N(0, 1) distribution:
Smirnov n=5: Prob(Dn- &gt;= 0.563278) = 0.0250
Smirnov n=5: Prob(Dn+ &gt;= 0.001005) = 0.9990</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the Empirical CDF against the target N(0, 1) CDF</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.step(np.concatenate([[-3], x]), ecdfs, where='post', label='Empirical CDF')
x3 = np.linspace(-3, 3, 100)
plt.plot(x3, target.cdf(x3), label='CDF for N(0, 1)')
plt.ylim([0, 1]); plt.grid(True); plt.legend();</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="add-vertical-lines-marking-dn-and-dn-_3">Add vertical lines marking Dn+ and Dn-<a class="headerlink" href="#add-vertical-lines-marking-dn-and-dn-_3" title="Permanent link">&para;</a></h1>
<blockquote>
<blockquote>
<blockquote>
<p>iminus, iplus = np.argmax(gaps, axis=0)
plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus], color='r', linestyle='dashed', lw=4)
plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1], color='m', linestyle='dashed', lw=4)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">smirnovi</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>smirnovi(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>smirnovi(n, p)</p>
<p>Inverse to <code>smirnov</code></p>
<p>Returns <code>d</code> such that <code>smirnov(n, d) == p</code>, the critical value
corresponding to <code>p</code>.</p>
<h2 id="parameters_452">Parameters<a class="headerlink" href="#parameters_452" title="Permanent link">&para;</a></h2>
<p>n : int
Number of samples
p : float array_like
Probability</p>
<h2 id="returns_487">Returns<a class="headerlink" href="#returns_487" title="Permanent link">&para;</a></h2>
<p>float
The value(s) of smirnovi(n, p), the critical values.</p>
<h2 id="notes_275">Notes<a class="headerlink" href="#notes_275" title="Permanent link">&para;</a></h2>
<p><code>smirnov</code> is used by <code>stats.kstest</code> in the application of the
Kolmogorov-Smirnov Goodness of Fit test. For historial reasons this
function is exposed in <code>scpy.special</code>, but the recommended way to achieve
the most accurate CDF/SF/PDF/PPF/ISF computations is to use the
<code>stats.ksone</code> distribution.</p>
<h2 id="see-also_325">See Also<a class="headerlink" href="#see-also_325" title="Permanent link">&para;</a></h2>
<p>smirnov  : The Survival Function (SF) for the distribution
scipy.stats.ksone : Provides the functionality as a continuous distribution
kolmogorov, kolmogi, scipy.stats.kstwobign : Functions for the two-sided distribution</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">softmax</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Softmax function</p>
<p>The softmax function transforms each element of a collection by
computing the exponential of each element divided by the sum of the
exponentials of all the elements.  That is, if <code>x</code> is a one-dimensional
numpy array::</p>
<p>softmax(x) = np.exp(x)/sum(np.exp(x))</p>
<h2 id="parameters_453">Parameters<a class="headerlink" href="#parameters_453" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
axis : int or tuple of ints, optional
Axis to compute values along. Default is None and softmax will be
computed over the entire array <code>x</code>.</p>
<h2 id="returns_488">Returns<a class="headerlink" href="#returns_488" title="Permanent link">&para;</a></h2>
<p>s : ndarray
An array the same shape as <code>x</code>. The result will sum to 1 along the
specified axis.</p>
<h2 id="notes_276">Notes<a class="headerlink" href="#notes_276" title="Permanent link">&para;</a></h2>
<p>The formula for the softmax function :math:<code>\sigma(x)</code> for a vector
:math:<code>x = \{x_0, x_1, ..., x_{n-1}\}</code> is</p>
<p>.. math:: \sigma(x)_j = \frac{e^{x_j}}{\sum_k e^{x_k}}</p>
<p>The <code>softmax</code> function is the gradient of <code>logsumexp</code>.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="examples_154">Examples<a class="headerlink" href="#examples_154" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import softmax
np.set_printoptions(precision=5)</p>
<p>x = np.array([[1, 0.5, 0.2, 3],
...               [1,  -1,   7, 3],
...               [2,  12,  13, 3]])
...</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the softmax transformation over the entire array.</p>
<blockquote>
<blockquote>
<blockquote>
<p>m = softmax(x)
m
array([[  4.48309e-06,   2.71913e-06,   2.01438e-06,   3.31258e-05],
[  4.48309e-06,   6.06720e-07,   1.80861e-03,   3.31258e-05],
[  1.21863e-05,   2.68421e-01,   7.29644e-01,   3.31258e-05]])</p>
<p>m.sum()
1.0000000000000002</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the softmax transformation along the first axis (i.e. the columns).</p>
<blockquote>
<blockquote>
<blockquote>
<p>m = softmax(x, axis=0)</p>
<p>m
array([[  2.11942e-01,   1.01300e-05,   2.75394e-06,   3.33333e-01],
[  2.11942e-01,   2.26030e-06,   2.47262e-03,   3.33333e-01],
[  5.76117e-01,   9.99988e-01,   9.97525e-01,   3.33333e-01]])</p>
<p>m.sum(axis=0)
array([ 1.,  1.,  1.,  1.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the softmax transformation along the second axis (i.e. the rows).</p>
<blockquote>
<blockquote>
<blockquote>
<p>m = softmax(x, axis=1)
m
array([[  1.05877e-01,   6.42177e-02,   4.75736e-02,   7.82332e-01],
[  2.42746e-03,   3.28521e-04,   9.79307e-01,   1.79366e-02],
[  1.22094e-05,   2.68929e-01,   7.31025e-01,   3.31885e-05]])</p>
<p>m.sum(axis=1)
array([ 1.,  1.,  1.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spence</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>spence(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>spence(z, out=None)</p>
<p>Spence's function, also known as the dilogarithm.</p>
<p>It is defined to be</p>
<p>.. math::
\int_0^z \frac{\log(t)}{1 - t}dt</p>
<p>for complex :math:<code>z</code>, where the contour of integration is taken
to avoid the branch cut of the logarithm. Spence's function is
analytic everywhere except the negative real axis where it has a
branch cut.</p>
<h2 id="parameters_454">Parameters<a class="headerlink" href="#parameters_454" title="Permanent link">&para;</a></h2>
<p>z : array_like
Points at which to evaluate Spence's function</p>
<h2 id="returns_489">Returns<a class="headerlink" href="#returns_489" title="Permanent link">&para;</a></h2>
<p>s : ndarray
Computed values of Spence's function</p>
<h2 id="notes_277">Notes<a class="headerlink" href="#notes_277" title="Permanent link">&para;</a></h2>
<p>There is a different convention which defines Spence's function by
the integral</p>
<p>.. math::
-\int_0^z \frac{\log(1 - t)}{t}dt;</p>
<p>this is our <code>spence(1 - z)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sph_harm</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sph_harm(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>sph_harm(m, n, theta, phi)</p>
<p>Compute spherical harmonics.</p>
<p>The spherical harmonics are defined as</p>
<p>.. math::</p>
<p>Y^m_n(\theta,\phi) = \sqrt{\frac{2n+1}{4\pi} \frac{(n-m)!}{(n+m)!}}
e^{i m \theta} P^m_n(\cos(\phi))</p>
<p>where :math:<code>P_n^m</code> are the associated Legendre functions; see <code>lpmv</code>.</p>
<h2 id="parameters_455">Parameters<a class="headerlink" href="#parameters_455" title="Permanent link">&para;</a></h2>
<p>m : array_like
Order of the harmonic (int); must have <code>|m| &lt;= n</code>.
n : array_like
Degree of the harmonic (int); must have <code>n &gt;= 0</code>. This is
often denoted by <code>l</code> (lower case L) in descriptions of
spherical harmonics.
theta : array_like
Azimuthal (longitudinal) coordinate; must be in <code>[0, 2*pi]</code>.
phi : array_like
Polar (colatitudinal) coordinate; must be in <code>[0, pi]</code>.</p>
<h2 id="returns_490">Returns<a class="headerlink" href="#returns_490" title="Permanent link">&para;</a></h2>
<p>y_mn : complex float
The harmonic :math:<code>Y^m_n</code> sampled at <code>theta</code> and <code>phi</code>.</p>
<h2 id="notes_278">Notes<a class="headerlink" href="#notes_278" title="Permanent link">&para;</a></h2>
<p>There are different conventions for the meanings of the input
arguments <code>theta</code> and <code>phi</code>. In SciPy <code>theta</code> is the
azimuthal angle and <code>phi</code> is the polar angle. It is common to
see the opposite convention, that is, <code>theta</code> as the polar angle
and <code>phi</code> as the azimuthal angle.</p>
<p>Note that SciPy's spherical harmonics include the Condon-Shortley
phase [2]_ because it is part of <code>lpmv</code>.</p>
<p>With SciPy's conventions, the first several spherical harmonics
are</p>
<p>.. math::</p>
<p>Y_0^0(\theta, \phi) &amp;= \frac{1}{2} \sqrt{\frac{1}{\pi}} \
Y_1^{-1}(\theta, \phi) &amp;= \frac{1}{2} \sqrt{\frac{3}{2\pi}}
e^{-i\theta} \sin(\phi) \
Y_1^0(\theta, \phi) &amp;= \frac{1}{2} \sqrt{\frac{3}{\pi}}
\cos(\phi) \
Y_1^1(\theta, \phi) &amp;= -\frac{1}{2} \sqrt{\frac{3}{2\pi}}
e^{i\theta} \sin(\phi).</p>
<h2 id="references_356">References<a class="headerlink" href="#references_356" title="Permanent link">&para;</a></h2>
<p>.. [1] Digital Library of Mathematical Functions, 14.30.
https://dlmf.nist.gov/14.30
.. [2] https://en.wikipedia.org/wiki/Spherical_harmonics#Condon.E2.80.93Shortley_phase</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spherical_in</span> <span class="o">:</span> <span class="o">?</span><span class="n">derivative</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Modified spherical Bessel function of the first kind or its derivative.</p>
<p>Defined as [1]_,</p>
<p>.. math:: i_n(z) = \sqrt{\frac{\pi}{2z}} I_{n + 1/2}(z),</p>
<p>where :math:<code>I_n</code> is the modified Bessel function of the first kind.</p>
<h2 id="parameters_456">Parameters<a class="headerlink" href="#parameters_456" title="Permanent link">&para;</a></h2>
<p>n : int, array_like
Order of the Bessel function (n &gt;= 0).
z : complex or float, array_like
Argument of the Bessel function.
derivative : bool, optional
If True, the value of the derivative (rather than the function
itself) is returned.</p>
<h2 id="returns_491">Returns<a class="headerlink" href="#returns_491" title="Permanent link">&para;</a></h2>
<p>in : ndarray</p>
<h2 id="notes_279">Notes<a class="headerlink" href="#notes_279" title="Permanent link">&para;</a></h2>
<p>The function is computed using its definitional relation to the
modified cylindrical Bessel function of the first kind.</p>
<p>The derivative is computed using the relations [2]_,</p>
<p>.. math::
i_n' = i_{n-1} - \frac{n + 1}{z} i_n.</p>
<p>i_1' = i_0</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="references_357">References<a class="headerlink" href="#references_357" title="Permanent link">&para;</a></h2>
<p>.. [1] https://dlmf.nist.gov/10.47.E7
.. [2] https://dlmf.nist.gov/10.51.E5</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spherical_jn</span> <span class="o">:</span> <span class="o">?</span><span class="n">derivative</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Spherical Bessel function of the first kind or its derivative.</p>
<p>Defined as [1]_,</p>
<p>.. math:: j_n(z) = \sqrt{\frac{\pi}{2z}} J_{n + 1/2}(z),</p>
<p>where :math:<code>J_n</code> is the Bessel function of the first kind.</p>
<h2 id="parameters_457">Parameters<a class="headerlink" href="#parameters_457" title="Permanent link">&para;</a></h2>
<p>n : int, array_like
Order of the Bessel function (n &gt;= 0).
z : complex or float, array_like
Argument of the Bessel function.
derivative : bool, optional
If True, the value of the derivative (rather than the function
itself) is returned.</p>
<h2 id="returns_492">Returns<a class="headerlink" href="#returns_492" title="Permanent link">&para;</a></h2>
<p>jn : ndarray</p>
<h2 id="notes_280">Notes<a class="headerlink" href="#notes_280" title="Permanent link">&para;</a></h2>
<p>For real arguments greater than the order, the function is computed
using the ascending recurrence [2]_.  For small real or complex
arguments, the definitional relation to the cylindrical Bessel function
of the first kind is used.</p>
<p>The derivative is computed using the relations [3]_,</p>
<p>.. math::
j_n'(z) = j_{n-1}(z) - \frac{n + 1}{z} j_n(z).</p>
<p>j_0'(z) = -j_1(z)</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="references_358">References<a class="headerlink" href="#references_358" title="Permanent link">&para;</a></h2>
<p>.. [1] https://dlmf.nist.gov/10.47.E3
.. [2] https://dlmf.nist.gov/10.51.E1
.. [3] https://dlmf.nist.gov/10.51.E2</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spherical_kn</span> <span class="o">:</span> <span class="o">?</span><span class="n">derivative</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Modified spherical Bessel function of the second kind or its derivative.</p>
<p>Defined as [1]_,</p>
<p>.. math:: k_n(z) = \sqrt{\frac{\pi}{2z}} K_{n + 1/2}(z),</p>
<p>where :math:<code>K_n</code> is the modified Bessel function of the second kind.</p>
<h2 id="parameters_458">Parameters<a class="headerlink" href="#parameters_458" title="Permanent link">&para;</a></h2>
<p>n : int, array_like
Order of the Bessel function (n &gt;= 0).
z : complex or float, array_like
Argument of the Bessel function.
derivative : bool, optional
If True, the value of the derivative (rather than the function
itself) is returned.</p>
<h2 id="returns_493">Returns<a class="headerlink" href="#returns_493" title="Permanent link">&para;</a></h2>
<p>kn : ndarray</p>
<h2 id="notes_281">Notes<a class="headerlink" href="#notes_281" title="Permanent link">&para;</a></h2>
<p>The function is computed using its definitional relation to the
modified cylindrical Bessel function of the second kind.</p>
<p>The derivative is computed using the relations [2]_,</p>
<p>.. math::
k_n' = -k_{n-1} - \frac{n + 1}{z} k_n.</p>
<p>k_0' = -k_1</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="references_359">References<a class="headerlink" href="#references_359" title="Permanent link">&para;</a></h2>
<p>.. [1] https://dlmf.nist.gov/10.47.E9
.. [2] https://dlmf.nist.gov/10.51.E5</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spherical_yn</span> <span class="o">:</span> <span class="o">?</span><span class="n">derivative</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Spherical Bessel function of the second kind or its derivative.</p>
<p>Defined as [1]_,</p>
<p>.. math:: y_n(z) = \sqrt{\frac{\pi}{2z}} Y_{n + 1/2}(z),</p>
<p>where :math:<code>Y_n</code> is the Bessel function of the second kind.</p>
<h2 id="parameters_459">Parameters<a class="headerlink" href="#parameters_459" title="Permanent link">&para;</a></h2>
<p>n : int, array_like
Order of the Bessel function (n &gt;= 0).
z : complex or float, array_like
Argument of the Bessel function.
derivative : bool, optional
If True, the value of the derivative (rather than the function
itself) is returned.</p>
<h2 id="returns_494">Returns<a class="headerlink" href="#returns_494" title="Permanent link">&para;</a></h2>
<p>yn : ndarray</p>
<h2 id="notes_282">Notes<a class="headerlink" href="#notes_282" title="Permanent link">&para;</a></h2>
<p>For real arguments, the function is computed using the ascending
recurrence [2]_.  For complex arguments, the definitional relation to
the cylindrical Bessel function of the second kind is used.</p>
<p>The derivative is computed using the relations [3]_,</p>
<p>.. math::
y_n' = y_{n-1} - \frac{n + 1}{z} y_n.</p>
<p>y_0' = -y_1</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="references_360">References<a class="headerlink" href="#references_360" title="Permanent link">&para;</a></h2>
<p>.. [1] https://dlmf.nist.gov/10.47.E4
.. [2] https://dlmf.nist.gov/10.51.E1
.. [3] https://dlmf.nist.gov/10.51.E2</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">stdtr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>stdtr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>stdtr(df, t)</p>
<p>Student t distribution cumulative distribution function</p>
<p>Returns the integral from minus infinity to t of the Student t
distribution with df &gt; 0 degrees of freedom::</p>
<p>gamma((df+1)/2)/(sqrt(df<em>pi)</em>gamma(df/2)) *
integral((1+x<strong>2/df)</strong>(-df/2-1/2), x=-inf..t)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">stdtridf</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>stdtridf(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>stdtridf(p, t)</p>
<p>Inverse of <code>stdtr</code> vs df</p>
<p>Returns the argument df such that stdtr(df, t) is equal to <code>p</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">stdtrit</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>stdtrit(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>stdtrit(df, p)</p>
<p>Inverse of <code>stdtr</code> vs <code>t</code></p>
<p>Returns the argument <code>t</code> such that stdtr(df, t) is equal to <code>p</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">struve</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>struve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>struve(v, x)</p>
<p>Struve function.</p>
<p>Return the value of the Struve function of order <code>v</code> at <code>x</code>.  The Struve
function is defined as,</p>
<p>.. math::
H_v(x) = (z/2)^{v + 1} \sum_{n=0}^\infty \frac{(-1)^n (z/2)^{2n}}{\Gamma(n + \frac{3}{2}) \Gamma(n + v + \frac{3}{2})},</p>
<p>where :math:<code>\Gamma</code> is the gamma function.</p>
<h2 id="parameters_460">Parameters<a class="headerlink" href="#parameters_460" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order of the Struve function (float).
x : array_like
Argument of the Struve function (float; must be positive unless <code>v</code> is
an integer).</p>
<h2 id="returns_495">Returns<a class="headerlink" href="#returns_495" title="Permanent link">&para;</a></h2>
<p>H : ndarray
Value of the Struve function of order <code>v</code> at <code>x</code>.</p>
<h2 id="notes_283">Notes<a class="headerlink" href="#notes_283" title="Permanent link">&para;</a></h2>
<p>Three methods discussed in [1]_ are used to evaluate the Struve function:</p>
<ul>
<li>power series</li>
<li>expansion in Bessel functions (if :math:<code>|z| &lt; |v| + 20</code>)</li>
<li>asymptotic large-z expansion (if :math:<code>z \geq 0.7v + 12</code>)</li>
</ul>
<p>Rounding errors are estimated based on the largest terms in the sums, and
the result associated with the smallest error is returned.</p>
<h2 id="see-also_326">See also<a class="headerlink" href="#see-also_326" title="Permanent link">&para;</a></h2>
<p>modstruve</p>
<h2 id="references_361">References<a class="headerlink" href="#references_361" title="Permanent link">&para;</a></h2>
<p>.. [1] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/11</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">t_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (first kind) quadrature.</p>
<p>Computes the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the first kind, :math:<code>T_n(x)</code>.  These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code>
with weight function :math:<code>w(x) = 1/\sqrt{1 - x^2}</code>. See 22.2.4
in [AS]_ for more details.</p>
<h2 id="parameters_461">Parameters<a class="headerlink" href="#parameters_461" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_496">Returns<a class="headerlink" href="#returns_496" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_327">See Also<a class="headerlink" href="#see-also_327" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad
numpy.polynomial.chebyshev.chebgauss</p>
<h2 id="references_362">References<a class="headerlink" href="#references_362" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tandg</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>tandg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>tandg(x)</p>
<p>Tangent of angle x given in degrees.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tklmbda</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>tklmbda(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>tklmbda(x, lmbda)</p>
<p>Tukey-Lambda cumulative distribution function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ts_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (first kind, shifted) quadrature.</p>
<p>Compute the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
shifted Chebyshev polynomial of the first kind, :math:<code>T_n(x)</code>.
These sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[0, 1]</code>
with weight function :math:<code>w(x) = 1/\sqrt{x - x^2}</code>. See 22.2.8
in [AS]_ for more details.</p>
<h2 id="parameters_462">Parameters<a class="headerlink" href="#parameters_462" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_497">Returns<a class="headerlink" href="#returns_497" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_328">See Also<a class="headerlink" href="#see-also_328" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_363">References<a class="headerlink" href="#references_363" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">u_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (second kind) quadrature.</p>
<p>Computes the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
Chebyshev polynomial of the second kind, :math:<code>U_n(x)</code>. These
sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[-1, 1]</code>
with weight function :math:<code>w(x) = \sqrt{1 - x^2}</code>. See 22.2.5 in
[AS]_ for details.</p>
<h2 id="parameters_463">Parameters<a class="headerlink" href="#parameters_463" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_498">Returns<a class="headerlink" href="#returns_498" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_329">See Also<a class="headerlink" href="#see-also_329" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_364">References<a class="headerlink" href="#references_364" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">us_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">mu</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Gauss-Chebyshev (second kind, shifted) quadrature.</p>
<p>Computes the sample points and weights for Gauss-Chebyshev
quadrature. The sample points are the roots of the n-th degree
shifted Chebyshev polynomial of the second kind, :math:<code>U_n(x)</code>.
These sample points and weights correctly integrate polynomials of
degree :math:<code>2n - 1</code> or less over the interval :math:<code>[0, 1]</code>
with weight function :math:<code>w(x) = \sqrt{x - x^2}</code>. See 22.2.9 in
[AS]_ for more details.</p>
<h2 id="parameters_464">Parameters<a class="headerlink" href="#parameters_464" title="Permanent link">&para;</a></h2>
<p>n : int
quadrature order
mu : bool, optional
If True, return the sum of the weights, optional.</p>
<h2 id="returns_499">Returns<a class="headerlink" href="#returns_499" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Sample points
w : ndarray
Weights
mu : float
Sum of the weights</p>
<h2 id="see-also_330">See Also<a class="headerlink" href="#see-also_330" title="Permanent link">&para;</a></h2>
<p>scipy.integrate.quadrature
scipy.integrate.fixed_quad</p>
<h2 id="references_365">References<a class="headerlink" href="#references_365" title="Permanent link">&para;</a></h2>
<p>.. [AS] Milton Abramowitz and Irene A. Stegun, eds.
Handbook of Mathematical Functions with Formulas,
Graphs, and Mathematical Tables. New York: Dover, 1972.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">voigt_profile</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>voigt_profile(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>voigt_profile(x, sigma, gamma, out=None)</p>
<p>Voigt profile.</p>
<p>The Voigt profile is a convolution of a 1D Normal distribution with
standard deviation <code>sigma</code> and a 1D Cauchy distribution with half-width at
half-maximum <code>gamma</code>.</p>
<h2 id="parameters_465">Parameters<a class="headerlink" href="#parameters_465" title="Permanent link">&para;</a></h2>
<p>x : array_like
Real argument
sigma : array_like
The standard deviation of the Normal distribution part
gamma : array_like
The half-width at half-maximum of the Cauchy distribution part
out : ndarray, optional
Optional output array for the function values</p>
<h2 id="returns_500">Returns<a class="headerlink" href="#returns_500" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
The Voigt profile at the given arguments</p>
<h2 id="notes_284">Notes<a class="headerlink" href="#notes_284" title="Permanent link">&para;</a></h2>
<p>It can be expressed in terms of Faddeeva function</p>
<p>.. math:: V(x; \sigma, \gamma) = \frac{Re[w(z)]}{\sigma\sqrt{2\pi}},
.. math:: z = \frac{x + i\gamma}{\sqrt{2}\sigma}</p>
<p>where :math:<code>w(z)</code> is the Faddeeva function.</p>
<h2 id="see-also_331">See Also<a class="headerlink" href="#see-also_331" title="Permanent link">&para;</a></h2>
<p>wofz : Faddeeva function</p>
<h2 id="references_366">References<a class="headerlink" href="#references_366" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Voigt_profile</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">wofz</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>wofz(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>wofz(z)</p>
<p>Faddeeva function</p>
<p>Returns the value of the Faddeeva function for complex argument::</p>
<p>exp(-z*<em>2) * erfc(-i</em>z)</p>
<h2 id="see-also_332">See Also<a class="headerlink" href="#see-also_332" title="Permanent link">&para;</a></h2>
<p>dawsn, erf, erfc, erfcx, erfi</p>
<h2 id="references_367">References<a class="headerlink" href="#references_367" title="Permanent link">&para;</a></h2>
<p>.. [1] Steven G. Johnson, Faddeeva W function implementation.
http://ab-initio.mit.edu/Faddeeva</p>
<h2 id="examples_155">Examples<a class="headerlink" href="#examples_155" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import special
import matplotlib.pyplot as plt</p>
<p>x = np.linspace(-3, 3)
z = special.wofz(x)</p>
<p>plt.plot(x, z.real, label='wofz(x).real')
plt.plot(x, z.imag, label='wofz(x).imag')
plt.xlabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>')
plt.legend(framealpha=1, shadow=True)
plt.grid(alpha=0.25)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">wrightomega</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>wrightomega(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>wrightomega(z, out=None)</p>
<p>Wright Omega function.</p>
<p>Defined as the solution to</p>
<p>.. math::</p>
<p>\omega + \log(\omega) = z</p>
<p>where :math:<code>\log</code> is the principal branch of the complex logarithm.</p>
<h2 id="parameters_466">Parameters<a class="headerlink" href="#parameters_466" title="Permanent link">&para;</a></h2>
<p>z : array_like
Points at which to evaluate the Wright Omega function</p>
<h2 id="returns_501">Returns<a class="headerlink" href="#returns_501" title="Permanent link">&para;</a></h2>
<p>omega : ndarray
Values of the Wright Omega function</p>
<h2 id="notes_285">Notes<a class="headerlink" href="#notes_285" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<p>The function can also be defined as</p>
<p>.. math::</p>
<p>\omega(z) = W_{K(z)}(e^z)</p>
<p>where :math:<code>K(z) = \lceil (\Im(z) - \pi)/(2\pi) \rceil</code> is the
unwinding number and :math:<code>W</code> is the Lambert W function.</p>
<p>The implementation here is taken from [1]_.</p>
<h2 id="see-also_333">See Also<a class="headerlink" href="#see-also_333" title="Permanent link">&para;</a></h2>
<p>lambertw : The Lambert W function</p>
<h2 id="references_368">References<a class="headerlink" href="#references_368" title="Permanent link">&para;</a></h2>
<p>.. [1] Lawrence, Corless, and Jeffrey, 'Algorithm 917: Complex
Double-Precision Evaluation of the Wright :math:<code>\omega</code>
Function.' ACM Transactions on Mathematical Software,
2012. :doi:<code>10.1145/2168773.2168779</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">xlog1py</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>xlog1py(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>xlog1py(x, y)</p>
<p>Compute <code>x*log1p(y)</code> so that the result is 0 if <code>x = 0</code>.</p>
<h2 id="parameters_467">Parameters<a class="headerlink" href="#parameters_467" title="Permanent link">&para;</a></h2>
<p>x : array_like
Multiplier
y : array_like
Argument</p>
<h2 id="returns_502">Returns<a class="headerlink" href="#returns_502" title="Permanent link">&para;</a></h2>
<p>z : array_like
Computed x*log1p(y)</p>
<h2 id="notes_286">Notes<a class="headerlink" href="#notes_286" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.13.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">xlogy</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>xlogy(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>xlogy(x, y)</p>
<p>Compute <code>x*log(y)</code> so that the result is 0 if <code>x = 0</code>.</p>
<h2 id="parameters_468">Parameters<a class="headerlink" href="#parameters_468" title="Permanent link">&para;</a></h2>
<p>x : array_like
Multiplier
y : array_like
Argument</p>
<h2 id="returns_503">Returns<a class="headerlink" href="#returns_503" title="Permanent link">&para;</a></h2>
<p>z : array_like
Computed x*log(y)</p>
<h2 id="notes_287">Notes<a class="headerlink" href="#notes_287" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.13.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">y0</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>y0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>y0(x)</p>
<p>Bessel function of the second kind of order 0.</p>
<h2 id="parameters_469">Parameters<a class="headerlink" href="#parameters_469" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float).</p>
<h2 id="returns_504">Returns<a class="headerlink" href="#returns_504" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
Value of the Bessel function of the second kind of order 0 at <code>x</code>.</p>
<h2 id="notes_288">Notes<a class="headerlink" href="#notes_288" title="Permanent link">&para;</a></h2>
<p>The domain is divided into the intervals [0, 5] and (5, infinity). In the
first interval a rational approximation :math:<code>R(x)</code> is employed to
compute,</p>
<p>.. math::</p>
<p>Y_0(x) = R(x) + \frac{2 \log(x) J_0(x)}{\pi},</p>
<p>where :math:<code>J_0</code> is the Bessel function of the first kind of order 0.</p>
<p>In the second interval, the Hankel asymptotic expansion is employed with
two rational functions of degree 6/6 and 7/7.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>y0</code>.</p>
<h2 id="see-also_334">See also<a class="headerlink" href="#see-also_334" title="Permanent link">&para;</a></h2>
<p>j0
yv</p>
<h2 id="references_369">References<a class="headerlink" href="#references_369" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">y0_zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">complex</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">nt</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute nt zeros of Bessel function Y0(z), and derivative at each zero.</p>
<p>The derivatives are given by Y0'(z0) = -Y1(z0) at each zero z0.</p>
<h2 id="parameters_470">Parameters<a class="headerlink" href="#parameters_470" title="Permanent link">&para;</a></h2>
<p>nt : int
Number of zeros to return
complex : bool, default False
Set to False to return only the real zeros; set to True to return only
the complex zeros with negative real part and positive imaginary part.
Note that the complex conjugates of the latter are also zeros of the
function, but are not returned by this routine.</p>
<h2 id="returns_505">Returns<a class="headerlink" href="#returns_505" title="Permanent link">&para;</a></h2>
<p>z0n : ndarray
Location of nth zero of Y0(z)
y0pz0n : ndarray
Value of derivative Y0'(z0) for nth zero</p>
<h2 id="references_370">References<a class="headerlink" href="#references_370" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 5.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">y1</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>y1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>y1(x)</p>
<p>Bessel function of the second kind of order 1.</p>
<h2 id="parameters_471">Parameters<a class="headerlink" href="#parameters_471" title="Permanent link">&para;</a></h2>
<p>x : array_like
Argument (float).</p>
<h2 id="returns_506">Returns<a class="headerlink" href="#returns_506" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
Value of the Bessel function of the second kind of order 1 at <code>x</code>.</p>
<h2 id="notes_289">Notes<a class="headerlink" href="#notes_289" title="Permanent link">&para;</a></h2>
<p>The domain is divided into the intervals [0, 8] and (8, infinity). In the
first interval a 25 term Chebyshev expansion is used, and computing
:math:<code>J_1</code> (the Bessel function of the first kind) is required. In the
second, the asymptotic trigonometric representation is employed using two
rational functions of degree 5/5.</p>
<p>This function is a wrapper for the Cephes [1]_ routine <code>y1</code>.</p>
<h2 id="see-also_335">See also<a class="headerlink" href="#see-also_335" title="Permanent link">&para;</a></h2>
<p>j1
yn
yv</p>
<h2 id="references_371">References<a class="headerlink" href="#references_371" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">y1_zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">complex</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">nt</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute nt zeros of Bessel function Y1(z), and derivative at each zero.</p>
<p>The derivatives are given by Y1'(z1) = Y0(z1) at each zero z1.</p>
<h2 id="parameters_472">Parameters<a class="headerlink" href="#parameters_472" title="Permanent link">&para;</a></h2>
<p>nt : int
Number of zeros to return
complex : bool, default False
Set to False to return only the real zeros; set to True to return only
the complex zeros with negative real part and positive imaginary part.
Note that the complex conjugates of the latter are also zeros of the
function, but are not returned by this routine.</p>
<h2 id="returns_507">Returns<a class="headerlink" href="#returns_507" title="Permanent link">&para;</a></h2>
<p>z1n : ndarray
Location of nth zero of Y1(z)
y1pz1n : ndarray
Value of derivative Y1'(z1) for nth zero</p>
<h2 id="references_372">References<a class="headerlink" href="#references_372" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 5.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">y1p_zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">complex</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">nt</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute nt zeros of Bessel derivative Y1'(z), and value at each zero.</p>
<p>The values are given by Y1(z1) at each z1 where Y1'(z1)=0.</p>
<h2 id="parameters_473">Parameters<a class="headerlink" href="#parameters_473" title="Permanent link">&para;</a></h2>
<p>nt : int
Number of zeros to return
complex : bool, default False
Set to False to return only the real zeros; set to True to return only
the complex zeros with negative real part and positive imaginary part.
Note that the complex conjugates of the latter are also zeros of the
function, but are not returned by this routine.</p>
<h2 id="returns_508">Returns<a class="headerlink" href="#returns_508" title="Permanent link">&para;</a></h2>
<p>z1pn : ndarray
Location of nth zero of Y1'(z)
y1z1pn : ndarray
Value of derivative Y1(z1) for nth zero</p>
<h2 id="references_373">References<a class="headerlink" href="#references_373" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 5.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">yn</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>yn(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>yn(n, x)</p>
<p>Bessel function of the second kind of integer order and real argument.</p>
<h2 id="parameters_474">Parameters<a class="headerlink" href="#parameters_474" title="Permanent link">&para;</a></h2>
<p>n : array_like
Order (integer).
z : array_like
Argument (float).</p>
<h2 id="returns_509">Returns<a class="headerlink" href="#returns_509" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
Value of the Bessel function, :math:<code>Y_n(x)</code>.</p>
<h2 id="notes_290">Notes<a class="headerlink" href="#notes_290" title="Permanent link">&para;</a></h2>
<p>Wrapper for the Cephes [1]_ routine <code>yn</code>.</p>
<p>The function is evaluated by forward recurrence on <code>n</code>, starting with
values computed by the Cephes routines <code>y0</code> and <code>y1</code>. If <code>n = 0</code> or 1,
the routine for <code>y0</code> or <code>y1</code> is called directly.</p>
<h2 id="see-also_336">See also<a class="headerlink" href="#see-also_336" title="Permanent link">&para;</a></h2>
<p>yv : For real order and real or complex argument.</p>
<h2 id="references_374">References<a class="headerlink" href="#references_374" title="Permanent link">&para;</a></h2>
<p>.. [1] Cephes Mathematical Functions Library,
http://www.netlib.org/cephes/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">yn_zeros</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">nt</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute zeros of integer-order Bessel function Yn(x).</p>
<h2 id="parameters_475">Parameters<a class="headerlink" href="#parameters_475" title="Permanent link">&para;</a></h2>
<p>n : int
Order of Bessel function
nt : int
Number of zeros to return</p>
<h2 id="references_375">References<a class="headerlink" href="#references_375" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 5.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ynp_zeros</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">nt</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute zeros of integer-order Bessel function derivative Yn'(x).</p>
<h2 id="parameters_476">Parameters<a class="headerlink" href="#parameters_476" title="Permanent link">&para;</a></h2>
<p>n : int
Order of Bessel function
nt : int
Number of zeros to return</p>
<h2 id="references_376">References<a class="headerlink" href="#references_376" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 5.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">yv</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>yv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>yv(v, z)</p>
<p>Bessel function of the second kind of real order and complex argument.</p>
<h2 id="parameters_477">Parameters<a class="headerlink" href="#parameters_477" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_510">Returns<a class="headerlink" href="#returns_510" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
Value of the Bessel function of the second kind, :math:<code>Y_v(x)</code>.</p>
<h2 id="notes_291">Notes<a class="headerlink" href="#notes_291" title="Permanent link">&para;</a></h2>
<p>For positive <code>v</code> values, the computation is carried out using the
AMOS [1]_ <code>zbesy</code> routine, which exploits the connection to the Hankel
Bessel functions :math:<code>H_v^{(1)}</code> and :math:<code>H_v^{(2)}</code>,</p>
<p>.. math:: Y_v(z) = \frac{1}{2\imath} (H_v^{(1)} - H_v^{(2)}).</p>
<p>For negative <code>v</code> values the formula,</p>
<p>.. math:: Y_{-v}(z) = Y_v(z) \cos(\pi v) + J_v(z) \sin(\pi v)</p>
<p>is used, where :math:<code>J_v(z)</code> is the Bessel function of the first kind,
computed using the AMOS routine <code>zbesj</code>.  Note that the second term is
exactly zero for integer <code>v</code>; to improve accuracy the second term is
explicitly omitted for <code>v</code> values such that <code>v = floor(v)</code>.</p>
<h2 id="see-also_337">See also<a class="headerlink" href="#see-also_337" title="Permanent link">&para;</a></h2>
<p>yve : :math:<code>Y_v</code> with leading exponential behavior stripped off.</p>
<h2 id="references_377">References<a class="headerlink" href="#references_377" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">yve</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>yve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>yve(v, z)</p>
<p>Exponentially scaled Bessel function of the second kind of real order.</p>
<p>Returns the exponentially scaled Bessel function of the second
kind of real order <code>v</code> at complex <code>z</code>::</p>
<p>yve(v, z) = yv(v, z) * exp(-abs(z.imag))</p>
<h2 id="parameters_478">Parameters<a class="headerlink" href="#parameters_478" title="Permanent link">&para;</a></h2>
<p>v : array_like
Order (float).
z : array_like
Argument (float or complex).</p>
<h2 id="returns_511">Returns<a class="headerlink" href="#returns_511" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
Value of the exponentially scaled Bessel function.</p>
<h2 id="notes_292">Notes<a class="headerlink" href="#notes_292" title="Permanent link">&para;</a></h2>
<p>For positive <code>v</code> values, the computation is carried out using the
AMOS [1]_ <code>zbesy</code> routine, which exploits the connection to the Hankel
Bessel functions :math:<code>H_v^{(1)}</code> and :math:<code>H_v^{(2)}</code>,</p>
<p>.. math:: Y_v(z) = \frac{1}{2\imath} (H_v^{(1)} - H_v^{(2)}).</p>
<p>For negative <code>v</code> values the formula,</p>
<p>.. math:: Y_{-v}(z) = Y_v(z) \cos(\pi v) + J_v(z) \sin(\pi v)</p>
<p>is used, where :math:<code>J_v(z)</code> is the Bessel function of the first kind,
computed using the AMOS routine <code>zbesj</code>.  Note that the second term is
exactly zero for integer <code>v</code>; to improve accuracy the second term is
explicitly omitted for <code>v</code> values such that <code>v = floor(v)</code>.</p>
<h2 id="references_378">References<a class="headerlink" href="#references_378" title="Permanent link">&para;</a></h2>
<p>.. [1] Donald E. Amos, 'AMOS, A Portable Package for Bessel Functions
of a Complex Argument and Nonnegative Order',
http://netlib.org/amos/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">yvp</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute nth derivative of Bessel function Yv(z) with respect to <code>z</code>.</p>
<h2 id="parameters_479">Parameters<a class="headerlink" href="#parameters_479" title="Permanent link">&para;</a></h2>
<p>v : float
Order of Bessel function
z : complex
Argument at which to evaluate the derivative
n : int, default 1
Order of derivative</p>
<h2 id="notes_293">Notes<a class="headerlink" href="#notes_293" title="Permanent link">&para;</a></h2>
<p>The derivative is computed using the relation DLFM 10.6.7 [2]_.</p>
<h2 id="references_379">References<a class="headerlink" href="#references_379" title="Permanent link">&para;</a></h2>
<p>.. [1] Zhang, Shanjie and Jin, Jianming. 'Computation of Special
Functions', John Wiley and Sons, 1996, chapter 5.
https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html
.. [2] NIST Digital Library of Mathematical Functions.
https://dlmf.nist.gov/10.6.E7</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeta</span> <span class="o">:</span> <span class="o">?</span><span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Riemann or Hurwitz zeta function.</p>
<h2 id="parameters_480">Parameters<a class="headerlink" href="#parameters_480" title="Permanent link">&para;</a></h2>
<p>x : array_like of float
Input data, must be real
q : array_like of float, optional
Input data, must be real.  Defaults to Riemann zeta.
out : ndarray, optional
Output array for the computed values.</p>
<h2 id="returns_512">Returns<a class="headerlink" href="#returns_512" title="Permanent link">&para;</a></h2>
<p>out : array_like
Values of zeta(x).</p>
<h2 id="notes_294">Notes<a class="headerlink" href="#notes_294" title="Permanent link">&para;</a></h2>
<p>The two-argument version is the Hurwitz zeta function</p>
<p>.. math::</p>
<p>\zeta(x, q) = \sum_{k=0}^{\infty} \frac{1}{(k + q)^x};</p>
<p>see [dlmf]_ for details. The Riemann zeta function corresponds to
the case when <code>q = 1</code>.</p>
<h2 id="see-also_338">See Also<a class="headerlink" href="#see-also_338" title="Permanent link">&para;</a></h2>
<p>zetac</p>
<h2 id="references_380">References<a class="headerlink" href="#references_380" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST, Digital Library of Mathematical Functions,
https://dlmf.nist.gov/25.11#i</p>
<h2 id="examples_156">Examples<a class="headerlink" href="#examples_156" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import zeta, polygamma, factorial</p>
</blockquote>
</blockquote>
</blockquote>
<p>Some specific values:</p>
<blockquote>
<blockquote>
<blockquote>
<p>zeta(2), np.pi**2/6
(1.6449340668482266, 1.6449340668482264)</p>
<p>zeta(4), np.pi**4/90
(1.0823232337111381, 1.082323233711138)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Relation to the <code>polygamma</code> function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>m = 3
x = 1.25
polygamma(m, x)
array(2.782144009188397)
(-1)**(m+1) * factorial(m) * zeta(m+1, x)
2.7821440091883969</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zetac</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zetac(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>zetac(x)</p>
<p>Riemann zeta function minus 1.</p>
<p>This function is defined as</p>
<p>.. math:: \zeta(x) = \sum_{k=2}^{\infty} 1 / k^x,</p>
<p>where <code>x &gt; 1</code>.  For <code>x &lt; 1</code> the analytic continuation is
computed. For more information on the Riemann zeta function, see
[dlmf]_.</p>
<h2 id="parameters_481">Parameters<a class="headerlink" href="#parameters_481" title="Permanent link">&para;</a></h2>
<p>x : array_like of float
Values at which to compute zeta(x) - 1 (must be real).</p>
<h2 id="returns_513">Returns<a class="headerlink" href="#returns_513" title="Permanent link">&para;</a></h2>
<p>out : array_like
Values of zeta(x) - 1.</p>
<h2 id="see-also_339">See Also<a class="headerlink" href="#see-also_339" title="Permanent link">&para;</a></h2>
<p>zeta</p>
<h2 id="examples_157">Examples<a class="headerlink" href="#examples_157" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import zetac, zeta</p>
</blockquote>
</blockquote>
</blockquote>
<p>Some special values:</p>
<blockquote>
<blockquote>
<blockquote>
<p>zetac(2), np.pi**2/6 - 1
(0.64493406684822641, 0.6449340668482264)</p>
<p>zetac(-1), -1.0/12 - 1
(-1.0833333333333333, -1.0833333333333333)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare <code>zetac(x)</code> to <code>zeta(x) - 1</code> for large <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>zetac(60), zeta(60) - 1
(8.673617380119933e-19, 0.0)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_381">References<a class="headerlink" href="#references_381" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/25</p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../Spatial/" title="Spatial" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Spatial
              </div>
            </div>
          </a>
        
        
          <a href="../Stats/" title="Stats" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Stats
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.d710d30a.min.js"></script>
      <script src="../../assets/javascripts/bundle.a45f732b.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: ["instant", "tabs"],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.c03f0417.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>