(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

module AxisError : sig
type tag = [`AxisError]
type t = [`AxisError | `BaseException | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val create : ?ndim:Py.Object.t -> ?msg_prefix:Py.Object.t -> axis:Py.Object.t -> unit -> t
(**
Axis supplied was invalid. 
*)

val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module ComplexWarning : sig
type tag = [`ComplexWarning]
type t = [`BaseException | `ComplexWarning | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module DataSource : sig
type tag = [`DataSource]
type t = [`DataSource | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?destpath:[`S of string | `None] -> unit -> t
(**
DataSource(destpath='.')

A generic data source file (file, http, ftp, ...).

DataSources can be local files or remote files/URLs.  The files may
also be compressed or uncompressed. DataSource hides some of the
low-level details of downloading the file, allowing you to simply pass
in a valid file path (or URL) and obtain a file object.

Parameters
----------
destpath : str or None, optional
    Path to the directory where the source file gets downloaded to for
    use.  If `destpath` is None, a temporary directory will be created.
    The default path is the current directory.

Notes
-----
URLs require a scheme string (``http://``) to be used, without it they
will fail::

    >>> repos = np.DataSource()
    >>> repos.exists('www.google.com/index.html')
    False
    >>> repos.exists('http://www.google.com/index.html')
    True

Temporary directories are deleted when the DataSource is deleted.

Examples
--------
::

    >>> ds = np.DataSource('/home/guido')
    >>> urlname = 'http://www.google.com/'
    >>> gfile = ds.open('http://www.google.com/')
    >>> ds.abspath(urlname)
    '/home/guido/www.google.com/index.html'

    >>> ds = np.DataSource(None)  # use with temporary file
    >>> ds.open('/home/guido/foobar.txt')
    <open file '/home/guido.foobar.txt', mode 'r' at 0x91d4430>
    >>> ds.abspath('/home/guido/foobar.txt')
    '/tmp/.../home/guido/foobar.txt'
*)

val abspath : path:string -> [> tag] Obj.t -> string
(**
Return absolute path of file in the DataSource directory.

If `path` is an URL, then `abspath` will return either the location
the file exists locally or the location it would exist when opened
using the `open` method.

Parameters
----------
path : str
    Can be a local file or a remote URL.

Returns
-------
out : str
    Complete path, including the `DataSource` destination directory.

Notes
-----
The functionality is based on `os.path.abspath`.
*)

val exists : path:string -> [> tag] Obj.t -> bool
(**
Test if path exists.

Test if `path` exists as (and in this order):

- a local file.
- a remote URL that has been downloaded and stored locally in the
  `DataSource` directory.
- a remote URL that has not been downloaded, but is valid and
  accessible.

Parameters
----------
path : str
    Can be a local file or a remote URL.

Returns
-------
out : bool
    True if `path` exists.

Notes
-----
When `path` is an URL, `exists` will return True if it's either
stored locally in the `DataSource` directory, or is a valid remote
URL.  `DataSource` does not discriminate between the two, the file
is accessible if it exists in either location.
*)

val open_ : ?mode:[`R | `W | `A] -> ?encoding:string -> ?newline:string -> path:string -> [> tag] Obj.t -> Py.Object.t
(**
Open and return file-like object.

If `path` is an URL, it will be downloaded, stored in the
`DataSource` directory and opened from there.

Parameters
----------
path : str
    Local file path or URL to open.
mode : {'r', 'w', 'a'}, optional
    Mode to open `path`.  Mode 'r' for reading, 'w' for writing,
    'a' to append. Available modes depend on the type of object
    specified by `path`. Default is 'r'.
encoding : {None, str}, optional
    Open text file with given encoding. The default encoding will be
    what `io.open` uses.
newline : {None, str}, optional
    Newline to use when reading text file.

Returns
-------
out : file object
    File object.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module MachAr : sig
type tag = [`MachAr]
type t = [`MachAr | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?float_conv:Py.Object.t -> ?int_conv:Py.Object.t -> ?float_to_float:Py.Object.t -> ?float_to_str:Py.Object.t -> ?title:string -> unit -> t
(**
Diagnosing machine parameters.

Attributes
----------
ibeta : int
    Radix in which numbers are represented.
it : int
    Number of base-`ibeta` digits in the floating point mantissa M.
machep : int
    Exponent of the smallest (most negative) power of `ibeta` that,
    added to 1.0, gives something different from 1.0
eps : float
    Floating-point number ``beta**machep`` (floating point precision)
negep : int
    Exponent of the smallest power of `ibeta` that, subtracted
    from 1.0, gives something different from 1.0.
epsneg : float
    Floating-point number ``beta**negep``.
iexp : int
    Number of bits in the exponent (including its sign and bias).
minexp : int
    Smallest (most negative) power of `ibeta` consistent with there
    being no leading zeros in the mantissa.
xmin : float
    Floating point number ``beta**minexp`` (the smallest [in
    magnitude] usable floating value).
maxexp : int
    Smallest (positive) power of `ibeta` that causes overflow.
xmax : float
    ``(1-epsneg) * beta**maxexp`` (the largest [in magnitude]
    usable floating value).
irnd : int
    In ``range(6)``, information on what kind of rounding is done
    in addition, and on how underflow is handled.
ngrd : int
    Number of 'guard digits' used when truncating the product
    of two mantissas to fit the representation.
epsilon : float
    Same as `eps`.
tiny : float
    Same as `xmin`.
huge : float
    Same as `xmax`.
precision : float
    ``- int(-log10(eps))``
resolution : float
    ``- 10**(-precision)``

Parameters
----------
float_conv : function, optional
    Function that converts an integer or integer array to a float
    or float array. Default is `float`.
int_conv : function, optional
    Function that converts a float or float array to an integer or
    integer array. Default is `int`.
float_to_float : function, optional
    Function that converts a float array to float. Default is `float`.
    Note that this does not seem to do anything useful in the current
    implementation.
float_to_str : function, optional
    Function that converts a single float to a string. Default is
    ``lambda v:'%24.16e' %v``.
title : str, optional
    Title that is printed in the string representation of `MachAr`.

See Also
--------
finfo : Machine limits for floating point types.
iinfo : Machine limits for integer types.

References
----------
.. [1] Press, Teukolsky, Vetterling and Flannery,
       'Numerical Recipes in C++,' 2nd ed,
       Cambridge University Press, 2002, p. 31.
*)


(** Attribute ibeta: get value or raise Not_found if None.*)
val ibeta : t -> int

(** Attribute ibeta: get value as an option. *)
val ibeta_opt : t -> (int) option


(** Attribute it: get value or raise Not_found if None.*)
val it : t -> int

(** Attribute it: get value as an option. *)
val it_opt : t -> (int) option


(** Attribute machep: get value or raise Not_found if None.*)
val machep : t -> int

(** Attribute machep: get value as an option. *)
val machep_opt : t -> (int) option


(** Attribute eps: get value or raise Not_found if None.*)
val eps : t -> float

(** Attribute eps: get value as an option. *)
val eps_opt : t -> (float) option


(** Attribute negep: get value or raise Not_found if None.*)
val negep : t -> int

(** Attribute negep: get value as an option. *)
val negep_opt : t -> (int) option


(** Attribute epsneg: get value or raise Not_found if None.*)
val epsneg : t -> float

(** Attribute epsneg: get value as an option. *)
val epsneg_opt : t -> (float) option


(** Attribute iexp: get value or raise Not_found if None.*)
val iexp : t -> int

(** Attribute iexp: get value as an option. *)
val iexp_opt : t -> (int) option


(** Attribute minexp: get value or raise Not_found if None.*)
val minexp : t -> int

(** Attribute minexp: get value as an option. *)
val minexp_opt : t -> (int) option


(** Attribute xmin: get value or raise Not_found if None.*)
val xmin : t -> float

(** Attribute xmin: get value as an option. *)
val xmin_opt : t -> (float) option


(** Attribute maxexp: get value or raise Not_found if None.*)
val maxexp : t -> int

(** Attribute maxexp: get value as an option. *)
val maxexp_opt : t -> (int) option


(** Attribute xmax: get value or raise Not_found if None.*)
val xmax : t -> float

(** Attribute xmax: get value as an option. *)
val xmax_opt : t -> (float) option


(** Attribute irnd: get value or raise Not_found if None.*)
val irnd : t -> int

(** Attribute irnd: get value as an option. *)
val irnd_opt : t -> (int) option


(** Attribute ngrd: get value or raise Not_found if None.*)
val ngrd : t -> int

(** Attribute ngrd: get value as an option. *)
val ngrd_opt : t -> (int) option


(** Attribute epsilon: get value or raise Not_found if None.*)
val epsilon : t -> float

(** Attribute epsilon: get value as an option. *)
val epsilon_opt : t -> (float) option


(** Attribute tiny: get value or raise Not_found if None.*)
val tiny : t -> float

(** Attribute tiny: get value as an option. *)
val tiny_opt : t -> (float) option


(** Attribute huge: get value or raise Not_found if None.*)
val huge : t -> float

(** Attribute huge: get value as an option. *)
val huge_opt : t -> (float) option


(** Attribute precision: get value or raise Not_found if None.*)
val precision : t -> float

(** Attribute precision: get value as an option. *)
val precision_opt : t -> (float) option


(** Attribute resolution: get value or raise Not_found if None.*)
val resolution : t -> float

(** Attribute resolution: get value as an option. *)
val resolution_opt : t -> (float) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module ModuleDeprecationWarning : sig
type tag = [`ModuleDeprecationWarning]
type t = [`BaseException | `ModuleDeprecationWarning | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module RankWarning : sig
type tag = [`RankWarning]
type t = [`BaseException | `Object | `RankWarning] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Tester : sig
type tag = [`NoseTester]
type t = [`NoseTester | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?package:[`Module of Py.Object.t | `S of string] -> ?raise_warnings:[`Sequence_of_warnings of Py.Object.t | `S of string | `None] -> ?depth:int -> ?check_fpu_mode:Py.Object.t -> unit -> t
(**
Nose test runner.

This class is made available as numpy.testing.Tester, and a test function
is typically added to a package's __init__.py like so::

  from numpy.testing import Tester
  test = Tester().test

Calling this test function finds and runs all tests associated with the
package and all its sub-packages.

Attributes
----------
package_path : str
    Full path to the package to test.
package_name : str
    Name of the package to test.

Parameters
----------
package : module, str or None, optional
    The package to test. If a string, this should be the full path to
    the package. If None (default), `package` is set to the module from
    which `NoseTester` is initialized.
raise_warnings : None, str or sequence of warnings, optional
    This specifies which warnings to configure as 'raise' instead
    of being shown once during the test execution.  Valid strings are:

      - 'develop' : equals ``(Warning,)``
      - 'release' : equals ``()``, don't raise on any warnings.

    Default is 'release'.
depth : int, optional
    If `package` is None, then this can be used to initialize from the
    module of the caller of (the caller of (...)) the code that
    initializes `NoseTester`. Default of 0 means the module of the
    immediate caller; higher values are useful for utility routines that
    want to initialize `NoseTester` objects on behalf of other code.
*)

val bench : ?label:[`Full | `Attribute_identifier of Py.Object.t | `Fast | `T] -> ?verbose:int -> ?extra_argv:[>`Ndarray] Obj.t -> [> tag] Obj.t -> bool
(**
Run benchmarks for module using nose.

Parameters
----------
label : {'fast', 'full', '', attribute identifier}, optional
    Identifies the benchmarks to run. This can be a string to pass to
    the nosetests executable with the '-A' option, or one of several
    special values.  Special values are:

    * 'fast' - the default - which corresponds to the ``nosetests -A``
      option of 'not slow'.
    * 'full' - fast (as above) and slow benchmarks as in the
      'no -A' option to nosetests - this is the same as ''.
    * None or '' - run all tests.
    * attribute_identifier - string passed directly to nosetests as '-A'.

verbose : int, optional
    Verbosity value for benchmark outputs, in the range 1-10. Default is 1.
extra_argv : list, optional
    List with any extra arguments to pass to nosetests.

Returns
-------
success : bool
    Returns True if running the benchmarks works, False if an error
    occurred.

Notes
-----
Benchmarks are like tests, but have names starting with 'bench' instead
of 'test', and can be found under the 'benchmarks' sub-directory of the
module.

Each NumPy module exposes `bench` in its namespace to run all benchmarks
for it.

Examples
--------
>>> success = np.lib.bench() #doctest: +SKIP
Running benchmarks for numpy.lib
...
using 562341 items:
unique:
0.11
unique1d:
0.11
ratio: 1.0
nUnique: 56230 == 56230
...
OK

>>> success #doctest: +SKIP
True
*)

val prepare_test_args : ?label:Py.Object.t -> ?verbose:Py.Object.t -> ?extra_argv:Py.Object.t -> ?doctests:Py.Object.t -> ?coverage:Py.Object.t -> ?timer:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Run tests for module using nose.

This method does the heavy lifting for the `test` method. It takes all
the same arguments, for details see `test`.

See Also
--------
test
*)

val test : ?label:[`Full | `Attribute_identifier of Py.Object.t | `Fast | `T] -> ?verbose:int -> ?extra_argv:[>`Ndarray] Obj.t -> ?doctests:bool -> ?coverage:bool -> ?raise_warnings:[`Sequence_of_warnings of Py.Object.t | `S of string] -> ?timer:[`Bool of bool | `I of int] -> [> tag] Obj.t -> Py.Object.t
(**
Run tests for module using nose.

Parameters
----------
label : {'fast', 'full', '', attribute identifier}, optional
    Identifies the tests to run. This can be a string to pass to
    the nosetests executable with the '-A' option, or one of several
    special values.  Special values are:

    * 'fast' - the default - which corresponds to the ``nosetests -A``
      option of 'not slow'.
    * 'full' - fast (as above) and slow tests as in the
      'no -A' option to nosetests - this is the same as ''.
    * None or '' - run all tests.
    * attribute_identifier - string passed directly to nosetests as '-A'.

verbose : int, optional
    Verbosity value for test outputs, in the range 1-10. Default is 1.
extra_argv : list, optional
    List with any extra arguments to pass to nosetests.
doctests : bool, optional
    If True, run doctests in module. Default is False.
coverage : bool, optional
    If True, report coverage of NumPy code. Default is False.
    (This requires the
    `coverage module <https://nedbatchelder.com/code/modules/coveragehtml>`_).
raise_warnings : None, str or sequence of warnings, optional
    This specifies which warnings to configure as 'raise' instead
    of being shown once during the test execution. Valid strings are:

    * 'develop' : equals ``(Warning,)``
    * 'release' : equals ``()``, do not raise on any warnings.
timer : bool or int, optional
    Timing of individual tests with ``nose-timer`` (which needs to be
    installed).  If True, time tests and report on all of them.
    If an integer (say ``N``), report timing results for ``N`` slowest
    tests.

Returns
-------
result : object
    Returns the result of running the tests as a
    ``nose.result.TextTestResult`` object.

Notes
-----
Each NumPy module exposes `test` in its namespace to run all tests for it.
For example, to run all tests for numpy.lib:

>>> np.lib.test() #doctest: +SKIP

Examples
--------
>>> result = np.lib.test() #doctest: +SKIP
Running unit tests for numpy.lib
...
Ran 976 tests in 3.933s

OK

>>> result.errors #doctest: +SKIP
[]
>>> result.knownfail #doctest: +SKIP
[]
*)


(** Attribute package_path: get value or raise Not_found if None.*)
val package_path : t -> string

(** Attribute package_path: get value as an option. *)
val package_path_opt : t -> (string) option


(** Attribute package_name: get value or raise Not_found if None.*)
val package_name : t -> string

(** Attribute package_name: get value as an option. *)
val package_name_opt : t -> (string) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module TooHardError : sig
type tag = [`TooHardError]
type t = [`BaseException | `Object | `TooHardError] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module VisibleDeprecationWarning : sig
type tag = [`VisibleDeprecationWarning]
type t = [`BaseException | `Object | `VisibleDeprecationWarning] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Bool : sig
type tag = [`Bool]
type t = [`Bool | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : Py.Object.t -> t
(**
bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.
*)

val as_integer_ratio : [> tag] Obj.t -> Py.Object.t
(**
Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)
*)

val bit_length : [> tag] Obj.t -> Py.Object.t
(**
Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6
*)

val from_bytes : ?signed:Py.Object.t -> bytes:Py.Object.t -> byteorder:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the integer represented by the given array of bytes.

bytes
  Holds the array of bytes to convert.  The argument must either
  support the buffer protocol or be an iterable object producing bytes.
  Bytes and bytearray are examples of built-in objects that support the
  buffer protocol.
byteorder
  The byte order used to represent the integer.  If byteorder is 'big',
  the most significant byte is at the beginning of the byte array.  If
  byteorder is 'little', the most significant byte is at the end of the
  byte array.  To request the native byte order of the host system, use
  `sys.byteorder' as the byte order value.
signed
  Indicates whether two's complement is used to represent the integer.
*)

val to_bytes : ?signed:Py.Object.t -> length:Py.Object.t -> byteorder:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return an array of bytes representing an integer.

length
  Length of bytes object to use.  An OverflowError is raised if the
  integer is not representable with the given number of bytes.
byteorder
  The byte order used to represent the integer.  If byteorder is 'big',
  the most significant byte is at the beginning of the byte array.  If
  byteorder is 'little', the most significant byte is at the end of the
  byte array.  To request the native byte order of the host system, use
  `sys.byteorder' as the byte order value.
signed
  Determines whether two's complement is used to represent the integer.
  If signed is False and a negative integer is given, an OverflowError
  is raised.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Bool8 : sig
type tag = [`Bool_]
type t = [`Bool_ | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Broadcast : sig
type tag = [`Broadcast]
type t = [`Broadcast | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Implement iter(self).
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Busdaycalendar : sig
type tag = [`Busdaycalendar]
type t = [`Busdaycalendar | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?weekmask:[`Array_like_of_bool of Py.Object.t | `S of string] -> ?holidays:Py.Object.t -> unit -> t
(**
busdaycalendar(weekmask='1111100', holidays=None)

A business day calendar object that efficiently stores information
defining valid days for the busday family of functions.

The default valid days are Monday through Friday ('business days').
A busdaycalendar object can be specified with any set of weekly
valid days, plus an optional 'holiday' dates that always will be invalid.

Once a busdaycalendar object is created, the weekmask and holidays
cannot be modified.

.. versionadded:: 1.7.0

Parameters
----------
weekmask : str or array_like of bool, optional
    A seven-element array indicating which of Monday through Sunday are
    valid days. May be specified as a length-seven list or array, like
    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
    like 'Mon Tue Wed Thu Fri', made up of 3-character abbreviations for
    weekdays, optionally separated by white space. Valid abbreviations
    are: Mon Tue Wed Thu Fri Sat Sun
holidays : array_like of datetime64[D], optional
    An array of dates to consider as invalid dates, no matter which
    weekday they fall upon.  Holiday dates may be specified in any
    order, and NaT (not-a-time) dates are ignored.  This list is
    saved in a normalized form that is suited for fast calculations
    of valid days.

Returns
-------
out : busdaycalendar
    A business day calendar object containing the specified
    weekmask and holidays values.

See Also
--------
is_busday : Returns a boolean array indicating valid days.
busday_offset : Applies an offset counted in valid days.
busday_count : Counts how many valid days are in a half-open date range.

Attributes
----------
Note: once a busdaycalendar object is created, you cannot modify the
weekmask or holidays.  The attributes return copies of internal data.
weekmask : (copy) seven-element array of bool
holidays : (copy) sorted array of datetime64[D]

Examples
--------
>>> # Some important days in July
... bdd = np.busdaycalendar(
...             holidays=['2011-07-01', '2011-07-04', '2011-07-17'])
>>> # Default is Monday to Friday weekdays
... bdd.weekmask
array([ True,  True,  True,  True,  True, False, False])
>>> # Any holidays already on the weekend are removed
... bdd.holidays
array(['2011-07-01', '2011-07-04'], dtype='datetime64[D]')
*)


(** Attribute Note: get value or raise Not_found if None.*)
val note : t -> Py.Object.t

(** Attribute Note: get value as an option. *)
val note_opt : t -> (Py.Object.t) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Byte : sig
type tag = [`Int8]
type t = [`Int8 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Bytes0 : sig
type tag = [`Bytes_]
type t = [`Bytes_ | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : Py.Object.t -> t
(**
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Implement iter(self).
*)

val center : ?fillchar:Py.Object.t -> width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a centered string of length width.

Padding is done using the specified fill character.
*)

val count : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.count(sub[, start[, end]]) -> int

Return the number of non-overlapping occurrences of subsection sub in
bytes B[start:end].  Optional arguments start and end are interpreted
as in slice notation.
*)

val decode : ?encoding:Py.Object.t -> ?errors:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Decode the bytes using the codec registered for encoding.

encoding
  The encoding with which to decode the bytes.
errors
  The error handling scheme to use for the handling of decoding errors.
  The default is 'strict' meaning that decoding errors raise a
  UnicodeDecodeError. Other possible values are 'ignore' and 'replace'
  as well as any other name registered with codecs.register_error that
  can handle UnicodeDecodeErrors.
*)

val endswith : ?start:Py.Object.t -> ?end_:Py.Object.t -> suffix:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.endswith(suffix[, start[, end]]) -> bool

Return True if B ends with the specified suffix, False otherwise.
With optional start, test B beginning at that position.
With optional end, stop comparing B at that position.
suffix can also be a tuple of bytes to try.
*)

val expandtabs : ?tabsize:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy where all tab characters are expanded using spaces.

If tabsize is not given, a tab size of 8 characters is assumed.
*)

val find : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.find(sub[, start[, end]]) -> int

Return the lowest index in B where subsection sub is found,
such that sub is contained within B[start,end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.
*)

val fromhex : string:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Create a bytes object from a string of hexadecimal numbers.

Spaces between two numbers are accepted.
Example: bytes.fromhex('B9 01EF') -> b'\\xb9\\x01\\xef'.
*)

val index : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.index(sub[, start[, end]]) -> int

Return the lowest index in B where subsection sub is found,
such that sub is contained within B[start,end].  Optional
arguments start and end are interpreted as in slice notation.

Raises ValueError when the subsection is not found.
*)

val join : iterable_of_bytes:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Concatenate any number of bytes objects.

The bytes whose method is called is inserted in between each pair.

The result is returned as a new bytes object.

Example: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.
*)

val ljust : ?fillchar:Py.Object.t -> width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a left-justified string of length width.

Padding is done using the specified fill character.
*)

val lstrip : ?bytes:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Strip leading bytes contained in the argument.

If the argument is omitted or None, strip leading  ASCII whitespace.
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)

val partition : sep:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Partition the bytes into three parts using the given separator.

This will search for the separator sep in the bytes. If the separator is found,
returns a 3-tuple containing the part before the separator, the separator
itself, and the part after it.

If the separator is not found, returns a 3-tuple containing the original bytes
object and two empty bytes objects.
*)

val replace : ?count:Py.Object.t -> old:Py.Object.t -> new_:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy with all occurrences of substring old replaced by new.

  count
    Maximum number of occurrences to replace.
    -1 (the default value) means replace all occurrences.

If the optional argument count is given, only the first count occurrences are
replaced.
*)

val rfind : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.rfind(sub[, start[, end]]) -> int

Return the highest index in B where subsection sub is found,
such that sub is contained within B[start,end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.
*)

val rindex : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.rindex(sub[, start[, end]]) -> int

Return the highest index in B where subsection sub is found,
such that sub is contained within B[start,end].  Optional
arguments start and end are interpreted as in slice notation.

Raise ValueError when the subsection is not found.
*)

val rjust : ?fillchar:Py.Object.t -> width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a right-justified string of length width.

Padding is done using the specified fill character.
*)

val rpartition : sep:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Partition the bytes into three parts using the given separator.

This will search for the separator sep in the bytes, starting at the end. If
the separator is found, returns a 3-tuple containing the part before the
separator, the separator itself, and the part after it.

If the separator is not found, returns a 3-tuple containing two empty bytes
objects and the original bytes object.
*)

val rsplit : ?sep:Py.Object.t -> ?maxsplit:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a list of the sections in the bytes, using sep as the delimiter.

  sep
    The delimiter according which to split the bytes.
    None (the default value) means split on ASCII whitespace characters
    (space, tab, return, newline, formfeed, vertical tab).
  maxsplit
    Maximum number of splits to do.
    -1 (the default value) means no limit.

Splitting is done starting at the end of the bytes and working to the front.
*)

val rstrip : ?bytes:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Strip trailing bytes contained in the argument.

If the argument is omitted or None, strip trailing ASCII whitespace.
*)

val split : ?sep:Py.Object.t -> ?maxsplit:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a list of the sections in the bytes, using sep as the delimiter.

sep
  The delimiter according which to split the bytes.
  None (the default value) means split on ASCII whitespace characters
  (space, tab, return, newline, formfeed, vertical tab).
maxsplit
  Maximum number of splits to do.
  -1 (the default value) means no limit.
*)

val splitlines : ?keepends:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a list of the lines in the bytes, breaking at line boundaries.

Line breaks are not included in the resulting list unless keepends is given and
true.
*)

val startswith : ?start:Py.Object.t -> ?end_:Py.Object.t -> prefix:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.startswith(prefix[, start[, end]]) -> bool

Return True if B starts with the specified prefix, False otherwise.
With optional start, test B beginning at that position.
With optional end, stop comparing B at that position.
prefix can also be a tuple of bytes to try.
*)

val strip : ?bytes:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Strip leading and trailing bytes contained in the argument.

If the argument is omitted or None, strip leading and trailing ASCII whitespace.
*)

val translate : ?delete:Py.Object.t -> table:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy with each character mapped by the given translation table.

  table
    Translation table, which must be a bytes object of length 256.

All characters occurring in the optional argument delete are removed.
The remaining characters are mapped through the given translation table.
*)

val zfill : width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Pad a numeric string with zeros on the left, to fill a field of the given width.

The original string is never truncated.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Cdouble : sig
type tag = [`Complex128]
type t = [`Complex128 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?real:Py.Object.t -> ?imag:Py.Object.t -> unit -> t
(**
Complex number type composed of two double-precision floating-point
numbers, compatible with Python `complex`.
Character code: ``'D'``.
Canonical name: ``np.cdouble``.
Alias: ``np.cfloat``.
Alias: ``np.complex_``.
Alias *on this platform*: ``np.complex128``: Complex number type composed of 2 64-bit-precision floating-point numbers.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Cfloat : sig
type tag = [`Complex128]
type t = [`Complex128 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?real:Py.Object.t -> ?imag:Py.Object.t -> unit -> t
(**
Complex number type composed of two double-precision floating-point
numbers, compatible with Python `complex`.
Character code: ``'D'``.
Canonical name: ``np.cdouble``.
Alias: ``np.cfloat``.
Alias: ``np.complex_``.
Alias *on this platform*: ``np.complex128``: Complex number type composed of 2 64-bit-precision floating-point numbers.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Character : sig
type tag = [`Character]
type t = [`Character | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Abstract base class of all character string scalar types.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Clongdouble : sig
type tag = [`Complex256]
type t = [`Complex256 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Clongfloat : sig
type tag = [`Complex256]
type t = [`Complex256 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Complex : sig
type tag = [`Complex]
type t = [`Complex | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?real:Py.Object.t -> ?imag:Py.Object.t -> unit -> t
(**
Create a complex number from a real part and an optional imaginary part.

This is equivalent to (real + imag*1j) where imag defaults to 0.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Complex256 : sig
type tag = [`Complex256]
type t = [`Complex256 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Complex64 : sig
type tag = [`Complex64]
type t = [`Complex64 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Complexfloating : sig
type tag = [`Complexfloating]
type t = [`Complexfloating | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Abstract base class of all complex number scalar types that are made up of
floating-point numbers.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Csingle : sig
type tag = [`Complex64]
type t = [`Complex64 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Datetime64 : sig
type tag = [`Datetime64]
type t = [`Datetime64 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Double : sig
type tag = [`Float64]
type t = [`Float64 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?x:Py.Object.t -> unit -> t
(**
Double-precision floating-point number type, compatible with Python `float`
and C ``double``.
Character code: ``'d'``.
Canonical name: ``np.double``.
Alias: ``np.float_``.
Alias *on this platform*: ``np.float64``: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val fromhex : string:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Create a floating-point number from a hexadecimal string.

>>> float.fromhex('0x1.ffffp10')
2047.984375
>>> float.fromhex('-0x1p-1074')
-5e-324
*)

val hex : [> tag] Obj.t -> Py.Object.t
(**
Return a hexadecimal representation of a floating-point number.

>>> (-0.1).hex()
'-0x1.999999999999ap-4'
>>> 3.14159.hex()
'0x1.921f9f01b866ep+1'
*)

val is_integer : [> tag] Obj.t -> Py.Object.t
(**
Return True if the float is an integer.
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Errstate : sig
type tag = [`Errstate]
type t = [`Errstate | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?kwargs:(string * Py.Object.t) list -> unit -> t
(**
errstate( **kwargs)

Context manager for floating-point error handling.

Using an instance of `errstate` as a context manager allows statements in
that context to execute with a known error handling behavior. Upon entering
the context the error handling is set with `seterr` and `seterrcall`, and
upon exiting it is reset to what it was before.

..  versionchanged:: 1.17.0
    `errstate` is also usable as a function decorator, saving
    a level of indentation if an entire function is wrapped.
    See :py:class:`contextlib.ContextDecorator` for more information.

Parameters
----------
kwargs : {divide, over, under, invalid}
    Keyword arguments. The valid keywords are the possible floating-point
    exceptions. Each keyword should have a string value that defines the
    treatment for the particular error. Possible values are
    {'ignore', 'warn', 'raise', 'call', 'print', 'log'}.

See Also
--------
seterr, geterr, seterrcall, geterrcall

Notes
-----
For complete documentation of the types of floating-point exceptions and
treatment options, see `seterr`.

Examples
--------
>>> from collections import OrderedDict
>>> olderr = np.seterr(all='ignore')  # Set error handling to known state.

>>> np.arange(3) / 0.
array([nan, inf, inf])
>>> with np.errstate(divide='warn'):
...     np.arange(3) / 0.
array([nan, inf, inf])

>>> np.sqrt(-1)
nan
>>> with np.errstate(invalid='raise'):
...     np.sqrt(-1)
Traceback (most recent call last):
  File '<stdin>', line 2, in <module>
FloatingPointError: invalid value encountered in sqrt

Outside the context the error handling behavior has not changed:

>>> OrderedDict(sorted(np.geterr().items()))
OrderedDict([('divide', 'ignore'), ('invalid', 'ignore'), ('over', 'ignore'), ('under', 'ignore')])
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Finfo : sig
type tag = [`Finfo]
type t = [`Finfo | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : [`Instance of Py.Object.t | `Dtype of Dtype.t | `F of float] -> t
(**
finfo(dtype)

Machine limits for floating point types.

Attributes
----------
bits : int
    The number of bits occupied by the type.
eps : float
    The smallest representable positive number such that
    ``1.0 + eps != 1.0``.  Type of `eps` is an appropriate floating
    point type.
epsneg : floating point number of the appropriate type
    The smallest representable positive number such that
    ``1.0 - epsneg != 1.0``.
iexp : int
    The number of bits in the exponent portion of the floating point
    representation.
machar : MachAr
    The object which calculated these parameters and holds more
    detailed information.
machep : int
    The exponent that yields `eps`.
max : floating point number of the appropriate type
    The largest representable number.
maxexp : int
    The smallest positive power of the base (2) that causes overflow.
min : floating point number of the appropriate type
    The smallest representable number, typically ``-max``.
minexp : int
    The most negative power of the base (2) consistent with there
    being no leading 0's in the mantissa.
negep : int
    The exponent that yields `epsneg`.
nexp : int
    The number of bits in the exponent including its sign and bias.
nmant : int
    The number of bits in the mantissa.
precision : int
    The approximate number of decimal digits to which this kind of
    float is precise.
resolution : floating point number of the appropriate type
    The approximate decimal resolution of this type, i.e.,
    ``10**-precision``.
tiny : float
    The smallest positive usable number.  Type of `tiny` is an
    appropriate floating point type.

Parameters
----------
dtype : float, dtype, or instance
    Kind of floating point data-type about which to get information.

See Also
--------
MachAr : The implementation of the tests that produce this information.
iinfo : The equivalent for integer data types.

Notes
-----
For developers of NumPy: do not instantiate this at the module level.
The initial calculation of these parameters is expensive and negatively
impacts import times.  These objects are cached, so calling ``finfo()``
repeatedly inside your functions is not a problem.
*)


(** Attribute bits: get value or raise Not_found if None.*)
val bits : t -> int

(** Attribute bits: get value as an option. *)
val bits_opt : t -> (int) option


(** Attribute eps: get value or raise Not_found if None.*)
val eps : t -> float

(** Attribute eps: get value as an option. *)
val eps_opt : t -> (float) option


(** Attribute epsneg: get value or raise Not_found if None.*)
val epsneg : t -> Py.Object.t

(** Attribute epsneg: get value as an option. *)
val epsneg_opt : t -> (Py.Object.t) option


(** Attribute iexp: get value or raise Not_found if None.*)
val iexp : t -> int

(** Attribute iexp: get value as an option. *)
val iexp_opt : t -> (int) option


(** Attribute machar: get value or raise Not_found if None.*)
val machar : t -> Py.Object.t

(** Attribute machar: get value as an option. *)
val machar_opt : t -> (Py.Object.t) option


(** Attribute machep: get value or raise Not_found if None.*)
val machep : t -> int

(** Attribute machep: get value as an option. *)
val machep_opt : t -> (int) option


(** Attribute max: get value or raise Not_found if None.*)
val max : t -> Py.Object.t

(** Attribute max: get value as an option. *)
val max_opt : t -> (Py.Object.t) option


(** Attribute maxexp: get value or raise Not_found if None.*)
val maxexp : t -> int

(** Attribute maxexp: get value as an option. *)
val maxexp_opt : t -> (int) option


(** Attribute min: get value or raise Not_found if None.*)
val min : t -> Py.Object.t

(** Attribute min: get value as an option. *)
val min_opt : t -> (Py.Object.t) option


(** Attribute minexp: get value or raise Not_found if None.*)
val minexp : t -> int

(** Attribute minexp: get value as an option. *)
val minexp_opt : t -> (int) option


(** Attribute negep: get value or raise Not_found if None.*)
val negep : t -> int

(** Attribute negep: get value as an option. *)
val negep_opt : t -> (int) option


(** Attribute nexp: get value or raise Not_found if None.*)
val nexp : t -> int

(** Attribute nexp: get value as an option. *)
val nexp_opt : t -> (int) option


(** Attribute nmant: get value or raise Not_found if None.*)
val nmant : t -> int

(** Attribute nmant: get value as an option. *)
val nmant_opt : t -> (int) option


(** Attribute precision: get value or raise Not_found if None.*)
val precision : t -> int

(** Attribute precision: get value as an option. *)
val precision_opt : t -> (int) option


(** Attribute resolution: get value or raise Not_found if None.*)
val resolution : t -> Py.Object.t

(** Attribute resolution: get value as an option. *)
val resolution_opt : t -> (Py.Object.t) option


(** Attribute tiny: get value or raise Not_found if None.*)
val tiny : t -> float

(** Attribute tiny: get value as an option. *)
val tiny_opt : t -> (float) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Flatiter : sig
type tag = [`Flatiter]
type t = [`Flatiter | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Flat iterator object to iterate over arrays.

A `flatiter` iterator is returned by ``x.flat`` for any array `x`.
It allows iterating over the array as if it were a 1-D array,
either in a for-loop or by calling its `next` method.

Iteration is done in row-major, C-style order (the last
index varying the fastest). The iterator can also be indexed using
basic slicing or advanced indexing.

See Also
--------
ndarray.flat : Return a flat iterator over an array.
ndarray.flatten : Returns a flattened copy of an array.

Notes
-----
A `flatiter` iterator can not be constructed directly from Python code
by calling the `flatiter` constructor.

Examples
--------
>>> x = np.arange(6).reshape(2, 3)
>>> fl = x.flat
>>> type(fl)
<class 'numpy.flatiter'>
>>> for item in fl:
...     print(item)
...
0
1
2
3
4
5

>>> fl[2:4]
array([2, 3])
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Implement iter(self).
*)

val __setitem__ : key:Py.Object.t -> value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Set self[key] to value.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Flexible : sig
type tag = [`Flexible]
type t = [`Flexible | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Abstract base class of all scalar types without predefined length.
The actual size of these types depends on the specific `np.dtype`
instantiation.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Float : sig
type tag = [`Float]
type t = [`Float | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?x:Py.Object.t -> unit -> t
(**
Convert a string or number to a floating point number, if possible.
*)

val as_integer_ratio : [> tag] Obj.t -> Py.Object.t
(**
Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original float
and with a positive denominator.

Raise OverflowError on infinities and a ValueError on NaNs.

>>> (10.0).as_integer_ratio()
(10, 1)
>>> (0.0).as_integer_ratio()
(0, 1)
>>> (-.25).as_integer_ratio()
(-1, 4)
*)

val conjugate : [> tag] Obj.t -> Py.Object.t
(**
Return self, the complex conjugate of any float.
*)

val fromhex : string:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Create a floating-point number from a hexadecimal string.

>>> float.fromhex('0x1.ffffp10')
2047.984375
>>> float.fromhex('-0x1p-1074')
-5e-324
*)

val hex : [> tag] Obj.t -> Py.Object.t
(**
Return a hexadecimal representation of a floating-point number.

>>> (-0.1).hex()
'-0x1.999999999999ap-4'
>>> 3.14159.hex()
'0x1.921f9f01b866ep+1'
*)

val is_integer : [> tag] Obj.t -> Py.Object.t
(**
Return True if the float is an integer.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Float128 : sig
type tag = [`Float128]
type t = [`Float128 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Float16 : sig
type tag = [`Float16]
type t = [`Float16 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Float32 : sig
type tag = [`Float32]
type t = [`Float32 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Floating : sig
type tag = [`Floating]
type t = [`Floating | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Abstract base class of all floating-point scalar types.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Format_parser : sig
type tag = [`Format_parser]
type t = [`Format_parser | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?aligned:bool -> ?byteorder:string -> formats:[`StringList of string list | `S of string] -> names:[`List_tuple_of_str of Py.Object.t | `S of string] -> titles:Py.Object.t -> unit -> t
(**
Class to convert formats, names, titles description to a dtype.

After constructing the format_parser object, the dtype attribute is
the converted data-type:
``dtype = format_parser(formats, names, titles).dtype``

Attributes
----------
dtype : dtype
    The converted data-type.

Parameters
----------
formats : str or list of str
    The format description, either specified as a string with
    comma-separated format descriptions in the form ``'f8, i4, a5'``, or
    a list of format description strings  in the form
    ``['f8', 'i4', 'a5']``.
names : str or list/tuple of str
    The field names, either specified as a comma-separated string in the
    form ``'col1, col2, col3'``, or as a list or tuple of strings in the
    form ``['col1', 'col2', 'col3']``.
    An empty list can be used, in that case default field names
    ('f0', 'f1', ...) are used.
titles : sequence
    Sequence of title strings. An empty list can be used to leave titles
    out.
aligned : bool, optional
    If True, align the fields by padding as the C-compiler would.
    Default is False.
byteorder : str, optional
    If specified, all the fields will be changed to the
    provided byte-order.  Otherwise, the default byte-order is
    used. For all available string specifiers, see `dtype.newbyteorder`.

See Also
--------
dtype, typename, sctype2char

Examples
--------
>>> np.format_parser(['<f8', '<i4', '<a5'], ['col1', 'col2', 'col3'],
...                  ['T1', 'T2', 'T3']).dtype
dtype([(('T1', 'col1'), '<f8'), (('T2', 'col2'), '<i4'), (('T3', 'col3'), 'S5')])

`names` and/or `titles` can be empty lists. If `titles` is an empty list,
titles will simply not appear. If `names` is empty, default field names
will be used.

>>> np.format_parser(['f8', 'i4', 'a5'], ['col1', 'col2', 'col3'],
...                  []).dtype
dtype([('col1', '<f8'), ('col2', '<i4'), ('col3', '<S5')])
>>> np.format_parser(['<f8', '<i4', '<a5'], [], []).dtype
dtype([('f0', '<f8'), ('f1', '<i4'), ('f2', 'S5')])
*)


(** Attribute dtype: get value or raise Not_found if None.*)
val dtype : t -> Dtype.t

(** Attribute dtype: get value as an option. *)
val dtype_opt : t -> (Dtype.t) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Generic : sig
type tag = [`Generic]
type t = [`Generic | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Base class for numpy scalar types.

Class from which most (all?) numpy scalar types are derived.  For
consistency, exposes the same API as `ndarray`, despite many
consequent attributes being either 'get-only,' or completely irrelevant.
This is the class from which it is strongly suggested users should derive
custom scalar types.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Half : sig
type tag = [`Float16]
type t = [`Float16 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Iinfo : sig
type tag = [`Iinfo]
type t = [`Iinfo | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : [`Dtype of Dtype.t | `PyObject of Py.Object.t] -> t
(**
iinfo(type)

Machine limits for integer types.

Attributes
----------
bits : int
    The number of bits occupied by the type.
min : int
    The smallest integer expressible by the type.
max : int
    The largest integer expressible by the type.

Parameters
----------
int_type : integer type, dtype, or instance
    The kind of integer data type to get information about.

See Also
--------
finfo : The equivalent for floating point data types.

Examples
--------
With types:

>>> ii16 = np.iinfo(np.int16)
>>> ii16.min
-32768
>>> ii16.max
32767
>>> ii32 = np.iinfo(np.int32)
>>> ii32.min
-2147483648
>>> ii32.max
2147483647

With instances:

>>> ii32 = np.iinfo(np.int32(10))
>>> ii32.min
-2147483648
>>> ii32.max
2147483647
*)


(** Attribute bits: get value or raise Not_found if None.*)
val bits : t -> int

(** Attribute bits: get value as an option. *)
val bits_opt : t -> (int) option


(** Attribute min: get value or raise Not_found if None.*)
val min : t -> int

(** Attribute min: get value as an option. *)
val min_opt : t -> (int) option


(** Attribute max: get value or raise Not_found if None.*)
val max : t -> int

(** Attribute max: get value as an option. *)
val max_opt : t -> (int) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Inexact : sig
type tag = [`Inexact]
type t = [`Inexact | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Abstract base class of all numeric scalar types with a (potentially)
inexact representation of the values in its range, such as
floating-point numbers.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Int : sig
type tag = [`Int]
type t = [`Int | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?x:Py.Object.t -> unit -> t
(**
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4
*)

val as_integer_ratio : [> tag] Obj.t -> Py.Object.t
(**
Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)
*)

val bit_length : [> tag] Obj.t -> Py.Object.t
(**
Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6
*)

val from_bytes : ?signed:Py.Object.t -> bytes:Py.Object.t -> byteorder:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the integer represented by the given array of bytes.

bytes
  Holds the array of bytes to convert.  The argument must either
  support the buffer protocol or be an iterable object producing bytes.
  Bytes and bytearray are examples of built-in objects that support the
  buffer protocol.
byteorder
  The byte order used to represent the integer.  If byteorder is 'big',
  the most significant byte is at the beginning of the byte array.  If
  byteorder is 'little', the most significant byte is at the end of the
  byte array.  To request the native byte order of the host system, use
  `sys.byteorder' as the byte order value.
signed
  Indicates whether two's complement is used to represent the integer.
*)

val to_bytes : ?signed:Py.Object.t -> length:Py.Object.t -> byteorder:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return an array of bytes representing an integer.

length
  Length of bytes object to use.  An OverflowError is raised if the
  integer is not representable with the given number of bytes.
byteorder
  The byte order used to represent the integer.  If byteorder is 'big',
  the most significant byte is at the beginning of the byte array.  If
  byteorder is 'little', the most significant byte is at the end of the
  byte array.  To request the native byte order of the host system, use
  `sys.byteorder' as the byte order value.
signed
  Determines whether two's complement is used to represent the integer.
  If signed is False and a negative integer is given, an OverflowError
  is raised.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Int0 : sig
type tag = [`Int64]
type t = [`Int64 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Int16 : sig
type tag = [`Int16]
type t = [`Int16 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Int32 : sig
type tag = [`Int32]
type t = [`Int32 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Int8 : sig
type tag = [`Int8]
type t = [`Int8 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Intc : sig
type tag = [`Int32]
type t = [`Int32 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Integer : sig
type tag = [`Integer]
type t = [`Integer | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Abstract base class of all integer scalar types.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Intp : sig
type tag = [`Int64]
type t = [`Int64 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Longlong : sig
type tag = [`Longlong]
type t = [`Longlong | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Matrix : sig
type tag = [`Matrix]
type t = [`ArrayLike | `Matrix | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?dtype:Dtype.t -> ?copy:bool -> data:[`Ndarray of [>`Ndarray] Obj.t | `S of string] -> unit -> t
(**
matrix(data, dtype=None, copy=True)

.. note:: It is no longer recommended to use this class, even for linear
          algebra. Instead use regular arrays. The class may be removed
          in the future.

Returns a matrix from an array-like object, or from a string of data.
A matrix is a specialized 2-D array that retains its 2-D nature
through operations.  It has certain special operators, such as ``*``
(matrix multiplication) and ``**`` (matrix power).

Parameters
----------
data : array_like or string
   If `data` is a string, it is interpreted as a matrix with commas
   or spaces separating columns, and semicolons separating rows.
dtype : data-type
   Data-type of the output matrix.
copy : bool
   If `data` is already an `ndarray`, then this flag determines
   whether the data is copied (the default), or whether a view is
   constructed.

See Also
--------
array

Examples
--------
>>> a = np.matrix('1 2; 3 4')
>>> a
matrix([[1, 2],
        [3, 4]])

>>> np.matrix([[1, 2], [3, 4]])
matrix([[1, 2],
        [3, 4]])
*)

val __getitem__ : index:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Implement iter(self).
*)

val __setitem__ : key:Py.Object.t -> value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Set self[key] to value.
*)

val all : ?axis:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Test whether all matrix elements along a given axis evaluate to True.

Parameters
----------
See `numpy.all` for complete descriptions

See Also
--------
numpy.all

Notes
-----
This is the same as `ndarray.all`, but it returns a `matrix` object.

Examples
--------
>>> x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
>>> y = x[0]; y
matrix([[0, 1, 2, 3]])
>>> (x == y)
matrix([[ True,  True,  True,  True],
        [False, False, False, False],
        [False, False, False, False]])
>>> (x == y).all()
False
>>> (x == y).all(0)
matrix([[False, False, False, False]])
>>> (x == y).all(1)
matrix([[ True],
        [False],
        [False]])
*)

val any : ?axis:int -> ?out:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Test whether any array element along a given axis evaluates to True.

Refer to `numpy.any` for full documentation.

Parameters
----------
axis : int, optional
    Axis along which logical OR is performed
out : ndarray, optional
    Output to existing array instead of creating new one, must have
    same shape as expected output

Returns
-------
    any : bool, ndarray
        Returns a single bool if `axis` is ``None``; otherwise,
        returns `ndarray`
*)

val argmax : ?axis:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Indexes of the maximum values along an axis.

Return the indexes of the first occurrences of the maximum values
along the specified axis.  If axis is None, the index is for the
flattened matrix.

Parameters
----------
See `numpy.argmax` for complete descriptions

See Also
--------
numpy.argmax

Notes
-----
This is the same as `ndarray.argmax`, but returns a `matrix` object
where `ndarray.argmax` would return an `ndarray`.

Examples
--------
>>> x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
>>> x.argmax()
11
>>> x.argmax(0)
matrix([[2, 2, 2, 2]])
>>> x.argmax(1)
matrix([[3],
        [3],
        [3]])
*)

val argmin : ?axis:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Indexes of the minimum values along an axis.

Return the indexes of the first occurrences of the minimum values
along the specified axis.  If axis is None, the index is for the
flattened matrix.

Parameters
----------
See `numpy.argmin` for complete descriptions.

See Also
--------
numpy.argmin

Notes
-----
This is the same as `ndarray.argmin`, but returns a `matrix` object
where `ndarray.argmin` would return an `ndarray`.

Examples
--------
>>> x = -np.matrix(np.arange(12).reshape((3,4))); x
matrix([[  0,  -1,  -2,  -3],
        [ -4,  -5,  -6,  -7],
        [ -8,  -9, -10, -11]])
>>> x.argmin()
11
>>> x.argmin(0)
matrix([[2, 2, 2, 2]])
>>> x.argmin(1)
matrix([[3],
        [3],
        [3]])
*)

val argpartition : ?axis:Py.Object.t -> ?kind:Py.Object.t -> ?order:Py.Object.t -> kth:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argpartition(kth, axis=-1, kind='introselect', order=None)

Returns the indices that would partition this array.

Refer to `numpy.argpartition` for full documentation.

.. versionadded:: 1.8.0

See Also
--------
numpy.argpartition : equivalent function
*)

val argsort : ?axis:Py.Object.t -> ?kind:Py.Object.t -> ?order:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argsort(axis=-1, kind=None, order=None)

Returns the indices that would sort this array.

Refer to `numpy.argsort` for full documentation.

See Also
--------
numpy.argsort : equivalent function
*)

val astype : ?order:[`C | `F | `A | `K] -> ?casting:[`No | `Equiv | `Safe | `Same_kind | `Unsafe] -> ?subok:Py.Object.t -> ?copy:bool -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)

Copy of the array, cast to a specified type.

Parameters
----------
dtype : str or dtype
    Typecode or data-type to which the array is cast.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout order of the result.
    'C' means C order, 'F' means Fortran order, 'A'
    means 'F' order if all the arrays are Fortran contiguous,
    'C' order otherwise, and 'K' means as close to the
    order the array elements appear in memory as possible.
    Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'unsafe'
    for backwards compatibility.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.
subok : bool, optional
    If True, then sub-classes will be passed-through (default), otherwise
    the returned array will be forced to be a base-class array.
copy : bool, optional
    By default, astype always returns a newly allocated array. If this
    is set to false, and the `dtype`, `order`, and `subok`
    requirements are satisfied, the input array is returned instead
    of a copy.

Returns
-------
arr_t : ndarray
    Unless `copy` is False and the other conditions for returning the input
    array are satisfied (see description for `copy` input parameter), `arr_t`
    is a new array of the same shape as the input array, with dtype, order
    given by `dtype`, `order`.

Notes
-----
.. versionchanged:: 1.17.0
   Casting between a simple data type and a structured one is possible only
   for 'unsafe' casting.  Casting to multiple fields is allowed, but
   casting from multiple fields is not.

.. versionchanged:: 1.9.0
   Casting from numeric to string types in 'safe' casting mode requires
   that the string dtype length is long enough to store the max
   integer/float value converted.

Raises
------
ComplexWarning
    When casting from complex to float or int. To avoid this,
    one should use ``a.real.astype(t)``.

Examples
--------
>>> x = np.array([1, 2, 2.5])
>>> x
array([1. ,  2. ,  2.5])

>>> x.astype(int)
array([1, 2, 2])
*)

val byteswap : ?inplace:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.byteswap(inplace=False)

Swap the bytes of the array elements

Toggle between low-endian and big-endian data representation by
returning a byteswapped array, optionally swapped in-place.
Arrays of byte-strings are not swapped. The real and imaginary
parts of a complex number are swapped individually.

Parameters
----------
inplace : bool, optional
    If ``True``, swap bytes in-place, default is ``False``.

Returns
-------
out : ndarray
    The byteswapped array. If `inplace` is ``True``, this is
    a view to self.

Examples
--------
>>> A = np.array([1, 256, 8755], dtype=np.int16)
>>> list(map(hex, A))
['0x1', '0x100', '0x2233']
>>> A.byteswap(inplace=True)
array([  256,     1, 13090], dtype=int16)
>>> list(map(hex, A))
['0x100', '0x1', '0x3322']

Arrays of byte-strings are not swapped

>>> A = np.array([b'ceg', b'fac'])
>>> A.byteswap()
array([b'ceg', b'fac'], dtype='|S3')

``A.newbyteorder().byteswap()`` produces an array with the same values
  but different representation in memory

>>> A = np.array([1, 2, 3])
>>> A.view(np.uint8)
array([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
       0, 0], dtype=uint8)
>>> A.newbyteorder().byteswap(inplace=True)
array([1, 2, 3])
>>> A.view(np.uint8)
array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
       0, 3], dtype=uint8)
*)

val choose : ?out:Py.Object.t -> ?mode:Py.Object.t -> choices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.choose(choices, out=None, mode='raise')

Use an index array to construct a new array from a set of choices.

Refer to `numpy.choose` for full documentation.

See Also
--------
numpy.choose : equivalent function
*)

val clip : ?min:Py.Object.t -> ?max:Py.Object.t -> ?out:Py.Object.t -> ?kwargs:(string * Py.Object.t) list -> [> tag] Obj.t -> Py.Object.t
(**
a.clip(min=None, max=None, out=None, **kwargs)

Return an array whose values are limited to ``[min, max]``.
One of max or min must be given.

Refer to `numpy.clip` for full documentation.

See Also
--------
numpy.clip : equivalent function
*)

val compress : ?axis:Py.Object.t -> ?out:Py.Object.t -> condition:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.compress(condition, axis=None, out=None)

Return selected slices of this array along given axis.

Refer to `numpy.compress` for full documentation.

See Also
--------
numpy.compress : equivalent function
*)

val conj : [> tag] Obj.t -> Py.Object.t
(**
a.conj()

Complex-conjugate all elements.

Refer to `numpy.conjugate` for full documentation.

See Also
--------
numpy.conjugate : equivalent function
*)

val conjugate : [> tag] Obj.t -> Py.Object.t
(**
a.conjugate()

Return the complex conjugate, element-wise.

Refer to `numpy.conjugate` for full documentation.

See Also
--------
numpy.conjugate : equivalent function
*)

val copy : ?order:[`C | `F | `A | `K] -> [> tag] Obj.t -> Py.Object.t
(**
a.copy(order='C')

Return a copy of the array.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout of the copy. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible. (Note that this function and :func:`numpy.copy` are very
    similar, but have different default values for their order=
    arguments.)

See also
--------
numpy.copy
numpy.copyto

Examples
--------
>>> x = np.array([[1,2,3],[4,5,6]], order='F')

>>> y = x.copy()

>>> x.fill(0)

>>> x
array([[0, 0, 0],
       [0, 0, 0]])

>>> y
array([[1, 2, 3],
       [4, 5, 6]])

>>> y.flags['C_CONTIGUOUS']
True
*)

val cumprod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.cumprod(axis=None, dtype=None, out=None)

Return the cumulative product of the elements along the given axis.

Refer to `numpy.cumprod` for full documentation.

See Also
--------
numpy.cumprod : equivalent function
*)

val cumsum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.cumsum(axis=None, dtype=None, out=None)

Return the cumulative sum of the elements along the given axis.

Refer to `numpy.cumsum` for full documentation.

See Also
--------
numpy.cumsum : equivalent function
*)

val diagonal : ?offset:Py.Object.t -> ?axis1:Py.Object.t -> ?axis2:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.diagonal(offset=0, axis1=0, axis2=1)

Return specified diagonals. In NumPy 1.9 the returned array is a
read-only view instead of a copy as in previous NumPy versions.  In
a future version the read-only restriction will be removed.

Refer to :func:`numpy.diagonal` for full documentation.

See Also
--------
numpy.diagonal : equivalent function
*)

val dot : ?out:Py.Object.t -> b:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.dot(b, out=None)

Dot product of two arrays.

Refer to `numpy.dot` for full documentation.

See Also
--------
numpy.dot : equivalent function

Examples
--------
>>> a = np.eye(2)
>>> b = np.ones((2, 2)) * 2
>>> a.dot(b)
array([[2.,  2.],
       [2.,  2.]])

This array method can be conveniently chained:

>>> a.dot(b).dot(b)
array([[8.,  8.],
       [8.,  8.]])
*)

val dump : file:[`Path of Py.Object.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.dump(file)

Dump a pickle of the array to the specified file.
The array can be read back with pickle.load or numpy.load.

Parameters
----------
file : str or Path
    A string naming the dump file.

    .. versionchanged:: 1.17.0
        `pathlib.Path` objects are now accepted.
*)

val dumps : [> tag] Obj.t -> Py.Object.t
(**
a.dumps()

Returns the pickle of the array as a string.
pickle.loads or numpy.loads will convert the string back to an array.

Parameters
----------
None
*)

val fill : value:[`F of float | `I of int | `Bool of bool | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.fill(value)

Fill the array with a scalar value.

Parameters
----------
value : scalar
    All elements of `a` will be assigned this value.

Examples
--------
>>> a = np.array([1, 2])
>>> a.fill(0)
>>> a
array([0, 0])
>>> a = np.empty(2)
>>> a.fill(1)
>>> a
array([1.,  1.])
*)

val flatten : ?order:[`C | `F | `A | `K] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a flattened copy of the matrix.

All `N` elements of the matrix are placed into a single row.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    'C' means to flatten in row-major (C-style) order. 'F' means to
    flatten in column-major (Fortran-style) order. 'A' means to
    flatten in column-major order if `m` is Fortran *contiguous* in
    memory, row-major order otherwise. 'K' means to flatten `m` in
    the order the elements occur in memory. The default is 'C'.

Returns
-------
y : matrix
    A copy of the matrix, flattened to a `(1, N)` matrix where `N`
    is the number of elements in the original matrix.

See Also
--------
ravel : Return a flattened array.
flat : A 1-D flat iterator over the matrix.

Examples
--------
>>> m = np.matrix([[1,2], [3,4]])
>>> m.flatten()
matrix([[1, 2, 3, 4]])
>>> m.flatten('F')
matrix([[1, 3, 2, 4]])
*)

val getA : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return `self` as an `ndarray` object.

Equivalent to ``np.asarray(self)``.

Parameters
----------
None

Returns
-------
ret : ndarray
    `self` as an `ndarray`

Examples
--------
>>> x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
>>> x.getA()
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
*)

val getA1 : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return `self` as a flattened `ndarray`.

Equivalent to ``np.asarray(x).ravel()``

Parameters
----------
None

Returns
-------
ret : ndarray
    `self`, 1-D, as an `ndarray`

Examples
--------
>>> x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
>>> x.getA1()
array([ 0,  1,  2, ...,  9, 10, 11])
*)

val getH : [> tag] Obj.t -> Py.Object.t
(**
Returns the (complex) conjugate transpose of `self`.

Equivalent to ``np.transpose(self)`` if `self` is real-valued.

Parameters
----------
None

Returns
-------
ret : matrix object
    complex conjugate transpose of `self`

Examples
--------
>>> x = np.matrix(np.arange(12).reshape((3,4)))
>>> z = x - 1j*x; z
matrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],
        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],
        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])
>>> z.getH()
matrix([[ 0. -0.j,  4. +4.j,  8. +8.j],
        [ 1. +1.j,  5. +5.j,  9. +9.j],
        [ 2. +2.j,  6. +6.j, 10.+10.j],
        [ 3. +3.j,  7. +7.j, 11.+11.j]])
*)

val getI : [> tag] Obj.t -> Py.Object.t
(**
Returns the (multiplicative) inverse of invertible `self`.

Parameters
----------
None

Returns
-------
ret : matrix object
    If `self` is non-singular, `ret` is such that ``ret * self`` ==
    ``self * ret`` == ``np.matrix(np.eye(self[0,:].size)`` all return
    ``True``.

Raises
------
numpy.linalg.LinAlgError: Singular matrix
    If `self` is singular.

See Also
--------
linalg.inv

Examples
--------
>>> m = np.matrix('[1, 2; 3, 4]'); m
matrix([[1, 2],
        [3, 4]])
>>> m.getI()
matrix([[-2. ,  1. ],
        [ 1.5, -0.5]])
>>> m.getI() * m
matrix([[ 1.,  0.], # may vary
        [ 0.,  1.]])
*)

val getT : [> tag] Obj.t -> Py.Object.t
(**
Returns the transpose of the matrix.

Does *not* conjugate!  For the complex conjugate transpose, use ``.H``.

Parameters
----------
None

Returns
-------
ret : matrix object
    The (non-conjugated) transpose of the matrix.

See Also
--------
transpose, getH

Examples
--------
>>> m = np.matrix('[1, 2; 3, 4]')
>>> m
matrix([[1, 2],
        [3, 4]])
>>> m.getT()
matrix([[1, 3],
        [2, 4]])
*)

val getfield : ?offset:int -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.getfield(dtype, offset=0)

Returns a field of the given array as a certain type.

A field is a view of the array data with a given data-type. The values in
the view are determined by the given type and the offset into the current
array in bytes. The offset needs to be such that the view dtype fits in the
array dtype; for example an array of dtype complex128 has 16-byte elements.
If taking a view with a 32-bit integer (4 bytes), the offset needs to be
between 0 and 12 bytes.

Parameters
----------
dtype : str or dtype
    The data type of the view. The dtype size of the view can not be larger
    than that of the array itself.
offset : int
    Number of bytes to skip before beginning the element view.

Examples
--------
>>> x = np.diag([1.+1.j]*2)
>>> x[1, 1] = 2 + 4.j
>>> x
array([[1.+1.j,  0.+0.j],
       [0.+0.j,  2.+4.j]])
>>> x.getfield(np.float64)
array([[1.,  0.],
       [0.,  2.]])

By choosing an offset of 8 bytes we can select the complex part of the
array for our view:

>>> x.getfield(np.float64, offset=8)
array([[1.,  0.],
       [0.,  4.]])
*)

val item : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.item( *args)

Copy an element of an array to a standard Python scalar and return it.

Parameters
----------
\*args : Arguments (variable number and type)

    * none: in this case, the method only works for arrays
      with one element (`a.size == 1`), which element is
      copied into a standard Python scalar object and returned.

    * int_type: this argument is interpreted as a flat index into
      the array, specifying which element to copy and return.

    * tuple of int_types: functions as does a single int_type argument,
      except that the argument is interpreted as an nd-index into the
      array.

Returns
-------
z : Standard Python scalar object
    A copy of the specified element of the array as a suitable
    Python scalar

Notes
-----
When the data type of `a` is longdouble or clongdouble, item() returns
a scalar array object because there is no available Python scalar that
would not lose information. Void arrays return a buffer object for item(),
unless fields are defined, in which case a tuple is returned.

`item` is very similar to a[args], except, instead of an array scalar,
a standard Python scalar is returned. This can be useful for speeding up
access to elements of the array and doing arithmetic on elements of the
array using Python's optimized math.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.item(3)
1
>>> x.item(7)
0
>>> x.item((0, 1))
2
>>> x.item((2, 2))
1
*)

val itemset : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.itemset( *args)

Insert scalar into an array (scalar is cast to array's dtype, if possible)

There must be at least 1 argument, and define the last argument
as *item*.  Then, ``a.itemset( *args)`` is equivalent to but faster
than ``a[args] = item``.  The item should be a scalar value and `args`
must select a single item in the array `a`.

Parameters
----------
\*args : Arguments
    If one argument: a scalar, only used in case `a` is of size 1.
    If two arguments: the last argument is the value to be set
    and must be a scalar, the first argument specifies a single array
    element location. It is either an int or a tuple.

Notes
-----
Compared to indexing syntax, `itemset` provides some speed increase
for placing a scalar into a particular location in an `ndarray`,
if you must do this.  However, generally this is discouraged:
among other problems, it complicates the appearance of the code.
Also, when using `itemset` (and `item`) inside a loop, be sure
to assign the methods to a local variable to avoid the attribute
look-up at each loop iteration.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.itemset(4, 0)
>>> x.itemset((2, 2), 9)
>>> x
array([[2, 2, 6],
       [1, 0, 6],
       [1, 0, 9]])
*)

val max : ?axis:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the maximum value along an axis.

Parameters
----------
See `amax` for complete descriptions

See Also
--------
amax, ndarray.max

Notes
-----
This is the same as `ndarray.max`, but returns a `matrix` object
where `ndarray.max` would return an ndarray.

Examples
--------
>>> x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
>>> x.max()
11
>>> x.max(0)
matrix([[ 8,  9, 10, 11]])
>>> x.max(1)
matrix([[ 3],
        [ 7],
        [11]])
*)

val mean : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns the average of the matrix elements along the given axis.

Refer to `numpy.mean` for full documentation.

See Also
--------
numpy.mean

Notes
-----
Same as `ndarray.mean` except that, where that returns an `ndarray`,
this returns a `matrix` object.

Examples
--------
>>> x = np.matrix(np.arange(12).reshape((3, 4)))
>>> x
matrix([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
>>> x.mean()
5.5
>>> x.mean(0)
matrix([[4., 5., 6., 7.]])
>>> x.mean(1)
matrix([[ 1.5],
        [ 5.5],
        [ 9.5]])
*)

val min : ?axis:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the minimum value along an axis.

Parameters
----------
See `amin` for complete descriptions.

See Also
--------
amin, ndarray.min

Notes
-----
This is the same as `ndarray.min`, but returns a `matrix` object
where `ndarray.min` would return an ndarray.

Examples
--------
>>> x = -np.matrix(np.arange(12).reshape((3,4))); x
matrix([[  0,  -1,  -2,  -3],
        [ -4,  -5,  -6,  -7],
        [ -8,  -9, -10, -11]])
>>> x.min()
-11
>>> x.min(0)
matrix([[ -8,  -9, -10, -11]])
>>> x.min(1)
matrix([[ -3],
        [ -7],
        [-11]])
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arr.newbyteorder(new_order='S')

Return the array with the same data viewed with a different byte order.

Equivalent to::

    arr.view(arr.dtype.newbytorder(new_order))

Changes are also made in all fields and sub-arrays of the array data
type.



Parameters
----------
new_order : string, optional
    Byte order to force; a value from the byte order specifications
    below. `new_order` codes can be any of:

    * 'S' - swap dtype from current to opposite endian
    * {'<', 'L'} - little endian
    * {'>', 'B'} - big endian
    * {'=', 'N'} - native order
    * {'|', 'I'} - ignore (no change to byte order)

    The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_arr : array
    New array object with the dtype reflecting given change to the
    byte order.
*)

val nonzero : [> tag] Obj.t -> Py.Object.t
(**
a.nonzero()

Return the indices of the elements that are non-zero.

Refer to `numpy.nonzero` for full documentation.

See Also
--------
numpy.nonzero : equivalent function
*)

val partition : ?axis:int -> ?kind:[`Introselect] -> ?order:[`StringList of string list | `S of string] -> kth:[`Is of int list | `I of int] -> [> tag] Obj.t -> Py.Object.t
(**
a.partition(kth, axis=-1, kind='introselect', order=None)

Rearranges the elements in the array in such a way that the value of the
element in kth position is in the position it would be in a sorted array.
All elements smaller than the kth element are moved before this element and
all equal or greater are moved behind it. The ordering of the elements in
the two partitions is undefined.

.. versionadded:: 1.8.0

Parameters
----------
kth : int or sequence of ints
    Element index to partition by. The kth element value will be in its
    final sorted position and all smaller elements will be moved before it
    and all equal or greater elements behind it.
    The order of all elements in the partitions is undefined.
    If provided with a sequence of kth it will partition all elements
    indexed by kth of them into their sorted position at once.
axis : int, optional
    Axis along which to sort. Default is -1, which means sort along the
    last axis.
kind : {'introselect'}, optional
    Selection algorithm. Default is 'introselect'.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc. A single field can
    be specified as a string, and not all fields need to be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

See Also
--------
numpy.partition : Return a parititioned copy of an array.
argpartition : Indirect partition.
sort : Full sort.

Notes
-----
See ``np.partition`` for notes on the different algorithms.

Examples
--------
>>> a = np.array([3, 4, 2, 1])
>>> a.partition(3)
>>> a
array([2, 1, 3, 4])

>>> a.partition((1, 3))
>>> a
array([1, 2, 3, 4])
*)

val prod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the product of the array elements over the given axis.

Refer to `prod` for full documentation.

See Also
--------
prod, ndarray.prod

Notes
-----
Same as `ndarray.prod`, except, where that returns an `ndarray`, this
returns a `matrix` object instead.

Examples
--------
>>> x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
>>> x.prod()
0
>>> x.prod(0)
matrix([[  0,  45, 120, 231]])
>>> x.prod(1)
matrix([[   0],
        [ 840],
        [7920]])
*)

val ptp : ?axis:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Peak-to-peak (maximum - minimum) value along the given axis.

Refer to `numpy.ptp` for full documentation.

See Also
--------
numpy.ptp

Notes
-----
Same as `ndarray.ptp`, except, where that would return an `ndarray` object,
this returns a `matrix` object.

Examples
--------
>>> x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
>>> x.ptp()
11
>>> x.ptp(0)
matrix([[8, 8, 8, 8]])
>>> x.ptp(1)
matrix([[3],
        [3],
        [3]])
*)

val put : ?mode:Py.Object.t -> indices:Py.Object.t -> values:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.put(indices, values, mode='raise')

Set ``a.flat[n] = values[n]`` for all `n` in indices.

Refer to `numpy.put` for full documentation.

See Also
--------
numpy.put : equivalent function
*)

val ravel : ?order:[`C | `F | `A | `K] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a flattened matrix.

Refer to `numpy.ravel` for more documentation.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    The elements of `m` are read using this index order. 'C' means to
    index the elements in C-like order, with the last axis index
    changing fastest, back to the first axis index changing slowest.
    'F' means to index the elements in Fortran-like index order, with
    the first index changing fastest, and the last index changing
    slowest. Note that the 'C' and 'F' options take no account of the
    memory layout of the underlying array, and only refer to the order
    of axis indexing.  'A' means to read the elements in Fortran-like
    index order if `m` is Fortran *contiguous* in memory, C-like order
    otherwise.  'K' means to read the elements in the order they occur
    in memory, except for reversing the data when strides are negative.
    By default, 'C' index order is used.

Returns
-------
ret : matrix
    Return the matrix flattened to shape `(1, N)` where `N`
    is the number of elements in the original matrix.
    A copy is made only if necessary.

See Also
--------
matrix.flatten : returns a similar output matrix but always a copy
matrix.flat : a flat iterator on the array.
numpy.ravel : related function which returns an ndarray
*)

val repeat : ?axis:Py.Object.t -> repeats:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.repeat(repeats, axis=None)

Repeat elements of an array.

Refer to `numpy.repeat` for full documentation.

See Also
--------
numpy.repeat : equivalent function
*)

val reshape : ?order:Py.Object.t -> int list -> [> tag] Obj.t -> Py.Object.t
(**
a.reshape(shape, order='C')

Returns an array containing the same data with a new shape.

Refer to `numpy.reshape` for full documentation.

See Also
--------
numpy.reshape : equivalent function

Notes
-----
Unlike the free function `numpy.reshape`, this method on `ndarray` allows
the elements of the shape parameter to be passed in as separate arguments.
For example, ``a.reshape(10, 11)`` is equivalent to
``a.reshape((10, 11))``.
*)

val resize : ?refcheck:bool -> new_shape:[`T_n_ints of Py.Object.t | `TupleOfInts of int list] -> [> tag] Obj.t -> Py.Object.t
(**
a.resize(new_shape, refcheck=True)

Change shape and size of array in-place.

Parameters
----------
new_shape : tuple of ints, or `n` ints
    Shape of resized array.
refcheck : bool, optional
    If False, reference count will not be checked. Default is True.

Returns
-------
None

Raises
------
ValueError
    If `a` does not own its own data or references or views to it exist,
    and the data memory must be changed.
    PyPy only: will always raise if the data memory must be changed, since
    there is no reliable way to determine if references or views to it
    exist.

SystemError
    If the `order` keyword argument is specified. This behaviour is a
    bug in NumPy.

See Also
--------
resize : Return a new array with the specified shape.

Notes
-----
This reallocates space for the data area if necessary.

Only contiguous arrays (data elements consecutive in memory) can be
resized.

The purpose of the reference count check is to make sure you
do not use this array as a buffer for another Python object and then
reallocate the memory. However, reference counts can increase in
other ways so if you are sure that you have not shared the memory
for this array with another Python object, then you may safely set
`refcheck` to False.

Examples
--------
Shrinking an array: array is flattened (in the order that the data are
stored in memory), resized, and reshaped:

>>> a = np.array([[0, 1], [2, 3]], order='C')
>>> a.resize((2, 1))
>>> a
array([[0],
       [1]])

>>> a = np.array([[0, 1], [2, 3]], order='F')
>>> a.resize((2, 1))
>>> a
array([[0],
       [2]])

Enlarging an array: as above, but missing entries are filled with zeros:

>>> b = np.array([[0, 1], [2, 3]])
>>> b.resize(2, 3) # new_shape parameter doesn't have to be a tuple
>>> b
array([[0, 1, 2],
       [3, 0, 0]])

Referencing an array prevents resizing...

>>> c = a
>>> a.resize((1, 1))
Traceback (most recent call last):
...
ValueError: cannot resize an array that references or is referenced ...

Unless `refcheck` is False:

>>> a.resize((1, 1), refcheck=False)
>>> a
array([[0]])
>>> c
array([[0]])
*)

val round : ?decimals:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.round(decimals=0, out=None)

Return `a` with each element rounded to the given number of decimals.

Refer to `numpy.around` for full documentation.

See Also
--------
numpy.around : equivalent function
*)

val searchsorted : ?side:Py.Object.t -> ?sorter:Py.Object.t -> v:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.searchsorted(v, side='left', sorter=None)

Find indices where elements of v should be inserted in a to maintain order.

For full documentation, see `numpy.searchsorted`

See Also
--------
numpy.searchsorted : equivalent function
*)

val setfield : ?offset:int -> val_:Py.Object.t -> dtype:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.setfield(val, dtype, offset=0)

Put a value into a specified place in a field defined by a data-type.

Place `val` into `a`'s field defined by `dtype` and beginning `offset`
bytes into the field.

Parameters
----------
val : object
    Value to be placed in field.
dtype : dtype object
    Data-type of the field in which to place `val`.
offset : int, optional
    The number of bytes into the field at which to place `val`.

Returns
-------
None

See Also
--------
getfield

Examples
--------
>>> x = np.eye(3)
>>> x.getfield(np.float64)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
>>> x.setfield(3, np.int32)
>>> x.getfield(np.int32)
array([[3, 3, 3],
       [3, 3, 3],
       [3, 3, 3]], dtype=int32)
>>> x
array([[1.0e+000, 1.5e-323, 1.5e-323],
       [1.5e-323, 1.0e+000, 1.5e-323],
       [1.5e-323, 1.5e-323, 1.0e+000]])
>>> x.setfield(np.eye(3), np.int32)
>>> x
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
*)

val setflags : ?write:bool -> ?align:bool -> ?uic:bool -> [> tag] Obj.t -> Py.Object.t
(**
a.setflags(write=None, align=None, uic=None)

Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
respectively.

These Boolean-valued flags affect how numpy interprets the memory
area used by `a` (see Notes below). The ALIGNED flag can only
be set to True if the data is actually aligned according to the type.
The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
to True. The flag WRITEABLE can only be set to True if the array owns its
own memory, or the ultimate owner of the memory exposes a writeable buffer
interface, or is a string. (The exception for string is made so that
unpickling can be done without copying memory.)

Parameters
----------
write : bool, optional
    Describes whether or not `a` can be written to.
align : bool, optional
    Describes whether or not `a` is aligned properly for its type.
uic : bool, optional
    Describes whether or not `a` is a copy of another 'base' array.

Notes
-----
Array flags provide information about how the memory area used
for the array is to be interpreted. There are 7 Boolean flags
in use, only four of which can be changed by the user:
WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.

WRITEABLE (W) the data area can be written to;

ALIGNED (A) the data and strides are aligned appropriately for the hardware
(as determined by the compiler);

UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;

WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
called, the base array will be updated with the contents of this array.

All flags can be accessed using the single (upper case) letter as well
as the full name.

Examples
--------
>>> y = np.array([[3, 1, 7],
...               [2, 0, 0],
...               [8, 5, 9]])
>>> y
array([[3, 1, 7],
       [2, 0, 0],
       [8, 5, 9]])
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(write=0, align=0)
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : False
  ALIGNED : False
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(uic=1)
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: cannot set WRITEBACKIFCOPY flag to True
*)

val sort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[`StringList of string list | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.sort(axis=-1, kind=None, order=None)

Sort an array in-place. Refer to `numpy.sort` for full documentation.

Parameters
----------
axis : int, optional
    Axis along which to sort. Default is -1, which means sort along the
    last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
    and 'mergesort' use timsort under the covers and, in general, the
    actual implementation will vary with datatype. The 'mergesort' option
    is retained for backwards compatibility.

    .. versionchanged:: 1.15.0.
       The 'stable' option was added.

order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  A single field can
    be specified as a string, and not all fields need be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

See Also
--------
numpy.sort : Return a sorted copy of an array.
numpy.argsort : Indirect sort.
numpy.lexsort : Indirect stable sort on multiple keys.
numpy.searchsorted : Find elements in sorted array.
numpy.partition: Partial sort.

Notes
-----
See `numpy.sort` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.array([[1,4], [3,1]])
>>> a.sort(axis=1)
>>> a
array([[1, 4],
       [1, 3]])
>>> a.sort(axis=0)
>>> a
array([[1, 3],
       [1, 4]])

Use the `order` keyword to specify a field to use when sorting a
structured array:

>>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])
>>> a.sort(order='y')
>>> a
array([(b'c', 1), (b'a', 2)],
      dtype=[('x', 'S1'), ('y', '<i8')])
*)

val squeeze : ?axis:int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a possibly reshaped matrix.

Refer to `numpy.squeeze` for more documentation.

Parameters
----------
axis : None or int or tuple of ints, optional
    Selects a subset of the single-dimensional entries in the shape.
    If an axis is selected with shape entry greater than one,
    an error is raised.

Returns
-------
squeezed : matrix
    The matrix, but as a (1, N) matrix if it had shape (N, 1).

See Also
--------
numpy.squeeze : related function

Notes
-----
If `m` has a single column then that column is returned
as the single row of a matrix.  Otherwise `m` is returned.
The returned matrix is always either `m` itself or a view into `m`.
Supplying an axis keyword argument will not affect the returned matrix
but it may cause an error to be raised.

Examples
--------
>>> c = np.matrix([[1], [2]])
>>> c
matrix([[1],
        [2]])
>>> c.squeeze()
matrix([[1, 2]])
>>> r = c.T
>>> r
matrix([[1, 2]])
>>> r.squeeze()
matrix([[1, 2]])
>>> m = np.matrix([[1, 2], [3, 4]])
>>> m.squeeze()
matrix([[1, 2],
        [3, 4]])
*)

val std : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?ddof:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the standard deviation of the array elements along the given axis.

Refer to `numpy.std` for full documentation.

See Also
--------
numpy.std

Notes
-----
This is the same as `ndarray.std`, except that where an `ndarray` would
be returned, a `matrix` object is returned instead.

Examples
--------
>>> x = np.matrix(np.arange(12).reshape((3, 4)))
>>> x
matrix([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
>>> x.std()
3.4520525295346629 # may vary
>>> x.std(0)
matrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]]) # may vary
>>> x.std(1)
matrix([[ 1.11803399],
        [ 1.11803399],
        [ 1.11803399]])
*)

val sum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns the sum of the matrix elements, along the given axis.

Refer to `numpy.sum` for full documentation.

See Also
--------
numpy.sum

Notes
-----
This is the same as `ndarray.sum`, except that where an `ndarray` would
be returned, a `matrix` object is returned instead.

Examples
--------
>>> x = np.matrix([[1, 2], [4, 3]])
>>> x.sum()
10
>>> x.sum(axis=1)
matrix([[3],
        [7]])
>>> x.sum(axis=1, dtype='float')
matrix([[3.],
        [7.]])
>>> out = np.zeros((2, 1), dtype='float')
>>> x.sum(axis=1, dtype='float', out=np.asmatrix(out))
matrix([[3.],
        [7.]])
*)

val swapaxes : axis1:Py.Object.t -> axis2:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.swapaxes(axis1, axis2)

Return a view of the array with `axis1` and `axis2` interchanged.

Refer to `numpy.swapaxes` for full documentation.

See Also
--------
numpy.swapaxes : equivalent function
*)

val take : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?mode:Py.Object.t -> indices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.take(indices, axis=None, out=None, mode='raise')

Return an array formed from the elements of `a` at the given indices.

Refer to `numpy.take` for full documentation.

See Also
--------
numpy.take : equivalent function
*)

val tobytes : ?order:[`C | `F | `None] -> [> tag] Obj.t -> Py.Object.t
(**
a.tobytes(order='C')

Construct Python bytes containing the raw data bytes in the array.

Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either 'C' or 'Fortran',
or 'Any' order (the default is 'C'-order). 'Any' order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means 'Fortran' order.

.. versionadded:: 1.9.0

Parameters
----------
order : {'C', 'F', None}, optional
    Order of the data for multidimensional arrays:
    C, Fortran, or the same as for the original array.

Returns
-------
s : bytes
    Python bytes exhibiting a copy of `a`'s raw data.

Examples
--------
>>> x = np.array([[0, 1], [2, 3]], dtype='<u2')
>>> x.tobytes()
b'\x00\x00\x01\x00\x02\x00\x03\x00'
>>> x.tobytes('C') == x.tobytes()
True
>>> x.tobytes('F')
b'\x00\x00\x02\x00\x01\x00\x03\x00'
*)

val tofile : ?sep:string -> ?format:string -> fid:[`S of string | `PyObject of Py.Object.t] -> [> tag] Obj.t -> Py.Object.t
(**
a.tofile(fid, sep='', format='%s')

Write array to a file as text or binary (default).

Data is always written in 'C' order, independent of the order of `a`.
The data produced by this method can be recovered using the function
fromfile().

Parameters
----------
fid : file or str or Path
    An open file object, or a string containing a filename.

    .. versionchanged:: 1.17.0
        `pathlib.Path` objects are now accepted.

sep : str
    Separator between array items for text output.
    If '' (empty), a binary file is written, equivalent to
    ``file.write(a.tobytes())``.
format : str
    Format string for text file output.
    Each entry in the array is formatted to text by first converting
    it to the closest Python type, and then using 'format' % item.

Notes
-----
This is a convenience function for quick storage of array data.
Information on endianness and precision is lost, so this method is not a
good choice for files intended to archive data or transport data between
machines with different endianness. Some of these problems can be overcome
by outputting the data as text files, at the expense of speed and file
size.

When fid is a file object, array contents are directly written to the
file, bypassing the file object's ``write`` method. As a result, tofile
cannot be used with files objects supporting compression (e.g., GzipFile)
or file-like objects that do not support ``fileno()`` (e.g., BytesIO).
*)

val tolist : [> tag] Obj.t -> Py.Object.t
(**
Return the matrix as a (possibly nested) list.

See `ndarray.tolist` for full documentation.

See Also
--------
ndarray.tolist

Examples
--------
>>> x = np.matrix(np.arange(12).reshape((3,4))); x
matrix([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
>>> x.tolist()
[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]
*)

val tostring : ?order:[`C | `F | `None] -> [> tag] Obj.t -> Py.Object.t
(**
a.tostring(order='C')

Construct Python bytes containing the raw data bytes in the array.

Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either 'C' or 'Fortran',
or 'Any' order (the default is 'C'-order). 'Any' order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means 'Fortran' order.

This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.

Parameters
----------
order : {'C', 'F', None}, optional
    Order of the data for multidimensional arrays:
    C, Fortran, or the same as for the original array.

Returns
-------
s : bytes
    Python bytes exhibiting a copy of `a`'s raw data.

Examples
--------
>>> x = np.array([[0, 1], [2, 3]], dtype='<u2')
>>> x.tobytes()
b'\x00\x00\x01\x00\x02\x00\x03\x00'
>>> x.tobytes('C') == x.tobytes()
True
>>> x.tobytes('F')
b'\x00\x00\x02\x00\x01\x00\x03\x00'
*)

val trace : ?offset:Py.Object.t -> ?axis1:Py.Object.t -> ?axis2:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)

Return the sum along diagonals of the array.

Refer to `numpy.trace` for full documentation.

See Also
--------
numpy.trace : equivalent function
*)

val transpose : Py.Object.t list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.transpose( *axes)

Returns a view of the array with axes transposed.

For a 1-D array this has no effect, as a transposed vector is simply the
same vector. To convert a 1-D array into a 2D column vector, an additional
dimension must be added. `np.atleast2d(a).T` achieves this, as does
`a[:, np.newaxis]`.
For a 2-D array, this is a standard matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
``a.shape = (i[0], i[1], ... i[n-2], i[n-1])``, then
``a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.

Parameters
----------
axes : None, tuple of ints, or `n` ints

 * None or no argument: reverses the order of the axes.

 * tuple of ints: `i` in the `j`-th place in the tuple means `a`'s
   `i`-th axis becomes `a.transpose()`'s `j`-th axis.

 * `n` ints: same as an n-tuple of the same ints (this form is
   intended simply as a 'convenience' alternative to the tuple form)

Returns
-------
out : ndarray
    View of `a`, with axes suitably permuted.

See Also
--------
ndarray.T : Array property returning the array transposed.
ndarray.reshape : Give a new shape to an array without changing its data.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> a
array([[1, 2],
       [3, 4]])
>>> a.transpose()
array([[1, 3],
       [2, 4]])
>>> a.transpose((1, 0))
array([[1, 3],
       [2, 4]])
>>> a.transpose(1, 0)
array([[1, 3],
       [2, 4]])
*)

val var : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?ddof:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns the variance of the matrix elements, along the given axis.

Refer to `numpy.var` for full documentation.

See Also
--------
numpy.var

Notes
-----
This is the same as `ndarray.var`, except that where an `ndarray` would
be returned, a `matrix` object is returned instead.

Examples
--------
>>> x = np.matrix(np.arange(12).reshape((3, 4)))
>>> x
matrix([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
>>> x.var()
11.916666666666666
>>> x.var(0)
matrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]]) # may vary
>>> x.var(1)
matrix([[1.25],
        [1.25],
        [1.25]])
*)

val view : ?dtype:[`Dtype of Dtype.t | `Ndarray_sub_class of Py.Object.t] -> ?type_:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.view(dtype=None, type=None)

New view of array with the same data.

Parameters
----------
dtype : data-type or ndarray sub-class, optional
    Data-type descriptor of the returned view, e.g., float32 or int16. The
    default, None, results in the view having the same data-type as `a`.
    This argument can also be specified as an ndarray sub-class, which
    then specifies the type of the returned object (this is equivalent to
    setting the ``type`` parameter).
type : Python type, optional
    Type of the returned view, e.g., ndarray or matrix.  Again, the
    default None results in type preservation.

Notes
-----
``a.view()`` is used two different ways:

``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
of the array's memory with a different data-type.  This can cause a
reinterpretation of the bytes of memory.

``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
returns an instance of `ndarray_subclass` that looks at the same array
(same shape, dtype, etc.)  This does not cause a reinterpretation of the
memory.

For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of
bytes per entry than the previous dtype (for example, converting a
regular array to a structured array), then the behavior of the view
cannot be predicted just from the superficial appearance of ``a`` (shown
by ``print(a)``). It also depends on exactly how ``a`` is stored in
memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus
defined as a slice or transpose, etc., the view may give different
results.


Examples
--------
>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])

Viewing array data using a different type and dtype:

>>> y = x.view(dtype=np.int16, type=np.matrix)
>>> y
matrix([[513]], dtype=int16)
>>> print(type(y))
<class 'numpy.matrix'>

Creating a view on a structured array so it can be used in calculations

>>> x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])
>>> xv = x.view(dtype=np.int8).reshape(-1,2)
>>> xv
array([[1, 2],
       [3, 4]], dtype=int8)
>>> xv.mean(0)
array([2.,  3.])

Making changes to the view changes the underlying array

>>> xv[0,1] = 20
>>> x
array([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])

Using a view to convert an array to a recarray:

>>> z = x.view(np.recarray)
>>> z.a
array([1, 3], dtype=int8)

Views share data:

>>> x[0] = (9, 10)
>>> z[0]
(9, 10)

Views that change the dtype size (bytes per entry) should normally be
avoided on arrays defined by slices, transposes, fortran-ordering, etc.:

>>> x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)
>>> y = x[:, 0:2]
>>> y
array([[1, 2],
       [4, 5]], dtype=int16)
>>> y.view(dtype=[('width', np.int16), ('length', np.int16)])
Traceback (most recent call last):
    ...
ValueError: To change to a dtype of a different size, the array must be C-contiguous
>>> z = y.copy()
>>> z.view(dtype=[('width', np.int16), ('length', np.int16)])
array([[(1, 2)],
       [(4, 5)]], dtype=[('width', '<i2'), ('length', '<i2')])
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Memmap : sig
type tag = [`Memmap]
type t = [`ArrayLike | `Memmap | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?dtype:Dtype.t -> ?mode:[`R_plus | `R | `W_plus | `C] -> ?offset:int -> ?shape:int list -> ?order:[`C | `F] -> filename:[`S of string | `PyObject of Py.Object.t] -> unit -> t
(**
Create a memory-map to an array stored in a *binary* file on disk.

Memory-mapped files are used for accessing small segments of large files
on disk, without reading the entire file into memory.  NumPy's
memmap's are array-like objects.  This differs from Python's ``mmap``
module, which uses file-like objects.

This subclass of ndarray has some unpleasant interactions with
some operations, because it doesn't quite fit properly as a subclass.
An alternative to using this subclass is to create the ``mmap``
object yourself, then create an ndarray with ndarray.__new__ directly,
passing the object created in its 'buffer=' parameter.

This class may at some point be turned into a factory function
which returns a view into an mmap buffer.

Delete the memmap instance to close the memmap file.


Parameters
----------
filename : str, file-like object, or pathlib.Path instance
    The file name or file object to be used as the array data buffer.
dtype : data-type, optional
    The data-type used to interpret the file contents.
    Default is `uint8`.
mode : {'r+', 'r', 'w+', 'c'}, optional
    The file is opened in this mode:

    +------+-------------------------------------------------------------+
    | 'r'  | Open existing file for reading only.                        |
    +------+-------------------------------------------------------------+
    | 'r+' | Open existing file for reading and writing.                 |
    +------+-------------------------------------------------------------+
    | 'w+' | Create or overwrite existing file for reading and writing.  |
    +------+-------------------------------------------------------------+
    | 'c'  | Copy-on-write: assignments affect data in memory, but       |
    |      | changes are not saved to disk.  The file on disk is         |
    |      | read-only.                                                  |
    +------+-------------------------------------------------------------+

    Default is 'r+'.
offset : int, optional
    In the file, array data starts at this offset. Since `offset` is
    measured in bytes, it should normally be a multiple of the byte-size
    of `dtype`. When ``mode != 'r'``, even positive offsets beyond end of
    file are valid; The file will be extended to accommodate the
    additional data. By default, ``memmap`` will start at the beginning of
    the file, even if ``filename`` is a file pointer ``fp`` and
    ``fp.tell() != 0``.
shape : tuple, optional
    The desired shape of the array. If ``mode == 'r'`` and the number
    of remaining bytes after `offset` is not a multiple of the byte-size
    of `dtype`, you must specify `shape`. By default, the returned array
    will be 1-D with the number of elements determined by file size
    and data-type.
order : {'C', 'F'}, optional
    Specify the order of the ndarray memory layout:
    :term:`row-major`, C-style or :term:`column-major`,
    Fortran-style.  This only has an effect if the shape is
    greater than 1-D.  The default order is 'C'.

Attributes
----------
filename : str or pathlib.Path instance
    Path to the mapped file.
offset : int
    Offset position in the file.
mode : str
    File mode.

Methods
-------
flush
    Flush any changes in memory to file on disk.
    When you delete a memmap object, flush is called first to write
    changes to disk before removing the object.


See also
--------
lib.format.open_memmap : Create or load a memory-mapped ``.npy`` file.

Notes
-----
The memmap object can be used anywhere an ndarray is accepted.
Given a memmap ``fp``, ``isinstance(fp, numpy.ndarray)`` returns
``True``.

Memory-mapped files cannot be larger than 2GB on 32-bit systems.

When a memmap causes a file to be created or extended beyond its
current size in the filesystem, the contents of the new part are
unspecified. On systems with POSIX filesystem semantics, the extended
part will be filled with zero bytes.

Examples
--------
>>> data = np.arange(12, dtype='float32')
>>> data.resize((3,4))

This example uses a temporary file so that doctest doesn't write
files to your directory. You would use a 'normal' filename.

>>> from tempfile import mkdtemp
>>> import os.path as path
>>> filename = path.join(mkdtemp(), 'newfile.dat')

Create a memmap with dtype and shape that matches our data:

>>> fp = np.memmap(filename, dtype='float32', mode='w+', shape=(3,4))
>>> fp
memmap([[0., 0., 0., 0.],
        [0., 0., 0., 0.],
        [0., 0., 0., 0.]], dtype=float32)

Write data to memmap array:

>>> fp[:] = data[:]
>>> fp
memmap([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)

>>> fp.filename == path.abspath(filename)
True

Deletion flushes memory changes to disk before removing the object:

>>> del fp

Load the memmap and verify data was stored:

>>> newfp = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))
>>> newfp
memmap([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)

Read-only memmap:

>>> fpr = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))
>>> fpr.flags.writeable
False

Copy-on-write memmap:

>>> fpc = np.memmap(filename, dtype='float32', mode='c', shape=(3,4))
>>> fpc.flags.writeable
True

It's possible to assign to copy-on-write array, but values are only
written into the memory copy of the array, and not written to disk:

>>> fpc
memmap([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)
>>> fpc[0,:] = 0
>>> fpc
memmap([[  0.,   0.,   0.,   0.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)

File on disk is unchanged:

>>> fpr
memmap([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)

Offset into a memmap:

>>> fpo = np.memmap(filename, dtype='float32', mode='r', offset=16)
>>> fpo
memmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)
*)

val __getitem__ : index:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Implement iter(self).
*)

val __setitem__ : key:Py.Object.t -> value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Set self[key] to value.
*)

val all : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.all(axis=None, out=None, keepdims=False)

Returns True if all elements evaluate to True.

Refer to `numpy.all` for full documentation.

See Also
--------
numpy.all : equivalent function
*)

val any : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.any(axis=None, out=None, keepdims=False)

Returns True if any of the elements of `a` evaluate to True.

Refer to `numpy.any` for full documentation.

See Also
--------
numpy.any : equivalent function
*)

val argmax : ?axis:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argmax(axis=None, out=None)

Return indices of the maximum values along the given axis.

Refer to `numpy.argmax` for full documentation.

See Also
--------
numpy.argmax : equivalent function
*)

val argmin : ?axis:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argmin(axis=None, out=None)

Return indices of the minimum values along the given axis of `a`.

Refer to `numpy.argmin` for detailed documentation.

See Also
--------
numpy.argmin : equivalent function
*)

val argpartition : ?axis:Py.Object.t -> ?kind:Py.Object.t -> ?order:Py.Object.t -> kth:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argpartition(kth, axis=-1, kind='introselect', order=None)

Returns the indices that would partition this array.

Refer to `numpy.argpartition` for full documentation.

.. versionadded:: 1.8.0

See Also
--------
numpy.argpartition : equivalent function
*)

val argsort : ?axis:Py.Object.t -> ?kind:Py.Object.t -> ?order:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argsort(axis=-1, kind=None, order=None)

Returns the indices that would sort this array.

Refer to `numpy.argsort` for full documentation.

See Also
--------
numpy.argsort : equivalent function
*)

val astype : ?order:[`C | `F | `A | `K] -> ?casting:[`No | `Equiv | `Safe | `Same_kind | `Unsafe] -> ?subok:Py.Object.t -> ?copy:bool -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)

Copy of the array, cast to a specified type.

Parameters
----------
dtype : str or dtype
    Typecode or data-type to which the array is cast.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout order of the result.
    'C' means C order, 'F' means Fortran order, 'A'
    means 'F' order if all the arrays are Fortran contiguous,
    'C' order otherwise, and 'K' means as close to the
    order the array elements appear in memory as possible.
    Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'unsafe'
    for backwards compatibility.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.
subok : bool, optional
    If True, then sub-classes will be passed-through (default), otherwise
    the returned array will be forced to be a base-class array.
copy : bool, optional
    By default, astype always returns a newly allocated array. If this
    is set to false, and the `dtype`, `order`, and `subok`
    requirements are satisfied, the input array is returned instead
    of a copy.

Returns
-------
arr_t : ndarray
    Unless `copy` is False and the other conditions for returning the input
    array are satisfied (see description for `copy` input parameter), `arr_t`
    is a new array of the same shape as the input array, with dtype, order
    given by `dtype`, `order`.

Notes
-----
.. versionchanged:: 1.17.0
   Casting between a simple data type and a structured one is possible only
   for 'unsafe' casting.  Casting to multiple fields is allowed, but
   casting from multiple fields is not.

.. versionchanged:: 1.9.0
   Casting from numeric to string types in 'safe' casting mode requires
   that the string dtype length is long enough to store the max
   integer/float value converted.

Raises
------
ComplexWarning
    When casting from complex to float or int. To avoid this,
    one should use ``a.real.astype(t)``.

Examples
--------
>>> x = np.array([1, 2, 2.5])
>>> x
array([1. ,  2. ,  2.5])

>>> x.astype(int)
array([1, 2, 2])
*)

val byteswap : ?inplace:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.byteswap(inplace=False)

Swap the bytes of the array elements

Toggle between low-endian and big-endian data representation by
returning a byteswapped array, optionally swapped in-place.
Arrays of byte-strings are not swapped. The real and imaginary
parts of a complex number are swapped individually.

Parameters
----------
inplace : bool, optional
    If ``True``, swap bytes in-place, default is ``False``.

Returns
-------
out : ndarray
    The byteswapped array. If `inplace` is ``True``, this is
    a view to self.

Examples
--------
>>> A = np.array([1, 256, 8755], dtype=np.int16)
>>> list(map(hex, A))
['0x1', '0x100', '0x2233']
>>> A.byteswap(inplace=True)
array([  256,     1, 13090], dtype=int16)
>>> list(map(hex, A))
['0x100', '0x1', '0x3322']

Arrays of byte-strings are not swapped

>>> A = np.array([b'ceg', b'fac'])
>>> A.byteswap()
array([b'ceg', b'fac'], dtype='|S3')

``A.newbyteorder().byteswap()`` produces an array with the same values
  but different representation in memory

>>> A = np.array([1, 2, 3])
>>> A.view(np.uint8)
array([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
       0, 0], dtype=uint8)
>>> A.newbyteorder().byteswap(inplace=True)
array([1, 2, 3])
>>> A.view(np.uint8)
array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
       0, 3], dtype=uint8)
*)

val choose : ?out:Py.Object.t -> ?mode:Py.Object.t -> choices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.choose(choices, out=None, mode='raise')

Use an index array to construct a new array from a set of choices.

Refer to `numpy.choose` for full documentation.

See Also
--------
numpy.choose : equivalent function
*)

val clip : ?min:Py.Object.t -> ?max:Py.Object.t -> ?out:Py.Object.t -> ?kwargs:(string * Py.Object.t) list -> [> tag] Obj.t -> Py.Object.t
(**
a.clip(min=None, max=None, out=None, **kwargs)

Return an array whose values are limited to ``[min, max]``.
One of max or min must be given.

Refer to `numpy.clip` for full documentation.

See Also
--------
numpy.clip : equivalent function
*)

val compress : ?axis:Py.Object.t -> ?out:Py.Object.t -> condition:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.compress(condition, axis=None, out=None)

Return selected slices of this array along given axis.

Refer to `numpy.compress` for full documentation.

See Also
--------
numpy.compress : equivalent function
*)

val conj : [> tag] Obj.t -> Py.Object.t
(**
a.conj()

Complex-conjugate all elements.

Refer to `numpy.conjugate` for full documentation.

See Also
--------
numpy.conjugate : equivalent function
*)

val conjugate : [> tag] Obj.t -> Py.Object.t
(**
a.conjugate()

Return the complex conjugate, element-wise.

Refer to `numpy.conjugate` for full documentation.

See Also
--------
numpy.conjugate : equivalent function
*)

val copy : ?order:[`C | `F | `A | `K] -> [> tag] Obj.t -> Py.Object.t
(**
a.copy(order='C')

Return a copy of the array.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout of the copy. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible. (Note that this function and :func:`numpy.copy` are very
    similar, but have different default values for their order=
    arguments.)

See also
--------
numpy.copy
numpy.copyto

Examples
--------
>>> x = np.array([[1,2,3],[4,5,6]], order='F')

>>> y = x.copy()

>>> x.fill(0)

>>> x
array([[0, 0, 0],
       [0, 0, 0]])

>>> y
array([[1, 2, 3],
       [4, 5, 6]])

>>> y.flags['C_CONTIGUOUS']
True
*)

val cumprod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.cumprod(axis=None, dtype=None, out=None)

Return the cumulative product of the elements along the given axis.

Refer to `numpy.cumprod` for full documentation.

See Also
--------
numpy.cumprod : equivalent function
*)

val cumsum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.cumsum(axis=None, dtype=None, out=None)

Return the cumulative sum of the elements along the given axis.

Refer to `numpy.cumsum` for full documentation.

See Also
--------
numpy.cumsum : equivalent function
*)

val diagonal : ?offset:Py.Object.t -> ?axis1:Py.Object.t -> ?axis2:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.diagonal(offset=0, axis1=0, axis2=1)

Return specified diagonals. In NumPy 1.9 the returned array is a
read-only view instead of a copy as in previous NumPy versions.  In
a future version the read-only restriction will be removed.

Refer to :func:`numpy.diagonal` for full documentation.

See Also
--------
numpy.diagonal : equivalent function
*)

val dot : ?out:Py.Object.t -> b:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.dot(b, out=None)

Dot product of two arrays.

Refer to `numpy.dot` for full documentation.

See Also
--------
numpy.dot : equivalent function

Examples
--------
>>> a = np.eye(2)
>>> b = np.ones((2, 2)) * 2
>>> a.dot(b)
array([[2.,  2.],
       [2.,  2.]])

This array method can be conveniently chained:

>>> a.dot(b).dot(b)
array([[8.,  8.],
       [8.,  8.]])
*)

val dump : file:[`Path of Py.Object.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.dump(file)

Dump a pickle of the array to the specified file.
The array can be read back with pickle.load or numpy.load.

Parameters
----------
file : str or Path
    A string naming the dump file.

    .. versionchanged:: 1.17.0
        `pathlib.Path` objects are now accepted.
*)

val dumps : [> tag] Obj.t -> Py.Object.t
(**
a.dumps()

Returns the pickle of the array as a string.
pickle.loads or numpy.loads will convert the string back to an array.

Parameters
----------
None
*)

val fill : value:[`F of float | `I of int | `Bool of bool | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.fill(value)

Fill the array with a scalar value.

Parameters
----------
value : scalar
    All elements of `a` will be assigned this value.

Examples
--------
>>> a = np.array([1, 2])
>>> a.fill(0)
>>> a
array([0, 0])
>>> a = np.empty(2)
>>> a.fill(1)
>>> a
array([1.,  1.])
*)

val flatten : ?order:[`C | `F | `A | `K] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.flatten(order='C')

Return a copy of the array collapsed into one dimension.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    'C' means to flatten in row-major (C-style) order.
    'F' means to flatten in column-major (Fortran-
    style) order. 'A' means to flatten in column-major
    order if `a` is Fortran *contiguous* in memory,
    row-major order otherwise. 'K' means to flatten
    `a` in the order the elements occur in memory.
    The default is 'C'.

Returns
-------
y : ndarray
    A copy of the input array, flattened to one dimension.

See Also
--------
ravel : Return a flattened array.
flat : A 1-D flat iterator over the array.

Examples
--------
>>> a = np.array([[1,2], [3,4]])
>>> a.flatten()
array([1, 2, 3, 4])
>>> a.flatten('F')
array([1, 3, 2, 4])
*)

val flush : [> tag] Obj.t -> Py.Object.t
(**
Write any changes in the array to the file on disk.

For further information, see `memmap`.

Parameters
----------
None

See Also
--------
memmap
*)

val getfield : ?offset:int -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.getfield(dtype, offset=0)

Returns a field of the given array as a certain type.

A field is a view of the array data with a given data-type. The values in
the view are determined by the given type and the offset into the current
array in bytes. The offset needs to be such that the view dtype fits in the
array dtype; for example an array of dtype complex128 has 16-byte elements.
If taking a view with a 32-bit integer (4 bytes), the offset needs to be
between 0 and 12 bytes.

Parameters
----------
dtype : str or dtype
    The data type of the view. The dtype size of the view can not be larger
    than that of the array itself.
offset : int
    Number of bytes to skip before beginning the element view.

Examples
--------
>>> x = np.diag([1.+1.j]*2)
>>> x[1, 1] = 2 + 4.j
>>> x
array([[1.+1.j,  0.+0.j],
       [0.+0.j,  2.+4.j]])
>>> x.getfield(np.float64)
array([[1.,  0.],
       [0.,  2.]])

By choosing an offset of 8 bytes we can select the complex part of the
array for our view:

>>> x.getfield(np.float64, offset=8)
array([[1.,  0.],
       [0.,  4.]])
*)

val item : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.item( *args)

Copy an element of an array to a standard Python scalar and return it.

Parameters
----------
\*args : Arguments (variable number and type)

    * none: in this case, the method only works for arrays
      with one element (`a.size == 1`), which element is
      copied into a standard Python scalar object and returned.

    * int_type: this argument is interpreted as a flat index into
      the array, specifying which element to copy and return.

    * tuple of int_types: functions as does a single int_type argument,
      except that the argument is interpreted as an nd-index into the
      array.

Returns
-------
z : Standard Python scalar object
    A copy of the specified element of the array as a suitable
    Python scalar

Notes
-----
When the data type of `a` is longdouble or clongdouble, item() returns
a scalar array object because there is no available Python scalar that
would not lose information. Void arrays return a buffer object for item(),
unless fields are defined, in which case a tuple is returned.

`item` is very similar to a[args], except, instead of an array scalar,
a standard Python scalar is returned. This can be useful for speeding up
access to elements of the array and doing arithmetic on elements of the
array using Python's optimized math.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.item(3)
1
>>> x.item(7)
0
>>> x.item((0, 1))
2
>>> x.item((2, 2))
1
*)

val itemset : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.itemset( *args)

Insert scalar into an array (scalar is cast to array's dtype, if possible)

There must be at least 1 argument, and define the last argument
as *item*.  Then, ``a.itemset( *args)`` is equivalent to but faster
than ``a[args] = item``.  The item should be a scalar value and `args`
must select a single item in the array `a`.

Parameters
----------
\*args : Arguments
    If one argument: a scalar, only used in case `a` is of size 1.
    If two arguments: the last argument is the value to be set
    and must be a scalar, the first argument specifies a single array
    element location. It is either an int or a tuple.

Notes
-----
Compared to indexing syntax, `itemset` provides some speed increase
for placing a scalar into a particular location in an `ndarray`,
if you must do this.  However, generally this is discouraged:
among other problems, it complicates the appearance of the code.
Also, when using `itemset` (and `item`) inside a loop, be sure
to assign the methods to a local variable to avoid the attribute
look-up at each loop iteration.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.itemset(4, 0)
>>> x.itemset((2, 2), 9)
>>> x
array([[2, 2, 6],
       [1, 0, 6],
       [1, 0, 9]])
*)

val max : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> ?initial:Py.Object.t -> ?where:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True)

Return the maximum along a given axis.

Refer to `numpy.amax` for full documentation.

See Also
--------
numpy.amax : equivalent function
*)

val mean : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.mean(axis=None, dtype=None, out=None, keepdims=False)

Returns the average of the array elements along given axis.

Refer to `numpy.mean` for full documentation.

See Also
--------
numpy.mean : equivalent function
*)

val min : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> ?initial:Py.Object.t -> ?where:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True)

Return the minimum along a given axis.

Refer to `numpy.amin` for full documentation.

See Also
--------
numpy.amin : equivalent function
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arr.newbyteorder(new_order='S')

Return the array with the same data viewed with a different byte order.

Equivalent to::

    arr.view(arr.dtype.newbytorder(new_order))

Changes are also made in all fields and sub-arrays of the array data
type.



Parameters
----------
new_order : string, optional
    Byte order to force; a value from the byte order specifications
    below. `new_order` codes can be any of:

    * 'S' - swap dtype from current to opposite endian
    * {'<', 'L'} - little endian
    * {'>', 'B'} - big endian
    * {'=', 'N'} - native order
    * {'|', 'I'} - ignore (no change to byte order)

    The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_arr : array
    New array object with the dtype reflecting given change to the
    byte order.
*)

val nonzero : [> tag] Obj.t -> Py.Object.t
(**
a.nonzero()

Return the indices of the elements that are non-zero.

Refer to `numpy.nonzero` for full documentation.

See Also
--------
numpy.nonzero : equivalent function
*)

val partition : ?axis:int -> ?kind:[`Introselect] -> ?order:[`StringList of string list | `S of string] -> kth:[`Is of int list | `I of int] -> [> tag] Obj.t -> Py.Object.t
(**
a.partition(kth, axis=-1, kind='introselect', order=None)

Rearranges the elements in the array in such a way that the value of the
element in kth position is in the position it would be in a sorted array.
All elements smaller than the kth element are moved before this element and
all equal or greater are moved behind it. The ordering of the elements in
the two partitions is undefined.

.. versionadded:: 1.8.0

Parameters
----------
kth : int or sequence of ints
    Element index to partition by. The kth element value will be in its
    final sorted position and all smaller elements will be moved before it
    and all equal or greater elements behind it.
    The order of all elements in the partitions is undefined.
    If provided with a sequence of kth it will partition all elements
    indexed by kth of them into their sorted position at once.
axis : int, optional
    Axis along which to sort. Default is -1, which means sort along the
    last axis.
kind : {'introselect'}, optional
    Selection algorithm. Default is 'introselect'.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc. A single field can
    be specified as a string, and not all fields need to be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

See Also
--------
numpy.partition : Return a parititioned copy of an array.
argpartition : Indirect partition.
sort : Full sort.

Notes
-----
See ``np.partition`` for notes on the different algorithms.

Examples
--------
>>> a = np.array([3, 4, 2, 1])
>>> a.partition(3)
>>> a
array([2, 1, 3, 4])

>>> a.partition((1, 3))
>>> a
array([1, 2, 3, 4])
*)

val prod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> ?initial:Py.Object.t -> ?where:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True)

Return the product of the array elements over the given axis

Refer to `numpy.prod` for full documentation.

See Also
--------
numpy.prod : equivalent function
*)

val ptp : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.ptp(axis=None, out=None, keepdims=False)

Peak to peak (maximum - minimum) value along a given axis.

Refer to `numpy.ptp` for full documentation.

See Also
--------
numpy.ptp : equivalent function
*)

val put : ?mode:Py.Object.t -> indices:Py.Object.t -> values:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.put(indices, values, mode='raise')

Set ``a.flat[n] = values[n]`` for all `n` in indices.

Refer to `numpy.put` for full documentation.

See Also
--------
numpy.put : equivalent function
*)

val ravel : ?order:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.ravel([order])

Return a flattened array.

Refer to `numpy.ravel` for full documentation.

See Also
--------
numpy.ravel : equivalent function

ndarray.flat : a flat iterator on the array.
*)

val repeat : ?axis:Py.Object.t -> repeats:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.repeat(repeats, axis=None)

Repeat elements of an array.

Refer to `numpy.repeat` for full documentation.

See Also
--------
numpy.repeat : equivalent function
*)

val reshape : ?order:Py.Object.t -> int list -> [> tag] Obj.t -> Py.Object.t
(**
a.reshape(shape, order='C')

Returns an array containing the same data with a new shape.

Refer to `numpy.reshape` for full documentation.

See Also
--------
numpy.reshape : equivalent function

Notes
-----
Unlike the free function `numpy.reshape`, this method on `ndarray` allows
the elements of the shape parameter to be passed in as separate arguments.
For example, ``a.reshape(10, 11)`` is equivalent to
``a.reshape((10, 11))``.
*)

val resize : ?refcheck:bool -> new_shape:[`T_n_ints of Py.Object.t | `TupleOfInts of int list] -> [> tag] Obj.t -> Py.Object.t
(**
a.resize(new_shape, refcheck=True)

Change shape and size of array in-place.

Parameters
----------
new_shape : tuple of ints, or `n` ints
    Shape of resized array.
refcheck : bool, optional
    If False, reference count will not be checked. Default is True.

Returns
-------
None

Raises
------
ValueError
    If `a` does not own its own data or references or views to it exist,
    and the data memory must be changed.
    PyPy only: will always raise if the data memory must be changed, since
    there is no reliable way to determine if references or views to it
    exist.

SystemError
    If the `order` keyword argument is specified. This behaviour is a
    bug in NumPy.

See Also
--------
resize : Return a new array with the specified shape.

Notes
-----
This reallocates space for the data area if necessary.

Only contiguous arrays (data elements consecutive in memory) can be
resized.

The purpose of the reference count check is to make sure you
do not use this array as a buffer for another Python object and then
reallocate the memory. However, reference counts can increase in
other ways so if you are sure that you have not shared the memory
for this array with another Python object, then you may safely set
`refcheck` to False.

Examples
--------
Shrinking an array: array is flattened (in the order that the data are
stored in memory), resized, and reshaped:

>>> a = np.array([[0, 1], [2, 3]], order='C')
>>> a.resize((2, 1))
>>> a
array([[0],
       [1]])

>>> a = np.array([[0, 1], [2, 3]], order='F')
>>> a.resize((2, 1))
>>> a
array([[0],
       [2]])

Enlarging an array: as above, but missing entries are filled with zeros:

>>> b = np.array([[0, 1], [2, 3]])
>>> b.resize(2, 3) # new_shape parameter doesn't have to be a tuple
>>> b
array([[0, 1, 2],
       [3, 0, 0]])

Referencing an array prevents resizing...

>>> c = a
>>> a.resize((1, 1))
Traceback (most recent call last):
...
ValueError: cannot resize an array that references or is referenced ...

Unless `refcheck` is False:

>>> a.resize((1, 1), refcheck=False)
>>> a
array([[0]])
>>> c
array([[0]])
*)

val round : ?decimals:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.round(decimals=0, out=None)

Return `a` with each element rounded to the given number of decimals.

Refer to `numpy.around` for full documentation.

See Also
--------
numpy.around : equivalent function
*)

val searchsorted : ?side:Py.Object.t -> ?sorter:Py.Object.t -> v:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.searchsorted(v, side='left', sorter=None)

Find indices where elements of v should be inserted in a to maintain order.

For full documentation, see `numpy.searchsorted`

See Also
--------
numpy.searchsorted : equivalent function
*)

val setfield : ?offset:int -> val_:Py.Object.t -> dtype:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.setfield(val, dtype, offset=0)

Put a value into a specified place in a field defined by a data-type.

Place `val` into `a`'s field defined by `dtype` and beginning `offset`
bytes into the field.

Parameters
----------
val : object
    Value to be placed in field.
dtype : dtype object
    Data-type of the field in which to place `val`.
offset : int, optional
    The number of bytes into the field at which to place `val`.

Returns
-------
None

See Also
--------
getfield

Examples
--------
>>> x = np.eye(3)
>>> x.getfield(np.float64)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
>>> x.setfield(3, np.int32)
>>> x.getfield(np.int32)
array([[3, 3, 3],
       [3, 3, 3],
       [3, 3, 3]], dtype=int32)
>>> x
array([[1.0e+000, 1.5e-323, 1.5e-323],
       [1.5e-323, 1.0e+000, 1.5e-323],
       [1.5e-323, 1.5e-323, 1.0e+000]])
>>> x.setfield(np.eye(3), np.int32)
>>> x
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
*)

val setflags : ?write:bool -> ?align:bool -> ?uic:bool -> [> tag] Obj.t -> Py.Object.t
(**
a.setflags(write=None, align=None, uic=None)

Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
respectively.

These Boolean-valued flags affect how numpy interprets the memory
area used by `a` (see Notes below). The ALIGNED flag can only
be set to True if the data is actually aligned according to the type.
The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
to True. The flag WRITEABLE can only be set to True if the array owns its
own memory, or the ultimate owner of the memory exposes a writeable buffer
interface, or is a string. (The exception for string is made so that
unpickling can be done without copying memory.)

Parameters
----------
write : bool, optional
    Describes whether or not `a` can be written to.
align : bool, optional
    Describes whether or not `a` is aligned properly for its type.
uic : bool, optional
    Describes whether or not `a` is a copy of another 'base' array.

Notes
-----
Array flags provide information about how the memory area used
for the array is to be interpreted. There are 7 Boolean flags
in use, only four of which can be changed by the user:
WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.

WRITEABLE (W) the data area can be written to;

ALIGNED (A) the data and strides are aligned appropriately for the hardware
(as determined by the compiler);

UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;

WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
called, the base array will be updated with the contents of this array.

All flags can be accessed using the single (upper case) letter as well
as the full name.

Examples
--------
>>> y = np.array([[3, 1, 7],
...               [2, 0, 0],
...               [8, 5, 9]])
>>> y
array([[3, 1, 7],
       [2, 0, 0],
       [8, 5, 9]])
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(write=0, align=0)
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : False
  ALIGNED : False
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(uic=1)
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: cannot set WRITEBACKIFCOPY flag to True
*)

val sort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[`StringList of string list | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.sort(axis=-1, kind=None, order=None)

Sort an array in-place. Refer to `numpy.sort` for full documentation.

Parameters
----------
axis : int, optional
    Axis along which to sort. Default is -1, which means sort along the
    last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
    and 'mergesort' use timsort under the covers and, in general, the
    actual implementation will vary with datatype. The 'mergesort' option
    is retained for backwards compatibility.

    .. versionchanged:: 1.15.0.
       The 'stable' option was added.

order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  A single field can
    be specified as a string, and not all fields need be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

See Also
--------
numpy.sort : Return a sorted copy of an array.
numpy.argsort : Indirect sort.
numpy.lexsort : Indirect stable sort on multiple keys.
numpy.searchsorted : Find elements in sorted array.
numpy.partition: Partial sort.

Notes
-----
See `numpy.sort` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.array([[1,4], [3,1]])
>>> a.sort(axis=1)
>>> a
array([[1, 4],
       [1, 3]])
>>> a.sort(axis=0)
>>> a
array([[1, 3],
       [1, 4]])

Use the `order` keyword to specify a field to use when sorting a
structured array:

>>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])
>>> a.sort(order='y')
>>> a
array([(b'c', 1), (b'a', 2)],
      dtype=[('x', 'S1'), ('y', '<i8')])
*)

val squeeze : ?axis:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.squeeze(axis=None)

Remove single-dimensional entries from the shape of `a`.

Refer to `numpy.squeeze` for full documentation.

See Also
--------
numpy.squeeze : equivalent function
*)

val std : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?ddof:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)

Returns the standard deviation of the array elements along given axis.

Refer to `numpy.std` for full documentation.

See Also
--------
numpy.std : equivalent function
*)

val sum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> ?initial:Py.Object.t -> ?where:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)

Return the sum of the array elements over the given axis.

Refer to `numpy.sum` for full documentation.

See Also
--------
numpy.sum : equivalent function
*)

val swapaxes : axis1:Py.Object.t -> axis2:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.swapaxes(axis1, axis2)

Return a view of the array with `axis1` and `axis2` interchanged.

Refer to `numpy.swapaxes` for full documentation.

See Also
--------
numpy.swapaxes : equivalent function
*)

val take : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?mode:Py.Object.t -> indices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.take(indices, axis=None, out=None, mode='raise')

Return an array formed from the elements of `a` at the given indices.

Refer to `numpy.take` for full documentation.

See Also
--------
numpy.take : equivalent function
*)

val tobytes : ?order:[`C | `F | `None] -> [> tag] Obj.t -> Py.Object.t
(**
a.tobytes(order='C')

Construct Python bytes containing the raw data bytes in the array.

Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either 'C' or 'Fortran',
or 'Any' order (the default is 'C'-order). 'Any' order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means 'Fortran' order.

.. versionadded:: 1.9.0

Parameters
----------
order : {'C', 'F', None}, optional
    Order of the data for multidimensional arrays:
    C, Fortran, or the same as for the original array.

Returns
-------
s : bytes
    Python bytes exhibiting a copy of `a`'s raw data.

Examples
--------
>>> x = np.array([[0, 1], [2, 3]], dtype='<u2')
>>> x.tobytes()
b'\x00\x00\x01\x00\x02\x00\x03\x00'
>>> x.tobytes('C') == x.tobytes()
True
>>> x.tobytes('F')
b'\x00\x00\x02\x00\x01\x00\x03\x00'
*)

val tofile : ?sep:string -> ?format:string -> fid:[`S of string | `PyObject of Py.Object.t] -> [> tag] Obj.t -> Py.Object.t
(**
a.tofile(fid, sep='', format='%s')

Write array to a file as text or binary (default).

Data is always written in 'C' order, independent of the order of `a`.
The data produced by this method can be recovered using the function
fromfile().

Parameters
----------
fid : file or str or Path
    An open file object, or a string containing a filename.

    .. versionchanged:: 1.17.0
        `pathlib.Path` objects are now accepted.

sep : str
    Separator between array items for text output.
    If '' (empty), a binary file is written, equivalent to
    ``file.write(a.tobytes())``.
format : str
    Format string for text file output.
    Each entry in the array is formatted to text by first converting
    it to the closest Python type, and then using 'format' % item.

Notes
-----
This is a convenience function for quick storage of array data.
Information on endianness and precision is lost, so this method is not a
good choice for files intended to archive data or transport data between
machines with different endianness. Some of these problems can be overcome
by outputting the data as text files, at the expense of speed and file
size.

When fid is a file object, array contents are directly written to the
file, bypassing the file object's ``write`` method. As a result, tofile
cannot be used with files objects supporting compression (e.g., GzipFile)
or file-like objects that do not support ``fileno()`` (e.g., BytesIO).
*)

val tolist : [> tag] Obj.t -> Py.Object.t
(**
a.tolist()

Return the array as an ``a.ndim``-levels deep nested list of Python scalars.

Return a copy of the array data as a (nested) Python list.
Data items are converted to the nearest compatible builtin Python type, via
the `~numpy.ndarray.item` function.

If ``a.ndim`` is 0, then since the depth of the nested list is 0, it will
not be a list at all, but a simple Python scalar.

Parameters
----------
none

Returns
-------
y : object, or list of object, or list of list of object, or ...
    The possibly nested list of array elements.

Notes
-----
The array may be recreated via ``a = np.array(a.tolist())``, although this
may sometimes lose precision.

Examples
--------
For a 1D array, ``a.tolist()`` is almost the same as ``list(a)``, 
except that ``tolist`` changes numpy scalars to Python scalars:

>>> a = np.uint32([1, 2])
>>> a_list = list(a)
>>> a_list
[1, 2]
>>> type(a_list[0])
<class 'numpy.uint32'>
>>> a_tolist = a.tolist()
>>> a_tolist
[1, 2]
>>> type(a_tolist[0])
<class 'int'>

Additionally, for a 2D array, ``tolist`` applies recursively:

>>> a = np.array([[1, 2], [3, 4]])
>>> list(a)
[array([1, 2]), array([3, 4])]
>>> a.tolist()
[[1, 2], [3, 4]]

The base case for this recursion is a 0D array:

>>> a = np.array(1)
>>> list(a)
Traceback (most recent call last):
  ...
TypeError: iteration over a 0-d array
>>> a.tolist()
1
*)

val tostring : ?order:[`C | `F | `None] -> [> tag] Obj.t -> Py.Object.t
(**
a.tostring(order='C')

Construct Python bytes containing the raw data bytes in the array.

Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either 'C' or 'Fortran',
or 'Any' order (the default is 'C'-order). 'Any' order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means 'Fortran' order.

This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.

Parameters
----------
order : {'C', 'F', None}, optional
    Order of the data for multidimensional arrays:
    C, Fortran, or the same as for the original array.

Returns
-------
s : bytes
    Python bytes exhibiting a copy of `a`'s raw data.

Examples
--------
>>> x = np.array([[0, 1], [2, 3]], dtype='<u2')
>>> x.tobytes()
b'\x00\x00\x01\x00\x02\x00\x03\x00'
>>> x.tobytes('C') == x.tobytes()
True
>>> x.tobytes('F')
b'\x00\x00\x02\x00\x01\x00\x03\x00'
*)

val trace : ?offset:Py.Object.t -> ?axis1:Py.Object.t -> ?axis2:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)

Return the sum along diagonals of the array.

Refer to `numpy.trace` for full documentation.

See Also
--------
numpy.trace : equivalent function
*)

val transpose : Py.Object.t list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.transpose( *axes)

Returns a view of the array with axes transposed.

For a 1-D array this has no effect, as a transposed vector is simply the
same vector. To convert a 1-D array into a 2D column vector, an additional
dimension must be added. `np.atleast2d(a).T` achieves this, as does
`a[:, np.newaxis]`.
For a 2-D array, this is a standard matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
``a.shape = (i[0], i[1], ... i[n-2], i[n-1])``, then
``a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.

Parameters
----------
axes : None, tuple of ints, or `n` ints

 * None or no argument: reverses the order of the axes.

 * tuple of ints: `i` in the `j`-th place in the tuple means `a`'s
   `i`-th axis becomes `a.transpose()`'s `j`-th axis.

 * `n` ints: same as an n-tuple of the same ints (this form is
   intended simply as a 'convenience' alternative to the tuple form)

Returns
-------
out : ndarray
    View of `a`, with axes suitably permuted.

See Also
--------
ndarray.T : Array property returning the array transposed.
ndarray.reshape : Give a new shape to an array without changing its data.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> a
array([[1, 2],
       [3, 4]])
>>> a.transpose()
array([[1, 3],
       [2, 4]])
>>> a.transpose((1, 0))
array([[1, 3],
       [2, 4]])
>>> a.transpose(1, 0)
array([[1, 3],
       [2, 4]])
*)

val var : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?ddof:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)

Returns the variance of the array elements, along given axis.

Refer to `numpy.var` for full documentation.

See Also
--------
numpy.var : equivalent function
*)

val view : ?dtype:[`Dtype of Dtype.t | `Ndarray_sub_class of Py.Object.t] -> ?type_:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.view(dtype=None, type=None)

New view of array with the same data.

Parameters
----------
dtype : data-type or ndarray sub-class, optional
    Data-type descriptor of the returned view, e.g., float32 or int16. The
    default, None, results in the view having the same data-type as `a`.
    This argument can also be specified as an ndarray sub-class, which
    then specifies the type of the returned object (this is equivalent to
    setting the ``type`` parameter).
type : Python type, optional
    Type of the returned view, e.g., ndarray or matrix.  Again, the
    default None results in type preservation.

Notes
-----
``a.view()`` is used two different ways:

``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
of the array's memory with a different data-type.  This can cause a
reinterpretation of the bytes of memory.

``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
returns an instance of `ndarray_subclass` that looks at the same array
(same shape, dtype, etc.)  This does not cause a reinterpretation of the
memory.

For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of
bytes per entry than the previous dtype (for example, converting a
regular array to a structured array), then the behavior of the view
cannot be predicted just from the superficial appearance of ``a`` (shown
by ``print(a)``). It also depends on exactly how ``a`` is stored in
memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus
defined as a slice or transpose, etc., the view may give different
results.


Examples
--------
>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])

Viewing array data using a different type and dtype:

>>> y = x.view(dtype=np.int16, type=np.matrix)
>>> y
matrix([[513]], dtype=int16)
>>> print(type(y))
<class 'numpy.matrix'>

Creating a view on a structured array so it can be used in calculations

>>> x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])
>>> xv = x.view(dtype=np.int8).reshape(-1,2)
>>> xv
array([[1, 2],
       [3, 4]], dtype=int8)
>>> xv.mean(0)
array([2.,  3.])

Making changes to the view changes the underlying array

>>> xv[0,1] = 20
>>> x
array([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])

Using a view to convert an array to a recarray:

>>> z = x.view(np.recarray)
>>> z.a
array([1, 3], dtype=int8)

Views share data:

>>> x[0] = (9, 10)
>>> z[0]
(9, 10)

Views that change the dtype size (bytes per entry) should normally be
avoided on arrays defined by slices, transposes, fortran-ordering, etc.:

>>> x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)
>>> y = x[:, 0:2]
>>> y
array([[1, 2],
       [4, 5]], dtype=int16)
>>> y.view(dtype=[('width', np.int16), ('length', np.int16)])
Traceback (most recent call last):
    ...
ValueError: To change to a dtype of a different size, the array must be C-contiguous
>>> z = y.copy()
>>> z.view(dtype=[('width', np.int16), ('length', np.int16)])
array([[(1, 2)],
       [(4, 5)]], dtype=[('width', '<i2'), ('length', '<i2')])
*)


(** Attribute filename: get value or raise Not_found if None.*)
val filename : t -> Py.Object.t

(** Attribute filename: get value as an option. *)
val filename_opt : t -> (Py.Object.t) option


(** Attribute offset: get value or raise Not_found if None.*)
val offset : t -> int

(** Attribute offset: get value as an option. *)
val offset_opt : t -> (int) option


(** Attribute mode: get value or raise Not_found if None.*)
val mode : t -> string

(** Attribute mode: get value as an option. *)
val mode_opt : t -> (string) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Ndarray : sig
type tag = [`Ndarray]
type t = [`ArrayLike | `Ndarray | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?dtype:Dtype.t -> ?buffer:Py.Object.t -> ?offset:int -> ?strides:int list -> ?order:[`C | `F] -> int list -> t
(**
ndarray(shape, dtype=float, buffer=None, offset=0,
        strides=None, order=None)

An array object represents a multidimensional, homogeneous array
of fixed-size items.  An associated data-type object describes the
format of each element in the array (its byte-order, how many bytes it
occupies in memory, whether it is an integer, a floating point number,
or something else, etc.)

Arrays should be constructed using `array`, `zeros` or `empty` (refer
to the See Also section below).  The parameters given here refer to
a low-level method (`ndarray(...)`) for instantiating an array.

For more information, refer to the `numpy` module and examine the
methods and attributes of an array.

Parameters
----------
(for the __new__ method; see Notes below)

shape : tuple of ints
    Shape of created array.
dtype : data-type, optional
    Any object that can be interpreted as a numpy data type.
buffer : object exposing buffer interface, optional
    Used to fill the array with data.
offset : int, optional
    Offset of array data in buffer.
strides : tuple of ints, optional
    Strides of data in memory.
order : {'C', 'F'}, optional
    Row-major (C-style) or column-major (Fortran-style) order.

Attributes
----------
T : ndarray
    Transpose of the array.
data : buffer
    The array's elements, in memory.
dtype : dtype object
    Describes the format of the elements in the array.
flags : dict
    Dictionary containing information related to memory use, e.g.,
    'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc.
flat : numpy.flatiter object
    Flattened version of the array as an iterator.  The iterator
    allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for
    assignment examples; TODO).
imag : ndarray
    Imaginary part of the array.
real : ndarray
    Real part of the array.
size : int
    Number of elements in the array.
itemsize : int
    The memory use of each array element in bytes.
nbytes : int
    The total number of bytes required to store the array data,
    i.e., ``itemsize * size``.
ndim : int
    The array's number of dimensions.
shape : tuple of ints
    Shape of the array.
strides : tuple of ints
    The step-size required to move from one element to the next in
    memory. For example, a contiguous ``(3, 4)`` array of type
    ``int16`` in C-order has strides ``(8, 2)``.  This implies that
    to move from element to element in memory requires jumps of 2 bytes.
    To move from row-to-row, one needs to jump 8 bytes at a time
    (``2 * 4``).
ctypes : ctypes object
    Class containing properties of the array needed for interaction
    with ctypes.
base : ndarray
    If the array is a view into another array, that array is its `base`
    (unless that array is also a view).  The `base` array is where the
    array data is actually stored.

See Also
--------
array : Construct an array.
zeros : Create an array, each element of which is zero.
empty : Create an array, but leave its allocated memory unchanged (i.e.,
        it contains 'garbage').
dtype : Create a data-type.

Notes
-----
There are two modes of creating an array using ``__new__``:

1. If `buffer` is None, then only `shape`, `dtype`, and `order`
   are used.
2. If `buffer` is an object exposing the buffer interface, then
   all keywords are interpreted.

No ``__init__`` method is needed because the array is fully initialized
after the ``__new__`` method.

Examples
--------
These examples illustrate the low-level `ndarray` constructor.  Refer
to the `See Also` section above for easier ways of constructing an
ndarray.

First mode, `buffer` is None:

>>> np.ndarray(shape=(2,2), dtype=float, order='F')
array([[0.0e+000, 0.0e+000], # random
       [     nan, 2.5e-323]])

Second mode:

>>> np.ndarray((2,), buffer=np.array([1,2,3]),
...            offset=np.int_().itemsize,
...            dtype=int) # offset = 1*itemsize, i.e. skip first element
array([2, 3])
*)

val get : key:Wrap_utils.Index.t -> [> tag] Obj.t -> t
(**
Return self[key].
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Implement iter(self).
*)

val set : key:Wrap_utils.Index.t -> value:[> tag] Obj.t -> [> tag] Obj.t -> unit
(**
Set self[key] to value.
*)

val all : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.all(axis=None, out=None, keepdims=False)

Returns True if all elements evaluate to True.

Refer to `numpy.all` for full documentation.

See Also
--------
numpy.all : equivalent function
*)

val any : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.any(axis=None, out=None, keepdims=False)

Returns True if any of the elements of `a` evaluate to True.

Refer to `numpy.any` for full documentation.

See Also
--------
numpy.any : equivalent function
*)

val argmax : ?axis:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argmax(axis=None, out=None)

Return indices of the maximum values along the given axis.

Refer to `numpy.argmax` for full documentation.

See Also
--------
numpy.argmax : equivalent function
*)

val argmin : ?axis:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argmin(axis=None, out=None)

Return indices of the minimum values along the given axis of `a`.

Refer to `numpy.argmin` for detailed documentation.

See Also
--------
numpy.argmin : equivalent function
*)

val argpartition : ?axis:Py.Object.t -> ?kind:Py.Object.t -> ?order:Py.Object.t -> kth:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argpartition(kth, axis=-1, kind='introselect', order=None)

Returns the indices that would partition this array.

Refer to `numpy.argpartition` for full documentation.

.. versionadded:: 1.8.0

See Also
--------
numpy.argpartition : equivalent function
*)

val argsort : ?axis:Py.Object.t -> ?kind:Py.Object.t -> ?order:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argsort(axis=-1, kind=None, order=None)

Returns the indices that would sort this array.

Refer to `numpy.argsort` for full documentation.

See Also
--------
numpy.argsort : equivalent function
*)

val astype : ?order:[`C | `F | `A | `K] -> ?casting:[`No | `Equiv | `Safe | `Same_kind | `Unsafe] -> ?subok:Py.Object.t -> ?copy:bool -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)

Copy of the array, cast to a specified type.

Parameters
----------
dtype : str or dtype
    Typecode or data-type to which the array is cast.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout order of the result.
    'C' means C order, 'F' means Fortran order, 'A'
    means 'F' order if all the arrays are Fortran contiguous,
    'C' order otherwise, and 'K' means as close to the
    order the array elements appear in memory as possible.
    Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'unsafe'
    for backwards compatibility.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.
subok : bool, optional
    If True, then sub-classes will be passed-through (default), otherwise
    the returned array will be forced to be a base-class array.
copy : bool, optional
    By default, astype always returns a newly allocated array. If this
    is set to false, and the `dtype`, `order`, and `subok`
    requirements are satisfied, the input array is returned instead
    of a copy.

Returns
-------
arr_t : ndarray
    Unless `copy` is False and the other conditions for returning the input
    array are satisfied (see description for `copy` input parameter), `arr_t`
    is a new array of the same shape as the input array, with dtype, order
    given by `dtype`, `order`.

Notes
-----
.. versionchanged:: 1.17.0
   Casting between a simple data type and a structured one is possible only
   for 'unsafe' casting.  Casting to multiple fields is allowed, but
   casting from multiple fields is not.

.. versionchanged:: 1.9.0
   Casting from numeric to string types in 'safe' casting mode requires
   that the string dtype length is long enough to store the max
   integer/float value converted.

Raises
------
ComplexWarning
    When casting from complex to float or int. To avoid this,
    one should use ``a.real.astype(t)``.

Examples
--------
>>> x = np.array([1, 2, 2.5])
>>> x
array([1. ,  2. ,  2.5])

>>> x.astype(int)
array([1, 2, 2])
*)

val byteswap : ?inplace:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.byteswap(inplace=False)

Swap the bytes of the array elements

Toggle between low-endian and big-endian data representation by
returning a byteswapped array, optionally swapped in-place.
Arrays of byte-strings are not swapped. The real and imaginary
parts of a complex number are swapped individually.

Parameters
----------
inplace : bool, optional
    If ``True``, swap bytes in-place, default is ``False``.

Returns
-------
out : ndarray
    The byteswapped array. If `inplace` is ``True``, this is
    a view to self.

Examples
--------
>>> A = np.array([1, 256, 8755], dtype=np.int16)
>>> list(map(hex, A))
['0x1', '0x100', '0x2233']
>>> A.byteswap(inplace=True)
array([  256,     1, 13090], dtype=int16)
>>> list(map(hex, A))
['0x100', '0x1', '0x3322']

Arrays of byte-strings are not swapped

>>> A = np.array([b'ceg', b'fac'])
>>> A.byteswap()
array([b'ceg', b'fac'], dtype='|S3')

``A.newbyteorder().byteswap()`` produces an array with the same values
  but different representation in memory

>>> A = np.array([1, 2, 3])
>>> A.view(np.uint8)
array([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
       0, 0], dtype=uint8)
>>> A.newbyteorder().byteswap(inplace=True)
array([1, 2, 3])
>>> A.view(np.uint8)
array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
       0, 3], dtype=uint8)
*)

val choose : ?out:Py.Object.t -> ?mode:Py.Object.t -> choices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.choose(choices, out=None, mode='raise')

Use an index array to construct a new array from a set of choices.

Refer to `numpy.choose` for full documentation.

See Also
--------
numpy.choose : equivalent function
*)

val clip : ?min:Py.Object.t -> ?max:Py.Object.t -> ?out:Py.Object.t -> ?kwargs:(string * Py.Object.t) list -> [> tag] Obj.t -> Py.Object.t
(**
a.clip(min=None, max=None, out=None, **kwargs)

Return an array whose values are limited to ``[min, max]``.
One of max or min must be given.

Refer to `numpy.clip` for full documentation.

See Also
--------
numpy.clip : equivalent function
*)

val compress : ?axis:Py.Object.t -> ?out:Py.Object.t -> condition:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.compress(condition, axis=None, out=None)

Return selected slices of this array along given axis.

Refer to `numpy.compress` for full documentation.

See Also
--------
numpy.compress : equivalent function
*)

val conj : [> tag] Obj.t -> Py.Object.t
(**
a.conj()

Complex-conjugate all elements.

Refer to `numpy.conjugate` for full documentation.

See Also
--------
numpy.conjugate : equivalent function
*)

val conjugate : [> tag] Obj.t -> Py.Object.t
(**
a.conjugate()

Return the complex conjugate, element-wise.

Refer to `numpy.conjugate` for full documentation.

See Also
--------
numpy.conjugate : equivalent function
*)

val copy : ?order:[`C | `F | `A | `K] -> [> tag] Obj.t -> Py.Object.t
(**
a.copy(order='C')

Return a copy of the array.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout of the copy. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible. (Note that this function and :func:`numpy.copy` are very
    similar, but have different default values for their order=
    arguments.)

See also
--------
numpy.copy
numpy.copyto

Examples
--------
>>> x = np.array([[1,2,3],[4,5,6]], order='F')

>>> y = x.copy()

>>> x.fill(0)

>>> x
array([[0, 0, 0],
       [0, 0, 0]])

>>> y
array([[1, 2, 3],
       [4, 5, 6]])

>>> y.flags['C_CONTIGUOUS']
True
*)

val cumprod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.cumprod(axis=None, dtype=None, out=None)

Return the cumulative product of the elements along the given axis.

Refer to `numpy.cumprod` for full documentation.

See Also
--------
numpy.cumprod : equivalent function
*)

val cumsum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.cumsum(axis=None, dtype=None, out=None)

Return the cumulative sum of the elements along the given axis.

Refer to `numpy.cumsum` for full documentation.

See Also
--------
numpy.cumsum : equivalent function
*)

val diagonal : ?offset:Py.Object.t -> ?axis1:Py.Object.t -> ?axis2:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.diagonal(offset=0, axis1=0, axis2=1)

Return specified diagonals. In NumPy 1.9 the returned array is a
read-only view instead of a copy as in previous NumPy versions.  In
a future version the read-only restriction will be removed.

Refer to :func:`numpy.diagonal` for full documentation.

See Also
--------
numpy.diagonal : equivalent function
*)

val dot : ?out:Py.Object.t -> b:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.dot(b, out=None)

Dot product of two arrays.

Refer to `numpy.dot` for full documentation.

See Also
--------
numpy.dot : equivalent function

Examples
--------
>>> a = np.eye(2)
>>> b = np.ones((2, 2)) * 2
>>> a.dot(b)
array([[2.,  2.],
       [2.,  2.]])

This array method can be conveniently chained:

>>> a.dot(b).dot(b)
array([[8.,  8.],
       [8.,  8.]])
*)

val dump : file:[`Path of Py.Object.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.dump(file)

Dump a pickle of the array to the specified file.
The array can be read back with pickle.load or numpy.load.

Parameters
----------
file : str or Path
    A string naming the dump file.

    .. versionchanged:: 1.17.0
        `pathlib.Path` objects are now accepted.
*)

val dumps : [> tag] Obj.t -> Py.Object.t
(**
a.dumps()

Returns the pickle of the array as a string.
pickle.loads or numpy.loads will convert the string back to an array.

Parameters
----------
None
*)

val fill : value:[`F of float | `I of int | `Bool of bool | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.fill(value)

Fill the array with a scalar value.

Parameters
----------
value : scalar
    All elements of `a` will be assigned this value.

Examples
--------
>>> a = np.array([1, 2])
>>> a.fill(0)
>>> a
array([0, 0])
>>> a = np.empty(2)
>>> a.fill(1)
>>> a
array([1.,  1.])
*)

val flatten : ?order:[`C | `F | `A | `K] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.flatten(order='C')

Return a copy of the array collapsed into one dimension.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    'C' means to flatten in row-major (C-style) order.
    'F' means to flatten in column-major (Fortran-
    style) order. 'A' means to flatten in column-major
    order if `a` is Fortran *contiguous* in memory,
    row-major order otherwise. 'K' means to flatten
    `a` in the order the elements occur in memory.
    The default is 'C'.

Returns
-------
y : ndarray
    A copy of the input array, flattened to one dimension.

See Also
--------
ravel : Return a flattened array.
flat : A 1-D flat iterator over the array.

Examples
--------
>>> a = np.array([[1,2], [3,4]])
>>> a.flatten()
array([1, 2, 3, 4])
>>> a.flatten('F')
array([1, 3, 2, 4])
*)

val getfield : ?offset:int -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.getfield(dtype, offset=0)

Returns a field of the given array as a certain type.

A field is a view of the array data with a given data-type. The values in
the view are determined by the given type and the offset into the current
array in bytes. The offset needs to be such that the view dtype fits in the
array dtype; for example an array of dtype complex128 has 16-byte elements.
If taking a view with a 32-bit integer (4 bytes), the offset needs to be
between 0 and 12 bytes.

Parameters
----------
dtype : str or dtype
    The data type of the view. The dtype size of the view can not be larger
    than that of the array itself.
offset : int
    Number of bytes to skip before beginning the element view.

Examples
--------
>>> x = np.diag([1.+1.j]*2)
>>> x[1, 1] = 2 + 4.j
>>> x
array([[1.+1.j,  0.+0.j],
       [0.+0.j,  2.+4.j]])
>>> x.getfield(np.float64)
array([[1.,  0.],
       [0.,  2.]])

By choosing an offset of 8 bytes we can select the complex part of the
array for our view:

>>> x.getfield(np.float64, offset=8)
array([[1.,  0.],
       [0.,  4.]])
*)

val item : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.item( *args)

Copy an element of an array to a standard Python scalar and return it.

Parameters
----------
\*args : Arguments (variable number and type)

    * none: in this case, the method only works for arrays
      with one element (`a.size == 1`), which element is
      copied into a standard Python scalar object and returned.

    * int_type: this argument is interpreted as a flat index into
      the array, specifying which element to copy and return.

    * tuple of int_types: functions as does a single int_type argument,
      except that the argument is interpreted as an nd-index into the
      array.

Returns
-------
z : Standard Python scalar object
    A copy of the specified element of the array as a suitable
    Python scalar

Notes
-----
When the data type of `a` is longdouble or clongdouble, item() returns
a scalar array object because there is no available Python scalar that
would not lose information. Void arrays return a buffer object for item(),
unless fields are defined, in which case a tuple is returned.

`item` is very similar to a[args], except, instead of an array scalar,
a standard Python scalar is returned. This can be useful for speeding up
access to elements of the array and doing arithmetic on elements of the
array using Python's optimized math.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.item(3)
1
>>> x.item(7)
0
>>> x.item((0, 1))
2
>>> x.item((2, 2))
1
*)

val itemset : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.itemset( *args)

Insert scalar into an array (scalar is cast to array's dtype, if possible)

There must be at least 1 argument, and define the last argument
as *item*.  Then, ``a.itemset( *args)`` is equivalent to but faster
than ``a[args] = item``.  The item should be a scalar value and `args`
must select a single item in the array `a`.

Parameters
----------
\*args : Arguments
    If one argument: a scalar, only used in case `a` is of size 1.
    If two arguments: the last argument is the value to be set
    and must be a scalar, the first argument specifies a single array
    element location. It is either an int or a tuple.

Notes
-----
Compared to indexing syntax, `itemset` provides some speed increase
for placing a scalar into a particular location in an `ndarray`,
if you must do this.  However, generally this is discouraged:
among other problems, it complicates the appearance of the code.
Also, when using `itemset` (and `item`) inside a loop, be sure
to assign the methods to a local variable to avoid the attribute
look-up at each loop iteration.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.itemset(4, 0)
>>> x.itemset((2, 2), 9)
>>> x
array([[2, 2, 6],
       [1, 0, 6],
       [1, 0, 9]])
*)

val max : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> ?initial:Py.Object.t -> ?where:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True)

Return the maximum along a given axis.

Refer to `numpy.amax` for full documentation.

See Also
--------
numpy.amax : equivalent function
*)

val mean : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.mean(axis=None, dtype=None, out=None, keepdims=False)

Returns the average of the array elements along given axis.

Refer to `numpy.mean` for full documentation.

See Also
--------
numpy.mean : equivalent function
*)

val min : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> ?initial:Py.Object.t -> ?where:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True)

Return the minimum along a given axis.

Refer to `numpy.amin` for full documentation.

See Also
--------
numpy.amin : equivalent function
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arr.newbyteorder(new_order='S')

Return the array with the same data viewed with a different byte order.

Equivalent to::

    arr.view(arr.dtype.newbytorder(new_order))

Changes are also made in all fields and sub-arrays of the array data
type.



Parameters
----------
new_order : string, optional
    Byte order to force; a value from the byte order specifications
    below. `new_order` codes can be any of:

    * 'S' - swap dtype from current to opposite endian
    * {'<', 'L'} - little endian
    * {'>', 'B'} - big endian
    * {'=', 'N'} - native order
    * {'|', 'I'} - ignore (no change to byte order)

    The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_arr : array
    New array object with the dtype reflecting given change to the
    byte order.
*)

val nonzero : [> tag] Obj.t -> Py.Object.t
(**
a.nonzero()

Return the indices of the elements that are non-zero.

Refer to `numpy.nonzero` for full documentation.

See Also
--------
numpy.nonzero : equivalent function
*)

val partition : ?axis:int -> ?kind:[`Introselect] -> ?order:[`StringList of string list | `S of string] -> kth:[`Is of int list | `I of int] -> [> tag] Obj.t -> Py.Object.t
(**
a.partition(kth, axis=-1, kind='introselect', order=None)

Rearranges the elements in the array in such a way that the value of the
element in kth position is in the position it would be in a sorted array.
All elements smaller than the kth element are moved before this element and
all equal or greater are moved behind it. The ordering of the elements in
the two partitions is undefined.

.. versionadded:: 1.8.0

Parameters
----------
kth : int or sequence of ints
    Element index to partition by. The kth element value will be in its
    final sorted position and all smaller elements will be moved before it
    and all equal or greater elements behind it.
    The order of all elements in the partitions is undefined.
    If provided with a sequence of kth it will partition all elements
    indexed by kth of them into their sorted position at once.
axis : int, optional
    Axis along which to sort. Default is -1, which means sort along the
    last axis.
kind : {'introselect'}, optional
    Selection algorithm. Default is 'introselect'.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc. A single field can
    be specified as a string, and not all fields need to be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

See Also
--------
numpy.partition : Return a parititioned copy of an array.
argpartition : Indirect partition.
sort : Full sort.

Notes
-----
See ``np.partition`` for notes on the different algorithms.

Examples
--------
>>> a = np.array([3, 4, 2, 1])
>>> a.partition(3)
>>> a
array([2, 1, 3, 4])

>>> a.partition((1, 3))
>>> a
array([1, 2, 3, 4])
*)

val prod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> ?initial:Py.Object.t -> ?where:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True)

Return the product of the array elements over the given axis

Refer to `numpy.prod` for full documentation.

See Also
--------
numpy.prod : equivalent function
*)

val ptp : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.ptp(axis=None, out=None, keepdims=False)

Peak to peak (maximum - minimum) value along a given axis.

Refer to `numpy.ptp` for full documentation.

See Also
--------
numpy.ptp : equivalent function
*)

val put : ?mode:Py.Object.t -> indices:Py.Object.t -> values:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.put(indices, values, mode='raise')

Set ``a.flat[n] = values[n]`` for all `n` in indices.

Refer to `numpy.put` for full documentation.

See Also
--------
numpy.put : equivalent function
*)

val ravel : ?order:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.ravel([order])

Return a flattened array.

Refer to `numpy.ravel` for full documentation.

See Also
--------
numpy.ravel : equivalent function

ndarray.flat : a flat iterator on the array.
*)

val repeat : ?axis:Py.Object.t -> repeats:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.repeat(repeats, axis=None)

Repeat elements of an array.

Refer to `numpy.repeat` for full documentation.

See Also
--------
numpy.repeat : equivalent function
*)

val reshape : ?order:Py.Object.t -> int list -> [> tag] Obj.t -> Py.Object.t
(**
a.reshape(shape, order='C')

Returns an array containing the same data with a new shape.

Refer to `numpy.reshape` for full documentation.

See Also
--------
numpy.reshape : equivalent function

Notes
-----
Unlike the free function `numpy.reshape`, this method on `ndarray` allows
the elements of the shape parameter to be passed in as separate arguments.
For example, ``a.reshape(10, 11)`` is equivalent to
``a.reshape((10, 11))``.
*)

val resize : ?refcheck:bool -> new_shape:[`T_n_ints of Py.Object.t | `TupleOfInts of int list] -> [> tag] Obj.t -> Py.Object.t
(**
a.resize(new_shape, refcheck=True)

Change shape and size of array in-place.

Parameters
----------
new_shape : tuple of ints, or `n` ints
    Shape of resized array.
refcheck : bool, optional
    If False, reference count will not be checked. Default is True.

Returns
-------
None

Raises
------
ValueError
    If `a` does not own its own data or references or views to it exist,
    and the data memory must be changed.
    PyPy only: will always raise if the data memory must be changed, since
    there is no reliable way to determine if references or views to it
    exist.

SystemError
    If the `order` keyword argument is specified. This behaviour is a
    bug in NumPy.

See Also
--------
resize : Return a new array with the specified shape.

Notes
-----
This reallocates space for the data area if necessary.

Only contiguous arrays (data elements consecutive in memory) can be
resized.

The purpose of the reference count check is to make sure you
do not use this array as a buffer for another Python object and then
reallocate the memory. However, reference counts can increase in
other ways so if you are sure that you have not shared the memory
for this array with another Python object, then you may safely set
`refcheck` to False.

Examples
--------
Shrinking an array: array is flattened (in the order that the data are
stored in memory), resized, and reshaped:

>>> a = np.array([[0, 1], [2, 3]], order='C')
>>> a.resize((2, 1))
>>> a
array([[0],
       [1]])

>>> a = np.array([[0, 1], [2, 3]], order='F')
>>> a.resize((2, 1))
>>> a
array([[0],
       [2]])

Enlarging an array: as above, but missing entries are filled with zeros:

>>> b = np.array([[0, 1], [2, 3]])
>>> b.resize(2, 3) # new_shape parameter doesn't have to be a tuple
>>> b
array([[0, 1, 2],
       [3, 0, 0]])

Referencing an array prevents resizing...

>>> c = a
>>> a.resize((1, 1))
Traceback (most recent call last):
...
ValueError: cannot resize an array that references or is referenced ...

Unless `refcheck` is False:

>>> a.resize((1, 1), refcheck=False)
>>> a
array([[0]])
>>> c
array([[0]])
*)

val round : ?decimals:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.round(decimals=0, out=None)

Return `a` with each element rounded to the given number of decimals.

Refer to `numpy.around` for full documentation.

See Also
--------
numpy.around : equivalent function
*)

val searchsorted : ?side:Py.Object.t -> ?sorter:Py.Object.t -> v:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.searchsorted(v, side='left', sorter=None)

Find indices where elements of v should be inserted in a to maintain order.

For full documentation, see `numpy.searchsorted`

See Also
--------
numpy.searchsorted : equivalent function
*)

val setfield : ?offset:int -> val_:Py.Object.t -> dtype:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.setfield(val, dtype, offset=0)

Put a value into a specified place in a field defined by a data-type.

Place `val` into `a`'s field defined by `dtype` and beginning `offset`
bytes into the field.

Parameters
----------
val : object
    Value to be placed in field.
dtype : dtype object
    Data-type of the field in which to place `val`.
offset : int, optional
    The number of bytes into the field at which to place `val`.

Returns
-------
None

See Also
--------
getfield

Examples
--------
>>> x = np.eye(3)
>>> x.getfield(np.float64)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
>>> x.setfield(3, np.int32)
>>> x.getfield(np.int32)
array([[3, 3, 3],
       [3, 3, 3],
       [3, 3, 3]], dtype=int32)
>>> x
array([[1.0e+000, 1.5e-323, 1.5e-323],
       [1.5e-323, 1.0e+000, 1.5e-323],
       [1.5e-323, 1.5e-323, 1.0e+000]])
>>> x.setfield(np.eye(3), np.int32)
>>> x
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
*)

val setflags : ?write:bool -> ?align:bool -> ?uic:bool -> [> tag] Obj.t -> Py.Object.t
(**
a.setflags(write=None, align=None, uic=None)

Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
respectively.

These Boolean-valued flags affect how numpy interprets the memory
area used by `a` (see Notes below). The ALIGNED flag can only
be set to True if the data is actually aligned according to the type.
The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
to True. The flag WRITEABLE can only be set to True if the array owns its
own memory, or the ultimate owner of the memory exposes a writeable buffer
interface, or is a string. (The exception for string is made so that
unpickling can be done without copying memory.)

Parameters
----------
write : bool, optional
    Describes whether or not `a` can be written to.
align : bool, optional
    Describes whether or not `a` is aligned properly for its type.
uic : bool, optional
    Describes whether or not `a` is a copy of another 'base' array.

Notes
-----
Array flags provide information about how the memory area used
for the array is to be interpreted. There are 7 Boolean flags
in use, only four of which can be changed by the user:
WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.

WRITEABLE (W) the data area can be written to;

ALIGNED (A) the data and strides are aligned appropriately for the hardware
(as determined by the compiler);

UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;

WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
called, the base array will be updated with the contents of this array.

All flags can be accessed using the single (upper case) letter as well
as the full name.

Examples
--------
>>> y = np.array([[3, 1, 7],
...               [2, 0, 0],
...               [8, 5, 9]])
>>> y
array([[3, 1, 7],
       [2, 0, 0],
       [8, 5, 9]])
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(write=0, align=0)
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : False
  ALIGNED : False
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(uic=1)
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: cannot set WRITEBACKIFCOPY flag to True
*)

val sort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[`StringList of string list | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.sort(axis=-1, kind=None, order=None)

Sort an array in-place. Refer to `numpy.sort` for full documentation.

Parameters
----------
axis : int, optional
    Axis along which to sort. Default is -1, which means sort along the
    last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
    and 'mergesort' use timsort under the covers and, in general, the
    actual implementation will vary with datatype. The 'mergesort' option
    is retained for backwards compatibility.

    .. versionchanged:: 1.15.0.
       The 'stable' option was added.

order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  A single field can
    be specified as a string, and not all fields need be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

See Also
--------
numpy.sort : Return a sorted copy of an array.
numpy.argsort : Indirect sort.
numpy.lexsort : Indirect stable sort on multiple keys.
numpy.searchsorted : Find elements in sorted array.
numpy.partition: Partial sort.

Notes
-----
See `numpy.sort` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.array([[1,4], [3,1]])
>>> a.sort(axis=1)
>>> a
array([[1, 4],
       [1, 3]])
>>> a.sort(axis=0)
>>> a
array([[1, 3],
       [1, 4]])

Use the `order` keyword to specify a field to use when sorting a
structured array:

>>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])
>>> a.sort(order='y')
>>> a
array([(b'c', 1), (b'a', 2)],
      dtype=[('x', 'S1'), ('y', '<i8')])
*)

val squeeze : ?axis:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.squeeze(axis=None)

Remove single-dimensional entries from the shape of `a`.

Refer to `numpy.squeeze` for full documentation.

See Also
--------
numpy.squeeze : equivalent function
*)

val std : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?ddof:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)

Returns the standard deviation of the array elements along given axis.

Refer to `numpy.std` for full documentation.

See Also
--------
numpy.std : equivalent function
*)

val sum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> ?initial:Py.Object.t -> ?where:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)

Return the sum of the array elements over the given axis.

Refer to `numpy.sum` for full documentation.

See Also
--------
numpy.sum : equivalent function
*)

val swapaxes : axis1:Py.Object.t -> axis2:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.swapaxes(axis1, axis2)

Return a view of the array with `axis1` and `axis2` interchanged.

Refer to `numpy.swapaxes` for full documentation.

See Also
--------
numpy.swapaxes : equivalent function
*)

val take : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?mode:Py.Object.t -> indices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.take(indices, axis=None, out=None, mode='raise')

Return an array formed from the elements of `a` at the given indices.

Refer to `numpy.take` for full documentation.

See Also
--------
numpy.take : equivalent function
*)

val tobytes : ?order:[`C | `F | `None] -> [> tag] Obj.t -> Py.Object.t
(**
a.tobytes(order='C')

Construct Python bytes containing the raw data bytes in the array.

Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either 'C' or 'Fortran',
or 'Any' order (the default is 'C'-order). 'Any' order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means 'Fortran' order.

.. versionadded:: 1.9.0

Parameters
----------
order : {'C', 'F', None}, optional
    Order of the data for multidimensional arrays:
    C, Fortran, or the same as for the original array.

Returns
-------
s : bytes
    Python bytes exhibiting a copy of `a`'s raw data.

Examples
--------
>>> x = np.array([[0, 1], [2, 3]], dtype='<u2')
>>> x.tobytes()
b'\x00\x00\x01\x00\x02\x00\x03\x00'
>>> x.tobytes('C') == x.tobytes()
True
>>> x.tobytes('F')
b'\x00\x00\x02\x00\x01\x00\x03\x00'
*)

val tofile : ?sep:string -> ?format:string -> fid:[`S of string | `PyObject of Py.Object.t] -> [> tag] Obj.t -> Py.Object.t
(**
a.tofile(fid, sep='', format='%s')

Write array to a file as text or binary (default).

Data is always written in 'C' order, independent of the order of `a`.
The data produced by this method can be recovered using the function
fromfile().

Parameters
----------
fid : file or str or Path
    An open file object, or a string containing a filename.

    .. versionchanged:: 1.17.0
        `pathlib.Path` objects are now accepted.

sep : str
    Separator between array items for text output.
    If '' (empty), a binary file is written, equivalent to
    ``file.write(a.tobytes())``.
format : str
    Format string for text file output.
    Each entry in the array is formatted to text by first converting
    it to the closest Python type, and then using 'format' % item.

Notes
-----
This is a convenience function for quick storage of array data.
Information on endianness and precision is lost, so this method is not a
good choice for files intended to archive data or transport data between
machines with different endianness. Some of these problems can be overcome
by outputting the data as text files, at the expense of speed and file
size.

When fid is a file object, array contents are directly written to the
file, bypassing the file object's ``write`` method. As a result, tofile
cannot be used with files objects supporting compression (e.g., GzipFile)
or file-like objects that do not support ``fileno()`` (e.g., BytesIO).
*)

val tolist : [> tag] Obj.t -> Py.Object.t
(**
a.tolist()

Return the array as an ``a.ndim``-levels deep nested list of Python scalars.

Return a copy of the array data as a (nested) Python list.
Data items are converted to the nearest compatible builtin Python type, via
the `~numpy.ndarray.item` function.

If ``a.ndim`` is 0, then since the depth of the nested list is 0, it will
not be a list at all, but a simple Python scalar.

Parameters
----------
none

Returns
-------
y : object, or list of object, or list of list of object, or ...
    The possibly nested list of array elements.

Notes
-----
The array may be recreated via ``a = np.array(a.tolist())``, although this
may sometimes lose precision.

Examples
--------
For a 1D array, ``a.tolist()`` is almost the same as ``list(a)``, 
except that ``tolist`` changes numpy scalars to Python scalars:

>>> a = np.uint32([1, 2])
>>> a_list = list(a)
>>> a_list
[1, 2]
>>> type(a_list[0])
<class 'numpy.uint32'>
>>> a_tolist = a.tolist()
>>> a_tolist
[1, 2]
>>> type(a_tolist[0])
<class 'int'>

Additionally, for a 2D array, ``tolist`` applies recursively:

>>> a = np.array([[1, 2], [3, 4]])
>>> list(a)
[array([1, 2]), array([3, 4])]
>>> a.tolist()
[[1, 2], [3, 4]]

The base case for this recursion is a 0D array:

>>> a = np.array(1)
>>> list(a)
Traceback (most recent call last):
  ...
TypeError: iteration over a 0-d array
>>> a.tolist()
1
*)

val tostring : ?order:[`C | `F | `None] -> [> tag] Obj.t -> Py.Object.t
(**
a.tostring(order='C')

Construct Python bytes containing the raw data bytes in the array.

Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either 'C' or 'Fortran',
or 'Any' order (the default is 'C'-order). 'Any' order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means 'Fortran' order.

This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.

Parameters
----------
order : {'C', 'F', None}, optional
    Order of the data for multidimensional arrays:
    C, Fortran, or the same as for the original array.

Returns
-------
s : bytes
    Python bytes exhibiting a copy of `a`'s raw data.

Examples
--------
>>> x = np.array([[0, 1], [2, 3]], dtype='<u2')
>>> x.tobytes()
b'\x00\x00\x01\x00\x02\x00\x03\x00'
>>> x.tobytes('C') == x.tobytes()
True
>>> x.tobytes('F')
b'\x00\x00\x02\x00\x01\x00\x03\x00'
*)

val trace : ?offset:Py.Object.t -> ?axis1:Py.Object.t -> ?axis2:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)

Return the sum along diagonals of the array.

Refer to `numpy.trace` for full documentation.

See Also
--------
numpy.trace : equivalent function
*)

val transpose : Py.Object.t list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.transpose( *axes)

Returns a view of the array with axes transposed.

For a 1-D array this has no effect, as a transposed vector is simply the
same vector. To convert a 1-D array into a 2D column vector, an additional
dimension must be added. `np.atleast2d(a).T` achieves this, as does
`a[:, np.newaxis]`.
For a 2-D array, this is a standard matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
``a.shape = (i[0], i[1], ... i[n-2], i[n-1])``, then
``a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.

Parameters
----------
axes : None, tuple of ints, or `n` ints

 * None or no argument: reverses the order of the axes.

 * tuple of ints: `i` in the `j`-th place in the tuple means `a`'s
   `i`-th axis becomes `a.transpose()`'s `j`-th axis.

 * `n` ints: same as an n-tuple of the same ints (this form is
   intended simply as a 'convenience' alternative to the tuple form)

Returns
-------
out : ndarray
    View of `a`, with axes suitably permuted.

See Also
--------
ndarray.T : Array property returning the array transposed.
ndarray.reshape : Give a new shape to an array without changing its data.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> a
array([[1, 2],
       [3, 4]])
>>> a.transpose()
array([[1, 3],
       [2, 4]])
>>> a.transpose((1, 0))
array([[1, 3],
       [2, 4]])
>>> a.transpose(1, 0)
array([[1, 3],
       [2, 4]])
*)

val var : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?ddof:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)

Returns the variance of the array elements, along given axis.

Refer to `numpy.var` for full documentation.

See Also
--------
numpy.var : equivalent function
*)

val view : ?dtype:[`Dtype of Dtype.t | `Ndarray_sub_class of Py.Object.t] -> ?type_:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.view(dtype=None, type=None)

New view of array with the same data.

Parameters
----------
dtype : data-type or ndarray sub-class, optional
    Data-type descriptor of the returned view, e.g., float32 or int16. The
    default, None, results in the view having the same data-type as `a`.
    This argument can also be specified as an ndarray sub-class, which
    then specifies the type of the returned object (this is equivalent to
    setting the ``type`` parameter).
type : Python type, optional
    Type of the returned view, e.g., ndarray or matrix.  Again, the
    default None results in type preservation.

Notes
-----
``a.view()`` is used two different ways:

``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
of the array's memory with a different data-type.  This can cause a
reinterpretation of the bytes of memory.

``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
returns an instance of `ndarray_subclass` that looks at the same array
(same shape, dtype, etc.)  This does not cause a reinterpretation of the
memory.

For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of
bytes per entry than the previous dtype (for example, converting a
regular array to a structured array), then the behavior of the view
cannot be predicted just from the superficial appearance of ``a`` (shown
by ``print(a)``). It also depends on exactly how ``a`` is stored in
memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus
defined as a slice or transpose, etc., the view may give different
results.


Examples
--------
>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])

Viewing array data using a different type and dtype:

>>> y = x.view(dtype=np.int16, type=np.matrix)
>>> y
matrix([[513]], dtype=int16)
>>> print(type(y))
<class 'numpy.matrix'>

Creating a view on a structured array so it can be used in calculations

>>> x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])
>>> xv = x.view(dtype=np.int8).reshape(-1,2)
>>> xv
array([[1, 2],
       [3, 4]], dtype=int8)
>>> xv.mean(0)
array([2.,  3.])

Making changes to the view changes the underlying array

>>> xv[0,1] = 20
>>> x
array([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])

Using a view to convert an array to a recarray:

>>> z = x.view(np.recarray)
>>> z.a
array([1, 3], dtype=int8)

Views share data:

>>> x[0] = (9, 10)
>>> z[0]
(9, 10)

Views that change the dtype size (bytes per entry) should normally be
avoided on arrays defined by slices, transposes, fortran-ordering, etc.:

>>> x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)
>>> y = x[:, 0:2]
>>> y
array([[1, 2],
       [4, 5]], dtype=int16)
>>> y.view(dtype=[('width', np.int16), ('length', np.int16)])
Traceback (most recent call last):
    ...
ValueError: To change to a dtype of a different size, the array must be C-contiguous
>>> z = y.copy()
>>> z.view(dtype=[('width', np.int16), ('length', np.int16)])
array([[(1, 2)],
       [(4, 5)]], dtype=[('width', '<i2'), ('length', '<i2')])
*)


(** Attribute T: get value or raise Not_found if None.*)
val t : t -> [`ArrayLike|`Ndarray|`Object] Obj.t

(** Attribute T: get value as an option. *)
val t_opt : t -> ([`ArrayLike|`Ndarray|`Object] Obj.t) option


(** Attribute data: get value or raise Not_found if None.*)
val data : t -> Py.Object.t

(** Attribute data: get value as an option. *)
val data_opt : t -> (Py.Object.t) option


(** Attribute dtype: get value or raise Not_found if None.*)
val dtype : t -> Py.Object.t

(** Attribute dtype: get value as an option. *)
val dtype_opt : t -> (Py.Object.t) option


(** Attribute flags: get value or raise Not_found if None.*)
val flags : t -> Py.Object.t

(** Attribute flags: get value as an option. *)
val flags_opt : t -> (Py.Object.t) option


(** Attribute flat: get value or raise Not_found if None.*)
val flat : t -> Py.Object.t

(** Attribute flat: get value as an option. *)
val flat_opt : t -> (Py.Object.t) option


(** Attribute imag: get value or raise Not_found if None.*)
val imag : t -> [`ArrayLike|`Ndarray|`Object] Obj.t

(** Attribute imag: get value as an option. *)
val imag_opt : t -> ([`ArrayLike|`Ndarray|`Object] Obj.t) option


(** Attribute real: get value or raise Not_found if None.*)
val real : t -> [`ArrayLike|`Ndarray|`Object] Obj.t

(** Attribute real: get value as an option. *)
val real_opt : t -> ([`ArrayLike|`Ndarray|`Object] Obj.t) option


(** Attribute size: get value or raise Not_found if None.*)
val size : t -> int

(** Attribute size: get value as an option. *)
val size_opt : t -> (int) option


(** Attribute itemsize: get value or raise Not_found if None.*)
val itemsize : t -> int

(** Attribute itemsize: get value as an option. *)
val itemsize_opt : t -> (int) option


(** Attribute nbytes: get value or raise Not_found if None.*)
val nbytes : t -> int

(** Attribute nbytes: get value as an option. *)
val nbytes_opt : t -> (int) option


(** Attribute ndim: get value or raise Not_found if None.*)
val ndim : t -> int

(** Attribute ndim: get value as an option. *)
val ndim_opt : t -> (int) option


(** Attribute shape: get value or raise Not_found if None.*)
val shape : t -> int list

(** Attribute shape: get value as an option. *)
val shape_opt : t -> (int list) option


(** Attribute strides: get value or raise Not_found if None.*)
val strides : t -> int array

(** Attribute strides: get value as an option. *)
val strides_opt : t -> (int array) option


(** Attribute ctypes: get value or raise Not_found if None.*)
val ctypes : t -> Py.Object.t

(** Attribute ctypes: get value as an option. *)
val ctypes_opt : t -> (Py.Object.t) option


(** Attribute base: get value or raise Not_found if None.*)
val base : t -> [`ArrayLike|`Ndarray|`Object] Obj.t

(** Attribute base: get value as an option. *)
val base_opt : t -> ([`ArrayLike|`Ndarray|`Object] Obj.t) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Ndenumerate : sig
type tag = [`Ndenumerate]
type t = [`Ndenumerate | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : [>`Ndarray] Obj.t -> t
(**
Multidimensional index iterator.

Return an iterator yielding pairs of array coordinates and values.

Parameters
----------
arr : ndarray
  Input array.

See Also
--------
ndindex, flatiter

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> for index, x in np.ndenumerate(a):
...     print(index, x)
(0, 0) 1
(0, 1) 2
(1, 0) 3
(1, 1) 4
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
None
*)

val next : [> tag] Obj.t -> (int array * Py.Object.t)
(**
Standard iterator method, returns the index tuple and array value.

Returns
-------
coords : tuple of ints
    The indices of the current iteration.
val : scalar
    The array element of the current iteration.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Ndindex : sig
type tag = [`Ndindex]
type t = [`Ndindex | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : int list -> t
(**
An N-dimensional iterator object to index arrays.

Given the shape of an array, an `ndindex` instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned, the last dimension is iterated over first.

Parameters
----------
`*args` : ints
  The size of each dimension of the array.

See Also
--------
ndenumerate, flatiter

Examples
--------
>>> for index in np.ndindex(3, 2, 1):
...     print(index)
(0, 0, 0)
(0, 1, 0)
(1, 0, 0)
(1, 1, 0)
(2, 0, 0)
(2, 1, 0)
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
None
*)

val ndincr : [> tag] Obj.t -> Py.Object.t
(**
Increment the multi-dimensional index by one.

This method is for backward compatibility only: do not use.
*)

val next : [> tag] Obj.t -> int array
(**
Standard iterator method, updates the index and returns the index
tuple.

Returns
-------
val : tuple of ints
    Returns a tuple containing the indices of the current
    iteration.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Nditer : sig
type tag = [`Nditer]
type t = [`Nditer | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Implement iter(self).
*)

val __setitem__ : key:Py.Object.t -> value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Set self[key] to value.
*)


(** Attribute dtypes: get value or raise Not_found if None.*)
val dtypes : t -> Py.Object.t

(** Attribute dtypes: get value as an option. *)
val dtypes_opt : t -> (Py.Object.t) option


(** Attribute finished: get value or raise Not_found if None.*)
val finished : t -> bool

(** Attribute finished: get value as an option. *)
val finished_opt : t -> (bool) option


(** Attribute has_delayed_bufalloc: get value or raise Not_found if None.*)
val has_delayed_bufalloc : t -> bool

(** Attribute has_delayed_bufalloc: get value as an option. *)
val has_delayed_bufalloc_opt : t -> (bool) option


(** Attribute has_index: get value or raise Not_found if None.*)
val has_index : t -> bool

(** Attribute has_index: get value as an option. *)
val has_index_opt : t -> (bool) option


(** Attribute has_multi_index: get value or raise Not_found if None.*)
val has_multi_index : t -> bool

(** Attribute has_multi_index: get value as an option. *)
val has_multi_index_opt : t -> (bool) option


(** Attribute index: get value or raise Not_found if None.*)
val index : t -> Py.Object.t

(** Attribute index: get value as an option. *)
val index_opt : t -> (Py.Object.t) option


(** Attribute iterationneedsapi: get value or raise Not_found if None.*)
val iterationneedsapi : t -> bool

(** Attribute iterationneedsapi: get value as an option. *)
val iterationneedsapi_opt : t -> (bool) option


(** Attribute iterindex: get value or raise Not_found if None.*)
val iterindex : t -> int

(** Attribute iterindex: get value as an option. *)
val iterindex_opt : t -> (int) option


(** Attribute itersize: get value or raise Not_found if None.*)
val itersize : t -> int

(** Attribute itersize: get value as an option. *)
val itersize_opt : t -> (int) option


(** Attribute itviews: get value or raise Not_found if None.*)
val itviews : t -> Py.Object.t

(** Attribute itviews: get value as an option. *)
val itviews_opt : t -> (Py.Object.t) option


(** Attribute multi_index: get value or raise Not_found if None.*)
val multi_index : t -> Py.Object.t

(** Attribute multi_index: get value as an option. *)
val multi_index_opt : t -> (Py.Object.t) option


(** Attribute ndim: get value or raise Not_found if None.*)
val ndim : t -> int

(** Attribute ndim: get value as an option. *)
val ndim_opt : t -> (int) option


(** Attribute nop: get value or raise Not_found if None.*)
val nop : t -> int

(** Attribute nop: get value as an option. *)
val nop_opt : t -> (int) option


(** Attribute operands: get value or raise Not_found if None.*)
val operands : t -> Py.Object.t

(** Attribute operands: get value as an option. *)
val operands_opt : t -> (Py.Object.t) option


(** Attribute shape: get value or raise Not_found if None.*)
val shape : t -> int list

(** Attribute shape: get value as an option. *)
val shape_opt : t -> (int list) option


(** Attribute value: get value or raise Not_found if None.*)
val value : t -> Py.Object.t

(** Attribute value: get value as an option. *)
val value_opt : t -> (Py.Object.t) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Number : sig
type tag = [`Number]
type t = [`Number | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Abstract base class of all numeric scalar types.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Object : sig
type tag = [`Object]
type t = [`Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
The base class of the class hierarchy.

When called, it accepts no arguments and returns a new featureless
instance that has no instance attributes and cannot be given any.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Object0 : sig
type tag = [`Object_]
type t = [`Object | `Object_] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Poly1d : sig
type tag = [`Poly1d]
type t = [`Object | `Poly1d] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?r:bool -> ?variable:string -> c_or_r:[>`Ndarray] Obj.t -> unit -> t
(**
A one-dimensional polynomial class.

A convenience class, used to encapsulate 'natural' operations on
polynomials so that said operations may take on their customary
form in code (see Examples).

Parameters
----------
c_or_r : array_like
    The polynomial's coefficients, in decreasing powers, or if
    the value of the second parameter is True, the polynomial's
    roots (values where the polynomial evaluates to 0).  For example,
    ``poly1d([1, 2, 3])`` returns an object that represents
    :math:`x^2 + 2x + 3`, whereas ``poly1d([1, 2, 3], True)`` returns
    one that represents :math:`(x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x -6`.
r : bool, optional
    If True, `c_or_r` specifies the polynomial's roots; the default
    is False.
variable : str, optional
    Changes the variable used when printing `p` from `x` to `variable`
    (see Examples).

Examples
--------
Construct the polynomial :math:`x^2 + 2x + 3`:

>>> p = np.poly1d([1, 2, 3])
>>> print(np.poly1d(p))
   2
1 x + 2 x + 3

Evaluate the polynomial at :math:`x = 0.5`:

>>> p(0.5)
4.25

Find the roots:

>>> p.r
array([-1.+1.41421356j, -1.-1.41421356j])
>>> p(p.r)
array([ -4.44089210e-16+0.j,  -4.44089210e-16+0.j]) # may vary

These numbers in the previous line represent (0, 0) to machine precision

Show the coefficients:

>>> p.c
array([1, 2, 3])

Display the order (the leading zero-coefficients are removed):

>>> p.order
2

Show the coefficient of the k-th power in the polynomial
(which is equivalent to ``p.c[-(i+1)]``):

>>> p[1]
2

Polynomials can be added, subtracted, multiplied, and divided
(returns quotient and remainder):

>>> p * p
poly1d([ 1,  4, 10, 12,  9])

>>> (p**3 + 4) / p
(poly1d([ 1.,  4., 10., 12.,  9.]), poly1d([4.]))

``asarray(p)`` gives the coefficient array, so polynomials can be
used in all functions that accept arrays:

>>> p**2 # square of polynomial
poly1d([ 1,  4, 10, 12,  9])

>>> np.square(p) # square of individual coefficients
array([1, 4, 9])

The variable used in the string representation of `p` can be modified,
using the `variable` parameter:

>>> p = np.poly1d([1,2,3], variable='z')
>>> print(p)
   2
1 z + 2 z + 3

Construct a polynomial from its roots:

>>> np.poly1d([1, 2], True)
poly1d([ 1., -3.,  2.])

This is the same polynomial as obtained by:

>>> np.poly1d([1, -1]) * np.poly1d([1, -2])
poly1d([ 1, -3,  2])
*)

val __getitem__ : val_:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
None
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
None
*)

val __setitem__ : key:Py.Object.t -> val_:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
None
*)

val deriv : ?m:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a derivative of this polynomial.

Refer to `polyder` for full documentation.

See Also
--------
polyder : equivalent function
*)

val integ : ?m:Py.Object.t -> ?k:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return an antiderivative (indefinite integral) of this polynomial.

Refer to `polyint` for full documentation.

See Also
--------
polyint : equivalent function
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Recarray : sig
type tag = [`Recarray]
type t = [`ArrayLike | `Object | `Recarray] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?dtype:Dtype.t -> ?buf:Py.Object.t -> ?offset:Py.Object.t -> ?strides:Py.Object.t -> ?formats:Py.Object.t -> ?names:string list -> ?titles:Py.Object.t -> ?byteorder:Py.Object.t -> ?aligned:Py.Object.t -> ?order:Py.Object.t -> int list -> t
(**
Construct an ndarray that allows field access using attributes.

Arrays may have a data-types containing fields, analogous
to columns in a spread sheet.  An example is ``[(x, int), (y, float)]``,
where each entry in the array is a pair of ``(int, float)``.  Normally,
these attributes are accessed using dictionary lookups such as ``arr['x']``
and ``arr['y']``.  Record arrays allow the fields to be accessed as members
of the array, using ``arr.x`` and ``arr.y``.

Parameters
----------
shape : tuple
    Shape of output array.
dtype : data-type, optional
    The desired data-type.  By default, the data-type is determined
    from `formats`, `names`, `titles`, `aligned` and `byteorder`.
formats : list of data-types, optional
    A list containing the data-types for the different columns, e.g.
    ``['i4', 'f8', 'i4']``.  `formats` does *not* support the new
    convention of using types directly, i.e. ``(int, float, int)``.
    Note that `formats` must be a list, not a tuple.
    Given that `formats` is somewhat limited, we recommend specifying
    `dtype` instead.
names : tuple of str, optional
    The name of each column, e.g. ``('x', 'y', 'z')``.
buf : buffer, optional
    By default, a new array is created of the given shape and data-type.
    If `buf` is specified and is an object exposing the buffer interface,
    the array will use the memory from the existing buffer.  In this case,
    the `offset` and `strides` keywords are available.

Other Parameters
----------------
titles : tuple of str, optional
    Aliases for column names.  For example, if `names` were
    ``('x', 'y', 'z')`` and `titles` is
    ``('x_coordinate', 'y_coordinate', 'z_coordinate')``, then
    ``arr['x']`` is equivalent to both ``arr.x`` and ``arr.x_coordinate``.
byteorder : {'<', '>', '='}, optional
    Byte-order for all fields.
aligned : bool, optional
    Align the fields in memory as the C-compiler would.
strides : tuple of ints, optional
    Buffer (`buf`) is interpreted according to these strides (strides
    define how many bytes each array element, row, column, etc.
    occupy in memory).
offset : int, optional
    Start reading buffer (`buf`) from this offset onwards.
order : {'C', 'F'}, optional
    Row-major (C-style) or column-major (Fortran-style) order.

Returns
-------
rec : recarray
    Empty array of the given shape and type.

See Also
--------
rec.fromrecords : Construct a record array from data.
record : fundamental data-type for `recarray`.
format_parser : determine a data-type from formats, names, titles.

Notes
-----
This constructor can be compared to ``empty``: it creates a new record
array but does not fill it with data.  To create a record array from data,
use one of the following methods:

1. Create a standard ndarray and convert it to a record array,
   using ``arr.view(np.recarray)``
2. Use the `buf` keyword.
3. Use `np.rec.fromrecords`.

Examples
--------
Create an array with two fields, ``x`` and ``y``:

>>> x = np.array([(1.0, 2), (3.0, 4)], dtype=[('x', '<f8'), ('y', '<i8')])
>>> x
array([(1., 2), (3., 4)], dtype=[('x', '<f8'), ('y', '<i8')])

>>> x['x']
array([1., 3.])

View the array as a record array:

>>> x = x.view(np.recarray)

>>> x.x
array([1., 3.])

>>> x.y
array([2, 4])

Create a new, empty record array:

>>> np.recarray((2,),
... dtype=[('x', int), ('y', float), ('z', int)]) #doctest: +SKIP
rec.array([(-1073741821, 1.2249118382103472e-301, 24547520),
       (3471280, 1.2134086255804012e-316, 0)],
      dtype=[('x', '<i4'), ('y', '<f8'), ('z', '<i4')])
*)

val __getitem__ : indx:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Implement iter(self).
*)

val __setitem__ : key:Py.Object.t -> value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Set self[key] to value.
*)

val all : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.all(axis=None, out=None, keepdims=False)

Returns True if all elements evaluate to True.

Refer to `numpy.all` for full documentation.

See Also
--------
numpy.all : equivalent function
*)

val any : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.any(axis=None, out=None, keepdims=False)

Returns True if any of the elements of `a` evaluate to True.

Refer to `numpy.any` for full documentation.

See Also
--------
numpy.any : equivalent function
*)

val argmax : ?axis:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argmax(axis=None, out=None)

Return indices of the maximum values along the given axis.

Refer to `numpy.argmax` for full documentation.

See Also
--------
numpy.argmax : equivalent function
*)

val argmin : ?axis:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argmin(axis=None, out=None)

Return indices of the minimum values along the given axis of `a`.

Refer to `numpy.argmin` for detailed documentation.

See Also
--------
numpy.argmin : equivalent function
*)

val argpartition : ?axis:Py.Object.t -> ?kind:Py.Object.t -> ?order:Py.Object.t -> kth:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argpartition(kth, axis=-1, kind='introselect', order=None)

Returns the indices that would partition this array.

Refer to `numpy.argpartition` for full documentation.

.. versionadded:: 1.8.0

See Also
--------
numpy.argpartition : equivalent function
*)

val argsort : ?axis:Py.Object.t -> ?kind:Py.Object.t -> ?order:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.argsort(axis=-1, kind=None, order=None)

Returns the indices that would sort this array.

Refer to `numpy.argsort` for full documentation.

See Also
--------
numpy.argsort : equivalent function
*)

val astype : ?order:[`C | `F | `A | `K] -> ?casting:[`No | `Equiv | `Safe | `Same_kind | `Unsafe] -> ?subok:Py.Object.t -> ?copy:bool -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)

Copy of the array, cast to a specified type.

Parameters
----------
dtype : str or dtype
    Typecode or data-type to which the array is cast.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout order of the result.
    'C' means C order, 'F' means Fortran order, 'A'
    means 'F' order if all the arrays are Fortran contiguous,
    'C' order otherwise, and 'K' means as close to the
    order the array elements appear in memory as possible.
    Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'unsafe'
    for backwards compatibility.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.
subok : bool, optional
    If True, then sub-classes will be passed-through (default), otherwise
    the returned array will be forced to be a base-class array.
copy : bool, optional
    By default, astype always returns a newly allocated array. If this
    is set to false, and the `dtype`, `order`, and `subok`
    requirements are satisfied, the input array is returned instead
    of a copy.

Returns
-------
arr_t : ndarray
    Unless `copy` is False and the other conditions for returning the input
    array are satisfied (see description for `copy` input parameter), `arr_t`
    is a new array of the same shape as the input array, with dtype, order
    given by `dtype`, `order`.

Notes
-----
.. versionchanged:: 1.17.0
   Casting between a simple data type and a structured one is possible only
   for 'unsafe' casting.  Casting to multiple fields is allowed, but
   casting from multiple fields is not.

.. versionchanged:: 1.9.0
   Casting from numeric to string types in 'safe' casting mode requires
   that the string dtype length is long enough to store the max
   integer/float value converted.

Raises
------
ComplexWarning
    When casting from complex to float or int. To avoid this,
    one should use ``a.real.astype(t)``.

Examples
--------
>>> x = np.array([1, 2, 2.5])
>>> x
array([1. ,  2. ,  2.5])

>>> x.astype(int)
array([1, 2, 2])
*)

val byteswap : ?inplace:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.byteswap(inplace=False)

Swap the bytes of the array elements

Toggle between low-endian and big-endian data representation by
returning a byteswapped array, optionally swapped in-place.
Arrays of byte-strings are not swapped. The real and imaginary
parts of a complex number are swapped individually.

Parameters
----------
inplace : bool, optional
    If ``True``, swap bytes in-place, default is ``False``.

Returns
-------
out : ndarray
    The byteswapped array. If `inplace` is ``True``, this is
    a view to self.

Examples
--------
>>> A = np.array([1, 256, 8755], dtype=np.int16)
>>> list(map(hex, A))
['0x1', '0x100', '0x2233']
>>> A.byteswap(inplace=True)
array([  256,     1, 13090], dtype=int16)
>>> list(map(hex, A))
['0x100', '0x1', '0x3322']

Arrays of byte-strings are not swapped

>>> A = np.array([b'ceg', b'fac'])
>>> A.byteswap()
array([b'ceg', b'fac'], dtype='|S3')

``A.newbyteorder().byteswap()`` produces an array with the same values
  but different representation in memory

>>> A = np.array([1, 2, 3])
>>> A.view(np.uint8)
array([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
       0, 0], dtype=uint8)
>>> A.newbyteorder().byteswap(inplace=True)
array([1, 2, 3])
>>> A.view(np.uint8)
array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
       0, 3], dtype=uint8)
*)

val choose : ?out:Py.Object.t -> ?mode:Py.Object.t -> choices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.choose(choices, out=None, mode='raise')

Use an index array to construct a new array from a set of choices.

Refer to `numpy.choose` for full documentation.

See Also
--------
numpy.choose : equivalent function
*)

val clip : ?min:Py.Object.t -> ?max:Py.Object.t -> ?out:Py.Object.t -> ?kwargs:(string * Py.Object.t) list -> [> tag] Obj.t -> Py.Object.t
(**
a.clip(min=None, max=None, out=None, **kwargs)

Return an array whose values are limited to ``[min, max]``.
One of max or min must be given.

Refer to `numpy.clip` for full documentation.

See Also
--------
numpy.clip : equivalent function
*)

val compress : ?axis:Py.Object.t -> ?out:Py.Object.t -> condition:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.compress(condition, axis=None, out=None)

Return selected slices of this array along given axis.

Refer to `numpy.compress` for full documentation.

See Also
--------
numpy.compress : equivalent function
*)

val conj : [> tag] Obj.t -> Py.Object.t
(**
a.conj()

Complex-conjugate all elements.

Refer to `numpy.conjugate` for full documentation.

See Also
--------
numpy.conjugate : equivalent function
*)

val conjugate : [> tag] Obj.t -> Py.Object.t
(**
a.conjugate()

Return the complex conjugate, element-wise.

Refer to `numpy.conjugate` for full documentation.

See Also
--------
numpy.conjugate : equivalent function
*)

val copy : ?order:[`C | `F | `A | `K] -> [> tag] Obj.t -> Py.Object.t
(**
a.copy(order='C')

Return a copy of the array.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout of the copy. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible. (Note that this function and :func:`numpy.copy` are very
    similar, but have different default values for their order=
    arguments.)

See also
--------
numpy.copy
numpy.copyto

Examples
--------
>>> x = np.array([[1,2,3],[4,5,6]], order='F')

>>> y = x.copy()

>>> x.fill(0)

>>> x
array([[0, 0, 0],
       [0, 0, 0]])

>>> y
array([[1, 2, 3],
       [4, 5, 6]])

>>> y.flags['C_CONTIGUOUS']
True
*)

val cumprod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.cumprod(axis=None, dtype=None, out=None)

Return the cumulative product of the elements along the given axis.

Refer to `numpy.cumprod` for full documentation.

See Also
--------
numpy.cumprod : equivalent function
*)

val cumsum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.cumsum(axis=None, dtype=None, out=None)

Return the cumulative sum of the elements along the given axis.

Refer to `numpy.cumsum` for full documentation.

See Also
--------
numpy.cumsum : equivalent function
*)

val diagonal : ?offset:Py.Object.t -> ?axis1:Py.Object.t -> ?axis2:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.diagonal(offset=0, axis1=0, axis2=1)

Return specified diagonals. In NumPy 1.9 the returned array is a
read-only view instead of a copy as in previous NumPy versions.  In
a future version the read-only restriction will be removed.

Refer to :func:`numpy.diagonal` for full documentation.

See Also
--------
numpy.diagonal : equivalent function
*)

val dot : ?out:Py.Object.t -> b:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.dot(b, out=None)

Dot product of two arrays.

Refer to `numpy.dot` for full documentation.

See Also
--------
numpy.dot : equivalent function

Examples
--------
>>> a = np.eye(2)
>>> b = np.ones((2, 2)) * 2
>>> a.dot(b)
array([[2.,  2.],
       [2.,  2.]])

This array method can be conveniently chained:

>>> a.dot(b).dot(b)
array([[8.,  8.],
       [8.,  8.]])
*)

val dump : file:[`Path of Py.Object.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.dump(file)

Dump a pickle of the array to the specified file.
The array can be read back with pickle.load or numpy.load.

Parameters
----------
file : str or Path
    A string naming the dump file.

    .. versionchanged:: 1.17.0
        `pathlib.Path` objects are now accepted.
*)

val dumps : [> tag] Obj.t -> Py.Object.t
(**
a.dumps()

Returns the pickle of the array as a string.
pickle.loads or numpy.loads will convert the string back to an array.

Parameters
----------
None
*)

val field : ?val_:Py.Object.t -> attr:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
None
*)

val fill : value:[`F of float | `I of int | `Bool of bool | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.fill(value)

Fill the array with a scalar value.

Parameters
----------
value : scalar
    All elements of `a` will be assigned this value.

Examples
--------
>>> a = np.array([1, 2])
>>> a.fill(0)
>>> a
array([0, 0])
>>> a = np.empty(2)
>>> a.fill(1)
>>> a
array([1.,  1.])
*)

val flatten : ?order:[`C | `F | `A | `K] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.flatten(order='C')

Return a copy of the array collapsed into one dimension.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    'C' means to flatten in row-major (C-style) order.
    'F' means to flatten in column-major (Fortran-
    style) order. 'A' means to flatten in column-major
    order if `a` is Fortran *contiguous* in memory,
    row-major order otherwise. 'K' means to flatten
    `a` in the order the elements occur in memory.
    The default is 'C'.

Returns
-------
y : ndarray
    A copy of the input array, flattened to one dimension.

See Also
--------
ravel : Return a flattened array.
flat : A 1-D flat iterator over the array.

Examples
--------
>>> a = np.array([[1,2], [3,4]])
>>> a.flatten()
array([1, 2, 3, 4])
>>> a.flatten('F')
array([1, 3, 2, 4])
*)

val getfield : ?offset:int -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.getfield(dtype, offset=0)

Returns a field of the given array as a certain type.

A field is a view of the array data with a given data-type. The values in
the view are determined by the given type and the offset into the current
array in bytes. The offset needs to be such that the view dtype fits in the
array dtype; for example an array of dtype complex128 has 16-byte elements.
If taking a view with a 32-bit integer (4 bytes), the offset needs to be
between 0 and 12 bytes.

Parameters
----------
dtype : str or dtype
    The data type of the view. The dtype size of the view can not be larger
    than that of the array itself.
offset : int
    Number of bytes to skip before beginning the element view.

Examples
--------
>>> x = np.diag([1.+1.j]*2)
>>> x[1, 1] = 2 + 4.j
>>> x
array([[1.+1.j,  0.+0.j],
       [0.+0.j,  2.+4.j]])
>>> x.getfield(np.float64)
array([[1.,  0.],
       [0.,  2.]])

By choosing an offset of 8 bytes we can select the complex part of the
array for our view:

>>> x.getfield(np.float64, offset=8)
array([[1.,  0.],
       [0.,  4.]])
*)

val item : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.item( *args)

Copy an element of an array to a standard Python scalar and return it.

Parameters
----------
\*args : Arguments (variable number and type)

    * none: in this case, the method only works for arrays
      with one element (`a.size == 1`), which element is
      copied into a standard Python scalar object and returned.

    * int_type: this argument is interpreted as a flat index into
      the array, specifying which element to copy and return.

    * tuple of int_types: functions as does a single int_type argument,
      except that the argument is interpreted as an nd-index into the
      array.

Returns
-------
z : Standard Python scalar object
    A copy of the specified element of the array as a suitable
    Python scalar

Notes
-----
When the data type of `a` is longdouble or clongdouble, item() returns
a scalar array object because there is no available Python scalar that
would not lose information. Void arrays return a buffer object for item(),
unless fields are defined, in which case a tuple is returned.

`item` is very similar to a[args], except, instead of an array scalar,
a standard Python scalar is returned. This can be useful for speeding up
access to elements of the array and doing arithmetic on elements of the
array using Python's optimized math.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.item(3)
1
>>> x.item(7)
0
>>> x.item((0, 1))
2
>>> x.item((2, 2))
1
*)

val itemset : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.itemset( *args)

Insert scalar into an array (scalar is cast to array's dtype, if possible)

There must be at least 1 argument, and define the last argument
as *item*.  Then, ``a.itemset( *args)`` is equivalent to but faster
than ``a[args] = item``.  The item should be a scalar value and `args`
must select a single item in the array `a`.

Parameters
----------
\*args : Arguments
    If one argument: a scalar, only used in case `a` is of size 1.
    If two arguments: the last argument is the value to be set
    and must be a scalar, the first argument specifies a single array
    element location. It is either an int or a tuple.

Notes
-----
Compared to indexing syntax, `itemset` provides some speed increase
for placing a scalar into a particular location in an `ndarray`,
if you must do this.  However, generally this is discouraged:
among other problems, it complicates the appearance of the code.
Also, when using `itemset` (and `item`) inside a loop, be sure
to assign the methods to a local variable to avoid the attribute
look-up at each loop iteration.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.itemset(4, 0)
>>> x.itemset((2, 2), 9)
>>> x
array([[2, 2, 6],
       [1, 0, 6],
       [1, 0, 9]])
*)

val max : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> ?initial:Py.Object.t -> ?where:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True)

Return the maximum along a given axis.

Refer to `numpy.amax` for full documentation.

See Also
--------
numpy.amax : equivalent function
*)

val mean : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.mean(axis=None, dtype=None, out=None, keepdims=False)

Returns the average of the array elements along given axis.

Refer to `numpy.mean` for full documentation.

See Also
--------
numpy.mean : equivalent function
*)

val min : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> ?initial:Py.Object.t -> ?where:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True)

Return the minimum along a given axis.

Refer to `numpy.amin` for full documentation.

See Also
--------
numpy.amin : equivalent function
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arr.newbyteorder(new_order='S')

Return the array with the same data viewed with a different byte order.

Equivalent to::

    arr.view(arr.dtype.newbytorder(new_order))

Changes are also made in all fields and sub-arrays of the array data
type.



Parameters
----------
new_order : string, optional
    Byte order to force; a value from the byte order specifications
    below. `new_order` codes can be any of:

    * 'S' - swap dtype from current to opposite endian
    * {'<', 'L'} - little endian
    * {'>', 'B'} - big endian
    * {'=', 'N'} - native order
    * {'|', 'I'} - ignore (no change to byte order)

    The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_arr : array
    New array object with the dtype reflecting given change to the
    byte order.
*)

val nonzero : [> tag] Obj.t -> Py.Object.t
(**
a.nonzero()

Return the indices of the elements that are non-zero.

Refer to `numpy.nonzero` for full documentation.

See Also
--------
numpy.nonzero : equivalent function
*)

val partition : ?axis:int -> ?kind:[`Introselect] -> ?order:[`StringList of string list | `S of string] -> kth:[`Is of int list | `I of int] -> [> tag] Obj.t -> Py.Object.t
(**
a.partition(kth, axis=-1, kind='introselect', order=None)

Rearranges the elements in the array in such a way that the value of the
element in kth position is in the position it would be in a sorted array.
All elements smaller than the kth element are moved before this element and
all equal or greater are moved behind it. The ordering of the elements in
the two partitions is undefined.

.. versionadded:: 1.8.0

Parameters
----------
kth : int or sequence of ints
    Element index to partition by. The kth element value will be in its
    final sorted position and all smaller elements will be moved before it
    and all equal or greater elements behind it.
    The order of all elements in the partitions is undefined.
    If provided with a sequence of kth it will partition all elements
    indexed by kth of them into their sorted position at once.
axis : int, optional
    Axis along which to sort. Default is -1, which means sort along the
    last axis.
kind : {'introselect'}, optional
    Selection algorithm. Default is 'introselect'.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc. A single field can
    be specified as a string, and not all fields need to be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

See Also
--------
numpy.partition : Return a parititioned copy of an array.
argpartition : Indirect partition.
sort : Full sort.

Notes
-----
See ``np.partition`` for notes on the different algorithms.

Examples
--------
>>> a = np.array([3, 4, 2, 1])
>>> a.partition(3)
>>> a
array([2, 1, 3, 4])

>>> a.partition((1, 3))
>>> a
array([1, 2, 3, 4])
*)

val prod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> ?initial:Py.Object.t -> ?where:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True)

Return the product of the array elements over the given axis

Refer to `numpy.prod` for full documentation.

See Also
--------
numpy.prod : equivalent function
*)

val ptp : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.ptp(axis=None, out=None, keepdims=False)

Peak to peak (maximum - minimum) value along a given axis.

Refer to `numpy.ptp` for full documentation.

See Also
--------
numpy.ptp : equivalent function
*)

val put : ?mode:Py.Object.t -> indices:Py.Object.t -> values:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.put(indices, values, mode='raise')

Set ``a.flat[n] = values[n]`` for all `n` in indices.

Refer to `numpy.put` for full documentation.

See Also
--------
numpy.put : equivalent function
*)

val ravel : ?order:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.ravel([order])

Return a flattened array.

Refer to `numpy.ravel` for full documentation.

See Also
--------
numpy.ravel : equivalent function

ndarray.flat : a flat iterator on the array.
*)

val repeat : ?axis:Py.Object.t -> repeats:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.repeat(repeats, axis=None)

Repeat elements of an array.

Refer to `numpy.repeat` for full documentation.

See Also
--------
numpy.repeat : equivalent function
*)

val reshape : ?order:Py.Object.t -> int list -> [> tag] Obj.t -> Py.Object.t
(**
a.reshape(shape, order='C')

Returns an array containing the same data with a new shape.

Refer to `numpy.reshape` for full documentation.

See Also
--------
numpy.reshape : equivalent function

Notes
-----
Unlike the free function `numpy.reshape`, this method on `ndarray` allows
the elements of the shape parameter to be passed in as separate arguments.
For example, ``a.reshape(10, 11)`` is equivalent to
``a.reshape((10, 11))``.
*)

val resize : ?refcheck:bool -> new_shape:[`T_n_ints of Py.Object.t | `TupleOfInts of int list] -> [> tag] Obj.t -> Py.Object.t
(**
a.resize(new_shape, refcheck=True)

Change shape and size of array in-place.

Parameters
----------
new_shape : tuple of ints, or `n` ints
    Shape of resized array.
refcheck : bool, optional
    If False, reference count will not be checked. Default is True.

Returns
-------
None

Raises
------
ValueError
    If `a` does not own its own data or references or views to it exist,
    and the data memory must be changed.
    PyPy only: will always raise if the data memory must be changed, since
    there is no reliable way to determine if references or views to it
    exist.

SystemError
    If the `order` keyword argument is specified. This behaviour is a
    bug in NumPy.

See Also
--------
resize : Return a new array with the specified shape.

Notes
-----
This reallocates space for the data area if necessary.

Only contiguous arrays (data elements consecutive in memory) can be
resized.

The purpose of the reference count check is to make sure you
do not use this array as a buffer for another Python object and then
reallocate the memory. However, reference counts can increase in
other ways so if you are sure that you have not shared the memory
for this array with another Python object, then you may safely set
`refcheck` to False.

Examples
--------
Shrinking an array: array is flattened (in the order that the data are
stored in memory), resized, and reshaped:

>>> a = np.array([[0, 1], [2, 3]], order='C')
>>> a.resize((2, 1))
>>> a
array([[0],
       [1]])

>>> a = np.array([[0, 1], [2, 3]], order='F')
>>> a.resize((2, 1))
>>> a
array([[0],
       [2]])

Enlarging an array: as above, but missing entries are filled with zeros:

>>> b = np.array([[0, 1], [2, 3]])
>>> b.resize(2, 3) # new_shape parameter doesn't have to be a tuple
>>> b
array([[0, 1, 2],
       [3, 0, 0]])

Referencing an array prevents resizing...

>>> c = a
>>> a.resize((1, 1))
Traceback (most recent call last):
...
ValueError: cannot resize an array that references or is referenced ...

Unless `refcheck` is False:

>>> a.resize((1, 1), refcheck=False)
>>> a
array([[0]])
>>> c
array([[0]])
*)

val round : ?decimals:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.round(decimals=0, out=None)

Return `a` with each element rounded to the given number of decimals.

Refer to `numpy.around` for full documentation.

See Also
--------
numpy.around : equivalent function
*)

val searchsorted : ?side:Py.Object.t -> ?sorter:Py.Object.t -> v:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.searchsorted(v, side='left', sorter=None)

Find indices where elements of v should be inserted in a to maintain order.

For full documentation, see `numpy.searchsorted`

See Also
--------
numpy.searchsorted : equivalent function
*)

val setfield : ?offset:int -> val_:Py.Object.t -> dtype:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.setfield(val, dtype, offset=0)

Put a value into a specified place in a field defined by a data-type.

Place `val` into `a`'s field defined by `dtype` and beginning `offset`
bytes into the field.

Parameters
----------
val : object
    Value to be placed in field.
dtype : dtype object
    Data-type of the field in which to place `val`.
offset : int, optional
    The number of bytes into the field at which to place `val`.

Returns
-------
None

See Also
--------
getfield

Examples
--------
>>> x = np.eye(3)
>>> x.getfield(np.float64)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
>>> x.setfield(3, np.int32)
>>> x.getfield(np.int32)
array([[3, 3, 3],
       [3, 3, 3],
       [3, 3, 3]], dtype=int32)
>>> x
array([[1.0e+000, 1.5e-323, 1.5e-323],
       [1.5e-323, 1.0e+000, 1.5e-323],
       [1.5e-323, 1.5e-323, 1.0e+000]])
>>> x.setfield(np.eye(3), np.int32)
>>> x
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
*)

val setflags : ?write:bool -> ?align:bool -> ?uic:bool -> [> tag] Obj.t -> Py.Object.t
(**
a.setflags(write=None, align=None, uic=None)

Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
respectively.

These Boolean-valued flags affect how numpy interprets the memory
area used by `a` (see Notes below). The ALIGNED flag can only
be set to True if the data is actually aligned according to the type.
The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
to True. The flag WRITEABLE can only be set to True if the array owns its
own memory, or the ultimate owner of the memory exposes a writeable buffer
interface, or is a string. (The exception for string is made so that
unpickling can be done without copying memory.)

Parameters
----------
write : bool, optional
    Describes whether or not `a` can be written to.
align : bool, optional
    Describes whether or not `a` is aligned properly for its type.
uic : bool, optional
    Describes whether or not `a` is a copy of another 'base' array.

Notes
-----
Array flags provide information about how the memory area used
for the array is to be interpreted. There are 7 Boolean flags
in use, only four of which can be changed by the user:
WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.

WRITEABLE (W) the data area can be written to;

ALIGNED (A) the data and strides are aligned appropriately for the hardware
(as determined by the compiler);

UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;

WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
called, the base array will be updated with the contents of this array.

All flags can be accessed using the single (upper case) letter as well
as the full name.

Examples
--------
>>> y = np.array([[3, 1, 7],
...               [2, 0, 0],
...               [8, 5, 9]])
>>> y
array([[3, 1, 7],
       [2, 0, 0],
       [8, 5, 9]])
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(write=0, align=0)
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : False
  ALIGNED : False
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(uic=1)
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: cannot set WRITEBACKIFCOPY flag to True
*)

val sort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[`StringList of string list | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.sort(axis=-1, kind=None, order=None)

Sort an array in-place. Refer to `numpy.sort` for full documentation.

Parameters
----------
axis : int, optional
    Axis along which to sort. Default is -1, which means sort along the
    last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
    and 'mergesort' use timsort under the covers and, in general, the
    actual implementation will vary with datatype. The 'mergesort' option
    is retained for backwards compatibility.

    .. versionchanged:: 1.15.0.
       The 'stable' option was added.

order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  A single field can
    be specified as a string, and not all fields need be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

See Also
--------
numpy.sort : Return a sorted copy of an array.
numpy.argsort : Indirect sort.
numpy.lexsort : Indirect stable sort on multiple keys.
numpy.searchsorted : Find elements in sorted array.
numpy.partition: Partial sort.

Notes
-----
See `numpy.sort` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.array([[1,4], [3,1]])
>>> a.sort(axis=1)
>>> a
array([[1, 4],
       [1, 3]])
>>> a.sort(axis=0)
>>> a
array([[1, 3],
       [1, 4]])

Use the `order` keyword to specify a field to use when sorting a
structured array:

>>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])
>>> a.sort(order='y')
>>> a
array([(b'c', 1), (b'a', 2)],
      dtype=[('x', 'S1'), ('y', '<i8')])
*)

val squeeze : ?axis:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.squeeze(axis=None)

Remove single-dimensional entries from the shape of `a`.

Refer to `numpy.squeeze` for full documentation.

See Also
--------
numpy.squeeze : equivalent function
*)

val std : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?ddof:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)

Returns the standard deviation of the array elements along given axis.

Refer to `numpy.std` for full documentation.

See Also
--------
numpy.std : equivalent function
*)

val sum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> ?initial:Py.Object.t -> ?where:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)

Return the sum of the array elements over the given axis.

Refer to `numpy.sum` for full documentation.

See Also
--------
numpy.sum : equivalent function
*)

val swapaxes : axis1:Py.Object.t -> axis2:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.swapaxes(axis1, axis2)

Return a view of the array with `axis1` and `axis2` interchanged.

Refer to `numpy.swapaxes` for full documentation.

See Also
--------
numpy.swapaxes : equivalent function
*)

val take : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?mode:Py.Object.t -> indices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.take(indices, axis=None, out=None, mode='raise')

Return an array formed from the elements of `a` at the given indices.

Refer to `numpy.take` for full documentation.

See Also
--------
numpy.take : equivalent function
*)

val tobytes : ?order:[`C | `F | `None] -> [> tag] Obj.t -> Py.Object.t
(**
a.tobytes(order='C')

Construct Python bytes containing the raw data bytes in the array.

Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either 'C' or 'Fortran',
or 'Any' order (the default is 'C'-order). 'Any' order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means 'Fortran' order.

.. versionadded:: 1.9.0

Parameters
----------
order : {'C', 'F', None}, optional
    Order of the data for multidimensional arrays:
    C, Fortran, or the same as for the original array.

Returns
-------
s : bytes
    Python bytes exhibiting a copy of `a`'s raw data.

Examples
--------
>>> x = np.array([[0, 1], [2, 3]], dtype='<u2')
>>> x.tobytes()
b'\x00\x00\x01\x00\x02\x00\x03\x00'
>>> x.tobytes('C') == x.tobytes()
True
>>> x.tobytes('F')
b'\x00\x00\x02\x00\x01\x00\x03\x00'
*)

val tofile : ?sep:string -> ?format:string -> fid:[`S of string | `PyObject of Py.Object.t] -> [> tag] Obj.t -> Py.Object.t
(**
a.tofile(fid, sep='', format='%s')

Write array to a file as text or binary (default).

Data is always written in 'C' order, independent of the order of `a`.
The data produced by this method can be recovered using the function
fromfile().

Parameters
----------
fid : file or str or Path
    An open file object, or a string containing a filename.

    .. versionchanged:: 1.17.0
        `pathlib.Path` objects are now accepted.

sep : str
    Separator between array items for text output.
    If '' (empty), a binary file is written, equivalent to
    ``file.write(a.tobytes())``.
format : str
    Format string for text file output.
    Each entry in the array is formatted to text by first converting
    it to the closest Python type, and then using 'format' % item.

Notes
-----
This is a convenience function for quick storage of array data.
Information on endianness and precision is lost, so this method is not a
good choice for files intended to archive data or transport data between
machines with different endianness. Some of these problems can be overcome
by outputting the data as text files, at the expense of speed and file
size.

When fid is a file object, array contents are directly written to the
file, bypassing the file object's ``write`` method. As a result, tofile
cannot be used with files objects supporting compression (e.g., GzipFile)
or file-like objects that do not support ``fileno()`` (e.g., BytesIO).
*)

val tolist : [> tag] Obj.t -> Py.Object.t
(**
a.tolist()

Return the array as an ``a.ndim``-levels deep nested list of Python scalars.

Return a copy of the array data as a (nested) Python list.
Data items are converted to the nearest compatible builtin Python type, via
the `~numpy.ndarray.item` function.

If ``a.ndim`` is 0, then since the depth of the nested list is 0, it will
not be a list at all, but a simple Python scalar.

Parameters
----------
none

Returns
-------
y : object, or list of object, or list of list of object, or ...
    The possibly nested list of array elements.

Notes
-----
The array may be recreated via ``a = np.array(a.tolist())``, although this
may sometimes lose precision.

Examples
--------
For a 1D array, ``a.tolist()`` is almost the same as ``list(a)``, 
except that ``tolist`` changes numpy scalars to Python scalars:

>>> a = np.uint32([1, 2])
>>> a_list = list(a)
>>> a_list
[1, 2]
>>> type(a_list[0])
<class 'numpy.uint32'>
>>> a_tolist = a.tolist()
>>> a_tolist
[1, 2]
>>> type(a_tolist[0])
<class 'int'>

Additionally, for a 2D array, ``tolist`` applies recursively:

>>> a = np.array([[1, 2], [3, 4]])
>>> list(a)
[array([1, 2]), array([3, 4])]
>>> a.tolist()
[[1, 2], [3, 4]]

The base case for this recursion is a 0D array:

>>> a = np.array(1)
>>> list(a)
Traceback (most recent call last):
  ...
TypeError: iteration over a 0-d array
>>> a.tolist()
1
*)

val tostring : ?order:[`C | `F | `None] -> [> tag] Obj.t -> Py.Object.t
(**
a.tostring(order='C')

Construct Python bytes containing the raw data bytes in the array.

Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either 'C' or 'Fortran',
or 'Any' order (the default is 'C'-order). 'Any' order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means 'Fortran' order.

This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.

Parameters
----------
order : {'C', 'F', None}, optional
    Order of the data for multidimensional arrays:
    C, Fortran, or the same as for the original array.

Returns
-------
s : bytes
    Python bytes exhibiting a copy of `a`'s raw data.

Examples
--------
>>> x = np.array([[0, 1], [2, 3]], dtype='<u2')
>>> x.tobytes()
b'\x00\x00\x01\x00\x02\x00\x03\x00'
>>> x.tobytes('C') == x.tobytes()
True
>>> x.tobytes('F')
b'\x00\x00\x02\x00\x01\x00\x03\x00'
*)

val trace : ?offset:Py.Object.t -> ?axis1:Py.Object.t -> ?axis2:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)

Return the sum along diagonals of the array.

Refer to `numpy.trace` for full documentation.

See Also
--------
numpy.trace : equivalent function
*)

val transpose : Py.Object.t list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.transpose( *axes)

Returns a view of the array with axes transposed.

For a 1-D array this has no effect, as a transposed vector is simply the
same vector. To convert a 1-D array into a 2D column vector, an additional
dimension must be added. `np.atleast2d(a).T` achieves this, as does
`a[:, np.newaxis]`.
For a 2-D array, this is a standard matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
``a.shape = (i[0], i[1], ... i[n-2], i[n-1])``, then
``a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.

Parameters
----------
axes : None, tuple of ints, or `n` ints

 * None or no argument: reverses the order of the axes.

 * tuple of ints: `i` in the `j`-th place in the tuple means `a`'s
   `i`-th axis becomes `a.transpose()`'s `j`-th axis.

 * `n` ints: same as an n-tuple of the same ints (this form is
   intended simply as a 'convenience' alternative to the tuple form)

Returns
-------
out : ndarray
    View of `a`, with axes suitably permuted.

See Also
--------
ndarray.T : Array property returning the array transposed.
ndarray.reshape : Give a new shape to an array without changing its data.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> a
array([[1, 2],
       [3, 4]])
>>> a.transpose()
array([[1, 3],
       [2, 4]])
>>> a.transpose((1, 0))
array([[1, 3],
       [2, 4]])
>>> a.transpose(1, 0)
array([[1, 3],
       [2, 4]])
*)

val var : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?ddof:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)

Returns the variance of the array elements, along given axis.

Refer to `numpy.var` for full documentation.

See Also
--------
numpy.var : equivalent function
*)

val view : ?dtype:[`Dtype of Dtype.t | `Ndarray_sub_class of Py.Object.t] -> ?type_:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.view(dtype=None, type=None)

New view of array with the same data.

Parameters
----------
dtype : data-type or ndarray sub-class, optional
    Data-type descriptor of the returned view, e.g., float32 or int16. The
    default, None, results in the view having the same data-type as `a`.
    This argument can also be specified as an ndarray sub-class, which
    then specifies the type of the returned object (this is equivalent to
    setting the ``type`` parameter).
type : Python type, optional
    Type of the returned view, e.g., ndarray or matrix.  Again, the
    default None results in type preservation.

Notes
-----
``a.view()`` is used two different ways:

``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
of the array's memory with a different data-type.  This can cause a
reinterpretation of the bytes of memory.

``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
returns an instance of `ndarray_subclass` that looks at the same array
(same shape, dtype, etc.)  This does not cause a reinterpretation of the
memory.

For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of
bytes per entry than the previous dtype (for example, converting a
regular array to a structured array), then the behavior of the view
cannot be predicted just from the superficial appearance of ``a`` (shown
by ``print(a)``). It also depends on exactly how ``a`` is stored in
memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus
defined as a slice or transpose, etc., the view may give different
results.


Examples
--------
>>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])

Viewing array data using a different type and dtype:

>>> y = x.view(dtype=np.int16, type=np.matrix)
>>> y
matrix([[513]], dtype=int16)
>>> print(type(y))
<class 'numpy.matrix'>

Creating a view on a structured array so it can be used in calculations

>>> x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])
>>> xv = x.view(dtype=np.int8).reshape(-1,2)
>>> xv
array([[1, 2],
       [3, 4]], dtype=int8)
>>> xv.mean(0)
array([2.,  3.])

Making changes to the view changes the underlying array

>>> xv[0,1] = 20
>>> x
array([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])

Using a view to convert an array to a recarray:

>>> z = x.view(np.recarray)
>>> z.a
array([1, 3], dtype=int8)

Views share data:

>>> x[0] = (9, 10)
>>> z[0]
(9, 10)

Views that change the dtype size (bytes per entry) should normally be
avoided on arrays defined by slices, transposes, fortran-ordering, etc.:

>>> x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)
>>> y = x[:, 0:2]
>>> y
array([[1, 2],
       [4, 5]], dtype=int16)
>>> y.view(dtype=[('width', np.int16), ('length', np.int16)])
Traceback (most recent call last):
    ...
ValueError: To change to a dtype of a different size, the array must be C-contiguous
>>> z = y.copy()
>>> z.view(dtype=[('width', np.int16), ('length', np.int16)])
array([[(1, 2)],
       [(4, 5)]], dtype=[('width', '<i2'), ('length', '<i2')])
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Record : sig
type tag = [`Record]
type t = [`Object | `Record] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : indx:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val __setitem__ : key:Py.Object.t -> value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Set self[key] to value.
*)

val pprint : [> tag] Obj.t -> Py.Object.t
(**
Pretty-print all fields.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Short : sig
type tag = [`Int16]
type t = [`Int16 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Signedinteger : sig
type tag = [`Signedinteger]
type t = [`Object | `Signedinteger] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Abstract base class of all signed integer scalar types.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Single : sig
type tag = [`Float32]
type t = [`Float32 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Str : sig
type tag = [`Str]
type t = [`Object | `Str] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?object_:Py.Object.t -> unit -> t
(**
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Implement iter(self).
*)

val capitalize : [> tag] Obj.t -> Py.Object.t
(**
Return a capitalized version of the string.

More specifically, make the first character have upper case and the rest lower
case.
*)

val casefold : [> tag] Obj.t -> Py.Object.t
(**
Return a version of the string suitable for caseless comparisons.
*)

val center : ?fillchar:Py.Object.t -> width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a centered string of length width.

Padding is done using the specified fill character (default is a space).
*)

val count : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.count(sub[, start[, end]]) -> int

Return the number of non-overlapping occurrences of substring sub in
string S[start:end].  Optional arguments start and end are
interpreted as in slice notation.
*)

val encode : ?encoding:Py.Object.t -> ?errors:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Encode the string using the codec registered for encoding.

encoding
  The encoding in which to encode the string.
errors
  The error handling scheme to use for encoding errors.
  The default is 'strict' meaning that encoding errors raise a
  UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
  'xmlcharrefreplace' as well as any other name registered with
  codecs.register_error that can handle UnicodeEncodeErrors.
*)

val endswith : ?start:Py.Object.t -> ?end_:Py.Object.t -> suffix:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.endswith(suffix[, start[, end]]) -> bool

Return True if S ends with the specified suffix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
suffix can also be a tuple of strings to try.
*)

val expandtabs : ?tabsize:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy where all tab characters are expanded using spaces.

If tabsize is not given, a tab size of 8 characters is assumed.
*)

val find : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.find(sub[, start[, end]]) -> int

Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.
*)

val format : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
S.format( *args, **kwargs) -> str

Return a formatted version of S, using substitutions from args and kwargs.
The substitutions are identified by braces ('{' and '}').
*)

val format_map : mapping:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.format_map(mapping) -> str

Return a formatted version of S, using substitutions from mapping.
The substitutions are identified by braces ('{' and '}').
*)

val index : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.index(sub[, start[, end]]) -> int

Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Raises ValueError when the substring is not found.
*)

val isalnum : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is an alpha-numeric string, False otherwise.

A string is alpha-numeric if all characters in the string are alpha-numeric and
there is at least one character in the string.
*)

val isalpha : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is an alphabetic string, False otherwise.

A string is alphabetic if all characters in the string are alphabetic and there
is at least one character in the string.
*)

val isascii : [> tag] Obj.t -> Py.Object.t
(**
Return True if all characters in the string are ASCII, False otherwise.

ASCII characters have code points in the range U+0000-U+007F.
Empty string is ASCII too.
*)

val isdecimal : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a decimal string, False otherwise.

A string is a decimal string if all characters in the string are decimal and
there is at least one character in the string.
*)

val isdigit : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a digit string, False otherwise.

A string is a digit string if all characters in the string are digits and there
is at least one character in the string.
*)

val isidentifier : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a valid Python identifier, False otherwise.

Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
such as 'def' or 'class'.
*)

val islower : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a lowercase string, False otherwise.

A string is lowercase if all cased characters in the string are lowercase and
there is at least one cased character in the string.
*)

val isnumeric : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a numeric string, False otherwise.

A string is numeric if all characters in the string are numeric and there is at
least one character in the string.
*)

val isprintable : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is printable, False otherwise.

A string is printable if all of its characters are considered printable in
repr() or if it is empty.
*)

val isspace : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a whitespace string, False otherwise.

A string is whitespace if all characters in the string are whitespace and there
is at least one character in the string.
*)

val istitle : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a title-cased string, False otherwise.

In a title-cased string, upper- and title-case characters may only
follow uncased characters and lowercase characters only cased ones.
*)

val isupper : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is an uppercase string, False otherwise.

A string is uppercase if all cased characters in the string are uppercase and
there is at least one cased character in the string.
*)

val join : iterable:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Concatenate any number of strings.

The string whose method is called is inserted in between each given string.
The result is returned as a new string.

Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
*)

val ljust : ?fillchar:Py.Object.t -> width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a left-justified string of length width.

Padding is done using the specified fill character (default is a space).
*)

val lower : [> tag] Obj.t -> Py.Object.t
(**
Return a copy of the string converted to lowercase.
*)

val lstrip : ?chars:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy of the string with leading whitespace removed.

If chars is given and not None, remove characters in chars instead.
*)

val partition : sep:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Partition the string into three parts using the given separator.

This will search for the separator in the string.  If the separator is found,
returns a 3-tuple containing the part before the separator, the separator
itself, and the part after it.

If the separator is not found, returns a 3-tuple containing the original string
and two empty strings.
*)

val replace : ?count:Py.Object.t -> old:Py.Object.t -> new_:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy with all occurrences of substring old replaced by new.

  count
    Maximum number of occurrences to replace.
    -1 (the default value) means replace all occurrences.

If the optional argument count is given, only the first count occurrences are
replaced.
*)

val rfind : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.rfind(sub[, start[, end]]) -> int

Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.
*)

val rindex : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.rindex(sub[, start[, end]]) -> int

Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Raises ValueError when the substring is not found.
*)

val rjust : ?fillchar:Py.Object.t -> width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a right-justified string of length width.

Padding is done using the specified fill character (default is a space).
*)

val rpartition : sep:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Partition the string into three parts using the given separator.

This will search for the separator in the string, starting at the end. If
the separator is found, returns a 3-tuple containing the part before the
separator, the separator itself, and the part after it.

If the separator is not found, returns a 3-tuple containing two empty strings
and the original string.
*)

val rsplit : ?sep:Py.Object.t -> ?maxsplit:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a list of the words in the string, using sep as the delimiter string.

  sep
    The delimiter according which to split the string.
    None (the default value) means split according to any whitespace,
    and discard empty strings from the result.
  maxsplit
    Maximum number of splits to do.
    -1 (the default value) means no limit.

Splits are done starting at the end of the string and working to the front.
*)

val rstrip : ?chars:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy of the string with trailing whitespace removed.

If chars is given and not None, remove characters in chars instead.
*)

val split : ?sep:Py.Object.t -> ?maxsplit:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a list of the words in the string, using sep as the delimiter string.

sep
  The delimiter according which to split the string.
  None (the default value) means split according to any whitespace,
  and discard empty strings from the result.
maxsplit
  Maximum number of splits to do.
  -1 (the default value) means no limit.
*)

val splitlines : ?keepends:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a list of the lines in the string, breaking at line boundaries.

Line breaks are not included in the resulting list unless keepends is given and
true.
*)

val startswith : ?start:Py.Object.t -> ?end_:Py.Object.t -> prefix:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.startswith(prefix[, start[, end]]) -> bool

Return True if S starts with the specified prefix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
prefix can also be a tuple of strings to try.
*)

val strip : ?chars:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy of the string with leading and trailing whitespace removed.

If chars is given and not None, remove characters in chars instead.
*)

val swapcase : [> tag] Obj.t -> Py.Object.t
(**
Convert uppercase characters to lowercase and lowercase characters to uppercase.
*)

val title : [> tag] Obj.t -> Py.Object.t
(**
Return a version of the string where each word is titlecased.

More specifically, words start with uppercased characters and all remaining
cased characters have lower case.
*)

val translate : table:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Replace each character in the string using the given translation table.

  table
    Translation table, which must be a mapping of Unicode ordinals to
    Unicode ordinals, strings, or None.

The table must implement lookup/indexing via __getitem__, for instance a
dictionary or list.  If this operation raises LookupError, the character is
left untouched.  Characters mapped to None are deleted.
*)

val upper : [> tag] Obj.t -> Py.Object.t
(**
Return a copy of the string converted to uppercase.
*)

val zfill : width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Pad a numeric string with zeros on the left, to fill a field of the given width.

The string is never truncated.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Str0 : sig
type tag = [`Str_]
type t = [`Object | `Str_] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?object_:Py.Object.t -> unit -> t
(**
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Implement iter(self).
*)

val capitalize : [> tag] Obj.t -> Py.Object.t
(**
Return a capitalized version of the string.

More specifically, make the first character have upper case and the rest lower
case.
*)

val casefold : [> tag] Obj.t -> Py.Object.t
(**
Return a version of the string suitable for caseless comparisons.
*)

val center : ?fillchar:Py.Object.t -> width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a centered string of length width.

Padding is done using the specified fill character (default is a space).
*)

val count : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.count(sub[, start[, end]]) -> int

Return the number of non-overlapping occurrences of substring sub in
string S[start:end].  Optional arguments start and end are
interpreted as in slice notation.
*)

val encode : ?encoding:Py.Object.t -> ?errors:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Encode the string using the codec registered for encoding.

encoding
  The encoding in which to encode the string.
errors
  The error handling scheme to use for encoding errors.
  The default is 'strict' meaning that encoding errors raise a
  UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
  'xmlcharrefreplace' as well as any other name registered with
  codecs.register_error that can handle UnicodeEncodeErrors.
*)

val endswith : ?start:Py.Object.t -> ?end_:Py.Object.t -> suffix:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.endswith(suffix[, start[, end]]) -> bool

Return True if S ends with the specified suffix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
suffix can also be a tuple of strings to try.
*)

val expandtabs : ?tabsize:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy where all tab characters are expanded using spaces.

If tabsize is not given, a tab size of 8 characters is assumed.
*)

val find : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.find(sub[, start[, end]]) -> int

Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.
*)

val format : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
S.format( *args, **kwargs) -> str

Return a formatted version of S, using substitutions from args and kwargs.
The substitutions are identified by braces ('{' and '}').
*)

val format_map : mapping:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.format_map(mapping) -> str

Return a formatted version of S, using substitutions from mapping.
The substitutions are identified by braces ('{' and '}').
*)

val index : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.index(sub[, start[, end]]) -> int

Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Raises ValueError when the substring is not found.
*)

val isalnum : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is an alpha-numeric string, False otherwise.

A string is alpha-numeric if all characters in the string are alpha-numeric and
there is at least one character in the string.
*)

val isalpha : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is an alphabetic string, False otherwise.

A string is alphabetic if all characters in the string are alphabetic and there
is at least one character in the string.
*)

val isascii : [> tag] Obj.t -> Py.Object.t
(**
Return True if all characters in the string are ASCII, False otherwise.

ASCII characters have code points in the range U+0000-U+007F.
Empty string is ASCII too.
*)

val isdecimal : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a decimal string, False otherwise.

A string is a decimal string if all characters in the string are decimal and
there is at least one character in the string.
*)

val isdigit : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a digit string, False otherwise.

A string is a digit string if all characters in the string are digits and there
is at least one character in the string.
*)

val isidentifier : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a valid Python identifier, False otherwise.

Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
such as 'def' or 'class'.
*)

val islower : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a lowercase string, False otherwise.

A string is lowercase if all cased characters in the string are lowercase and
there is at least one cased character in the string.
*)

val isnumeric : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a numeric string, False otherwise.

A string is numeric if all characters in the string are numeric and there is at
least one character in the string.
*)

val isprintable : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is printable, False otherwise.

A string is printable if all of its characters are considered printable in
repr() or if it is empty.
*)

val isspace : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a whitespace string, False otherwise.

A string is whitespace if all characters in the string are whitespace and there
is at least one character in the string.
*)

val istitle : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is a title-cased string, False otherwise.

In a title-cased string, upper- and title-case characters may only
follow uncased characters and lowercase characters only cased ones.
*)

val isupper : [> tag] Obj.t -> Py.Object.t
(**
Return True if the string is an uppercase string, False otherwise.

A string is uppercase if all cased characters in the string are uppercase and
there is at least one cased character in the string.
*)

val join : iterable:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Concatenate any number of strings.

The string whose method is called is inserted in between each given string.
The result is returned as a new string.

Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
*)

val ljust : ?fillchar:Py.Object.t -> width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a left-justified string of length width.

Padding is done using the specified fill character (default is a space).
*)

val lower : [> tag] Obj.t -> Py.Object.t
(**
Return a copy of the string converted to lowercase.
*)

val lstrip : ?chars:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy of the string with leading whitespace removed.

If chars is given and not None, remove characters in chars instead.
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)

val partition : sep:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Partition the string into three parts using the given separator.

This will search for the separator in the string.  If the separator is found,
returns a 3-tuple containing the part before the separator, the separator
itself, and the part after it.

If the separator is not found, returns a 3-tuple containing the original string
and two empty strings.
*)

val replace : ?count:Py.Object.t -> old:Py.Object.t -> new_:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy with all occurrences of substring old replaced by new.

  count
    Maximum number of occurrences to replace.
    -1 (the default value) means replace all occurrences.

If the optional argument count is given, only the first count occurrences are
replaced.
*)

val rfind : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.rfind(sub[, start[, end]]) -> int

Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.
*)

val rindex : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.rindex(sub[, start[, end]]) -> int

Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Raises ValueError when the substring is not found.
*)

val rjust : ?fillchar:Py.Object.t -> width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a right-justified string of length width.

Padding is done using the specified fill character (default is a space).
*)

val rpartition : sep:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Partition the string into three parts using the given separator.

This will search for the separator in the string, starting at the end. If
the separator is found, returns a 3-tuple containing the part before the
separator, the separator itself, and the part after it.

If the separator is not found, returns a 3-tuple containing two empty strings
and the original string.
*)

val rsplit : ?sep:Py.Object.t -> ?maxsplit:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a list of the words in the string, using sep as the delimiter string.

  sep
    The delimiter according which to split the string.
    None (the default value) means split according to any whitespace,
    and discard empty strings from the result.
  maxsplit
    Maximum number of splits to do.
    -1 (the default value) means no limit.

Splits are done starting at the end of the string and working to the front.
*)

val rstrip : ?chars:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy of the string with trailing whitespace removed.

If chars is given and not None, remove characters in chars instead.
*)

val split : ?sep:Py.Object.t -> ?maxsplit:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a list of the words in the string, using sep as the delimiter string.

sep
  The delimiter according which to split the string.
  None (the default value) means split according to any whitespace,
  and discard empty strings from the result.
maxsplit
  Maximum number of splits to do.
  -1 (the default value) means no limit.
*)

val splitlines : ?keepends:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a list of the lines in the string, breaking at line boundaries.

Line breaks are not included in the resulting list unless keepends is given and
true.
*)

val startswith : ?start:Py.Object.t -> ?end_:Py.Object.t -> prefix:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
S.startswith(prefix[, start[, end]]) -> bool

Return True if S starts with the specified prefix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
prefix can also be a tuple of strings to try.
*)

val strip : ?chars:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy of the string with leading and trailing whitespace removed.

If chars is given and not None, remove characters in chars instead.
*)

val swapcase : [> tag] Obj.t -> Py.Object.t
(**
Convert uppercase characters to lowercase and lowercase characters to uppercase.
*)

val title : [> tag] Obj.t -> Py.Object.t
(**
Return a version of the string where each word is titlecased.

More specifically, words start with uppercased characters and all remaining
cased characters have lower case.
*)

val translate : table:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Replace each character in the string using the given translation table.

  table
    Translation table, which must be a mapping of Unicode ordinals to
    Unicode ordinals, strings, or None.

The table must implement lookup/indexing via __getitem__, for instance a
dictionary or list.  If this operation raises LookupError, the character is
left untouched.  Characters mapped to None are deleted.
*)

val upper : [> tag] Obj.t -> Py.Object.t
(**
Return a copy of the string converted to uppercase.
*)

val zfill : width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Pad a numeric string with zeros on the left, to fill a field of the given width.

The string is never truncated.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Timedelta64 : sig
type tag = [`Timedelta64]
type t = [`Object | `Timedelta64] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Ubyte : sig
type tag = [`Uint8]
type t = [`Object | `Uint8] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Ufunc : sig
type tag = [`Ufunc]
type t = [`Object | `Ufunc] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Functions that operate element by element on whole arrays.

To see the documentation for a specific ufunc, use `info`.  For
example, ``np.info(np.sin)``.  Because ufuncs are written in C
(for speed) and linked into Python with NumPy's ufunc facility,
Python's help() function finds this page whenever help() is called
on a ufunc.

A detailed explanation of ufuncs can be found in the docs for :ref:`ufuncs`.

Calling ufuncs:
===============

op( *x[, out], where=True, **kwargs)
Apply `op` to the arguments `*x` elementwise, broadcasting the arguments.

The broadcasting rules are:

* Dimensions of length 1 may be prepended to either array.
* Arrays may be repeated along dimensions of length 1.

Parameters
----------
*x : array_like
    Input arrays.
out : ndarray, None, or tuple of ndarray and None, optional
    Alternate array object(s) in which to put the result; if provided, it
    must have a shape that the inputs broadcast to. A tuple of arrays
    (possible only as a keyword argument) must have length equal to the
    number of outputs; use None for uninitialized outputs to be
    allocated by the ufunc.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
r : ndarray or tuple of ndarray
    `r` will have the shape that the arrays in `x` broadcast to; if `out` is
    provided, it will be returned. If not, `r` will be allocated and
    may contain uninitialized values. If the function has more than one
    output, then the result will be a tuple of arrays.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Uint : sig
type tag = [`Uint64]
type t = [`Object | `Uint64] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Uint16 : sig
type tag = [`Uint16]
type t = [`Object | `Uint16] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Uint32 : sig
type tag = [`Uint32]
type t = [`Object | `Uint32] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Uint8 : sig
type tag = [`Uint8]
type t = [`Object | `Uint8] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Uintc : sig
type tag = [`Uint32]
type t = [`Object | `Uint32] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Ulonglong : sig
type tag = [`Ulonglong]
type t = [`Object | `Ulonglong] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Unsignedinteger : sig
type tag = [`Unsignedinteger]
type t = [`Object | `Unsignedinteger] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Abstract base class of all unsigned integer scalar types.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Ushort : sig
type tag = [`Uint16]
type t = [`Object | `Uint16] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> Dtype.t
(**
newbyteorder(new_order='S')

Return a new `dtype` with a different byte order.

Changes are also made in all fields and sub-arrays of the data type.

The `new_order` code can be any from the following:

* 'S' - swap dtype from current to opposite endian
* {'<', 'L'} - little endian
* {'>', 'B'} - big endian
* {'=', 'N'} - native order
* {'|', 'I'} - ignore (no change to byte order)

Parameters
----------
new_order : str, optional
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_dtype : dtype
    New `dtype` object with the given change to the byte order.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Vectorize : sig
type tag = [`Vectorize]
type t = [`Object | `Vectorize] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?otypes:[`List_of_dtypes of Py.Object.t | `S of string] -> ?doc:string -> ?excluded:Py.Object.t -> ?cache:bool -> ?signature:string -> pyfunc:Py.Object.t -> unit -> t
(**
vectorize(pyfunc, otypes=None, doc=None, excluded=None, cache=False,
          signature=None)

Generalized function class.

Define a vectorized function which takes a nested sequence of objects or
numpy arrays as inputs and returns a single numpy array or a tuple of numpy
arrays. The vectorized function evaluates `pyfunc` over successive tuples
of the input arrays like the python map function, except it uses the
broadcasting rules of numpy.

The data type of the output of `vectorized` is determined by calling
the function with the first element of the input.  This can be avoided
by specifying the `otypes` argument.

Parameters
----------
pyfunc : callable
    A python function or method.
otypes : str or list of dtypes, optional
    The output data type. It must be specified as either a string of
    typecode characters or a list of data type specifiers. There should
    be one data type specifier for each output.
doc : str, optional
    The docstring for the function. If None, the docstring will be the
    ``pyfunc.__doc__``.
excluded : set, optional
    Set of strings or integers representing the positional or keyword
    arguments for which the function will not be vectorized.  These will be
    passed directly to `pyfunc` unmodified.

    .. versionadded:: 1.7.0

cache : bool, optional
   If `True`, then cache the first function call that determines the number
   of outputs if `otypes` is not provided.

    .. versionadded:: 1.7.0

signature : string, optional
    Generalized universal function signature, e.g., ``(m,n),(n)->(m)`` for
    vectorized matrix-vector multiplication. If provided, ``pyfunc`` will
    be called with (and expected to return) arrays with shapes given by the
    size of corresponding core dimensions. By default, ``pyfunc`` is
    assumed to take scalars as input and output.

    .. versionadded:: 1.12.0

Returns
-------
vectorized : callable
    Vectorized function.

See Also
--------
frompyfunc : Takes an arbitrary Python function and returns a ufunc

Notes
-----
The `vectorize` function is provided primarily for convenience, not for
performance. The implementation is essentially a for loop.

If `otypes` is not specified, then a call to the function with the
first argument will be used to determine the number of outputs.  The
results of this call will be cached if `cache` is `True` to prevent
calling the function twice.  However, to implement the cache, the
original function must be wrapped which will slow down subsequent
calls, so only do this if your function is expensive.

The new keyword argument interface and `excluded` argument support
further degrades performance.

References
----------
.. [1] NumPy Reference, section `Generalized Universal Function API
       <https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html>`_.

Examples
--------
>>> def myfunc(a, b):
...     'Return a-b if a>b, otherwise return a+b'
...     if a > b:
...         return a - b
...     else:
...         return a + b

>>> vfunc = np.vectorize(myfunc)
>>> vfunc([1, 2, 3, 4], 2)
array([3, 4, 1, 2])

The docstring is taken from the input function to `vectorize` unless it
is specified:

>>> vfunc.__doc__
'Return a-b if a>b, otherwise return a+b'
>>> vfunc = np.vectorize(myfunc, doc='Vectorized `myfunc`')
>>> vfunc.__doc__
'Vectorized `myfunc`'

The output type is determined by evaluating the first element of the input,
unless it is specified:

>>> out = vfunc([1, 2, 3, 4], 2)
>>> type(out[0])
<class 'numpy.int64'>
>>> vfunc = np.vectorize(myfunc, otypes=[float])
>>> out = vfunc([1, 2, 3, 4], 2)
>>> type(out[0])
<class 'numpy.float64'>

The `excluded` argument can be used to prevent vectorizing over certain
arguments.  This can be useful for array-like arguments of a fixed length
such as the coefficients for a polynomial as in `polyval`:

>>> def mypolyval(p, x):
...     _p = list(p)
...     res = _p.pop(0)
...     while _p:
...         res = res*x + _p.pop(0)
...     return res
>>> vpolyval = np.vectorize(mypolyval, excluded=['p'])
>>> vpolyval(p=[1, 2, 3], x=[0, 1])
array([3, 6])

Positional arguments may also be excluded by specifying their position:

>>> vpolyval.excluded.add(0)
>>> vpolyval([1, 2, 3], x=[0, 1])
array([3, 6])

The `signature` argument allows for vectorizing functions that act on
non-scalar arrays of fixed length. For example, you can use it for a
vectorized calculation of Pearson correlation coefficient and its p-value:

>>> import scipy.stats
>>> pearsonr = np.vectorize(scipy.stats.pearsonr,
...                 signature='(n),(n)->(),()')
>>> pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]])
(array([ 1., -1.]), array([ 0.,  0.]))

Or for a vectorized convolution:

>>> convolve = np.vectorize(np.convolve, signature='(n),(m)->(k)')
>>> convolve(np.eye(4), [1, 2, 1])
array([[1., 2., 1., 0., 0., 0.],
       [0., 1., 2., 1., 0., 0.],
       [0., 0., 1., 2., 1., 0.],
       [0., 0., 0., 1., 2., 1.]])
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Void : sig
type tag = [`Void]
type t = [`Object | `Void] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val __setitem__ : key:Py.Object.t -> value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Set self[key] to value.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Dual : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

val cholesky : ?lower:bool -> ?overwrite_a:bool -> ?check_finite:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the Cholesky decomposition of a matrix.

Returns the Cholesky decomposition, :math:`A = L L^*` or
:math:`A = U^* U` of a Hermitian positive-definite matrix A.

Parameters
----------
a : (M, M) array_like
    Matrix to be decomposed
lower : bool, optional
    Whether to compute the upper or lower triangular Cholesky
    factorization.  Default is upper-triangular.
overwrite_a : bool, optional
    Whether to overwrite data in `a` (may improve performance).
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
c : (M, M) ndarray
    Upper- or lower-triangular Cholesky factor of `a`.

Raises
------
LinAlgError : if decomposition fails.

Examples
--------
>>> from scipy.linalg import cholesky
>>> a = np.array([[1,-2j],[2j,5]])
>>> L = cholesky(a, lower=True)
>>> L
array([[ 1.+0.j,  0.+0.j],
       [ 0.+2.j,  1.+0.j]])
>>> L @ L.T.conj()
array([[ 1.+0.j,  0.-2.j],
       [ 0.+2.j,  5.+0.j]])
*)

val det : ?overwrite_a:bool -> ?check_finite:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the determinant of a matrix

The determinant of a square matrix is a value derived arithmetically
from the coefficients of the matrix.

The determinant for a 3x3 matrix, for example, is computed as follows::

    a    b    c
    d    e    f = A
    g    h    i

    det(A) = a*e*i + b*f*g + c*d*h - c*e*g - b*d*i - a*f*h

Parameters
----------
a : (M, M) array_like
    A square matrix.
overwrite_a : bool, optional
    Allow overwriting data in a (may enhance performance).
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
det : float or complex
    Determinant of `a`.

Notes
-----
The determinant is computed via LU factorization, LAPACK routine z/dgetrf.

Examples
--------
>>> from scipy import linalg
>>> a = np.array([[1,2,3], [4,5,6], [7,8,9]])
>>> linalg.det(a)
0.0
>>> a = np.array([[0,2,3], [4,5,6], [7,8,9]])
>>> linalg.det(a)
3.0
*)

val eig : ?b:[>`Ndarray] Obj.t -> ?left:bool -> ?right:bool -> ?overwrite_a:bool -> ?overwrite_b:bool -> ?check_finite:bool -> ?homogeneous_eigvals:bool -> [>`Ndarray] Obj.t -> (Py.Object.t * Py.Object.t * Py.Object.t)
(**
Solve an ordinary or generalized eigenvalue problem of a square matrix.

Find eigenvalues w and right or left eigenvectors of a general matrix::

    a   vr[:,i] = w[i]        b   vr[:,i]
    a.H vl[:,i] = w[i].conj() b.H vl[:,i]

where ``.H`` is the Hermitian conjugation.

Parameters
----------
a : (M, M) array_like
    A complex or real matrix whose eigenvalues and eigenvectors
    will be computed.
b : (M, M) array_like, optional
    Right-hand side matrix in a generalized eigenvalue problem.
    Default is None, identity matrix is assumed.
left : bool, optional
    Whether to calculate and return left eigenvectors.  Default is False.
right : bool, optional
    Whether to calculate and return right eigenvectors.  Default is True.
overwrite_a : bool, optional
    Whether to overwrite `a`; may improve performance.  Default is False.
overwrite_b : bool, optional
    Whether to overwrite `b`; may improve performance.  Default is False.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
homogeneous_eigvals : bool, optional
    If True, return the eigenvalues in homogeneous coordinates.
    In this case ``w`` is a (2, M) array so that::

        w[1,i] a vr[:,i] = w[0,i] b vr[:,i]

    Default is False.

Returns
-------
w : (M,) or (2, M) double or complex ndarray
    The eigenvalues, each repeated according to its
    multiplicity. The shape is (M,) unless
    ``homogeneous_eigvals=True``.
vl : (M, M) double or complex ndarray
    The normalized left eigenvector corresponding to the eigenvalue
    ``w[i]`` is the column vl[:,i]. Only returned if ``left=True``.
vr : (M, M) double or complex ndarray
    The normalized right eigenvector corresponding to the eigenvalue
    ``w[i]`` is the column ``vr[:,i]``.  Only returned if ``right=True``.

Raises
------
LinAlgError
    If eigenvalue computation does not converge.

See Also
--------
eigvals : eigenvalues of general arrays
eigh : Eigenvalues and right eigenvectors for symmetric/Hermitian arrays.
eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian
    band matrices
eigh_tridiagonal : eigenvalues and right eiegenvectors for
    symmetric/Hermitian tridiagonal matrices

Examples
--------
>>> from scipy import linalg
>>> a = np.array([[0., -1.], [1., 0.]])
>>> linalg.eigvals(a)
array([0.+1.j, 0.-1.j])

>>> b = np.array([[0., 1.], [1., 1.]])
>>> linalg.eigvals(a, b)
array([ 1.+0.j, -1.+0.j])

>>> a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]])
>>> linalg.eigvals(a, homogeneous_eigvals=True)
array([[3.+0.j, 8.+0.j, 7.+0.j],
       [1.+0.j, 1.+0.j, 1.+0.j]])

>>> a = np.array([[0., -1.], [1., 0.]])
>>> linalg.eigvals(a) == linalg.eig(a)[0]
array([ True,  True])
>>> linalg.eig(a, left=True, right=False)[1] # normalized left eigenvector
array([[-0.70710678+0.j        , -0.70710678-0.j        ],
       [-0.        +0.70710678j, -0.        -0.70710678j]])
>>> linalg.eig(a, left=False, right=True)[1] # normalized right eigenvector
array([[0.70710678+0.j        , 0.70710678-0.j        ],
       [0.        -0.70710678j, 0.        +0.70710678j]])
*)

val eigh : ?b:[>`Ndarray] Obj.t -> ?lower:bool -> ?eigvals_only:bool -> ?overwrite_a:bool -> ?overwrite_b:bool -> ?turbo:bool -> ?eigvals:Py.Object.t -> ?type_:int -> ?check_finite:bool -> [>`Ndarray] Obj.t -> ([`ArrayLike|`Ndarray|`Object] Obj.t * Py.Object.t)
(**
Solve an ordinary or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.

Find eigenvalues w and optionally eigenvectors v of matrix `a`, where
`b` is positive definite::

                  a v[:,i] = w[i] b v[:,i]
    v[i,:].conj() a v[:,i] = w[i]
    v[i,:].conj() b v[:,i] = 1

Parameters
----------
a : (M, M) array_like
    A complex Hermitian or real symmetric matrix whose eigenvalues and
    eigenvectors will be computed.
b : (M, M) array_like, optional
    A complex Hermitian or real symmetric definite positive matrix in.
    If omitted, identity matrix is assumed.
lower : bool, optional
    Whether the pertinent array data is taken from the lower or upper
    triangle of `a`. (Default: lower)
eigvals_only : bool, optional
    Whether to calculate only eigenvalues and no eigenvectors.
    (Default: both are calculated)
turbo : bool, optional
    Use divide and conquer algorithm (faster but expensive in memory,
    only for generalized eigenvalue problem and if eigvals=None)
eigvals : tuple (lo, hi), optional
    Indexes of the smallest and largest (in ascending order) eigenvalues
    and corresponding eigenvectors to be returned: 0 <= lo <= hi <= M-1.
    If omitted, all eigenvalues and eigenvectors are returned.
type : int, optional
    Specifies the problem type to be solved:

       type = 1: a   v[:,i] = w[i] b v[:,i]

       type = 2: a b v[:,i] = w[i]   v[:,i]

       type = 3: b a v[:,i] = w[i]   v[:,i]
overwrite_a : bool, optional
    Whether to overwrite data in `a` (may improve performance)
overwrite_b : bool, optional
    Whether to overwrite data in `b` (may improve performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
w : (N,) float ndarray
    The N (1<=N<=M) selected eigenvalues, in ascending order, each
    repeated according to its multiplicity.
v : (M, N) complex ndarray
    (if eigvals_only == False)

    The normalized selected eigenvector corresponding to the
    eigenvalue w[i] is the column v[:,i].

    Normalization:

        type 1 and 3: v.conj() a      v  = w

        type 2: inv(v).conj() a  inv(v) = w

        type = 1 or 2: v.conj() b      v  = I

        type = 3: v.conj() inv(b) v  = I

Raises
------
LinAlgError
    If eigenvalue computation does not converge,
    an error occurred, or b matrix is not definite positive. Note that
    if input matrices are not symmetric or hermitian, no error is reported
    but results will be wrong.

See Also
--------
eigvalsh : eigenvalues of symmetric or Hermitian arrays
eig : eigenvalues and right eigenvectors for non-symmetric arrays
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eigh_tridiagonal : eigenvalues and right eiegenvectors for
    symmetric/Hermitian tridiagonal matrices

Notes
-----
This function does not check the input array for being hermitian/symmetric
in order to allow for representing arrays with only their upper/lower
triangular parts.

Examples
--------
>>> from scipy.linalg import eigh
>>> A = np.array([[6, 3, 1, 5], [3, 0, 5, 1], [1, 5, 6, 2], [5, 1, 2, 2]])
>>> w, v = eigh(A)
>>> np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4)))
True
*)

val eigvals : ?b:[>`Ndarray] Obj.t -> ?overwrite_a:bool -> ?check_finite:bool -> ?homogeneous_eigvals:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute eigenvalues from an ordinary or generalized eigenvalue problem.

Find eigenvalues of a general matrix::

    a   vr[:,i] = w[i]        b   vr[:,i]

Parameters
----------
a : (M, M) array_like
    A complex or real matrix whose eigenvalues and eigenvectors
    will be computed.
b : (M, M) array_like, optional
    Right-hand side matrix in a generalized eigenvalue problem.
    If omitted, identity matrix is assumed.
overwrite_a : bool, optional
    Whether to overwrite data in a (may improve performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities
    or NaNs.
homogeneous_eigvals : bool, optional
    If True, return the eigenvalues in homogeneous coordinates.
    In this case ``w`` is a (2, M) array so that::

        w[1,i] a vr[:,i] = w[0,i] b vr[:,i]

    Default is False.

Returns
-------
w : (M,) or (2, M) double or complex ndarray
    The eigenvalues, each repeated according to its multiplicity
    but not in any specific order. The shape is (M,) unless
    ``homogeneous_eigvals=True``.

Raises
------
LinAlgError
    If eigenvalue computation does not converge

See Also
--------
eig : eigenvalues and right eigenvectors of general arrays.
eigvalsh : eigenvalues of symmetric or Hermitian arrays
eigvals_banded : eigenvalues for symmetric/Hermitian band matrices
eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal
    matrices

Examples
--------
>>> from scipy import linalg
>>> a = np.array([[0., -1.], [1., 0.]])
>>> linalg.eigvals(a)
array([0.+1.j, 0.-1.j])

>>> b = np.array([[0., 1.], [1., 1.]])
>>> linalg.eigvals(a, b)
array([ 1.+0.j, -1.+0.j])

>>> a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]])
>>> linalg.eigvals(a, homogeneous_eigvals=True)
array([[3.+0.j, 8.+0.j, 7.+0.j],
       [1.+0.j, 1.+0.j, 1.+0.j]])
*)

val eigvalsh : ?b:[>`Ndarray] Obj.t -> ?lower:bool -> ?overwrite_a:bool -> ?overwrite_b:bool -> ?turbo:bool -> ?eigvals:Py.Object.t -> ?type_:int -> ?check_finite:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Solve an ordinary or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.

Find eigenvalues w of matrix a, where b is positive definite::

                  a v[:,i] = w[i] b v[:,i]
    v[i,:].conj() a v[:,i] = w[i]
    v[i,:].conj() b v[:,i] = 1


Parameters
----------
a : (M, M) array_like
    A complex Hermitian or real symmetric matrix whose eigenvalues and
    eigenvectors will be computed.
b : (M, M) array_like, optional
    A complex Hermitian or real symmetric definite positive matrix in.
    If omitted, identity matrix is assumed.
lower : bool, optional
    Whether the pertinent array data is taken from the lower or upper
    triangle of `a`. (Default: lower)
turbo : bool, optional
    Use divide and conquer algorithm (faster but expensive in memory,
    only for generalized eigenvalue problem and if eigvals=None)
eigvals : tuple (lo, hi), optional
    Indexes of the smallest and largest (in ascending order) eigenvalues
    and corresponding eigenvectors to be returned: 0 <= lo < hi <= M-1.
    If omitted, all eigenvalues and eigenvectors are returned.
type : int, optional
    Specifies the problem type to be solved:

       type = 1: a   v[:,i] = w[i] b v[:,i]

       type = 2: a b v[:,i] = w[i]   v[:,i]

       type = 3: b a v[:,i] = w[i]   v[:,i]
overwrite_a : bool, optional
    Whether to overwrite data in `a` (may improve performance)
overwrite_b : bool, optional
    Whether to overwrite data in `b` (may improve performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
w : (N,) float ndarray
    The N (1<=N<=M) selected eigenvalues, in ascending order, each
    repeated according to its multiplicity.

Raises
------
LinAlgError
    If eigenvalue computation does not converge,
    an error occurred, or b matrix is not definite positive. Note that
    if input matrices are not symmetric or hermitian, no error is reported
    but results will be wrong.

See Also
--------
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eigvals : eigenvalues of general arrays
eigvals_banded : eigenvalues for symmetric/Hermitian band matrices
eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal
    matrices

Notes
-----
This function does not check the input array for being hermitian/symmetric
in order to allow for representing arrays with only their upper/lower
triangular parts.

Examples
--------
>>> from scipy.linalg import eigvalsh
>>> A = np.array([[6, 3, 1, 5], [3, 0, 5, 1], [1, 5, 6, 2], [5, 1, 2, 2]])
>>> w = eigvalsh(A)
>>> w
array([-3.74637491, -0.76263923,  6.08502336, 12.42399079])
*)

val fft : ?n:int -> ?axis:int -> ?norm:string -> ?overwrite_x:bool -> ?workers:int -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the one-dimensional discrete Fourier Transform.

This function computes the one-dimensional *n*-point discrete Fourier
Transform (DFT) with the efficient Fast Fourier Transform (FFT)
algorithm [1]_.

Parameters
----------
x : array_like
    Input array, can be complex.
n : int, optional
    Length of the transformed axis of the output.
    If `n` is smaller than the length of the input, the input is cropped.
    If it is larger, the input is padded with zeros.  If `n` is not given,
    the length of the input along the axis specified by `axis` is used.
axis : int, optional
    Axis over which to compute the FFT.  If not given, the last axis is
    used.
norm : {None, 'ortho'}, optional
    Normalization mode. Default is None, meaning no normalization on the
    forward transforms and scaling by ``1/n`` on the `ifft`.
    For ``norm='ortho'``, both directions are scaled by ``1/sqrt(n)``.
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed; the default is False.
    See the notes below for more details.
workers : int, optional
    Maximum number of workers to use for parallel computation. If negative,
    the value wraps around from ``os.cpu_count()``. See below for more
    details.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.

Raises
------
IndexError
    if `axes` is larger than the last axis of `x`.

See Also
--------
ifft : The inverse of `fft`.
fft2 : The two-dimensional FFT.
fftn : The *n*-dimensional FFT.
rfftn : The *n*-dimensional FFT of real input.
fftfreq : Frequency bins for given FFT parameters.
next_fast_len : Size to pad input to for most efficient transforms

Notes
-----

FFT (Fast Fourier Transform) refers to a way the discrete Fourier Transform
(DFT) can be calculated efficiently, by using symmetries in the calculated
terms. The symmetry is highest when `n` is a power of 2, and the transform
is therefore most efficient for these sizes. For poorly factorizable sizes,
`scipy.fft` uses Bluestein's algorithm [2]_ and so is never worse than
O(`n` log `n`). Further performance improvements may be seen by zero-padding
the input using `next_fast_len`.

If ``x`` is a 1d array, then the `fft` is equivalent to ::

    y[k] = np.sum(x * np.exp(-2j * np.pi * k * np.arange(n)/n))

The frequency term ``f=k/n`` is found at ``y[k]``. At ``y[n/2]`` we reach
the Nyquist frequency and wrap around to the negative-frequency terms. So,
for an 8-point transform, the frequencies of the result are
[0, 1, 2, 3, -4, -3, -2, -1]. To rearrange the fft output so that the
zero-frequency component is centered, like [-4, -3, -2, -1, 0, 1, 2, 3],
use `fftshift`.

Transforms can be done in single, double or extended precision (long
double) floating point. Half precision inputs will be converted to single
precision and non floating-point inputs will be converted to double
precision.

If the data type of ``x`` is real, a 'real FFT' algorithm is automatically
used, which roughly halves the computation time.  To increase efficiency
a little further, use `rfft`, which does the same calculation, but only
outputs half of the symmetrical spectrum.  If the data is both real and
symmetrical, the `dct` can again double the efficiency, by generating
half of the spectrum from half of the signal.

When ``overwrite_x=True`` is specified, the memory referenced by ``x`` may
be used by the implementation in any way. This may include reusing the
memory for the result, but this is in no way guaranteed. You should not
rely on the contents of ``x`` after the transform as this may change in
future without warning.

The ``workers`` argument specifies the maximum number of parallel jobs to
split the FFT computation into. This will execute independent 1-dimensional
FFTs within ``x``. So, ``x`` must be at least 2-dimensional and the
non-transformed axes must be large enough to split into chunks. If ``x`` is
too small, fewer jobs may be used than requested.

References
----------
.. [1] Cooley, James W., and John W. Tukey, 1965, 'An algorithm for the
       machine calculation of complex Fourier series,' *Math. Comput.*
       19: 297-301.
.. [2] Bluestein, L., 1970, 'A linear filtering approach to the
       computation of discrete Fourier transform'. *IEEE Transactions on
       Audio and Electroacoustics.* 18 (4): 451-455.

Examples
--------
>>> import scipy.fft
>>> scipy.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
        2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
       -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
        1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])

In this example, real input has an FFT which is Hermitian, i.e., symmetric
in the real part and anti-symmetric in the imaginary part:

>>> from scipy.fft import fft, fftfreq, fftshift
>>> import matplotlib.pyplot as plt
>>> t = np.arange(256)
>>> sp = fftshift(fft(np.sin(t)))
>>> freq = fftshift(fftfreq(t.shape[-1]))
>>> plt.plot(freq, sp.real, freq, sp.imag)
[<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
>>> plt.show()
*)

val fft2 : ?s:int list -> ?axes:int list -> ?norm:string -> ?overwrite_x:bool -> ?workers:int -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the 2-dimensional discrete Fourier Transform

This function computes the *n*-dimensional discrete Fourier Transform
over any axes in an *M*-dimensional array by means of the
Fast Fourier Transform (FFT).  By default, the transform is computed over
the last two axes of the input array, i.e., a 2-dimensional FFT.

Parameters
----------
x : array_like
    Input array, can be complex
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
    This corresponds to ``n`` for ``fft(x, n)``.
    Along each axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.
axes : sequence of ints, optional
    Axes over which to compute the FFT. If not given, the last two axes are
    used.
norm : {None, 'ortho'}, optional
    Normalization mode (see `fft`). Default is None.
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed; the default is False.
    See :func:`fft` for more details.
workers : int, optional
    Maximum number of workers to use for parallel computation. If negative,
    the value wraps around from ``os.cpu_count()``.
    See :func:`~scipy.fft.fft` for more details.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or the last two axes if `axes` is not given.

Raises
------
ValueError
    If `s` and `axes` have different length, or `axes` not given and
    ``len(s) != 2``.
IndexError
    If an element of `axes` is larger than than the number of axes of `x`.

See Also
--------
ifft2 : The inverse two-dimensional FFT.
fft : The one-dimensional FFT.
fftn : The *n*-dimensional FFT.
fftshift : Shifts zero-frequency terms to the center of the array.
    For two-dimensional input, swaps first and third quadrants, and second
    and fourth quadrants.

Notes
-----
`fft2` is just `fftn` with a different default for `axes`.

The output, analogously to `fft`, contains the term for zero frequency in
the low-order corner of the transformed axes, the positive frequency terms
in the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
the axes, in order of decreasingly negative frequency.

See `fftn` for details and a plotting example, and `fft` for
definitions and conventions used.


Examples
--------
>>> import scipy.fft
>>> x = np.mgrid[:5, :5][0]
>>> scipy.fft.fft2(x)
array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ]])
*)

val fftn : ?s:int list -> ?axes:int list -> ?norm:string -> ?overwrite_x:bool -> ?workers:int -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the N-dimensional discrete Fourier Transform.

This function computes the *N*-dimensional discrete Fourier Transform over
any number of axes in an *M*-dimensional array by means of the Fast Fourier
Transform (FFT).

Parameters
----------
x : array_like
    Input array, can be complex.
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
    This corresponds to ``n`` for ``fft(x, n)``.
    Along any axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.
axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last ``len(s)``
    axes are used, or all axes if `s` is also not specified.
norm : {None, 'ortho'}, optional
    Normalization mode (see `fft`). Default is None.
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed; the default is False.
    See :func:`fft` for more details.
workers : int, optional
    Maximum number of workers to use for parallel computation. If negative,
    the value wraps around from ``os.cpu_count()``.
    See :func:`~scipy.fft.fft` for more details.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` and `x`,
    as explained in the parameters section above.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `x`.

See Also
--------
ifftn : The inverse of `fftn`, the inverse *n*-dimensional FFT.
fft : The one-dimensional FFT, with definitions and conventions used.
rfftn : The *n*-dimensional FFT of real input.
fft2 : The two-dimensional FFT.
fftshift : Shifts zero-frequency terms to centre of array

Notes
-----
The output, analogously to `fft`, contains the term for zero frequency in
the low-order corner of all axes, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.

Examples
--------
>>> import scipy.fft
>>> x = np.mgrid[:3, :3, :3][0]
>>> scipy.fft.fftn(x, axes=(1, 2))
array([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary
        [ 0.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j]],
       [[ 9.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j]],
       [[18.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j]]])
>>> scipy.fft.fftn(x, (2, 2), axes=(0, 1))
array([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary
        [ 0.+0.j,  0.+0.j,  0.+0.j]],
       [[-2.+0.j, -2.+0.j, -2.+0.j],
        [ 0.+0.j,  0.+0.j,  0.+0.j]]])

>>> import matplotlib.pyplot as plt
>>> [X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,
...                      2 * np.pi * np.arange(200) / 34)
>>> S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)
>>> FS = scipy.fft.fftn(S)
>>> plt.imshow(np.log(np.abs(scipy.fft.fftshift(FS))**2))
<matplotlib.image.AxesImage object at 0x...>
>>> plt.show()
*)

val i0 : [`Ndarray of [>`Ndarray] Obj.t | `PyObject of Py.Object.t] -> Py.Object.t
(**
Modified Bessel function of the first kind, order 0.

Usually denoted :math:`I_0`.  This function does broadcast, but will *not*
'up-cast' int dtype arguments unless accompanied by at least one float or
complex dtype argument (see Raises below).

Parameters
----------
x : array_like, dtype float or complex
    Argument of the Bessel function.

Returns
-------
out : ndarray, shape = x.shape, dtype = x.dtype
    The modified Bessel function evaluated at each of the elements of `x`.

Raises
------
TypeError: array cannot be safely cast to required type
    If argument consists exclusively of int dtypes.

See Also
--------
scipy.special.i0, scipy.special.iv, scipy.special.ive

Notes
-----
The scipy implementation is recommended over this function: it is a
proper ufunc written in C, and more than an order of magnitude faster.

We use the algorithm published by Clenshaw [1]_ and referenced by
Abramowitz and Stegun [2]_, for which the function domain is
partitioned into the two intervals [0,8] and (8,inf), and Chebyshev
polynomial expansions are employed in each interval. Relative error on
the domain [0,30] using IEEE arithmetic is documented [3]_ as having a
peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).

References
----------
.. [1] C. W. Clenshaw, 'Chebyshev series for mathematical functions', in
       *National Physical Laboratory Mathematical Tables*, vol. 5, London:
       Her Majesty's Stationery Office, 1962.
.. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical
       Functions*, 10th printing, New York: Dover, 1964, pp. 379.
       http://www.math.sfu.ca/~cbm/aands/page_379.htm
.. [3] http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html

Examples
--------
>>> np.i0(0.)
array(1.0)  # may vary
>>> np.i0([0., 1. + 2j])
array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])  # may vary
*)

val ifft : ?n:int -> ?axis:int -> ?norm:string -> ?overwrite_x:bool -> ?workers:int -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the one-dimensional inverse discrete Fourier Transform.

This function computes the inverse of the one-dimensional *n*-point
discrete Fourier transform computed by `fft`.  In other words,
``ifft(fft(x)) == x`` to within numerical accuracy.

The input should be ordered in the same way as is returned by `fft`,
i.e.,

* ``x[0]`` should contain the zero frequency term,
* ``x[1:n//2]`` should contain the positive-frequency terms,
* ``x[n//2 + 1:]`` should contain the negative-frequency terms, in
  increasing order starting from the most negative frequency.

For an even number of input points, ``x[n//2]`` represents the sum of
the values at the positive and negative Nyquist frequencies, as the two
are aliased together. See `fft` for details.

Parameters
----------
x : array_like
    Input array, can be complex.
n : int, optional
    Length of the transformed axis of the output.
    If `n` is smaller than the length of the input, the input is cropped.
    If it is larger, the input is padded with zeros.  If `n` is not given,
    the length of the input along the axis specified by `axis` is used.
    See notes about padding issues.
axis : int, optional
    Axis over which to compute the inverse DFT.  If not given, the last
    axis is used.
norm : {None, 'ortho'}, optional
    Normalization mode (see `fft`). Default is None.
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed; the default is False.
    See :func:`fft` for more details.
workers : int, optional
    Maximum number of workers to use for parallel computation. If negative,
    the value wraps around from ``os.cpu_count()``.
    See :func:`~scipy.fft.fft` for more details.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.

Raises
------
IndexError
    If `axes` is larger than the last axis of `x`.

See Also
--------
fft : The one-dimensional (forward) FFT, of which `ifft` is the inverse
ifft2 : The two-dimensional inverse FFT.
ifftn : The n-dimensional inverse FFT.

Notes
-----
If the input parameter `n` is larger than the size of the input, the input
is padded by appending zeros at the end.  Even though this is the common
approach, it might lead to surprising results.  If a different padding is
desired, it must be performed before calling `ifft`.

If ``x`` is a 1d array, then the `ifft` is equivalent to ::

    y[k] = np.sum(x * np.exp(2j * np.pi * k * np.arange(n)/n)) / len(x)

As with `fft`, `ifft` has support for all floating point types and is
optimized for real input.

Examples
--------
>>> import scipy.fft
>>> scipy.fft.ifft([0, 4, 0, 0])
array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary

Create and plot a band-limited signal with random phases:

>>> import matplotlib.pyplot as plt
>>> t = np.arange(400)
>>> n = np.zeros((400,), dtype=complex)
>>> n[40:60] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20,)))
>>> s = scipy.fft.ifft(n)
>>> plt.plot(t, s.real, 'b-', t, s.imag, 'r--')
[<matplotlib.lines.Line2D object at ...>, <matplotlib.lines.Line2D object at ...>]
>>> plt.legend(('real', 'imaginary'))
<matplotlib.legend.Legend object at ...>
>>> plt.show()
*)

val ifft2 : ?s:int list -> ?axes:int list -> ?norm:string -> ?overwrite_x:bool -> ?workers:int -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the 2-dimensional inverse discrete Fourier Transform.

This function computes the inverse of the 2-dimensional discrete Fourier
Transform over any number of axes in an M-dimensional array by means of
the Fast Fourier Transform (FFT).  In other words, ``ifft2(fft2(x)) == x``
to within numerical accuracy.  By default, the inverse transform is
computed over the last two axes of the input array.

The input, analogously to `ifft`, should be ordered in the same way as is
returned by `fft2`, i.e. it should have the term for zero frequency
in the low-order corner of the two axes, the positive frequency terms in
the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
both axes, in order of decreasingly negative frequency.

Parameters
----------
x : array_like
    Input array, can be complex.
s : sequence of ints, optional
    Shape (length of each axis) of the output (``s[0]`` refers to axis 0,
    ``s[1]`` to axis 1, etc.).  This corresponds to `n` for ``ifft(x, n)``.
    Along each axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.  See notes for issue on `ifft` zero padding.
axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last two
    axes are used.
norm : {None, 'ortho'}, optional
    Normalization mode (see `fft`). Default is None.
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed; the default is False.
    See :func:`fft` for more details.
workers : int, optional
    Maximum number of workers to use for parallel computation. If negative,
    the value wraps around from ``os.cpu_count()``.
    See :func:`~scipy.fft.fft` for more details.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or the last two axes if `axes` is not given.

Raises
------
ValueError
    If `s` and `axes` have different length, or `axes` not given and
    ``len(s) != 2``.
IndexError
    If an element of `axes` is larger than than the number of axes of `x`.

See Also
--------
fft2 : The forward 2-dimensional FFT, of which `ifft2` is the inverse.
ifftn : The inverse of the *n*-dimensional FFT.
fft : The one-dimensional FFT.
ifft : The one-dimensional inverse FFT.

Notes
-----
`ifft2` is just `ifftn` with a different default for `axes`.

See `ifftn` for details and a plotting example, and `fft` for
definition and conventions used.

Zero-padding, analogously with `ifft`, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before `ifft2` is called.

Examples
--------
>>> import scipy.fft
>>> x = 4 * np.eye(4)
>>> scipy.fft.ifft2(x)
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],
       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])
*)

val ifftn : ?s:int list -> ?axes:int list -> ?norm:string -> ?overwrite_x:bool -> ?workers:int -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the N-dimensional inverse discrete Fourier Transform.

This function computes the inverse of the N-dimensional discrete
Fourier Transform over any number of axes in an M-dimensional array by
means of the Fast Fourier Transform (FFT).  In other words,
``ifftn(fftn(x)) == x`` to within numerical accuracy.

The input, analogously to `ifft`, should be ordered in the same way as is
returned by `fftn`, i.e. it should have the term for zero frequency
in all axes in the low-order corner, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.

Parameters
----------
x : array_like
    Input array, can be complex.
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
    This corresponds to ``n`` for ``ifft(x, n)``.
    Along any axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.  See notes for issue on `ifft` zero padding.
axes : sequence of ints, optional
    Axes over which to compute the IFFT.  If not given, the last ``len(s)``
    axes are used, or all axes if `s` is also not specified.
norm : {None, 'ortho'}, optional
    Normalization mode (see `fft`). Default is None.
overwrite_x : bool, optional
    If True, the contents of `x` can be destroyed; the default is False.
    See :func:`fft` for more details.
workers : int, optional
    Maximum number of workers to use for parallel computation. If negative,
    the value wraps around from ``os.cpu_count()``.
    See :func:`~scipy.fft.fft` for more details.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` or `x`,
    as explained in the parameters section above.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `x`.

See Also
--------
fftn : The forward *n*-dimensional FFT, of which `ifftn` is the inverse.
ifft : The one-dimensional inverse FFT.
ifft2 : The two-dimensional inverse FFT.
ifftshift : Undoes `fftshift`, shifts zero-frequency terms to beginning
    of array.

Notes
-----
Zero-padding, analogously with `ifft`, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before `ifftn` is called.

Examples
--------
>>> import scipy.fft
>>> x = np.eye(4)
>>> scipy.fft.ifftn(scipy.fft.fftn(x, axes=(0,)), axes=(1,))
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],
       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])


Create and plot an image with band-limited frequency content:

>>> import matplotlib.pyplot as plt
>>> n = np.zeros((200,200), dtype=complex)
>>> n[60:80, 20:40] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20, 20)))
>>> im = scipy.fft.ifftn(n).real
>>> plt.imshow(im)
<matplotlib.image.AxesImage object at 0x...>
>>> plt.show()
*)

val inv : ?overwrite_a:bool -> ?check_finite:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the inverse of a matrix.

Parameters
----------
a : array_like
    Square matrix to be inverted.
overwrite_a : bool, optional
    Discard data in `a` (may improve performance). Default is False.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
ainv : ndarray
    Inverse of the matrix `a`.

Raises
------
LinAlgError
    If `a` is singular.
ValueError
    If `a` is not square, or not 2-dimensional.

Examples
--------
>>> from scipy import linalg
>>> a = np.array([[1., 2.], [3., 4.]])
>>> linalg.inv(a)
array([[-2. ,  1. ],
       [ 1.5, -0.5]])
>>> np.dot(a, linalg.inv(a))
array([[ 1.,  0.],
       [ 0.,  1.]])
*)

val lstsq : ?cond:float -> ?overwrite_a:bool -> ?overwrite_b:bool -> ?check_finite:bool -> ?lapack_driver:string -> b:Py.Object.t -> [>`Ndarray] Obj.t -> (Py.Object.t * Py.Object.t * int * Py.Object.t option)
(**
Compute least-squares solution to equation Ax = b.

Compute a vector x such that the 2-norm ``|b - A x|`` is minimized.

Parameters
----------
a : (M, N) array_like
    Left hand side array
b : (M,) or (M, K) array_like
    Right hand side array
cond : float, optional
    Cutoff for 'small' singular values; used to determine effective
    rank of a. Singular values smaller than
    ``rcond * largest_singular_value`` are considered zero.
overwrite_a : bool, optional
    Discard data in `a` (may enhance performance). Default is False.
overwrite_b : bool, optional
    Discard data in `b` (may enhance performance). Default is False.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
lapack_driver : str, optional
    Which LAPACK driver is used to solve the least-squares problem.
    Options are ``'gelsd'``, ``'gelsy'``, ``'gelss'``. Default
    (``'gelsd'``) is a good choice.  However, ``'gelsy'`` can be slightly
    faster on many problems.  ``'gelss'`` was used historically.  It is
    generally slow but uses less memory.

    .. versionadded:: 0.17.0

Returns
-------
x : (N,) or (N, K) ndarray
    Least-squares solution.  Return shape matches shape of `b`.
residues : (K,) ndarray or float
    Square of the 2-norm for each column in ``b - a x``, if ``M > N`` and
    ``ndim(A) == n`` (returns a scalar if b is 1-D). Otherwise a
    (0,)-shaped array is returned.
rank : int
    Effective rank of `a`.
s : (min(M, N),) ndarray or None
    Singular values of `a`. The condition number of a is
    ``abs(s[0] / s[-1])``.

Raises
------
LinAlgError
    If computation does not converge.

ValueError
    When parameters are not compatible.

See Also
--------
scipy.optimize.nnls : linear least squares with non-negativity constraint

Notes
-----
When ``'gelsy'`` is used as a driver, `residues` is set to a (0,)-shaped
array and `s` is always ``None``.

Examples
--------
>>> from scipy.linalg import lstsq
>>> import matplotlib.pyplot as plt

Suppose we have the following data:

>>> x = np.array([1, 2.5, 3.5, 4, 5, 7, 8.5])
>>> y = np.array([0.3, 1.1, 1.5, 2.0, 3.2, 6.6, 8.6])

We want to fit a quadratic polynomial of the form ``y = a + b*x**2``
to this data.  We first form the 'design matrix' M, with a constant
column of 1s and a column containing ``x**2``:

>>> M = x[:, np.newaxis]**[0, 2]
>>> M
array([[  1.  ,   1.  ],
       [  1.  ,   6.25],
       [  1.  ,  12.25],
       [  1.  ,  16.  ],
       [  1.  ,  25.  ],
       [  1.  ,  49.  ],
       [  1.  ,  72.25]])

We want to find the least-squares solution to ``M.dot(p) = y``,
where ``p`` is a vector with length 2 that holds the parameters
``a`` and ``b``.

>>> p, res, rnk, s = lstsq(M, y)
>>> p
array([ 0.20925829,  0.12013861])

Plot the data and the fitted curve.

>>> plt.plot(x, y, 'o', label='data')
>>> xx = np.linspace(0, 9, 101)
>>> yy = p[0] + p[1]*xx**2
>>> plt.plot(xx, yy, label='least squares fit, $y = a + bx^2$')
>>> plt.xlabel('x')
>>> plt.ylabel('y')
>>> plt.legend(framealpha=1, shadow=True)
>>> plt.grid(alpha=0.25)
>>> plt.show()
*)

val norm : ?ord:[`PyObject of Py.Object.t | `Fro] -> ?axis:[`I of int | `T2_tuple_of_ints of Py.Object.t] -> ?keepdims:bool -> ?check_finite:bool -> Py.Object.t -> Py.Object.t
(**
Matrix or vector norm.

This function is able to return one of seven different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the ``ord`` parameter.

Parameters
----------
a : (M,) or (M, N) array_like
    Input array.  If `axis` is None, `a` must be 1-D or 2-D.
ord : {non-zero int, inf, -inf, 'fro'}, optional
    Order of the norm (see table under ``Notes``). inf means numpy's
    `inf` object
axis : {int, 2-tuple of ints, None}, optional
    If `axis` is an integer, it specifies the axis of `a` along which to
    compute the vector norms.  If `axis` is a 2-tuple, it specifies the
    axes that hold 2-D matrices, and the matrix norms of these matrices
    are computed.  If `axis` is None then either a vector norm (when `a`
    is 1-D) or a matrix norm (when `a` is 2-D) is returned.
keepdims : bool, optional
    If this is set to True, the axes which are normed over are left in the
    result as dimensions with size one.  With this option the result will
    broadcast correctly against the original `a`.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
n : float or ndarray
    Norm of the matrix or vector(s).

Notes
-----
For values of ``ord <= 0``, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.

The following norms can be calculated:

=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)**ord)**(1./ord)
=====  ============================  ==========================

The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

The ``axis`` and ``keepdims`` arguments are passed directly to
``numpy.linalg.norm`` and are only usable if they are supported
by the version of numpy in use.

References
----------
.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
       Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15

Examples
--------
>>> from scipy.linalg import norm
>>> a = np.arange(9) - 4.0
>>> a
array([-4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])
>>> b = a.reshape((3, 3))
>>> b
array([[-4., -3., -2.],
       [-1.,  0.,  1.],
       [ 2.,  3.,  4.]])

>>> norm(a)
7.745966692414834
>>> norm(b)
7.745966692414834
>>> norm(b, 'fro')
7.745966692414834
>>> norm(a, np.inf)
4
>>> norm(b, np.inf)
9
>>> norm(a, -np.inf)
0
>>> norm(b, -np.inf)
2

>>> norm(a, 1)
20
>>> norm(b, 1)
7
>>> norm(a, -1)
-4.6566128774142013e-010
>>> norm(b, -1)
6
>>> norm(a, 2)
7.745966692414834
>>> norm(b, 2)
7.3484692283495345

>>> norm(a, -2)
0
>>> norm(b, -2)
1.8570331885190563e-016
>>> norm(a, 3)
5.8480354764257312
>>> norm(a, -3)
0
*)

val pinv : ?cond:Py.Object.t -> ?rcond:Py.Object.t -> ?return_rank:bool -> ?check_finite:bool -> [>`Ndarray] Obj.t -> ([`ArrayLike|`Ndarray|`Object] Obj.t * int)
(**
Compute the (Moore-Penrose) pseudo-inverse of a matrix.

Calculate a generalized inverse of a matrix using its
singular-value decomposition and including all 'large' singular
values.

Parameters
----------
a : (M, N) array_like
    Matrix to be pseudo-inverted.
cond, rcond : float or None
    Cutoff for 'small' singular values; singular values smaller than this
    value are considered as zero. If both are omitted, the default value
    ``max(M,N)*largest_singular_value*eps`` is used where ``eps`` is the
    machine precision value of the datatype of ``a``.

    .. versionchanged:: 1.3.0
        Previously the default cutoff value was just ``eps*f`` where ``f``
        was ``1e3`` for single precision and ``1e6`` for double precision.

return_rank : bool, optional
    If True, return the effective rank of the matrix.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
B : (N, M) ndarray
    The pseudo-inverse of matrix `a`.
rank : int
    The effective rank of the matrix.  Returned if `return_rank` is True.

Raises
------
LinAlgError
    If SVD computation does not converge.

Examples
--------
>>> from scipy import linalg
>>> a = np.random.randn(9, 6)
>>> B = linalg.pinv2(a)
>>> np.allclose(a, np.dot(a, np.dot(B, a)))
True
>>> np.allclose(B, np.dot(B, np.dot(a, B)))
True
*)

val register_func : name:Py.Object.t -> func:Py.Object.t -> unit -> Py.Object.t
(**
None
*)

val restore_all : unit -> Py.Object.t
(**
None
*)

val restore_func : Py.Object.t -> Py.Object.t
(**
None
*)

val solve : ?sym_pos:bool -> ?lower:bool -> ?overwrite_a:bool -> ?overwrite_b:bool -> ?debug:Py.Object.t -> ?check_finite:bool -> ?assume_a:string -> ?transposed:bool -> b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Solves the linear equation set ``a * x = b`` for the unknown ``x``
for square ``a`` matrix.

If the data matrix is known to be a particular type then supplying the
corresponding string to ``assume_a`` key chooses the dedicated solver.
The available options are

===================  ========
 generic matrix       'gen'
 symmetric            'sym'
 hermitian            'her'
 positive definite    'pos'
===================  ========

If omitted, ``'gen'`` is the default structure.

The datatype of the arrays define which solver is called regardless
of the values. In other words, even when the complex array entries have
precisely zero imaginary parts, the complex solver will be called based
on the data type of the array.

Parameters
----------
a : (N, N) array_like
    Square input data
b : (N, NRHS) array_like
    Input data for the right hand side.
sym_pos : bool, optional
    Assume `a` is symmetric and positive definite. This key is deprecated
    and assume_a = 'pos' keyword is recommended instead. The functionality
    is the same. It will be removed in the future.
lower : bool, optional
    If True, only the data contained in the lower triangle of `a`. Default
    is to use upper triangle. (ignored for ``'gen'``)
overwrite_a : bool, optional
    Allow overwriting data in `a` (may enhance performance).
    Default is False.
overwrite_b : bool, optional
    Allow overwriting data in `b` (may enhance performance).
    Default is False.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
assume_a : str, optional
    Valid entries are explained above.
transposed: bool, optional
    If True, ``a^T x = b`` for real matrices, raises `NotImplementedError`
    for complex matrices (only for True).

Returns
-------
x : (N, NRHS) ndarray
    The solution array.

Raises
------
ValueError
    If size mismatches detected or input a is not square.
LinAlgError
    If the matrix is singular.
LinAlgWarning
    If an ill-conditioned input a is detected.
NotImplementedError
    If transposed is True and input a is a complex matrix.

Examples
--------
Given `a` and `b`, solve for `x`:

>>> a = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])
>>> b = np.array([2, 4, -1])
>>> from scipy import linalg
>>> x = linalg.solve(a, b)
>>> x
array([ 2., -2.,  9.])
>>> np.dot(a, x) == b
array([ True,  True,  True], dtype=bool)

Notes
-----
If the input b matrix is a 1D array with N elements, when supplied
together with an NxN input a, it is assumed as a valid column vector
despite the apparent size mismatch. This is compatible with the
numpy.dot() behavior and the returned result is still 1D array.

The generic, symmetric, hermitian and positive definite solutions are
obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of
LAPACK respectively.
*)

val svd : ?full_matrices:bool -> ?compute_uv:bool -> ?overwrite_a:bool -> ?check_finite:bool -> ?lapack_driver:[`Gesdd | `Gesvd] -> [>`Ndarray] Obj.t -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Singular Value Decomposition.

Factorizes the matrix `a` into two unitary matrices ``U`` and ``Vh``, and
a 1-D array ``s`` of singular values (real, non-negative) such that
``a == U @ S @ Vh``, where ``S`` is a suitably shaped matrix of zeros with
main diagonal ``s``.

Parameters
----------
a : (M, N) array_like
    Matrix to decompose.
full_matrices : bool, optional
    If True (default), `U` and `Vh` are of shape ``(M, M)``, ``(N, N)``.
    If False, the shapes are ``(M, K)`` and ``(K, N)``, where
    ``K = min(M, N)``.
compute_uv : bool, optional
    Whether to compute also ``U`` and ``Vh`` in addition to ``s``.
    Default is True.
overwrite_a : bool, optional
    Whether to overwrite `a`; may improve performance.
    Default is False.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
lapack_driver : {'gesdd', 'gesvd'}, optional
    Whether to use the more efficient divide-and-conquer approach
    (``'gesdd'``) or general rectangular approach (``'gesvd'``)
    to compute the SVD. MATLAB and Octave use the ``'gesvd'`` approach.
    Default is ``'gesdd'``.

    .. versionadded:: 0.18

Returns
-------
U : ndarray
    Unitary matrix having left singular vectors as columns.
    Of shape ``(M, M)`` or ``(M, K)``, depending on `full_matrices`.
s : ndarray
    The singular values, sorted in non-increasing order.
    Of shape (K,), with ``K = min(M, N)``.
Vh : ndarray
    Unitary matrix having right singular vectors as rows.
    Of shape ``(N, N)`` or ``(K, N)`` depending on `full_matrices`.

For ``compute_uv=False``, only ``s`` is returned.

Raises
------
LinAlgError
    If SVD computation does not converge.

See also
--------
svdvals : Compute singular values of a matrix.
diagsvd : Construct the Sigma matrix, given the vector s.

Examples
--------
>>> from scipy import linalg
>>> m, n = 9, 6
>>> a = np.random.randn(m, n) + 1.j*np.random.randn(m, n)
>>> U, s, Vh = linalg.svd(a)
>>> U.shape,  s.shape, Vh.shape
((9, 9), (6,), (6, 6))

Reconstruct the original matrix from the decomposition:

>>> sigma = np.zeros((m, n))
>>> for i in range(min(m, n)):
...     sigma[i, i] = s[i]
>>> a1 = np.dot(U, np.dot(sigma, Vh))
>>> np.allclose(a, a1)
True

Alternatively, use ``full_matrices=False`` (notice that the shape of
``U`` is then ``(m, n)`` instead of ``(m, m)``):

>>> U, s, Vh = linalg.svd(a, full_matrices=False)
>>> U.shape, s.shape, Vh.shape
((9, 6), (6,), (6, 6))
>>> S = np.diag(s)
>>> np.allclose(a, np.dot(U, np.dot(S, Vh)))
True

>>> s2 = linalg.svd(a, compute_uv=False)
>>> np.allclose(s, s2)
True
*)


end

module Emath : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

val any : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Test whether any array element along a given axis evaluates to True.

Returns single boolean unless `axis` is not ``None``

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : None or int or tuple of ints, optional
    Axis or axes along which a logical OR reduction is performed.
    The default (``axis=None``) is to perform a logical OR over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a reduction is performed on multiple
    axes, instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output and its type is preserved
    (e.g., if it is of type float, then it will remain so, returning
    1.0 for True and 0.0 for False, regardless of the type of `a`).
    See `ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `any` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
any : bool or ndarray
    A new boolean or `ndarray` is returned unless `out` is specified,
    in which case a reference to `out` is returned.

See Also
--------
ndarray.any : equivalent method

all : Test whether all elements along a given axis evaluate to True.

Notes
-----
Not a Number (NaN), positive infinity and negative infinity evaluate
to `True` because these are not equal to zero.

Examples
--------
>>> np.any([[True, False], [True, True]])
True

>>> np.any([[True, False], [False, False]], axis=0)
array([ True, False])

>>> np.any([-1, 0, 5])
True

>>> np.any(np.nan)
True

>>> o=np.array(False)
>>> z=np.any([-1, 4, 5], out=o)
>>> z, o
(array(True), array(True))
>>> # Check now that z is a reference to o
>>> z is o
True
>>> id(z), id(o) # identity of z and o              # doctest: +SKIP
(191614240, 191614240)
*)

val arccos : [`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the inverse cosine of x.

Return the 'principal value' (for a description of this, see
`numpy.arccos`) of the inverse cosine of `x`. For real `x` such that
`abs(x) <= 1`, this is a real number in the closed interval
:math:`[0, \pi]`.  Otherwise, the complex principle value is returned.

Parameters
----------
x : array_like or scalar
   The value(s) whose arccos is (are) required.

Returns
-------
out : ndarray or scalar
   The inverse cosine(s) of the `x` value(s). If `x` was a scalar, so
   is `out`, otherwise an array object is returned.

See Also
--------
numpy.arccos

Notes
-----
For an arccos() that returns ``NAN`` when real `x` is not in the
interval ``[-1,1]``, use `numpy.arccos`.

Examples
--------
>>> np.set_printoptions(precision=4)

>>> np.emath.arccos(1) # a scalar is returned
0.0

>>> np.emath.arccos([1,2])
array([0.-0.j   , 0.-1.317j])
*)

val arcsin : [`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the inverse sine of x.

Return the 'principal value' (for a description of this, see
`numpy.arcsin`) of the inverse sine of `x`. For real `x` such that
`abs(x) <= 1`, this is a real number in the closed interval
:math:`[-\pi/2, \pi/2]`.  Otherwise, the complex principle value is
returned.

Parameters
----------
x : array_like or scalar
   The value(s) whose arcsin is (are) required.

Returns
-------
out : ndarray or scalar
   The inverse sine(s) of the `x` value(s). If `x` was a scalar, so
   is `out`, otherwise an array object is returned.

See Also
--------
numpy.arcsin

Notes
-----
For an arcsin() that returns ``NAN`` when real `x` is not in the
interval ``[-1,1]``, use `numpy.arcsin`.

Examples
--------
>>> np.set_printoptions(precision=4)

>>> np.emath.arcsin(0)
0.0

>>> np.emath.arcsin([0,1])
array([0.    , 1.5708])
*)

val arctanh : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the inverse hyperbolic tangent of `x`.

Return the 'principal value' (for a description of this, see
`numpy.arctanh`) of `arctanh(x)`. For real `x` such that
`abs(x) < 1`, this is a real number.  If `abs(x) > 1`, or if `x` is
complex, the result is complex. Finally, `x = 1` returns``inf`` and
`x=-1` returns ``-inf``.

Parameters
----------
x : array_like
   The value(s) whose arctanh is (are) required.

Returns
-------
out : ndarray or scalar
   The inverse hyperbolic tangent(s) of the `x` value(s). If `x` was
   a scalar so is `out`, otherwise an array is returned.


See Also
--------
numpy.arctanh

Notes
-----
For an arctanh() that returns ``NAN`` when real `x` is not in the
interval ``(-1,1)``, use `numpy.arctanh` (this latter, however, does
return +/-inf for `x = +/-1`).

Examples
--------
>>> np.set_printoptions(precision=4)

>>> from numpy.testing import suppress_warnings
>>> with suppress_warnings() as sup:
...     sup.filter(RuntimeWarning)
...     np.emath.arctanh(np.eye(2))
array([[inf,  0.],
       [ 0., inf]])
>>> np.emath.arctanh([1j])
array([0.+0.7854j])
*)

val array_function_dispatch : ?module_:string -> ?verify:bool -> ?docs_from_dispatcher:bool -> dispatcher:Py.Object.t -> unit -> Py.Object.t
(**
Decorator for adding dispatch with the __array_function__ protocol.

See NEP-18 for example usage.

Parameters
----------
dispatcher : callable
    Function that when called like ``dispatcher( *args, **kwargs)`` with
    arguments from the NumPy function call returns an iterable of
    array-like arguments to check for ``__array_function__``.
module : str, optional
    __module__ attribute to set on new function, e.g., ``module='numpy'``.
    By default, module is copied from the decorated function.
verify : bool, optional
    If True, verify the that the signature of the dispatcher and decorated
    function signatures match exactly: all required and optional arguments
    should appear in order with the same names, but the default values for
    all optional arguments should be ``None``. Only disable verification
    if the dispatcher's signature needs to deviate for some particular
    reason, e.g., because the function has a signature like
    ``func( *args, **kwargs)``.
docs_from_dispatcher : bool, optional
    If True, copy docs from the dispatcher function onto the dispatched
    function, rather than from the implementation. This is useful for
    functions defined in C, which otherwise don't have docstrings.

Returns
-------
Function suitable for decorating the implementation of a NumPy function.
*)

val asarray : ?dtype:Dtype.t -> ?order:[`C | `F] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Convert the input to an array.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major (C-style) or
    column-major (Fortran-style) memory representation.
    Defaults to 'C'.

Returns
-------
out : ndarray
    Array interpretation of `a`.  No copy is performed if the input
    is already an ndarray with matching dtype and order.  If `a` is a
    subclass of ndarray, a base class ndarray is returned.

See Also
--------
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array:

>>> a = [1, 2]
>>> np.asarray(a)
array([1, 2])

Existing arrays are not copied:

>>> a = np.array([1, 2])
>>> np.asarray(a) is a
True

If `dtype` is set, array is copied only if dtype does not match:

>>> a = np.array([1, 2], dtype=np.float32)
>>> np.asarray(a, dtype=np.float32) is a
True
>>> np.asarray(a, dtype=np.float64) is a
False

Contrary to `asanyarray`, ndarray subclasses are not passed through:

>>> issubclass(np.recarray, np.ndarray)
True
>>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
>>> np.asarray(a) is a
False
>>> np.asanyarray(a) is a
True
*)

val isreal : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Returns a bool array, where True if input element is real.

If element has complex type with zero complex part, the return value
for that element is True.

Parameters
----------
x : array_like
    Input array.

Returns
-------
out : ndarray, bool
    Boolean array of same shape as `x`.

See Also
--------
iscomplex
isrealobj : Return True if x is not a complex type.

Examples
--------
>>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])
array([False,  True,  True,  True,  True, False])
*)

val log : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the natural logarithm of `x`.

Return the 'principal value' (for a description of this, see `numpy.log`)
of :math:`log_e(x)`. For real `x > 0`, this is a real number (``log(0)``
returns ``-inf`` and ``log(np.inf)`` returns ``inf``). Otherwise, the
complex principle value is returned.

Parameters
----------
x : array_like
   The value(s) whose log is (are) required.

Returns
-------
out : ndarray or scalar
   The log of the `x` value(s). If `x` was a scalar, so is `out`,
   otherwise an array is returned.

See Also
--------
numpy.log

Notes
-----
For a log() that returns ``NAN`` when real `x < 0`, use `numpy.log`
(note, however, that otherwise `numpy.log` and this `log` are identical,
i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`, and,
notably, the complex principle value if ``x.imag != 0``).

Examples
--------
>>> np.emath.log(np.exp(1))
1.0

Negative arguments are handled 'correctly' (recall that
``exp(log(x)) == x`` does *not* hold for real ``x < 0``):

>>> np.emath.log(-np.exp(1)) == (1 + np.pi * 1j)
True
*)

val log10 : [`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the logarithm base 10 of `x`.

Return the 'principal value' (for a description of this, see
`numpy.log10`) of :math:`log_{10}(x)`. For real `x > 0`, this
is a real number (``log10(0)`` returns ``-inf`` and ``log10(np.inf)``
returns ``inf``). Otherwise, the complex principle value is returned.

Parameters
----------
x : array_like or scalar
   The value(s) whose log base 10 is (are) required.

Returns
-------
out : ndarray or scalar
   The log base 10 of the `x` value(s). If `x` was a scalar, so is `out`,
   otherwise an array object is returned.

See Also
--------
numpy.log10

Notes
-----
For a log10() that returns ``NAN`` when real `x < 0`, use `numpy.log10`
(note, however, that otherwise `numpy.log10` and this `log10` are
identical, i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`,
and, notably, the complex principle value if ``x.imag != 0``).

Examples
--------

(We set the printing precision so the example can be auto-tested)

>>> np.set_printoptions(precision=4)

>>> np.emath.log10(10**1)
1.0

>>> np.emath.log10([-10**1, -10**2, 10**2])
array([1.+1.3644j, 2.+1.3644j, 2.+0.j    ])
*)

val log2 : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the logarithm base 2 of `x`.

Return the 'principal value' (for a description of this, see
`numpy.log2`) of :math:`log_2(x)`. For real `x > 0`, this is
a real number (``log2(0)`` returns ``-inf`` and ``log2(np.inf)`` returns
``inf``). Otherwise, the complex principle value is returned.

Parameters
----------
x : array_like
   The value(s) whose log base 2 is (are) required.

Returns
-------
out : ndarray or scalar
   The log base 2 of the `x` value(s). If `x` was a scalar, so is `out`,
   otherwise an array is returned.

See Also
--------
numpy.log2

Notes
-----
For a log2() that returns ``NAN`` when real `x < 0`, use `numpy.log2`
(note, however, that otherwise `numpy.log2` and this `log2` are
identical, i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`,
and, notably, the complex principle value if ``x.imag != 0``).

Examples
--------
We set the printing precision so the example can be auto-tested:

>>> np.set_printoptions(precision=4)

>>> np.emath.log2(8)
3.0
>>> np.emath.log2([-4, -8, 8])
array([2.+4.5324j, 3.+4.5324j, 3.+0.j    ])
*)

val logn : n:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Take log base n of x.

If `x` contains negative inputs, the answer is computed and returned in the
complex domain.

Parameters
----------
n : array_like
   The integer base(s) in which the log is taken.
x : array_like
   The value(s) whose log base `n` is (are) required.

Returns
-------
out : ndarray or scalar
   The log base `n` of the `x` value(s). If `x` was a scalar, so is
   `out`, otherwise an array is returned.

Examples
--------
>>> np.set_printoptions(precision=4)

>>> np.lib.scimath.logn(2, [4, 8])
array([2., 3.])
>>> np.lib.scimath.logn(2, [-4, -8, 8])
array([2.+4.5324j, 3.+4.5324j, 3.+0.j    ])
*)

val power : p:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return x to the power p, (x**p).

If `x` contains negative values, the output is converted to the
complex domain.

Parameters
----------
x : array_like
    The input value(s).
p : array_like of ints
    The power(s) to which `x` is raised. If `x` contains multiple values,
    `p` has to either be a scalar, or contain the same number of values
    as `x`. In the latter case, the result is
    ``x[0]**p[0], x[1]**p[1], ...``.

Returns
-------
out : ndarray or scalar
    The result of ``x**p``. If `x` and `p` are scalars, so is `out`,
    otherwise an array is returned.

See Also
--------
numpy.power

Examples
--------
>>> np.set_printoptions(precision=4)

>>> np.lib.scimath.power([2, 4], 2)
array([ 4, 16])
>>> np.lib.scimath.power([2, 4], -2)
array([0.25  ,  0.0625])
>>> np.lib.scimath.power([-2, 4], 2)
array([ 4.-0.j, 16.+0.j])
*)

val sqrt : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the square root of x.

For negative input elements, a complex value is returned
(unlike `numpy.sqrt` which returns NaN).

Parameters
----------
x : array_like
   The input value(s).

Returns
-------
out : ndarray or scalar
   The square root of `x`. If `x` was a scalar, so is `out`,
   otherwise an array is returned.

See Also
--------
numpy.sqrt

Examples
--------
For real, non-negative inputs this works just like `numpy.sqrt`:

>>> np.lib.scimath.sqrt(1)
1.0
>>> np.lib.scimath.sqrt([1, 4])
array([1.,  2.])

But it automatically handles negative inputs:

>>> np.lib.scimath.sqrt(-1)
1j
>>> np.lib.scimath.sqrt([-1,4])
array([0.+1.j, 2.+0.j])
*)


end

module Fft : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

module Helper : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

val arange : ?start:[`F of float | `I of int] -> ?step:[`F of float | `I of int] -> ?dtype:Dtype.t -> stop:[`F of float | `I of int] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arange([start,] stop[, step,], dtype=None)

Return evenly spaced values within a given interval.

Values are generated within the half-open interval ``[start, stop)``
(in other words, the interval including `start` but excluding `stop`).
For integer arguments the function is equivalent to the Python built-in
`range` function, but returns an ndarray rather than a list.

When using a non-integer step, such as 0.1, the results will often not
be consistent.  It is better to use `numpy.linspace` for these cases.

Parameters
----------
start : number, optional
    Start of interval.  The interval includes this value.  The default
    start value is 0.
stop : number
    End of interval.  The interval does not include this value, except
    in some cases where `step` is not an integer and floating point
    round-off affects the length of `out`.
step : number, optional
    Spacing between values.  For any output `out`, this is the distance
    between two adjacent values, ``out[i+1] - out[i]``.  The default
    step size is 1.  If `step` is specified as a position argument,
    `start` must also be given.
dtype : dtype
    The type of the output array.  If `dtype` is not given, infer the data
    type from the other input arguments.

Returns
-------
arange : ndarray
    Array of evenly spaced values.

    For floating point arguments, the length of the result is
    ``ceil((stop - start)/step)``.  Because of floating point overflow,
    this rule may result in the last element of `out` being greater
    than `stop`.

See Also
--------
numpy.linspace : Evenly spaced numbers with careful handling of endpoints.
numpy.ogrid: Arrays of evenly spaced numbers in N-dimensions.
numpy.mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.

Examples
--------
>>> np.arange(3)
array([0, 1, 2])
>>> np.arange(3.0)
array([ 0.,  1.,  2.])
>>> np.arange(3,7)
array([3, 4, 5, 6])
>>> np.arange(3,7,2)
array([3, 5])
*)

val array_function_dispatch : ?module_:string -> ?verify:bool -> ?docs_from_dispatcher:bool -> dispatcher:Py.Object.t -> unit -> Py.Object.t
(**
Decorator for adding dispatch with the __array_function__ protocol.

See NEP-18 for example usage.

Parameters
----------
dispatcher : callable
    Function that when called like ``dispatcher( *args, **kwargs)`` with
    arguments from the NumPy function call returns an iterable of
    array-like arguments to check for ``__array_function__``.
module : str, optional
    __module__ attribute to set on new function, e.g., ``module='numpy'``.
    By default, module is copied from the decorated function.
verify : bool, optional
    If True, verify the that the signature of the dispatcher and decorated
    function signatures match exactly: all required and optional arguments
    should appear in order with the same names, but the default values for
    all optional arguments should be ``None``. Only disable verification
    if the dispatcher's signature needs to deviate for some particular
    reason, e.g., because the function has a signature like
    ``func( *args, **kwargs)``.
docs_from_dispatcher : bool, optional
    If True, copy docs from the dispatcher function onto the dispatched
    function, rather than from the implementation. This is useful for
    functions defined in C, which otherwise don't have docstrings.

Returns
-------
Function suitable for decorating the implementation of a NumPy function.
*)

val asarray : ?dtype:Dtype.t -> ?order:[`C | `F] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Convert the input to an array.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major (C-style) or
    column-major (Fortran-style) memory representation.
    Defaults to 'C'.

Returns
-------
out : ndarray
    Array interpretation of `a`.  No copy is performed if the input
    is already an ndarray with matching dtype and order.  If `a` is a
    subclass of ndarray, a base class ndarray is returned.

See Also
--------
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array:

>>> a = [1, 2]
>>> np.asarray(a)
array([1, 2])

Existing arrays are not copied:

>>> a = np.array([1, 2])
>>> np.asarray(a) is a
True

If `dtype` is set, array is copied only if dtype does not match:

>>> a = np.array([1, 2], dtype=np.float32)
>>> np.asarray(a, dtype=np.float32) is a
True
>>> np.asarray(a, dtype=np.float64) is a
False

Contrary to `asanyarray`, ndarray subclasses are not passed through:

>>> issubclass(np.recarray, np.ndarray)
True
>>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
>>> np.asarray(a) is a
False
>>> np.asanyarray(a) is a
True
*)

val empty : ?dtype:Dtype.t -> ?order:[`C | `F] -> int list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
empty(shape, dtype=float, order='C')

Return a new array of given shape and type, without initializing entries.

Parameters
----------
shape : int or tuple of int
    Shape of the empty array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    Desired output data-type for the array, e.g, `numpy.int8`. Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: 'C'
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data of the given shape, dtype, and
    order.  Object arrays will be initialized to None.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Notes
-----
`empty`, unlike `zeros`, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.

Examples
--------
>>> np.empty([2, 2])
array([[ -9.74499359e+001,   6.69583040e-309],
       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized

>>> np.empty([2, 2], dtype=int)
array([[-1073741821, -1067949133],
       [  496041986,    19249760]])                     #uninitialized
*)

val fftfreq : ?d:[`F of float | `I of int | `Bool of bool | `S of string] -> n:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the Discrete Fourier Transform sample frequencies.

The returned float array `f` contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.

Given a window length `n` and a sample spacing `d`::

  f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d*n)   if n is even
  f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd

Parameters
----------
n : int
    Window length.
d : scalar, optional
    Sample spacing (inverse of the sampling rate). Defaults to 1.

Returns
-------
f : ndarray
    Array of length `n` containing the sample frequencies.

Examples
--------
>>> signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
>>> fourier = np.fft.fft(signal)
>>> n = signal.size
>>> timestep = 0.1
>>> freq = np.fft.fftfreq(n, d=timestep)
>>> freq
array([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])
*)

val fftshift : ?axes:[`Shape_tuple of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Shift the zero-frequency component to the center of the spectrum.

This function swaps half-spaces for all axes listed (defaults to all).
Note that ``y[0]`` is the Nyquist component only if ``len(x)`` is even.

Parameters
----------
x : array_like
    Input array.
axes : int or shape tuple, optional
    Axes over which to shift.  Default is None, which shifts all axes.

Returns
-------
y : ndarray
    The shifted array.

See Also
--------
ifftshift : The inverse of `fftshift`.

Examples
--------
>>> freqs = np.fft.fftfreq(10, 0.1)
>>> freqs
array([ 0.,  1.,  2., ..., -3., -2., -1.])
>>> np.fft.fftshift(freqs)
array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])

Shift the zero-frequency component only along the second axis:

>>> freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
>>> freqs
array([[ 0.,  1.,  2.],
       [ 3.,  4., -4.],
       [-3., -2., -1.]])
>>> np.fft.fftshift(freqs, axes=(1,))
array([[ 2.,  0.,  1.],
       [-4.,  3.,  4.],
       [-1., -3., -2.]])
*)

val ifftshift : ?axes:[`Shape_tuple of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
The inverse of `fftshift`. Although identical for even-length `x`, the
functions differ by one sample for odd-length `x`.

Parameters
----------
x : array_like
    Input array.
axes : int or shape tuple, optional
    Axes over which to calculate.  Defaults to None, which shifts all axes.

Returns
-------
y : ndarray
    The shifted array.

See Also
--------
fftshift : Shift zero-frequency component to the center of the spectrum.

Examples
--------
>>> freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
>>> freqs
array([[ 0.,  1.,  2.],
       [ 3.,  4., -4.],
       [-3., -2., -1.]])
>>> np.fft.ifftshift(np.fft.fftshift(freqs))
array([[ 0.,  1.,  2.],
       [ 3.,  4., -4.],
       [-3., -2., -1.]])
*)

val rfftfreq : ?d:[`F of float | `I of int | `Bool of bool | `S of string] -> n:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the Discrete Fourier Transform sample frequencies
(for usage with rfft, irfft).

The returned float array `f` contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.

Given a window length `n` and a sample spacing `d`::

  f = [0, 1, ...,     n/2-1,     n/2] / (d*n)   if n is even
  f = [0, 1, ..., (n-1)/2-1, (n-1)/2] / (d*n)   if n is odd

Unlike `fftfreq` (but like `scipy.fftpack.rfftfreq`)
the Nyquist frequency component is considered to be positive.

Parameters
----------
n : int
    Window length.
d : scalar, optional
    Sample spacing (inverse of the sampling rate). Defaults to 1.

Returns
-------
f : ndarray
    Array of length ``n//2 + 1`` containing the sample frequencies.

Examples
--------
>>> signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)
>>> fourier = np.fft.rfft(signal)
>>> n = signal.size
>>> sample_rate = 100
>>> freq = np.fft.fftfreq(n, d=1./sample_rate)
>>> freq
array([  0.,  10.,  20., ..., -30., -20., -10.])
>>> freq = np.fft.rfftfreq(n, d=1./sample_rate)
>>> freq
array([  0.,  10.,  20.,  30.,  40.,  50.])
*)

val roll : ?axis:int list -> shift:int list -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Roll array elements along a given axis.

Elements that roll beyond the last position are re-introduced at
the first.

Parameters
----------
a : array_like
    Input array.
shift : int or tuple of ints
    The number of places by which elements are shifted.  If a tuple,
    then `axis` must be a tuple of the same size, and each of the
    given axes is shifted by the corresponding number.  If an int
    while `axis` is a tuple of ints, then the same value is used for
    all given axes.
axis : int or tuple of ints, optional
    Axis or axes along which elements are shifted.  By default, the
    array is flattened before shifting, after which the original
    shape is restored.

Returns
-------
res : ndarray
    Output array, with the same shape as `a`.

See Also
--------
rollaxis : Roll the specified axis backwards, until it lies in a
           given position.

Notes
-----
.. versionadded:: 1.12.0

Supports rolling over multiple dimensions simultaneously.

Examples
--------
>>> x = np.arange(10)
>>> np.roll(x, 2)
array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])
>>> np.roll(x, -2)
array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])

>>> x2 = np.reshape(x, (2,5))
>>> x2
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
>>> np.roll(x2, 1)
array([[9, 0, 1, 2, 3],
       [4, 5, 6, 7, 8]])
>>> np.roll(x2, -1)
array([[1, 2, 3, 4, 5],
       [6, 7, 8, 9, 0]])
>>> np.roll(x2, 1, axis=0)
array([[5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4]])
>>> np.roll(x2, -1, axis=0)
array([[5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4]])
>>> np.roll(x2, 1, axis=1)
array([[4, 0, 1, 2, 3],
       [9, 5, 6, 7, 8]])
>>> np.roll(x2, -1, axis=1)
array([[1, 2, 3, 4, 0],
       [6, 7, 8, 9, 5]])
*)

val set_module : Py.Object.t -> Py.Object.t
(**
Decorator for overriding __module__ on a function or class.

Example usage::

    @set_module('numpy')
    def example():
        pass

    assert example.__module__ == 'numpy'
*)


end

val fft : ?n:int -> ?axis:int -> ?norm:string -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the one-dimensional discrete Fourier Transform.

This function computes the one-dimensional *n*-point discrete Fourier
Transform (DFT) with the efficient Fast Fourier Transform (FFT)
algorithm [CT].

Parameters
----------
a : array_like
    Input array, can be complex.
n : int, optional
    Length of the transformed axis of the output.
    If `n` is smaller than the length of the input, the input is cropped.
    If it is larger, the input is padded with zeros.  If `n` is not given,
    the length of the input along the axis specified by `axis` is used.
axis : int, optional
    Axis over which to compute the FFT.  If not given, the last axis is
    used.
norm : {None, 'ortho'}, optional
    .. versionadded:: 1.10.0

    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.

Raises
------
IndexError
    if `axes` is larger than the last axis of `a`.

See Also
--------
numpy.fft : for definition of the DFT and conventions used.
ifft : The inverse of `fft`.
fft2 : The two-dimensional FFT.
fftn : The *n*-dimensional FFT.
rfftn : The *n*-dimensional FFT of real input.
fftfreq : Frequency bins for given FFT parameters.

Notes
-----
FFT (Fast Fourier Transform) refers to a way the discrete Fourier
Transform (DFT) can be calculated efficiently, by using symmetries in the
calculated terms.  The symmetry is highest when `n` is a power of 2, and
the transform is therefore most efficient for these sizes.

The DFT is defined, with the conventions used in this implementation, in
the documentation for the `numpy.fft` module.

References
----------
.. [CT] Cooley, James W., and John W. Tukey, 1965, 'An algorithm for the
        machine calculation of complex Fourier series,' *Math. Comput.*
        19: 297-301.

Examples
--------
>>> np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
        2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
       -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
        1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])

In this example, real input has an FFT which is Hermitian, i.e., symmetric
in the real part and anti-symmetric in the imaginary part, as described in
the `numpy.fft` documentation:

>>> import matplotlib.pyplot as plt
>>> t = np.arange(256)
>>> sp = np.fft.fft(np.sin(t))
>>> freq = np.fft.fftfreq(t.shape[-1])
>>> plt.plot(freq, sp.real, freq, sp.imag)
[<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
>>> plt.show()
*)

val fft2 : ?s:int list -> ?axes:int list -> ?norm:string -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the 2-dimensional discrete Fourier Transform

This function computes the *n*-dimensional discrete Fourier Transform
over any axes in an *M*-dimensional array by means of the
Fast Fourier Transform (FFT).  By default, the transform is computed over
the last two axes of the input array, i.e., a 2-dimensional FFT.

Parameters
----------
a : array_like
    Input array, can be complex
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
    This corresponds to ``n`` for ``fft(x, n)``.
    Along each axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.
axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last two
    axes are used.  A repeated index in `axes` means the transform over
    that axis is performed multiple times.  A one-element sequence means
    that a one-dimensional FFT is performed.
norm : {None, 'ortho'}, optional
    .. versionadded:: 1.10.0

    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or the last two axes if `axes` is not given.

Raises
------
ValueError
    If `s` and `axes` have different length, or `axes` not given and
    ``len(s) != 2``.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
numpy.fft : Overall view of discrete Fourier transforms, with definitions
     and conventions used.
ifft2 : The inverse two-dimensional FFT.
fft : The one-dimensional FFT.
fftn : The *n*-dimensional FFT.
fftshift : Shifts zero-frequency terms to the center of the array.
    For two-dimensional input, swaps first and third quadrants, and second
    and fourth quadrants.

Notes
-----
`fft2` is just `fftn` with a different default for `axes`.

The output, analogously to `fft`, contains the term for zero frequency in
the low-order corner of the transformed axes, the positive frequency terms
in the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
the axes, in order of decreasingly negative frequency.

See `fftn` for details and a plotting example, and `numpy.fft` for
definitions and conventions used.


Examples
--------
>>> a = np.mgrid[:5, :5][0]
>>> np.fft.fft2(a)
array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ]])
*)

val fftfreq : ?d:[`F of float | `I of int | `Bool of bool | `S of string] -> n:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the Discrete Fourier Transform sample frequencies.

The returned float array `f` contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.

Given a window length `n` and a sample spacing `d`::

  f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d*n)   if n is even
  f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd

Parameters
----------
n : int
    Window length.
d : scalar, optional
    Sample spacing (inverse of the sampling rate). Defaults to 1.

Returns
-------
f : ndarray
    Array of length `n` containing the sample frequencies.

Examples
--------
>>> signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
>>> fourier = np.fft.fft(signal)
>>> n = signal.size
>>> timestep = 0.1
>>> freq = np.fft.fftfreq(n, d=timestep)
>>> freq
array([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])
*)

val fftn : ?s:int list -> ?axes:int list -> ?norm:string -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the N-dimensional discrete Fourier Transform.

This function computes the *N*-dimensional discrete Fourier Transform over
any number of axes in an *M*-dimensional array by means of the Fast Fourier
Transform (FFT).

Parameters
----------
a : array_like
    Input array, can be complex.
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
    This corresponds to ``n`` for ``fft(x, n)``.
    Along any axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.
axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last ``len(s)``
    axes are used, or all axes if `s` is also not specified.
    Repeated indices in `axes` means that the transform over that axis is
    performed multiple times.
norm : {None, 'ortho'}, optional
    .. versionadded:: 1.10.0

    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` and `a`,
    as explained in the parameters section above.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
numpy.fft : Overall view of discrete Fourier transforms, with definitions
    and conventions used.
ifftn : The inverse of `fftn`, the inverse *n*-dimensional FFT.
fft : The one-dimensional FFT, with definitions and conventions used.
rfftn : The *n*-dimensional FFT of real input.
fft2 : The two-dimensional FFT.
fftshift : Shifts zero-frequency terms to centre of array

Notes
-----
The output, analogously to `fft`, contains the term for zero frequency in
the low-order corner of all axes, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.

See `numpy.fft` for details, definitions and conventions used.

Examples
--------
>>> a = np.mgrid[:3, :3, :3][0]
>>> np.fft.fftn(a, axes=(1, 2))
array([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary
        [ 0.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j]],
       [[ 9.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j]],
       [[18.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j]]])
>>> np.fft.fftn(a, (2, 2), axes=(0, 1))
array([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary
        [ 0.+0.j,  0.+0.j,  0.+0.j]],
       [[-2.+0.j, -2.+0.j, -2.+0.j],
        [ 0.+0.j,  0.+0.j,  0.+0.j]]])

>>> import matplotlib.pyplot as plt
>>> [X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,
...                      2 * np.pi * np.arange(200) / 34)
>>> S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)
>>> FS = np.fft.fftn(S)
>>> plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))
<matplotlib.image.AxesImage object at 0x...>
>>> plt.show()
*)

val fftshift : ?axes:[`Shape_tuple of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Shift the zero-frequency component to the center of the spectrum.

This function swaps half-spaces for all axes listed (defaults to all).
Note that ``y[0]`` is the Nyquist component only if ``len(x)`` is even.

Parameters
----------
x : array_like
    Input array.
axes : int or shape tuple, optional
    Axes over which to shift.  Default is None, which shifts all axes.

Returns
-------
y : ndarray
    The shifted array.

See Also
--------
ifftshift : The inverse of `fftshift`.

Examples
--------
>>> freqs = np.fft.fftfreq(10, 0.1)
>>> freqs
array([ 0.,  1.,  2., ..., -3., -2., -1.])
>>> np.fft.fftshift(freqs)
array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])

Shift the zero-frequency component only along the second axis:

>>> freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
>>> freqs
array([[ 0.,  1.,  2.],
       [ 3.,  4., -4.],
       [-3., -2., -1.]])
>>> np.fft.fftshift(freqs, axes=(1,))
array([[ 2.,  0.,  1.],
       [-4.,  3.,  4.],
       [-1., -3., -2.]])
*)

val hfft : ?n:int -> ?axis:int -> ?norm:string -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
spectrum.

Parameters
----------
a : array_like
    The input array.
n : int, optional
    Length of the transformed axis of the output. For `n` output
    points, ``n//2 + 1`` input points are necessary.  If the input is
    longer than this, it is cropped.  If it is shorter than this, it is
    padded with zeros.  If `n` is not given, it is taken to be ``2*(m-1)``
    where ``m`` is the length of the input along the axis specified by
    `axis`.
axis : int, optional
    Axis over which to compute the FFT. If not given, the last
    axis is used.
norm : {None, 'ortho'}, optional
    Normalization mode (see `numpy.fft`). Default is None.

    .. versionadded:: 1.10.0

Returns
-------
out : ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.
    The length of the transformed axis is `n`, or, if `n` is not given,
    ``2*m - 2`` where ``m`` is the length of the transformed axis of
    the input. To get an odd number of output points, `n` must be
    specified, for instance as ``2*m - 1`` in the typical case,

Raises
------
IndexError
    If `axis` is larger than the last axis of `a`.

See also
--------
rfft : Compute the one-dimensional FFT for real input.
ihfft : The inverse of `hfft`.

Notes
-----
`hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it's `hfft` for
which you must supply the length of the result if it is to be odd.

* even: ``ihfft(hfft(a, 2*len(a) - 2) == a``, within roundoff error,
* odd: ``ihfft(hfft(a, 2*len(a) - 1) == a``, within roundoff error.

The correct interpretation of the hermitian input depends on the length of
the original data, as given by `n`. This is because each input shape could
correspond to either an odd or even length signal. By default, `hfft`
assumes an even output length which puts the last entry at the Nyquist
frequency; aliasing with its symmetric counterpart. By Hermitian symmetry,
the value is thus treated as purely real. To avoid losing information, the
shape of the full signal **must** be given.

Examples
--------
>>> signal = np.array([1, 2, 3, 4, 3, 2])
>>> np.fft.fft(signal)
array([15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j]) # may vary
>>> np.fft.hfft(signal[:4]) # Input first half of signal
array([15.,  -4.,   0.,  -1.,   0.,  -4.])
>>> np.fft.hfft(signal, 6)  # Input entire signal and truncate
array([15.,  -4.,   0.,  -1.,   0.,  -4.])


>>> signal = np.array([[1, 1.j], [-1.j, 2]])
>>> np.conj(signal.T) - signal   # check Hermitian symmetry
array([[ 0.-0.j,  -0.+0.j], # may vary
       [ 0.+0.j,  0.-0.j]])
>>> freq_spectrum = np.fft.hfft(signal)
>>> freq_spectrum
array([[ 1.,  1.],
       [ 2., -2.]])
*)

val ifft : ?n:int -> ?axis:int -> ?norm:string -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the one-dimensional inverse discrete Fourier Transform.

This function computes the inverse of the one-dimensional *n*-point
discrete Fourier transform computed by `fft`.  In other words,
``ifft(fft(a)) == a`` to within numerical accuracy.
For a general description of the algorithm and definitions,
see `numpy.fft`.

The input should be ordered in the same way as is returned by `fft`,
i.e.,

* ``a[0]`` should contain the zero frequency term,
* ``a[1:n//2]`` should contain the positive-frequency terms,
* ``a[n//2 + 1:]`` should contain the negative-frequency terms, in
  increasing order starting from the most negative frequency.

For an even number of input points, ``A[n//2]`` represents the sum of
the values at the positive and negative Nyquist frequencies, as the two
are aliased together. See `numpy.fft` for details.

Parameters
----------
a : array_like
    Input array, can be complex.
n : int, optional
    Length of the transformed axis of the output.
    If `n` is smaller than the length of the input, the input is cropped.
    If it is larger, the input is padded with zeros.  If `n` is not given,
    the length of the input along the axis specified by `axis` is used.
    See notes about padding issues.
axis : int, optional
    Axis over which to compute the inverse DFT.  If not given, the last
    axis is used.
norm : {None, 'ortho'}, optional
    .. versionadded:: 1.10.0

    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.

Raises
------
IndexError
    If `axes` is larger than the last axis of `a`.

See Also
--------
numpy.fft : An introduction, with definitions and general explanations.
fft : The one-dimensional (forward) FFT, of which `ifft` is the inverse
ifft2 : The two-dimensional inverse FFT.
ifftn : The n-dimensional inverse FFT.

Notes
-----
If the input parameter `n` is larger than the size of the input, the input
is padded by appending zeros at the end.  Even though this is the common
approach, it might lead to surprising results.  If a different padding is
desired, it must be performed before calling `ifft`.

Examples
--------
>>> np.fft.ifft([0, 4, 0, 0])
array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary

Create and plot a band-limited signal with random phases:

>>> import matplotlib.pyplot as plt
>>> t = np.arange(400)
>>> n = np.zeros((400,), dtype=complex)
>>> n[40:60] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20,)))
>>> s = np.fft.ifft(n)
>>> plt.plot(t, s.real, 'b-', t, s.imag, 'r--')
[<matplotlib.lines.Line2D object at ...>, <matplotlib.lines.Line2D object at ...>]
>>> plt.legend(('real', 'imaginary'))
<matplotlib.legend.Legend object at ...>
>>> plt.show()
*)

val ifft2 : ?s:int list -> ?axes:int list -> ?norm:string -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the 2-dimensional inverse discrete Fourier Transform.

This function computes the inverse of the 2-dimensional discrete Fourier
Transform over any number of axes in an M-dimensional array by means of
the Fast Fourier Transform (FFT).  In other words, ``ifft2(fft2(a)) == a``
to within numerical accuracy.  By default, the inverse transform is
computed over the last two axes of the input array.

The input, analogously to `ifft`, should be ordered in the same way as is
returned by `fft2`, i.e. it should have the term for zero frequency
in the low-order corner of the two axes, the positive frequency terms in
the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
both axes, in order of decreasingly negative frequency.

Parameters
----------
a : array_like
    Input array, can be complex.
s : sequence of ints, optional
    Shape (length of each axis) of the output (``s[0]`` refers to axis 0,
    ``s[1]`` to axis 1, etc.).  This corresponds to `n` for ``ifft(x, n)``.
    Along each axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.  See notes for issue on `ifft` zero padding.
axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last two
    axes are used.  A repeated index in `axes` means the transform over
    that axis is performed multiple times.  A one-element sequence means
    that a one-dimensional FFT is performed.
norm : {None, 'ortho'}, optional
    .. versionadded:: 1.10.0

    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or the last two axes if `axes` is not given.

Raises
------
ValueError
    If `s` and `axes` have different length, or `axes` not given and
    ``len(s) != 2``.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
numpy.fft : Overall view of discrete Fourier transforms, with definitions
     and conventions used.
fft2 : The forward 2-dimensional FFT, of which `ifft2` is the inverse.
ifftn : The inverse of the *n*-dimensional FFT.
fft : The one-dimensional FFT.
ifft : The one-dimensional inverse FFT.

Notes
-----
`ifft2` is just `ifftn` with a different default for `axes`.

See `ifftn` for details and a plotting example, and `numpy.fft` for
definition and conventions used.

Zero-padding, analogously with `ifft`, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before `ifft2` is called.

Examples
--------
>>> a = 4 * np.eye(4)
>>> np.fft.ifft2(a)
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],
       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])
*)

val ifftn : ?s:int list -> ?axes:int list -> ?norm:string -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the N-dimensional inverse discrete Fourier Transform.

This function computes the inverse of the N-dimensional discrete
Fourier Transform over any number of axes in an M-dimensional array by
means of the Fast Fourier Transform (FFT).  In other words,
``ifftn(fftn(a)) == a`` to within numerical accuracy.
For a description of the definitions and conventions used, see `numpy.fft`.

The input, analogously to `ifft`, should be ordered in the same way as is
returned by `fftn`, i.e. it should have the term for zero frequency
in all axes in the low-order corner, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.

Parameters
----------
a : array_like
    Input array, can be complex.
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
    This corresponds to ``n`` for ``ifft(x, n)``.
    Along any axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.  See notes for issue on `ifft` zero padding.
axes : sequence of ints, optional
    Axes over which to compute the IFFT.  If not given, the last ``len(s)``
    axes are used, or all axes if `s` is also not specified.
    Repeated indices in `axes` means that the inverse transform over that
    axis is performed multiple times.
norm : {None, 'ortho'}, optional
    .. versionadded:: 1.10.0

    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` or `a`,
    as explained in the parameters section above.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
numpy.fft : Overall view of discrete Fourier transforms, with definitions
     and conventions used.
fftn : The forward *n*-dimensional FFT, of which `ifftn` is the inverse.
ifft : The one-dimensional inverse FFT.
ifft2 : The two-dimensional inverse FFT.
ifftshift : Undoes `fftshift`, shifts zero-frequency terms to beginning
    of array.

Notes
-----
See `numpy.fft` for definitions and conventions used.

Zero-padding, analogously with `ifft`, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before `ifftn` is called.

Examples
--------
>>> a = np.eye(4)
>>> np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],
       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])


Create and plot an image with band-limited frequency content:

>>> import matplotlib.pyplot as plt
>>> n = np.zeros((200,200), dtype=complex)
>>> n[60:80, 20:40] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20, 20)))
>>> im = np.fft.ifftn(n).real
>>> plt.imshow(im)
<matplotlib.image.AxesImage object at 0x...>
>>> plt.show()
*)

val ifftshift : ?axes:[`Shape_tuple of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
The inverse of `fftshift`. Although identical for even-length `x`, the
functions differ by one sample for odd-length `x`.

Parameters
----------
x : array_like
    Input array.
axes : int or shape tuple, optional
    Axes over which to calculate.  Defaults to None, which shifts all axes.

Returns
-------
y : ndarray
    The shifted array.

See Also
--------
fftshift : Shift zero-frequency component to the center of the spectrum.

Examples
--------
>>> freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
>>> freqs
array([[ 0.,  1.,  2.],
       [ 3.,  4., -4.],
       [-3., -2., -1.]])
>>> np.fft.ifftshift(np.fft.fftshift(freqs))
array([[ 0.,  1.,  2.],
       [ 3.,  4., -4.],
       [-3., -2., -1.]])
*)

val ihfft : ?n:int -> ?axis:int -> ?norm:string -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the inverse FFT of a signal that has Hermitian symmetry.

Parameters
----------
a : array_like
    Input array.
n : int, optional
    Length of the inverse FFT, the number of points along
    transformation axis in the input to use.  If `n` is smaller than
    the length of the input, the input is cropped.  If it is larger,
    the input is padded with zeros. If `n` is not given, the length of
    the input along the axis specified by `axis` is used.
axis : int, optional
    Axis over which to compute the inverse FFT. If not given, the last
    axis is used.
norm : {None, 'ortho'}, optional
    Normalization mode (see `numpy.fft`). Default is None.

    .. versionadded:: 1.10.0

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.
    The length of the transformed axis is ``n//2 + 1``.

See also
--------
hfft, irfft

Notes
-----
`hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it's `hfft` for
which you must supply the length of the result if it is to be odd:

* even: ``ihfft(hfft(a, 2*len(a) - 2) == a``, within roundoff error,
* odd: ``ihfft(hfft(a, 2*len(a) - 1) == a``, within roundoff error.

Examples
--------
>>> spectrum = np.array([ 15, -4, 0, -1, 0, -4])
>>> np.fft.ifft(spectrum)
array([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary
>>> np.fft.ihfft(spectrum)
array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary
*)

val irfft : ?n:int -> ?axis:int -> ?norm:string -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the inverse of the n-point DFT for real input.

This function computes the inverse of the one-dimensional *n*-point
discrete Fourier Transform of real input computed by `rfft`.
In other words, ``irfft(rfft(a), len(a)) == a`` to within numerical
accuracy. (See Notes below for why ``len(a)`` is necessary here.)

The input is expected to be in the form returned by `rfft`, i.e. the
real zero-frequency term followed by the complex positive frequency terms
in order of increasing frequency.  Since the discrete Fourier Transform of
real input is Hermitian-symmetric, the negative frequency terms are taken
to be the complex conjugates of the corresponding positive frequency terms.

Parameters
----------
a : array_like
    The input array.
n : int, optional
    Length of the transformed axis of the output.
    For `n` output points, ``n//2+1`` input points are necessary.  If the
    input is longer than this, it is cropped.  If it is shorter than this,
    it is padded with zeros.  If `n` is not given, it is taken to be
    ``2*(m-1)`` where ``m`` is the length of the input along the axis
    specified by `axis`.
axis : int, optional
    Axis over which to compute the inverse FFT. If not given, the last
    axis is used.
norm : {None, 'ortho'}, optional
    .. versionadded:: 1.10.0

    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.
    The length of the transformed axis is `n`, or, if `n` is not given,
    ``2*(m-1)`` where ``m`` is the length of the transformed axis of the
    input. To get an odd number of output points, `n` must be specified.

Raises
------
IndexError
    If `axis` is larger than the last axis of `a`.

See Also
--------
numpy.fft : For definition of the DFT and conventions used.
rfft : The one-dimensional FFT of real input, of which `irfft` is inverse.
fft : The one-dimensional FFT.
irfft2 : The inverse of the two-dimensional FFT of real input.
irfftn : The inverse of the *n*-dimensional FFT of real input.

Notes
-----
Returns the real valued `n`-point inverse discrete Fourier transform
of `a`, where `a` contains the non-negative frequency terms of a
Hermitian-symmetric sequence. `n` is the length of the result, not the
input.

If you specify an `n` such that `a` must be zero-padded or truncated, the
extra/removed values will be added/removed at high frequencies. One can
thus resample a series to `m` points via Fourier interpolation by:
``a_resamp = irfft(rfft(a), m)``.

The correct interpretation of the hermitian input depends on the length of
the original data, as given by `n`. This is because each input shape could
correspond to either an odd or even length signal. By default, `irfft`
assumes an even output length which puts the last entry at the Nyquist
frequency; aliasing with its symmetric counterpart. By Hermitian symmetry,
the value is thus treated as purely real. To avoid losing information, the
correct length of the real input **must** be given.

Examples
--------
>>> np.fft.ifft([1, -1j, -1, 1j])
array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary
>>> np.fft.irfft([1, -1j, -1])
array([0.,  1.,  0.,  0.])

Notice how the last term in the input to the ordinary `ifft` is the
complex conjugate of the second term, and the output has zero imaginary
part everywhere.  When calling `irfft`, the negative frequencies are not
specified, and the output array is purely real.
*)

val irfft2 : ?s:int list -> ?axes:int list -> ?norm:string -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the 2-dimensional inverse FFT of a real array.

Parameters
----------
a : array_like
    The input array
s : sequence of ints, optional
    Shape of the real output to the inverse FFT.
axes : sequence of ints, optional
    The axes over which to compute the inverse fft.
    Default is the last two axes.
norm : {None, 'ortho'}, optional
    .. versionadded:: 1.10.0

    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : ndarray
    The result of the inverse real 2-D FFT.

See Also
--------
irfftn : Compute the inverse of the N-dimensional FFT of real input.

Notes
-----
This is really `irfftn` with different defaults.
For more details see `irfftn`.
*)

val irfftn : ?s:int list -> ?axes:int list -> ?norm:string -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the inverse of the N-dimensional FFT of real input.

This function computes the inverse of the N-dimensional discrete
Fourier Transform for real input over any number of axes in an
M-dimensional array by means of the Fast Fourier Transform (FFT).  In
other words, ``irfftn(rfftn(a), a.shape) == a`` to within numerical
accuracy. (The ``a.shape`` is necessary like ``len(a)`` is for `irfft`,
and for the same reason.)

The input should be ordered in the same way as is returned by `rfftn`,
i.e. as for `irfft` for the final transformation axis, and as for `ifftn`
along all the other axes.

Parameters
----------
a : array_like
    Input array.
s : sequence of ints, optional
    Shape (length of each transformed axis) of the output
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.). `s` is also the
    number of input points used along this axis, except for the last axis,
    where ``s[-1]//2+1`` points of the input are used.
    Along any axis, if the shape indicated by `s` is smaller than that of
    the input, the input is cropped.  If it is larger, the input is padded
    with zeros. If `s` is not given, the shape of the input along the axes
    specified by axes is used. Except for the last axis which is taken to be
    ``2*(m-1)`` where ``m`` is the length of the input along that axis.
axes : sequence of ints, optional
    Axes over which to compute the inverse FFT. If not given, the last
    `len(s)` axes are used, or all axes if `s` is also not specified.
    Repeated indices in `axes` means that the inverse transform over that
    axis is performed multiple times.
norm : {None, 'ortho'}, optional
    .. versionadded:: 1.10.0

    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` or `a`,
    as explained in the parameters section above.
    The length of each transformed axis is as given by the corresponding
    element of `s`, or the length of the input in every axis except for the
    last one if `s` is not given.  In the final transformed axis the length
    of the output when `s` is not given is ``2*(m-1)`` where ``m`` is the
    length of the final transformed axis of the input.  To get an odd
    number of output points in the final axis, `s` must be specified.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
rfftn : The forward n-dimensional FFT of real input,
        of which `ifftn` is the inverse.
fft : The one-dimensional FFT, with definitions and conventions used.
irfft : The inverse of the one-dimensional FFT of real input.
irfft2 : The inverse of the two-dimensional FFT of real input.

Notes
-----
See `fft` for definitions and conventions used.

See `rfft` for definitions and conventions used for real input.

The correct interpretation of the hermitian input depends on the shape of
the original data, as given by `s`. This is because each input shape could
correspond to either an odd or even length signal. By default, `irfftn`
assumes an even output length which puts the last entry at the Nyquist
frequency; aliasing with its symmetric counterpart. When performing the
final complex to real transform, the last value is thus treated as purely
real. To avoid losing information, the correct shape of the real input
**must** be given.

Examples
--------
>>> a = np.zeros((3, 2, 2))
>>> a[0, 0, 0] = 3 * 2 * 2
>>> np.fft.irfftn(a)
array([[[1.,  1.],
        [1.,  1.]],
       [[1.,  1.],
        [1.,  1.]],
       [[1.,  1.],
        [1.,  1.]]])
*)

val rfft : ?n:int -> ?axis:int -> ?norm:string -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the one-dimensional discrete Fourier Transform for real input.

This function computes the one-dimensional *n*-point discrete Fourier
Transform (DFT) of a real-valued array by means of an efficient algorithm
called the Fast Fourier Transform (FFT).

Parameters
----------
a : array_like
    Input array
n : int, optional
    Number of points along transformation axis in the input to use.
    If `n` is smaller than the length of the input, the input is cropped.
    If it is larger, the input is padded with zeros. If `n` is not given,
    the length of the input along the axis specified by `axis` is used.
axis : int, optional
    Axis over which to compute the FFT. If not given, the last axis is
    used.
norm : {None, 'ortho'}, optional
    .. versionadded:: 1.10.0

    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axis
    indicated by `axis`, or the last one if `axis` is not specified.
    If `n` is even, the length of the transformed axis is ``(n/2)+1``.
    If `n` is odd, the length is ``(n+1)/2``.

Raises
------
IndexError
    If `axis` is larger than the last axis of `a`.

See Also
--------
numpy.fft : For definition of the DFT and conventions used.
irfft : The inverse of `rfft`.
fft : The one-dimensional FFT of general (complex) input.
fftn : The *n*-dimensional FFT.
rfftn : The *n*-dimensional FFT of real input.

Notes
-----
When the DFT is computed for purely real input, the output is
Hermitian-symmetric, i.e. the negative frequency terms are just the complex
conjugates of the corresponding positive-frequency terms, and the
negative-frequency terms are therefore redundant.  This function does not
compute the negative frequency terms, and the length of the transformed
axis of the output is therefore ``n//2 + 1``.

When ``A = rfft(a)`` and fs is the sampling frequency, ``A[0]`` contains
the zero-frequency term 0*fs, which is real due to Hermitian symmetry.

If `n` is even, ``A[-1]`` contains the term representing both positive
and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely
real. If `n` is odd, there is no term at fs/2; ``A[-1]`` contains
the largest positive frequency (fs/2*(n-1)/n), and is complex in the
general case.

If the input `a` contains an imaginary part, it is silently discarded.

Examples
--------
>>> np.fft.fft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary
>>> np.fft.rfft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary

Notice how the final element of the `fft` output is the complex conjugate
of the second element, for real input. For `rfft`, this symmetry is
exploited to compute only the non-negative frequency terms.
*)

val rfft2 : ?s:int list -> ?axes:int list -> ?norm:string -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the 2-dimensional FFT of a real array.

Parameters
----------
a : array
    Input array, taken to be real.
s : sequence of ints, optional
    Shape of the FFT.
axes : sequence of ints, optional
    Axes over which to compute the FFT.
norm : {None, 'ortho'}, optional
    .. versionadded:: 1.10.0

    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : ndarray
    The result of the real 2-D FFT.

See Also
--------
rfftn : Compute the N-dimensional discrete Fourier Transform for real
        input.

Notes
-----
This is really just `rfftn` with different default behavior.
For more details see `rfftn`.
*)

val rfftfreq : ?d:[`F of float | `I of int | `Bool of bool | `S of string] -> n:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the Discrete Fourier Transform sample frequencies
(for usage with rfft, irfft).

The returned float array `f` contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.

Given a window length `n` and a sample spacing `d`::

  f = [0, 1, ...,     n/2-1,     n/2] / (d*n)   if n is even
  f = [0, 1, ..., (n-1)/2-1, (n-1)/2] / (d*n)   if n is odd

Unlike `fftfreq` (but like `scipy.fftpack.rfftfreq`)
the Nyquist frequency component is considered to be positive.

Parameters
----------
n : int
    Window length.
d : scalar, optional
    Sample spacing (inverse of the sampling rate). Defaults to 1.

Returns
-------
f : ndarray
    Array of length ``n//2 + 1`` containing the sample frequencies.

Examples
--------
>>> signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)
>>> fourier = np.fft.rfft(signal)
>>> n = signal.size
>>> sample_rate = 100
>>> freq = np.fft.fftfreq(n, d=1./sample_rate)
>>> freq
array([  0.,  10.,  20., ..., -30., -20., -10.])
>>> freq = np.fft.rfftfreq(n, d=1./sample_rate)
>>> freq
array([  0.,  10.,  20.,  30.,  40.,  50.])
*)

val rfftn : ?s:int list -> ?axes:int list -> ?norm:string -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the N-dimensional discrete Fourier Transform for real input.

This function computes the N-dimensional discrete Fourier Transform over
any number of axes in an M-dimensional real array by means of the Fast
Fourier Transform (FFT).  By default, all axes are transformed, with the
real transform performed over the last axis, while the remaining
transforms are complex.

Parameters
----------
a : array_like
    Input array, taken to be real.
s : sequence of ints, optional
    Shape (length along each transformed axis) to use from the input.
    (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
    The final element of `s` corresponds to `n` for ``rfft(x, n)``, while
    for the remaining axes, it corresponds to `n` for ``fft(x, n)``.
    Along any axis, if the given shape is smaller than that of the input,
    the input is cropped.  If it is larger, the input is padded with zeros.
    if `s` is not given, the shape of the input along the axes specified
    by `axes` is used.
axes : sequence of ints, optional
    Axes over which to compute the FFT.  If not given, the last ``len(s)``
    axes are used, or all axes if `s` is also not specified.
norm : {None, 'ortho'}, optional
    .. versionadded:: 1.10.0

    Normalization mode (see `numpy.fft`). Default is None.

Returns
-------
out : complex ndarray
    The truncated or zero-padded input, transformed along the axes
    indicated by `axes`, or by a combination of `s` and `a`,
    as explained in the parameters section above.
    The length of the last axis transformed will be ``s[-1]//2+1``,
    while the remaining transformed axes will have lengths according to
    `s`, or unchanged from the input.

Raises
------
ValueError
    If `s` and `axes` have different length.
IndexError
    If an element of `axes` is larger than than the number of axes of `a`.

See Also
--------
irfftn : The inverse of `rfftn`, i.e. the inverse of the n-dimensional FFT
     of real input.
fft : The one-dimensional FFT, with definitions and conventions used.
rfft : The one-dimensional FFT of real input.
fftn : The n-dimensional FFT.
rfft2 : The two-dimensional FFT of real input.

Notes
-----
The transform for real input is performed over the last transformation
axis, as by `rfft`, then the transform over the remaining axes is
performed as by `fftn`.  The order of the output is as for `rfft` for the
final transformation axis, and as for `fftn` for the remaining
transformation axes.

See `fft` for details, definitions and conventions used.

Examples
--------
>>> a = np.ones((2, 2, 2))
>>> np.fft.rfftn(a)
array([[[8.+0.j,  0.+0.j], # may vary
        [0.+0.j,  0.+0.j]],
       [[0.+0.j,  0.+0.j],
        [0.+0.j,  0.+0.j]]])

>>> np.fft.rfftn(a, axes=(2, 0))
array([[[4.+0.j,  0.+0.j], # may vary
        [4.+0.j,  0.+0.j]],
       [[0.+0.j,  0.+0.j],
        [0.+0.j,  0.+0.j]]])
*)


end

module Linalg : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

module LinAlgError : sig
type tag = [`LinAlgError]
type t = [`BaseException | `LinAlgError | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Lapack_lite : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

module LapackError : sig
type tag = [`LapackError]
type t = [`BaseException | `LapackError | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end


end

module Linalg : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

val abs : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Calculate the absolute value element-wise.

``np.abs`` is a shorthand for this function.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
absolute : ndarray
    An ndarray containing the absolute value of
    each element in `x`.  For complex input, ``a + ib``, the
    absolute value is :math:`\sqrt{ a^2 + b^2 }`.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> x = np.array([-1.2, 1.2])
>>> np.absolute(x)
array([ 1.2,  1.2])
>>> np.absolute(1.2 + 1j)
1.5620499351813308

Plot the function over ``[-10, 10]``:

>>> import matplotlib.pyplot as plt

>>> x = np.linspace(start=-10, stop=10, num=101)
>>> plt.plot(x, np.absolute(x))
>>> plt.show()

Plot the function over the complex plane:

>>> xx = x + 1j * x[:, np.newaxis]
>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
>>> plt.show()
*)

val add : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Add arguments element-wise.

Parameters
----------
x1, x2 : array_like
    The arrays to be added. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
add : ndarray or scalar
    The sum of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
Equivalent to `x1` + `x2` in terms of array broadcasting.

Examples
--------
>>> np.add(1.0, 4.0)
5.0
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.add(x1, x2)
array([[  0.,   2.,   4.],
       [  3.,   5.,   7.],
       [  6.,   8.,  10.]])
*)

val all : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Test whether all array elements along a given axis evaluate to True.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : None or int or tuple of ints, optional
    Axis or axes along which a logical AND reduction is performed.
    The default (``axis=None``) is to perform a logical AND over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a reduction is performed on multiple
    axes, instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternate output array in which to place the result.
    It must have the same shape as the expected output and its
    type is preserved (e.g., if ``dtype(out)`` is float, the result
    will consist of 0.0's and 1.0's). See `ufuncs-output-type` for more
    details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `all` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
all : ndarray, bool
    A new boolean or array is returned unless `out` is specified,
    in which case a reference to `out` is returned.

See Also
--------
ndarray.all : equivalent method

any : Test whether any element along a given axis evaluates to True.

Notes
-----
Not a Number (NaN), positive infinity and negative infinity
evaluate to `True` because these are not equal to zero.

Examples
--------
>>> np.all([[True,False],[True,True]])
False

>>> np.all([[True,False],[True,True]], axis=0)
array([ True, False])

>>> np.all([-1, 4, 5])
True

>>> np.all([1.0, np.nan])
True

>>> o=np.array(False)
>>> z=np.all([-1, 4, 5], out=o)
>>> id(z), id(o), z
(28293632, 28293632, array(True)) # may vary
*)

val amax : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> ?initial:[`F of float | `I of int | `Bool of bool | `S of string] -> ?where:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the maximum of an array or maximum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, the maximum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `amax` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

initial : scalar, optional
    The minimum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to compare for the maximum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.17.0

Returns
-------
amax : ndarray or scalar
    Maximum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amin :
    The minimum value of an array along a given axis, propagating any NaNs.
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
argmax :
    Return the indices of the maximum values.

nanmin, minimum, fmin

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.

Don't use `amax` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
``amax(a, axis=0)``.

Examples
--------
>>> a = np.arange(4).reshape((2,2))
>>> a
array([[0, 1],
       [2, 3]])
>>> np.amax(a)           # Maximum of the flattened array
3
>>> np.amax(a, axis=0)   # Maxima along the first axis
array([2, 3])
>>> np.amax(a, axis=1)   # Maxima along the second axis
array([1, 3])
>>> np.amax(a, where=[False, True], initial=-1, axis=0)
array([-1,  3])
>>> b = np.arange(5, dtype=float)
>>> b[2] = np.NaN
>>> np.amax(b)
nan
>>> np.amax(b, where=~np.isnan(b), initial=-1)
4.0
>>> np.nanmax(b)
4.0

You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:

>>> np.max([[-50], [10]], axis=-1, initial=0)
array([ 0, 10])

Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.

>>> np.max([5], initial=6)
6
>>> max([5], default=6)
5
*)

val amin : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> ?initial:[`F of float | `I of int | `Bool of bool | `S of string] -> ?where:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the minimum of an array or minimum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, the minimum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `amin` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

initial : scalar, optional
    The maximum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to compare for the minimum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.17.0

Returns
-------
amin : ndarray or scalar
    Minimum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amax :
    The maximum value of an array along a given axis, propagating any NaNs.
nanmin :
    The minimum value of an array along a given axis, ignoring any NaNs.
minimum :
    Element-wise minimum of two arrays, propagating any NaNs.
fmin :
    Element-wise minimum of two arrays, ignoring any NaNs.
argmin :
    Return the indices of the minimum values.

nanmax, maximum, fmax

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.

Don't use `amin` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
``amin(a, axis=0)``.

Examples
--------
>>> a = np.arange(4).reshape((2,2))
>>> a
array([[0, 1],
       [2, 3]])
>>> np.amin(a)           # Minimum of the flattened array
0
>>> np.amin(a, axis=0)   # Minima along the first axis
array([0, 1])
>>> np.amin(a, axis=1)   # Minima along the second axis
array([0, 2])
>>> np.amin(a, where=[False, True], initial=10, axis=0)
array([10,  1])

>>> b = np.arange(5, dtype=float)
>>> b[2] = np.NaN
>>> np.amin(b)
nan
>>> np.amin(b, where=~np.isnan(b), initial=10)
0.0
>>> np.nanmin(b)
0.0

>>> np.min([[-50], [10]], axis=-1, initial=0)
array([-50,   0])

Notice that the initial value is used as one of the elements for which the
minimum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.

Notice that this isn't the same as Python's ``default`` argument.

>>> np.min([6], initial=5)
5
>>> min([6], default=5)
6
*)

val array : ?dtype:Dtype.t -> ?copy:bool -> ?order:[`K | `A | `C | `F] -> ?subok:bool -> ?ndmin:int -> object_:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)

Create an array.

Parameters
----------
object : array_like
    An array, any object exposing the array interface, an object whose
    __array__ method returns an array, or any (nested) sequence.
dtype : data-type, optional
    The desired data-type for the array.  If not given, then the type will
    be determined as the minimum type required to hold the objects in the
    sequence.
copy : bool, optional
    If true (default), then the object is copied.  Otherwise, a copy will
    only be made if __array__ returns a copy, if obj is a nested sequence,
    or if a copy is needed to satisfy any of the other requirements
    (`dtype`, `order`, etc.).
order : {'K', 'A', 'C', 'F'}, optional
    Specify the memory layout of the array. If object is not an array, the
    newly created array will be in C order (row major) unless 'F' is
    specified, in which case it will be in Fortran order (column major).
    If object is an array the following holds.

    ===== ========= ===================================================
    order  no copy                     copy=True
    ===== ========= ===================================================
    'K'   unchanged F & C order preserved, otherwise most similar order
    'A'   unchanged F order if input is F and not C, otherwise C order
    'C'   C order   C order
    'F'   F order   F order
    ===== ========= ===================================================

    When ``copy=False`` and a copy is made for other reasons, the result is
    the same as if ``copy=True``, with some exceptions for `A`, see the
    Notes section. The default order is 'K'.
subok : bool, optional
    If True, then sub-classes will be passed-through, otherwise
    the returned array will be forced to be a base-class array (default).
ndmin : int, optional
    Specifies the minimum number of dimensions that the resulting
    array should have.  Ones will be pre-pended to the shape as
    needed to meet this requirement.

Returns
-------
out : ndarray
    An array object satisfying the specified requirements.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Notes
-----
When order is 'A' and `object` is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.

Examples
--------
>>> np.array([1, 2, 3])
array([1, 2, 3])

Upcasting:

>>> np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])

More than one dimension:

>>> np.array([[1, 2], [3, 4]])
array([[1, 2],
       [3, 4]])

Minimum dimensions 2:

>>> np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])

Type provided:

>>> np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])

Data-type consisting of more than one element:

>>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])
>>> x['a']
array([1, 3])

Creating an array from sub-classes:

>>> np.array(np.mat('1 2; 3 4'))
array([[1, 2],
       [3, 4]])

>>> np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
        [3, 4]])
*)

val array_function_dispatch : ?module_:Py.Object.t -> ?verify:Py.Object.t -> ?docs_from_dispatcher:Py.Object.t -> dispatcher:Py.Object.t -> unit -> Py.Object.t
(**
partial(func, *args, **keywords) - new function with partial application
of the given arguments and keywords.
*)

val asanyarray : ?dtype:Dtype.t -> ?order:[`C | `F] -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Convert the input to an ndarray, but pass ndarray subclasses through.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes scalars, lists, lists of tuples, tuples, tuples of tuples,
    tuples of lists, and ndarrays.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major (C-style) or column-major
    (Fortran-style) memory representation.  Defaults to 'C'.

Returns
-------
out : ndarray or an ndarray subclass
    Array interpretation of `a`.  If `a` is an ndarray or a subclass
    of ndarray, it is returned as-is and no copy is performed.

See Also
--------
asarray : Similar function which always returns ndarrays.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
asarray_chkfinite : Similar function which checks input for NaNs and
                    Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array:

>>> a = [1, 2]
>>> np.asanyarray(a)
array([1, 2])

Instances of `ndarray` subclasses are passed through as-is:

>>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
>>> np.asanyarray(a) is a
True
*)

val asarray : ?dtype:Dtype.t -> ?order:[`C | `F] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Convert the input to an array.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major (C-style) or
    column-major (Fortran-style) memory representation.
    Defaults to 'C'.

Returns
-------
out : ndarray
    Array interpretation of `a`.  No copy is performed if the input
    is already an ndarray with matching dtype and order.  If `a` is a
    subclass of ndarray, a base class ndarray is returned.

See Also
--------
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array:

>>> a = [1, 2]
>>> np.asarray(a)
array([1, 2])

Existing arrays are not copied:

>>> a = np.array([1, 2])
>>> np.asarray(a) is a
True

If `dtype` is set, array is copied only if dtype does not match:

>>> a = np.array([1, 2], dtype=np.float32)
>>> np.asarray(a, dtype=np.float32) is a
True
>>> np.asarray(a, dtype=np.float64) is a
False

Contrary to `asanyarray`, ndarray subclasses are not passed through:

>>> issubclass(np.recarray, np.ndarray)
True
>>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
>>> np.asarray(a) is a
False
>>> np.asanyarray(a) is a
True
*)

val atleast_2d : Py.Object.t list -> Py.Object.t
(**
View inputs as arrays with at least two dimensions.

Parameters
----------
arys1, arys2, ... : array_like
    One or more array-like sequences.  Non-array inputs are converted
    to arrays.  Arrays that already have two or more dimensions are
    preserved.

Returns
-------
res, res2, ... : ndarray
    An array, or list of arrays, each with ``a.ndim >= 2``.
    Copies are avoided where possible, and views with two or more
    dimensions are returned.

See Also
--------
atleast_1d, atleast_3d

Examples
--------
>>> np.atleast_2d(3.0)
array([[3.]])

>>> x = np.arange(3.0)
>>> np.atleast_2d(x)
array([[0., 1., 2.]])
>>> np.atleast_2d(x).base is x
True

>>> np.atleast_2d(1, [1, 2], [[1, 2]])
[array([[1]]), array([[1, 2]]), array([[1, 2]])]
*)

val cholesky : Py.Object.t -> Py.Object.t
(**
Cholesky decomposition.

Return the Cholesky decomposition, `L * L.H`, of the square matrix `a`,
where `L` is lower-triangular and .H is the conjugate transpose operator
(which is the ordinary transpose if `a` is real-valued).  `a` must be
Hermitian (symmetric if real-valued) and positive-definite.  Only `L` is
actually returned.

Parameters
----------
a : (..., M, M) array_like
    Hermitian (symmetric if all elements are real), positive-definite
    input matrix.

Returns
-------
L : (..., M, M) array_like
    Upper or lower-triangular Cholesky factor of `a`.  Returns a
    matrix object if `a` is a matrix object.

Raises
------
LinAlgError
   If the decomposition fails, for example, if `a` is not
   positive-definite.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The Cholesky decomposition is often used as a fast way of solving

.. math:: A \mathbf{x} = \mathbf{b}

(when `A` is both Hermitian/symmetric and positive-definite).

First, we solve for :math:`\mathbf{y}` in

.. math:: L \mathbf{y} = \mathbf{b},

and then for :math:`\mathbf{x}` in

.. math:: L.H \mathbf{x} = \mathbf{y}.

Examples
--------
>>> A = np.array([[1,-2j],[2j,5]])
>>> A
array([[ 1.+0.j, -0.-2.j],
       [ 0.+2.j,  5.+0.j]])
>>> L = np.linalg.cholesky(A)
>>> L
array([[1.+0.j, 0.+0.j],
       [0.+2.j, 1.+0.j]])
>>> np.dot(L, L.T.conj()) # verify that L * L.H = A
array([[1.+0.j, 0.-2.j],
       [0.+2.j, 5.+0.j]])
>>> A = [[1,-2j],[2j,5]] # what happens if A is only array_like?
>>> np.linalg.cholesky(A) # an ndarray object is returned
array([[1.+0.j, 0.+0.j],
       [0.+2.j, 1.+0.j]])
>>> # But a matrix object is returned if A is a matrix object
>>> np.linalg.cholesky(np.matrix(A))
matrix([[ 1.+0.j,  0.+0.j],
        [ 0.+2.j,  1.+0.j]])
*)

val cond : ?p:[`Two | `One | `Fro | `PyObject of Py.Object.t] -> Py.Object.t -> Py.Object.t
(**
Compute the condition number of a matrix.

This function is capable of returning the condition number using
one of seven different norms, depending on the value of `p` (see
Parameters below).

Parameters
----------
x : (..., M, N) array_like
    The matrix whose condition number is sought.
p : {None, 1, -1, 2, -2, inf, -inf, 'fro'}, optional
    Order of the norm:

    =====  ============================
    p      norm for matrices
    =====  ============================
    None   2-norm, computed directly using the ``SVD``
    'fro'  Frobenius norm
    inf    max(sum(abs(x), axis=1))
    -inf   min(sum(abs(x), axis=1))
    1      max(sum(abs(x), axis=0))
    -1     min(sum(abs(x), axis=0))
    2      2-norm (largest sing. value)
    -2     smallest singular value
    =====  ============================

    inf means the numpy.inf object, and the Frobenius norm is
    the root-of-sum-of-squares norm.

Returns
-------
c : {float, inf}
    The condition number of the matrix. May be infinite.

See Also
--------
numpy.linalg.norm

Notes
-----
The condition number of `x` is defined as the norm of `x` times the
norm of the inverse of `x` [1]_; the norm can be the usual L2-norm
(root-of-sum-of-squares) or one of a number of other matrix norms.

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, Orlando, FL,
       Academic Press, Inc., 1980, pg. 285.

Examples
--------
>>> from numpy import linalg as LA
>>> a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])
>>> a
array([[ 1,  0, -1],
       [ 0,  1,  0],
       [ 1,  0,  1]])
>>> LA.cond(a)
1.4142135623730951
>>> LA.cond(a, 'fro')
3.1622776601683795
>>> LA.cond(a, np.inf)
2.0
>>> LA.cond(a, -np.inf)
1.0
>>> LA.cond(a, 1)
2.0
>>> LA.cond(a, -1)
1.0
>>> LA.cond(a, 2)
1.4142135623730951
>>> LA.cond(a, -2)
0.70710678118654746 # may vary
>>> min(LA.svd(a, compute_uv=False))*min(LA.svd(LA.inv(a), compute_uv=False))
0.70710678118654746 # may vary
*)

val count_nonzero : ?axis:[`Tuple of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Counts the number of non-zero values in the array ``a``.

The word 'non-zero' is in reference to the Python 2.x
built-in method ``__nonzero__()`` (renamed ``__bool__()``
in Python 3.x) of Python objects that tests an object's
'truthfulness'. For example, any number is considered
truthful if it is nonzero, whereas any string is considered
truthful if it is not the empty string. Thus, this function
(recursively) counts how many elements in ``a`` (and in
sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``
method evaluated to ``True``.

Parameters
----------
a : array_like
    The array for which to count non-zeros.
axis : int or tuple, optional
    Axis or tuple of axes along which to count non-zeros.
    Default is None, meaning that non-zeros will be counted
    along a flattened version of ``a``.

    .. versionadded:: 1.12.0

Returns
-------
count : int or array of int
    Number of non-zero values in the array along a given axis.
    Otherwise, the total number of non-zero values in the array
    is returned.

See Also
--------
nonzero : Return the coordinates of all the non-zero values.

Examples
--------
>>> np.count_nonzero(np.eye(4))
4
>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])
5
>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=0)
array([1, 1, 1, 1, 1])
>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=1)
array([2, 3])
*)

val det : Py.Object.t -> Py.Object.t
(**
Compute the determinant of an array.

Parameters
----------
a : (..., M, M) array_like
    Input array to compute determinants for.

Returns
-------
det : (...) array_like
    Determinant of `a`.

See Also
--------
slogdet : Another way to represent the determinant, more suitable
  for large matrices where underflow/overflow may occur.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The determinant is computed via LU factorization using the LAPACK
routine ``z/dgetrf``.

Examples
--------
The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:

>>> a = np.array([[1, 2], [3, 4]])
>>> np.linalg.det(a)
-2.0 # may vary

Computing determinants for a stack of matrices:

>>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
>>> a.shape
(3, 2, 2)
>>> np.linalg.det(a)
array([-2., -3., -8.])
*)

val divide : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Returns a true division of the inputs, element-wise.

Instead of the Python traditional 'floor division', this returns a true
division.  True division adjusts the output type to present the best
answer, regardless of input types.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
The floor division operator ``//`` was added in Python 2.2 making
``//`` and ``/`` equivalent operators.  The default floor division
operation of ``/`` can be replaced by true division with ``from
__future__ import division``.

In Python 3.0, ``//`` is the floor division operator and ``/`` the
true division operator.  The ``true_divide(x1, x2)`` function is
equivalent to true division in Python.

Examples
--------
>>> x = np.arange(5)
>>> np.true_divide(x, 4)
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])

>>> x//4
array([0, 0, 0, 0, 1])

>>> from __future__ import division
>>> x/4
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
>>> x//4
array([0, 0, 0, 0, 1])
*)

val dot : ?out:[>`Ndarray] Obj.t -> b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
dot(a, b, out=None)

Dot product of two arrays. Specifically,

- If both `a` and `b` are 1-D arrays, it is inner product of vectors
  (without complex conjugation).

- If both `a` and `b` are 2-D arrays, it is matrix multiplication,
  but using :func:`matmul` or ``a @ b`` is preferred.

- If either `a` or `b` is 0-D (scalar), it is equivalent to :func:`multiply`
  and using ``numpy.multiply(a, b)`` or ``a * b`` is preferred.

- If `a` is an N-D array and `b` is a 1-D array, it is a sum product over
  the last axis of `a` and `b`.

- If `a` is an N-D array and `b` is an M-D array (where ``M>=2``), it is a
  sum product over the last axis of `a` and the second-to-last axis of `b`::

    dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])

Parameters
----------
a : array_like
    First argument.
b : array_like
    Second argument.
out : ndarray, optional
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for `dot(a,b)`. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.

Returns
-------
output : ndarray
    Returns the dot product of `a` and `b`.  If `a` and `b` are both
    scalars or both 1-D arrays then a scalar is returned; otherwise
    an array is returned.
    If `out` is given, then it is returned.

Raises
------
ValueError
    If the last dimension of `a` is not the same size as
    the second-to-last dimension of `b`.

See Also
--------
vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : '@' operator as method with out parameter.

Examples
--------
>>> np.dot(3, 4)
12

Neither argument is complex-conjugated:

>>> np.dot([2j, 3j], [2j, 3j])
(-13+0j)

For 2-D arrays it is the matrix product:

>>> a = [[1, 0], [0, 1]]
>>> b = [[4, 1], [2, 2]]
>>> np.dot(a, b)
array([[4, 1],
       [2, 2]])

>>> a = np.arange(3*4*5*6).reshape((3,4,5,6))
>>> b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
>>> np.dot(a, b)[2,3,2,1,2,2]
499128
>>> sum(a[2,3,2,:] * b[1,2,:,2])
499128
*)

val eig : Py.Object.t -> (Py.Object.t * Py.Object.t)
(**
Compute the eigenvalues and right eigenvectors of a square array.

Parameters
----------
a : (..., M, M) array
    Matrices for which the eigenvalues and right eigenvectors will
    be computed

Returns
-------
w : (..., M) array
    The eigenvalues, each repeated according to its multiplicity.
    The eigenvalues are not necessarily ordered. The resulting
    array will be of complex type, unless the imaginary part is
    zero in which case it will be cast to a real type. When `a`
    is real the resulting eigenvalues will be real (0 imaginary
    part) or occur in conjugate pairs

v : (..., M, M) array
    The normalized (unit 'length') eigenvectors, such that the
    column ``v[:,i]`` is the eigenvector corresponding to the
    eigenvalue ``w[i]``.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eigvals : eigenvalues of a non-symmetric array.

eigh : eigenvalues and eigenvectors of a real symmetric or complex
       Hermitian (conjugate symmetric) array.

eigvalsh : eigenvalues of a real symmetric or complex Hermitian
           (conjugate symmetric) array.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

This is implemented using the ``_geev`` LAPACK routines which compute
the eigenvalues and eigenvectors of general square arrays.

The number `w` is an eigenvalue of `a` if there exists a vector
`v` such that ``dot(a,v) = w * v``. Thus, the arrays `a`, `w`, and
`v` satisfy the equations ``dot(a[:,:], v[:,i]) = w[i] * v[:,i]``
for :math:`i \in \{0,...,M-1\}`.

The array `v` of eigenvectors may not be of maximum rank, that is, some
of the columns may be linearly dependent, although round-off error may
obscure that fact. If the eigenvalues are all different, then theoretically
the eigenvectors are linearly independent. Likewise, the (complex-valued)
matrix of eigenvectors `v` is unitary if the matrix `a` is normal, i.e.,
if ``dot(a, a.H) = dot(a.H, a)``, where `a.H` denotes the conjugate
transpose of `a`.

Finally, it is emphasized that `v` consists of the *right* (as in
right-hand side) eigenvectors of `a`.  A vector `y` satisfying
``dot(y.T, a) = z * y.T`` for some number `z` is called a *left*
eigenvector of `a`, and, in general, the left and right eigenvectors
of a matrix are not necessarily the (perhaps conjugate) transposes
of each other.

References
----------
G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando, FL,
Academic Press, Inc., 1980, Various pp.

Examples
--------
>>> from numpy import linalg as LA

(Almost) trivial example with real e-values and e-vectors.

>>> w, v = LA.eig(np.diag((1, 2, 3)))
>>> w; v
array([1., 2., 3.])
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])

Real matrix possessing complex e-values and e-vectors; note that the
e-values are complex conjugates of each other.

>>> w, v = LA.eig(np.array([[1, -1], [1, 1]]))
>>> w; v
array([1.+1.j, 1.-1.j])
array([[0.70710678+0.j        , 0.70710678-0.j        ],
       [0.        -0.70710678j, 0.        +0.70710678j]])

Complex-valued matrix with real e-values (but complex-valued e-vectors);
note that ``a.conj().T == a``, i.e., `a` is Hermitian.

>>> a = np.array([[1, 1j], [-1j, 1]])
>>> w, v = LA.eig(a)
>>> w; v
array([2.+0.j, 0.+0.j])
array([[ 0.        +0.70710678j,  0.70710678+0.j        ], # may vary
       [ 0.70710678+0.j        , -0.        +0.70710678j]])

Be careful about round-off error!

>>> a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])
>>> # Theor. e-values are 1 +/- 1e-9
>>> w, v = LA.eig(a)
>>> w; v
array([1., 1.])
array([[1., 0.],
       [0., 1.]])
*)

val eigh : ?uplo:[`L | `U] -> Py.Object.t -> (Py.Object.t * Py.Object.t)
(**
Return the eigenvalues and eigenvectors of a complex Hermitian
(conjugate symmetric) or a real symmetric matrix.

Returns two objects, a 1-D array containing the eigenvalues of `a`, and
a 2-D square array or matrix (depending on the input type) of the
corresponding eigenvectors (in columns).

Parameters
----------
a : (..., M, M) array
    Hermitian or real symmetric matrices whose eigenvalues and
    eigenvectors are to be computed.
UPLO : {'L', 'U'}, optional
    Specifies whether the calculation is done with the lower triangular
    part of `a` ('L', default) or the upper triangular part ('U').
    Irrespective of this value only the real parts of the diagonal will
    be considered in the computation to preserve the notion of a Hermitian
    matrix. It therefore follows that the imaginary part of the diagonal
    will always be treated as zero.

Returns
-------
w : (..., M) ndarray
    The eigenvalues in ascending order, each repeated according to
    its multiplicity.
v : {(..., M, M) ndarray, (..., M, M) matrix}
    The column ``v[:, i]`` is the normalized eigenvector corresponding
    to the eigenvalue ``w[i]``.  Will return a matrix object if `a` is
    a matrix object.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eigvalsh : eigenvalues of real symmetric or complex Hermitian
           (conjugate symmetric) arrays.
eig : eigenvalues and right eigenvectors for non-symmetric arrays.
eigvals : eigenvalues of non-symmetric arrays.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The eigenvalues/eigenvectors are computed using LAPACK routines ``_syevd``,
``_heevd``.

The eigenvalues of real symmetric or complex Hermitian matrices are
always real. [1]_ The array `v` of (column) eigenvectors is unitary
and `a`, `w`, and `v` satisfy the equations
``dot(a, v[:, i]) = w[i] * v[:, i]``.

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
       FL, Academic Press, Inc., 1980, pg. 222.

Examples
--------
>>> from numpy import linalg as LA
>>> a = np.array([[1, -2j], [2j, 5]])
>>> a
array([[ 1.+0.j, -0.-2.j],
       [ 0.+2.j,  5.+0.j]])
>>> w, v = LA.eigh(a)
>>> w; v
array([0.17157288, 5.82842712])
array([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary
       [ 0.        +0.38268343j,  0.        -0.92387953j]])

>>> np.dot(a, v[:, 0]) - w[0] * v[:, 0] # verify 1st e-val/vec pair
array([5.55111512e-17+0.0000000e+00j, 0.00000000e+00+1.2490009e-16j])
>>> np.dot(a, v[:, 1]) - w[1] * v[:, 1] # verify 2nd e-val/vec pair
array([0.+0.j, 0.+0.j])

>>> A = np.matrix(a) # what happens if input is a matrix object
>>> A
matrix([[ 1.+0.j, -0.-2.j],
        [ 0.+2.j,  5.+0.j]])
>>> w, v = LA.eigh(A)
>>> w; v
array([0.17157288, 5.82842712])
matrix([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary
        [ 0.        +0.38268343j,  0.        -0.92387953j]])

>>> # demonstrate the treatment of the imaginary part of the diagonal
>>> a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
>>> a
array([[5.+2.j, 9.-2.j],
       [0.+2.j, 2.-1.j]])
>>> # with UPLO='L' this is numerically equivalent to using LA.eig() with:
>>> b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
>>> b
array([[5.+0.j, 0.-2.j],
       [0.+2.j, 2.+0.j]])
>>> wa, va = LA.eigh(a)
>>> wb, vb = LA.eig(b)
>>> wa; wb
array([1., 6.])
array([6.+0.j, 1.+0.j])
>>> va; vb
array([[-0.4472136 +0.j        , -0.89442719+0.j        ], # may vary
       [ 0.        +0.89442719j,  0.        -0.4472136j ]])
array([[ 0.89442719+0.j       , -0.        +0.4472136j],
       [-0.        +0.4472136j,  0.89442719+0.j       ]])
*)

val eigvals : Py.Object.t -> Py.Object.t
(**
Compute the eigenvalues of a general matrix.

Main difference between `eigvals` and `eig`: the eigenvectors aren't
returned.

Parameters
----------
a : (..., M, M) array_like
    A complex- or real-valued matrix whose eigenvalues will be computed.

Returns
-------
w : (..., M,) ndarray
    The eigenvalues, each repeated according to its multiplicity.
    They are not necessarily ordered, nor are they necessarily
    real for real matrices.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eig : eigenvalues and right eigenvectors of general arrays
eigvalsh : eigenvalues of real symmetric or complex Hermitian
           (conjugate symmetric) arrays.
eigh : eigenvalues and eigenvectors of real symmetric or complex
       Hermitian (conjugate symmetric) arrays.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

This is implemented using the ``_geev`` LAPACK routines which compute
the eigenvalues and eigenvectors of general square arrays.

Examples
--------
Illustration, using the fact that the eigenvalues of a diagonal matrix
are its diagonal elements, that multiplying a matrix on the left
by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
of `Q`), preserves the eigenvalues of the 'middle' matrix.  In other words,
if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
``A``:

>>> from numpy import linalg as LA
>>> x = np.random.random()
>>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
>>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
(1.0, 1.0, 0.0)

Now multiply a diagonal matrix by ``Q`` on one side and by ``Q.T`` on the other:

>>> D = np.diag((-1,1))
>>> LA.eigvals(D)
array([-1.,  1.])
>>> A = np.dot(Q, D)
>>> A = np.dot(A, Q.T)
>>> LA.eigvals(A)
array([ 1., -1.]) # random
*)

val eigvalsh : ?uplo:[`L | `U] -> Py.Object.t -> Py.Object.t
(**
Compute the eigenvalues of a complex Hermitian or real symmetric matrix.

Main difference from eigh: the eigenvectors are not computed.

Parameters
----------
a : (..., M, M) array_like
    A complex- or real-valued matrix whose eigenvalues are to be
    computed.
UPLO : {'L', 'U'}, optional
    Specifies whether the calculation is done with the lower triangular
    part of `a` ('L', default) or the upper triangular part ('U').
    Irrespective of this value only the real parts of the diagonal will
    be considered in the computation to preserve the notion of a Hermitian
    matrix. It therefore follows that the imaginary part of the diagonal
    will always be treated as zero.

Returns
-------
w : (..., M,) ndarray
    The eigenvalues in ascending order, each repeated according to
    its multiplicity.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eigh : eigenvalues and eigenvectors of real symmetric or complex Hermitian
       (conjugate symmetric) arrays.
eigvals : eigenvalues of general real or complex arrays.
eig : eigenvalues and right eigenvectors of general real or complex
      arrays.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The eigenvalues are computed using LAPACK routines ``_syevd``, ``_heevd``.

Examples
--------
>>> from numpy import linalg as LA
>>> a = np.array([[1, -2j], [2j, 5]])
>>> LA.eigvalsh(a)
array([ 0.17157288,  5.82842712]) # may vary

>>> # demonstrate the treatment of the imaginary part of the diagonal
>>> a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
>>> a
array([[5.+2.j, 9.-2.j],
       [0.+2.j, 2.-1.j]])
>>> # with UPLO='L' this is numerically equivalent to using LA.eigvals()
>>> # with:
>>> b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
>>> b
array([[5.+0.j, 0.-2.j],
       [0.+2.j, 2.+0.j]])
>>> wa = LA.eigvalsh(a)
>>> wb = LA.eigvals(b)
>>> wa; wb
array([1., 6.])
array([6.+0.j, 1.+0.j])
*)

val empty : ?dtype:Dtype.t -> ?order:[`C | `F] -> int list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
empty(shape, dtype=float, order='C')

Return a new array of given shape and type, without initializing entries.

Parameters
----------
shape : int or tuple of int
    Shape of the empty array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    Desired output data-type for the array, e.g, `numpy.int8`. Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: 'C'
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data of the given shape, dtype, and
    order.  Object arrays will be initialized to None.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Notes
-----
`empty`, unlike `zeros`, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.

Examples
--------
>>> np.empty([2, 2])
array([[ -9.74499359e+001,   6.69583040e-309],
       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized

>>> np.empty([2, 2], dtype=int)
array([[-1073741821, -1067949133],
       [  496041986,    19249760]])                     #uninitialized
*)

val empty_like : ?dtype:Dtype.t -> ?order:[`F | `A | `PyObject of Py.Object.t] -> ?subok:bool -> ?shape:int list -> prototype:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
empty_like(prototype, dtype=None, order='K', subok=True, shape=None)

Return a new array with the same shape and type as a given array.

Parameters
----------
prototype : array_like
    The shape and data-type of `prototype` define these same attributes
    of the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if ``prototype`` is Fortran
    contiguous, 'C' otherwise. 'K' means match the layout of ``prototype``
    as closely as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of 'a', otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data with the same
    shape and type as `prototype`.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.

Notes
-----
This function does *not* initialize the returned array; to do that use
`zeros_like` or `ones_like` instead.  It may be marginally faster than
the functions that do set the array values.

Examples
--------
>>> a = ([1,2,3], [4,5,6])                         # a is array-like
>>> np.empty_like(a)
array([[-1073741821, -1073741821,           3],    # uninitialized
       [          0,           0, -1073741821]])
>>> a = np.array([[1., 2., 3.],[4.,5.,6.]])
>>> np.empty_like(a)
array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized
       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])
*)

val eye : ?m:int -> ?k:int -> ?dtype:Dtype.t -> ?order:[`C | `F] -> n:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a 2-D array with ones on the diagonal and zeros elsewhere.

Parameters
----------
N : int
  Number of rows in the output.
M : int, optional
  Number of columns in the output. If None, defaults to `N`.
k : int, optional
  Index of the diagonal: 0 (the default) refers to the main diagonal,
  a positive value refers to an upper diagonal, and a negative value
  to a lower diagonal.
dtype : data-type, optional
  Data-type of the returned array.
order : {'C', 'F'}, optional
    Whether the output should be stored in row-major (C-style) or
    column-major (Fortran-style) order in memory.

    .. versionadded:: 1.14.0

Returns
-------
I : ndarray of shape (N,M)
  An array where all elements are equal to zero, except for the `k`-th
  diagonal, whose values are equal to one.

See Also
--------
identity : (almost) equivalent function
diag : diagonal 2-D array from a 1-D array specified by the user.

Examples
--------
>>> np.eye(2, dtype=int)
array([[1, 0],
       [0, 1]])
>>> np.eye(3, k=1)
array([[0.,  1.,  0.],
       [0.,  0.,  1.],
       [0.,  0.,  0.]])
*)

val fastCopyAndTranspose : Py.Object.t -> Py.Object.t
(**
_fastCopyAndTranspose(a)
*)

val get_linalg_error_extobj : Py.Object.t -> Py.Object.t
(**
None
*)

val inv : Py.Object.t -> Py.Object.t
(**
Compute the (multiplicative) inverse of a matrix.

Given a square matrix `a`, return the matrix `ainv` satisfying
``dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])``.

Parameters
----------
a : (..., M, M) array_like
    Matrix to be inverted.

Returns
-------
ainv : (..., M, M) ndarray or matrix
    (Multiplicative) inverse of the matrix `a`.

Raises
------
LinAlgError
    If `a` is not square or inversion fails.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

Examples
--------
>>> from numpy.linalg import inv
>>> a = np.array([[1., 2.], [3., 4.]])
>>> ainv = inv(a)
>>> np.allclose(np.dot(a, ainv), np.eye(2))
True
>>> np.allclose(np.dot(ainv, a), np.eye(2))
True

If a is a matrix object, then the return value is a matrix as well:

>>> ainv = inv(np.matrix(a))
>>> ainv
matrix([[-2. ,  1. ],
        [ 1.5, -0.5]])

Inverses of several matrices can be computed at once:

>>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
>>> inv(a)
array([[[-2.  ,  1.  ],
        [ 1.5 , -0.5 ]],
       [[-1.25,  0.75],
        [ 0.75, -0.25]]])
*)

val isComplexType : Py.Object.t -> Py.Object.t
(**
None
*)

val isfinite : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Test element-wise for finiteness (not infinity or not Not a Number).

The result is returned as a boolean array.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray, bool
    True where ``x`` is not positive infinity, negative infinity,
    or NaN; false otherwise.
    This is a scalar if `x` is a scalar.

See Also
--------
isinf, isneginf, isposinf, isnan

Notes
-----
Not a Number, positive infinity and negative infinity are considered
to be non-finite.

NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Also that positive infinity is not equivalent to negative infinity. But
infinity is equivalent to positive infinity.  Errors result if the
second argument is also supplied when `x` is a scalar input, or if
first and second arguments have different shapes.

Examples
--------
>>> np.isfinite(1)
True
>>> np.isfinite(0)
True
>>> np.isfinite(np.nan)
False
>>> np.isfinite(np.inf)
False
>>> np.isfinite(np.NINF)
False
>>> np.isfinite([np.log(-1.),1.,np.log(0)])
array([False,  True, False])

>>> x = np.array([-np.inf, 0., np.inf])
>>> y = np.array([2, 2, 2])
>>> np.isfinite(x, y)
array([0, 1, 0])
>>> y
array([0, 1, 0])
*)

val isnan : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
isnan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Test element-wise for NaN and return result as a boolean array.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or bool
    True where ``x`` is NaN, false otherwise.
    This is a scalar if `x` is a scalar.

See Also
--------
isinf, isneginf, isposinf, isfinite, isnat

Notes
-----
NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.

Examples
--------
>>> np.isnan(np.nan)
True
>>> np.isnan(np.inf)
False
>>> np.isnan([np.log(-1.),1.,np.log(0)])
array([ True, False, False])
*)

val lstsq : ?rcond:float -> b:Py.Object.t -> [>`Ndarray] Obj.t -> (Py.Object.t * Py.Object.t * int * Py.Object.t)
(**
Return the least-squares solution to a linear matrix equation.

Solves the equation :math:`a x = b` by computing a vector `x` that
minimizes the squared Euclidean 2-norm :math:`\| b - a x \|^2_2`.
The equation may be under-, well-, or over-determined (i.e., the
number of linearly independent rows of `a` can be less than, equal
to, or greater than its number of linearly independent columns).
If `a` is square and of full rank, then `x` (but for round-off error)
is the 'exact' solution of the equation.

Parameters
----------
a : (M, N) array_like
    'Coefficient' matrix.
b : {(M,), (M, K)} array_like
    Ordinate or 'dependent variable' values. If `b` is two-dimensional,
    the least-squares solution is calculated for each of the `K` columns
    of `b`.
rcond : float, optional
    Cut-off ratio for small singular values of `a`.
    For the purposes of rank determination, singular values are treated
    as zero if they are smaller than `rcond` times the largest singular
    value of `a`.

    .. versionchanged:: 1.14.0
       If not set, a FutureWarning is given. The previous default
       of ``-1`` will use the machine precision as `rcond` parameter,
       the new default will use the machine precision times `max(M, N)`.
       To silence the warning and use the new default, use ``rcond=None``,
       to keep using the old behavior, use ``rcond=-1``.

Returns
-------
x : {(N,), (N, K)} ndarray
    Least-squares solution. If `b` is two-dimensional,
    the solutions are in the `K` columns of `x`.
residuals : {(1,), (K,), (0,)} ndarray
    Sums of residuals; squared Euclidean 2-norm for each column in
    ``b - a*x``.
    If the rank of `a` is < N or M <= N, this is an empty array.
    If `b` is 1-dimensional, this is a (1,) shape array.
    Otherwise the shape is (K,).
rank : int
    Rank of matrix `a`.
s : (min(M, N),) ndarray
    Singular values of `a`.

Raises
------
LinAlgError
    If computation does not converge.

Notes
-----
If `b` is a matrix, then all array results are returned as matrices.

Examples
--------
Fit a line, ``y = mx + c``, through some noisy data-points:

>>> x = np.array([0, 1, 2, 3])
>>> y = np.array([-1, 0.2, 0.9, 2.1])

By examining the coefficients, we see that the line should have a
gradient of roughly 1 and cut the y-axis at, more or less, -1.

We can rewrite the line equation as ``y = Ap``, where ``A = [[x 1]]``
and ``p = [[m], [c]]``.  Now use `lstsq` to solve for `p`:

>>> A = np.vstack([x, np.ones(len(x))]).T
>>> A
array([[ 0.,  1.],
       [ 1.,  1.],
       [ 2.,  1.],
       [ 3.,  1.]])

>>> m, c = np.linalg.lstsq(A, y, rcond=None)[0]
>>> m, c
(1.0 -0.95) # may vary

Plot the data along with the fitted line:

>>> import matplotlib.pyplot as plt
>>> _ = plt.plot(x, y, 'o', label='Original data', markersize=10)
>>> _ = plt.plot(x, m*x + c, 'r', label='Fitted line')
>>> _ = plt.legend()
>>> plt.show()
*)

val matmul : ?out:[>`Ndarray] Obj.t -> ?where:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
matmul(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Matrix product of two arrays.

Parameters
----------
x1, x2 : array_like
    Input arrays, scalars not allowed.
out : ndarray, optional
    A location into which the result is stored. If provided, it must have
    a shape that matches the signature `(n,k),(k,m)->(n,m)`. If not
    provided or None, a freshly-allocated array is returned.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

    .. versionadded:: 1.16
       Now handles ufunc kwargs

Returns
-------
y : ndarray
    The matrix product of the inputs.
    This is a scalar only when both x1, x2 are 1-d vectors.

Raises
------
ValueError
    If the last dimension of `a` is not the same size as
    the second-to-last dimension of `b`.

    If a scalar value is passed in.

See Also
--------
vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
dot : alternative matrix product with different broadcasting rules.

Notes
-----

The behavior depends on the arguments in the following way.

- If both arguments are 2-D they are multiplied like conventional
  matrices.
- If either argument is N-D, N > 2, it is treated as a stack of
  matrices residing in the last two indexes and broadcast accordingly.
- If the first argument is 1-D, it is promoted to a matrix by
  prepending a 1 to its dimensions. After matrix multiplication
  the prepended 1 is removed.
- If the second argument is 1-D, it is promoted to a matrix by
  appending a 1 to its dimensions. After matrix multiplication
  the appended 1 is removed.

``matmul`` differs from ``dot`` in two important ways:

- Multiplication by scalars is not allowed, use ``*`` instead.
- Stacks of matrices are broadcast together as if the matrices
  were elements, respecting the signature ``(n,k),(k,m)->(n,m)``:

  >>> a = np.ones([9, 5, 7, 4])
  >>> c = np.ones([9, 5, 4, 3])
  >>> np.dot(a, c).shape
  (9, 5, 7, 9, 5, 3)
  >>> np.matmul(a, c).shape
  (9, 5, 7, 3)
  >>> # n is 7, k is 4, m is 3

The matmul function implements the semantics of the `@` operator introduced
in Python 3.5 following PEP465.

Examples
--------
For 2-D arrays it is the matrix product:

>>> a = np.array([[1, 0],
...               [0, 1]])
>>> b = np.array([[4, 1],
...               [2, 2]])
>>> np.matmul(a, b)
array([[4, 1],
       [2, 2]])

For 2-D mixed with 1-D, the result is the usual.

>>> a = np.array([[1, 0],
...               [0, 1]])
>>> b = np.array([1, 2])
>>> np.matmul(a, b)
array([1, 2])
>>> np.matmul(b, a)
array([1, 2])


Broadcasting is conventional for stacks of arrays

>>> a = np.arange(2 * 2 * 4).reshape((2, 2, 4))
>>> b = np.arange(2 * 2 * 4).reshape((2, 4, 2))
>>> np.matmul(a,b).shape
(2, 2, 2)
>>> np.matmul(a, b)[0, 1, 1]
98
>>> sum(a[0, 1, :] * b[0 , :, 1])
98

Vector, vector returns the scalar inner product, but neither argument
is complex-conjugated:

>>> np.matmul([2j, 3j], [2j, 3j])
(-13+0j)

Scalar multiplication raises an error.

>>> np.matmul([1,2], 3)
Traceback (most recent call last):
...
ValueError: matmul: Input operand 1 does not have enough dimensions ...

.. versionadded:: 1.10.0
*)

val matrix_power : n:int -> Py.Object.t -> Py.Object.t
(**
Raise a square matrix to the (integer) power `n`.

For positive integers `n`, the power is computed by repeated matrix
squarings and matrix multiplications. If ``n == 0``, the identity matrix
of the same shape as M is returned. If ``n < 0``, the inverse
is computed and then raised to the ``abs(n)``.

.. note:: Stacks of object matrices are not currently supported.

Parameters
----------
a : (..., M, M) array_like
    Matrix to be 'powered'.
n : int
    The exponent can be any integer or long integer, positive,
    negative, or zero.

Returns
-------
a**n : (..., M, M) ndarray or matrix object
    The return value is the same shape and type as `M`;
    if the exponent is positive or zero then the type of the
    elements is the same as those of `M`. If the exponent is
    negative the elements are floating-point.

Raises
------
LinAlgError
    For matrices that are not square or that (for negative powers) cannot
    be inverted numerically.

Examples
--------
>>> from numpy.linalg import matrix_power
>>> i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit
>>> matrix_power(i, 3) # should = -i
array([[ 0, -1],
       [ 1,  0]])
>>> matrix_power(i, 0)
array([[1, 0],
       [0, 1]])
>>> matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements
array([[ 0.,  1.],
       [-1.,  0.]])

Somewhat more sophisticated example

>>> q = np.zeros((4, 4))
>>> q[0:2, 0:2] = -i
>>> q[2:4, 2:4] = i
>>> q # one of the three quaternion units not equal to 1
array([[ 0., -1.,  0.,  0.],
       [ 1.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  1.],
       [ 0.,  0., -1.,  0.]])
>>> matrix_power(q, 2) # = -np.eye(4)
array([[-1.,  0.,  0.,  0.],
       [ 0., -1.,  0.,  0.],
       [ 0.,  0., -1.,  0.],
       [ 0.,  0.,  0., -1.]])
*)

val matrix_rank : ?tol:[`F of float | `T_array_like of Py.Object.t] -> ?hermitian:bool -> m:Py.Object.t -> unit -> Py.Object.t
(**
Return matrix rank of array using SVD method

Rank of the array is the number of singular values of the array that are
greater than `tol`.

.. versionchanged:: 1.14
   Can now operate on stacks of matrices

Parameters
----------
M : {(M,), (..., M, N)} array_like
    Input vector or stack of matrices.
tol : (...) array_like, float, optional
    Threshold below which SVD values are considered zero. If `tol` is
    None, and ``S`` is an array with singular values for `M`, and
    ``eps`` is the epsilon value for datatype of ``S``, then `tol` is
    set to ``S.max() * max(M.shape) * eps``.

    .. versionchanged:: 1.14
       Broadcasted against the stack of matrices
hermitian : bool, optional
    If True, `M` is assumed to be Hermitian (symmetric if real-valued),
    enabling a more efficient method for finding singular values.
    Defaults to False.

    .. versionadded:: 1.14

Returns
-------
rank : (...) array_like
    Rank of M.

Notes
-----
The default threshold to detect rank deficiency is a test on the magnitude
of the singular values of `M`.  By default, we identify singular values less
than ``S.max() * max(M.shape) * eps`` as indicating rank deficiency (with
the symbols defined above). This is the algorithm MATLAB uses [1].  It also
appears in *Numerical recipes* in the discussion of SVD solutions for linear
least squares [2].

This default threshold is designed to detect rank deficiency accounting for
the numerical errors of the SVD computation.  Imagine that there is a column
in `M` that is an exact (in floating point) linear combination of other
columns in `M`. Computing the SVD on `M` will not produce a singular value
exactly equal to 0 in general: any difference of the smallest SVD value from
0 will be caused by numerical imprecision in the calculation of the SVD.
Our threshold for small SVD values takes this numerical imprecision into
account, and the default threshold will detect such numerical rank
deficiency.  The threshold may declare a matrix `M` rank deficient even if
the linear combination of some columns of `M` is not exactly equal to
another column of `M` but only numerically very close to another column of
`M`.

We chose our default threshold because it is in wide use.  Other thresholds
are possible.  For example, elsewhere in the 2007 edition of *Numerical
recipes* there is an alternative threshold of ``S.max() *
np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)``. The authors describe
this threshold as being based on 'expected roundoff error' (p 71).

The thresholds above deal with floating point roundoff error in the
calculation of the SVD.  However, you may have more information about the
sources of error in `M` that would make you consider other tolerance values
to detect *effective* rank deficiency.  The most useful measure of the
tolerance depends on the operations you intend to use on your matrix.  For
example, if your data come from uncertain measurements with uncertainties
greater than floating point epsilon, choosing a tolerance near that
uncertainty may be preferable.  The tolerance may be absolute if the
uncertainties are absolute rather than relative.

References
----------
.. [1] MATLAB reference documention, 'Rank'
       https://www.mathworks.com/help/techdoc/ref/rank.html
.. [2] W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery,
       'Numerical Recipes (3rd edition)', Cambridge University Press, 2007,
       page 795.

Examples
--------
>>> from numpy.linalg import matrix_rank
>>> matrix_rank(np.eye(4)) # Full rank matrix
4
>>> I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix
>>> matrix_rank(I)
3
>>> matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0
1
>>> matrix_rank(np.zeros((4,)))
0
*)

val moveaxis : source:[`I of int | `Sequence_of_int of Py.Object.t] -> destination:[`I of int | `Sequence_of_int of Py.Object.t] -> Py.Object.t -> Py.Object.t
(**
Move axes of an array to new positions.

Other axes remain in their original order.

.. versionadded:: 1.11.0

Parameters
----------
a : np.ndarray
    The array whose axes should be reordered.
source : int or sequence of int
    Original positions of the axes to move. These must be unique.
destination : int or sequence of int
    Destination positions for each of the original axes. These must also be
    unique.

Returns
-------
result : np.ndarray
    Array with moved axes. This array is a view of the input array.

See Also
--------
transpose: Permute the dimensions of an array.
swapaxes: Interchange two axes of an array.

Examples
--------

>>> x = np.zeros((3, 4, 5))
>>> np.moveaxis(x, 0, -1).shape
(4, 5, 3)
>>> np.moveaxis(x, -1, 0).shape
(5, 3, 4)

These all achieve the same result:

>>> np.transpose(x).shape
(5, 4, 3)
>>> np.swapaxes(x, 0, -1).shape
(5, 4, 3)
>>> np.moveaxis(x, [0, 1], [-1, -2]).shape
(5, 4, 3)
>>> np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape
(5, 4, 3)
*)

val multi_dot : Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the dot product of two or more arrays in a single function call,
while automatically selecting the fastest evaluation order.

`multi_dot` chains `numpy.dot` and uses optimal parenthesization
of the matrices [1]_ [2]_. Depending on the shapes of the matrices,
this can speed up the multiplication a lot.

If the first argument is 1-D it is treated as a row vector.
If the last argument is 1-D it is treated as a column vector.
The other arguments must be 2-D.

Think of `multi_dot` as::

    def multi_dot(arrays): return functools.reduce(np.dot, arrays)


Parameters
----------
arrays : sequence of array_like
    If the first argument is 1-D it is treated as row vector.
    If the last argument is 1-D it is treated as column vector.
    The other arguments must be 2-D.

Returns
-------
output : ndarray
    Returns the dot product of the supplied arrays.

See Also
--------
dot : dot multiplication with two arguments.

References
----------

.. [1] Cormen, 'Introduction to Algorithms', Chapter 15.2, p. 370-378
.. [2] https://en.wikipedia.org/wiki/Matrix_chain_multiplication

Examples
--------
`multi_dot` allows you to write::

>>> from numpy.linalg import multi_dot
>>> # Prepare some data
>>> A = np.random.random((10000, 100))
>>> B = np.random.random((100, 1000))
>>> C = np.random.random((1000, 5))
>>> D = np.random.random((5, 333))
>>> # the actual dot multiplication
>>> _ = multi_dot([A, B, C, D])

instead of::

>>> _ = np.dot(np.dot(np.dot(A, B), C), D)
>>> # or
>>> _ = A.dot(B).dot(C).dot(D)

Notes
-----
The cost for a matrix multiplication can be calculated with the
following function::

    def cost(A, B):
        return A.shape[0] * A.shape[1] * B.shape[1]

Assume we have three matrices
:math:`A_{10x100}, B_{100x5}, C_{5x50}`.

The costs for the two different parenthesizations are as follows::

    cost((AB)C) = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500
    cost(A(BC)) = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000
*)

val multiply : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Multiply arguments element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays to be multiplied. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The product of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
Equivalent to `x1` * `x2` in terms of array broadcasting.

Examples
--------
>>> np.multiply(2.0, 4.0)
8.0

>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.multiply(x1, x2)
array([[  0.,   1.,   4.],
       [  0.,   4.,  10.],
       [  0.,   7.,  16.]])
*)

val norm : ?ord:[`Nuc | `PyObject of Py.Object.t | `Fro] -> ?axis:[`I of int | `T2_tuple_of_ints of Py.Object.t] -> ?keepdims:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Matrix or vector norm.

This function is able to return one of eight different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the ``ord`` parameter.

Parameters
----------
x : array_like
    Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
    is None. If both `axis` and `ord` are None, the 2-norm of
    ``x.ravel`` will be returned.
ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
    Order of the norm (see table under ``Notes``). inf means numpy's
    `inf` object. The default is None.
axis : {None, int, 2-tuple of ints}, optional.
    If `axis` is an integer, it specifies the axis of `x` along which to
    compute the vector norms.  If `axis` is a 2-tuple, it specifies the
    axes that hold 2-D matrices, and the matrix norms of these matrices
    are computed.  If `axis` is None then either a vector norm (when `x`
    is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
    is None.

    .. versionadded:: 1.8.0

keepdims : bool, optional
    If this is set to True, the axes which are normed over are left in the
    result as dimensions with size one.  With this option the result will
    broadcast correctly against the original `x`.

    .. versionadded:: 1.10.0

Returns
-------
n : float or ndarray
    Norm of the matrix or vector(s).

Notes
-----
For values of ``ord <= 0``, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.

The following norms can be calculated:

=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
'nuc'  nuclear norm                  --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)**ord)**(1./ord)
=====  ============================  ==========================

The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

The nuclear norm is the sum of the singular values.

References
----------
.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
       Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15

Examples
--------
>>> from numpy import linalg as LA
>>> a = np.arange(9) - 4
>>> a
array([-4, -3, -2, ...,  2,  3,  4])
>>> b = a.reshape((3, 3))
>>> b
array([[-4, -3, -2],
       [-1,  0,  1],
       [ 2,  3,  4]])

>>> LA.norm(a)
7.745966692414834
>>> LA.norm(b)
7.745966692414834
>>> LA.norm(b, 'fro')
7.745966692414834
>>> LA.norm(a, np.inf)
4.0
>>> LA.norm(b, np.inf)
9.0
>>> LA.norm(a, -np.inf)
0.0
>>> LA.norm(b, -np.inf)
2.0

>>> LA.norm(a, 1)
20.0
>>> LA.norm(b, 1)
7.0
>>> LA.norm(a, -1)
-4.6566128774142013e-010
>>> LA.norm(b, -1)
6.0
>>> LA.norm(a, 2)
7.745966692414834
>>> LA.norm(b, 2)
7.3484692283495345

>>> LA.norm(a, -2)
0.0
>>> LA.norm(b, -2)
1.8570331885190563e-016 # may vary
>>> LA.norm(a, 3)
5.8480354764257312 # may vary
>>> LA.norm(a, -3)
0.0

Using the `axis` argument to compute vector norms:

>>> c = np.array([[ 1, 2, 3],
...               [-1, 1, 4]])
>>> LA.norm(c, axis=0)
array([ 1.41421356,  2.23606798,  5.        ])
>>> LA.norm(c, axis=1)
array([ 3.74165739,  4.24264069])
>>> LA.norm(c, ord=1, axis=1)
array([ 6.,  6.])

Using the `axis` argument to compute matrix norms:

>>> m = np.arange(8).reshape(2,2,2)
>>> LA.norm(m, axis=(1,2))
array([  3.74165739,  11.22497216])
>>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
(3.7416573867739413, 11.224972160321824)
*)

val normalize_axis_index : ?msg_prefix:string -> axis:int -> ndim:int -> unit -> int
(**
normalize_axis_index(axis, ndim, msg_prefix=None)

Normalizes an axis index, `axis`, such that is a valid positive index into
the shape of array with `ndim` dimensions. Raises an AxisError with an
appropriate message if this is not possible.

Used internally by all axis-checking logic.

.. versionadded:: 1.13.0

Parameters
----------
axis : int
    The un-normalized index of the axis. Can be negative
ndim : int
    The number of dimensions of the array that `axis` should be normalized
    against
msg_prefix : str
    A prefix to put before the message, typically the name of the argument

Returns
-------
normalized_axis : int
    The normalized axis index, such that `0 <= normalized_axis < ndim`

Raises
------
AxisError
    If the axis index is invalid, when `-ndim <= axis < ndim` is false.

Examples
--------
>>> normalize_axis_index(0, ndim=3)
0
>>> normalize_axis_index(1, ndim=3)
1
>>> normalize_axis_index(-1, ndim=3)
2

>>> normalize_axis_index(3, ndim=3)
Traceback (most recent call last):
...
AxisError: axis 3 is out of bounds for array of dimension 3
>>> normalize_axis_index(-4, ndim=3, msg_prefix='axes_arg')
Traceback (most recent call last):
...
AxisError: axes_arg: axis -4 is out of bounds for array of dimension 3
*)

val pinv : ?rcond:Py.Object.t -> ?hermitian:bool -> Py.Object.t -> Py.Object.t
(**
Compute the (Moore-Penrose) pseudo-inverse of a matrix.

Calculate the generalized inverse of a matrix using its
singular-value decomposition (SVD) and including all
*large* singular values.

.. versionchanged:: 1.14
   Can now operate on stacks of matrices

Parameters
----------
a : (..., M, N) array_like
    Matrix or stack of matrices to be pseudo-inverted.
rcond : (...) array_like of float
    Cutoff for small singular values.
    Singular values less than or equal to
    ``rcond * largest_singular_value`` are set to zero.
    Broadcasts against the stack of matrices.
hermitian : bool, optional
    If True, `a` is assumed to be Hermitian (symmetric if real-valued),
    enabling a more efficient method for finding singular values.
    Defaults to False.

    .. versionadded:: 1.17.0

Returns
-------
B : (..., N, M) ndarray
    The pseudo-inverse of `a`. If `a` is a `matrix` instance, then so
    is `B`.

Raises
------
LinAlgError
    If the SVD computation does not converge.

Notes
-----
The pseudo-inverse of a matrix A, denoted :math:`A^+`, is
defined as: 'the matrix that 'solves' [the least-squares problem]
:math:`Ax = b`,' i.e., if :math:`\bar{x}` is said solution, then
:math:`A^+` is that matrix such that :math:`\bar{x} = A^+b`.

It can be shown that if :math:`Q_1 \Sigma Q_2^T = A` is the singular
value decomposition of A, then
:math:`A^+ = Q_2 \Sigma^+ Q_1^T`, where :math:`Q_{1,2}` are
orthogonal matrices, :math:`\Sigma` is a diagonal matrix consisting
of A's so-called singular values, (followed, typically, by
zeros), and then :math:`\Sigma^+` is simply the diagonal matrix
consisting of the reciprocals of A's singular values
(again, followed by zeros). [1]_

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
       FL, Academic Press, Inc., 1980, pp. 139-142.

Examples
--------
The following example checks that ``a * a+ * a == a`` and
``a+ * a * a+ == a+``:

>>> a = np.random.randn(9, 6)
>>> B = np.linalg.pinv(a)
>>> np.allclose(a, np.dot(a, np.dot(B, a)))
True
>>> np.allclose(B, np.dot(B, np.dot(a, B)))
True
*)

val product : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
Return the product of array elements over a given axis.

See Also
--------
prod : equivalent function; see for details.
*)

val qr : ?mode:[`Reduced | `Complete | `R | `Raw] -> [>`Ndarray] Obj.t -> (Py.Object.t * Py.Object.t)
(**
Compute the qr factorization of a matrix.

Factor the matrix `a` as *qr*, where `q` is orthonormal and `r` is
upper-triangular.

Parameters
----------
a : array_like, shape (M, N)
    Matrix to be factored.
mode : {'reduced', 'complete', 'r', 'raw'}, optional
    If K = min(M, N), then

    * 'reduced'  : returns q, r with dimensions (M, K), (K, N) (default)
    * 'complete' : returns q, r with dimensions (M, M), (M, N)
    * 'r'        : returns r only with dimensions (K, N)
    * 'raw'      : returns h, tau with dimensions (N, M), (K,)

    The options 'reduced', 'complete, and 'raw' are new in numpy 1.8,
    see the notes for more information. The default is 'reduced', and to
    maintain backward compatibility with earlier versions of numpy both
    it and the old default 'full' can be omitted. Note that array h
    returned in 'raw' mode is transposed for calling Fortran. The
    'economic' mode is deprecated.  The modes 'full' and 'economic' may
    be passed using only the first letter for backwards compatibility,
    but all others must be spelled out. See the Notes for more
    explanation.


Returns
-------
q : ndarray of float or complex, optional
    A matrix with orthonormal columns. When mode = 'complete' the
    result is an orthogonal/unitary matrix depending on whether or not
    a is real/complex. The determinant may be either +/- 1 in that
    case.
r : ndarray of float or complex, optional
    The upper-triangular matrix.
(h, tau) : ndarrays of np.double or np.cdouble, optional
    The array h contains the Householder reflectors that generate q
    along with r. The tau array contains scaling factors for the
    reflectors. In the deprecated  'economic' mode only h is returned.

Raises
------
LinAlgError
    If factoring fails.

Notes
-----
This is an interface to the LAPACK routines ``dgeqrf``, ``zgeqrf``,
``dorgqr``, and ``zungqr``.

For more information on the qr factorization, see for example:
https://en.wikipedia.org/wiki/QR_factorization

Subclasses of `ndarray` are preserved except for the 'raw' mode. So if
`a` is of type `matrix`, all the return values will be matrices too.

New 'reduced', 'complete', and 'raw' options for mode were added in
NumPy 1.8.0 and the old option 'full' was made an alias of 'reduced'.  In
addition the options 'full' and 'economic' were deprecated.  Because
'full' was the previous default and 'reduced' is the new default,
backward compatibility can be maintained by letting `mode` default.
The 'raw' option was added so that LAPACK routines that can multiply
arrays by q using the Householder reflectors can be used. Note that in
this case the returned arrays are of type np.double or np.cdouble and
the h array is transposed to be FORTRAN compatible.  No routines using
the 'raw' return are currently exposed by numpy, but some are available
in lapack_lite and just await the necessary work.

Examples
--------
>>> a = np.random.randn(9, 6)
>>> q, r = np.linalg.qr(a)
>>> np.allclose(a, np.dot(q, r))  # a does equal qr
True
>>> r2 = np.linalg.qr(a, mode='r')
>>> np.allclose(r, r2)  # mode='r' returns the same r as mode='full'
True

Example illustrating a common use of `qr`: solving of least squares
problems

What are the least-squares-best `m` and `y0` in ``y = y0 + mx`` for
the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points
and you'll see that it should be y0 = 0, m = 1.)  The answer is provided
by solving the over-determined matrix equation ``Ax = b``, where::

  A = array([[0, 1], [1, 1], [1, 1], [2, 1]])
  x = array([[y0], [m]])
  b = array([[1], [0], [2], [1]])

If A = qr such that q is orthonormal (which is always possible via
Gram-Schmidt), then ``x = inv(r) * (q.T) * b``.  (In numpy practice,
however, we simply use `lstsq`.)

>>> A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])
>>> A
array([[0, 1],
       [1, 1],
       [1, 1],
       [2, 1]])
>>> b = np.array([1, 0, 2, 1])
>>> q, r = np.linalg.qr(A)
>>> p = np.dot(q.T, b)
>>> np.dot(np.linalg.inv(r), p)
array([  1.1e-16,   1.0e+00])
*)

val set_module : Py.Object.t -> Py.Object.t
(**
Decorator for overriding __module__ on a function or class.

Example usage::

    @set_module('numpy')
    def example():
        pass

    assert example.__module__ == 'numpy'
*)

val sign : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
sign(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Returns an element-wise indication of the sign of a number.

The `sign` function returns ``-1 if x < 0, 0 if x==0, 1 if x > 0``.  nan
is returned for nan inputs.

For complex inputs, the `sign` function returns
``sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j``.

complex(nan, 0) is returned for complex nan inputs.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The sign of `x`.
    This is a scalar if `x` is a scalar.

Notes
-----
There is more than one definition of sign in common use for complex
numbers.  The definition used here is equivalent to :math:`x/\sqrt{x*x}`
which is different from a common alternative, :math:`x/|x|`.

Examples
--------
>>> np.sign([-5., 4.5])
array([-1.,  1.])
>>> np.sign(0)
0
>>> np.sign(5-2j)
(1+0j)
*)

val slogdet : Py.Object.t -> (Py.Object.t * Py.Object.t)
(**
Compute the sign and (natural) logarithm of the determinant of an array.

If an array has a very small or very large determinant, then a call to
`det` may overflow or underflow. This routine is more robust against such
issues, because it computes the logarithm of the determinant rather than
the determinant itself.

Parameters
----------
a : (..., M, M) array_like
    Input array, has to be a square 2-D array.

Returns
-------
sign : (...) array_like
    A number representing the sign of the determinant. For a real matrix,
    this is 1, 0, or -1. For a complex matrix, this is a complex number
    with absolute value 1 (i.e., it is on the unit circle), or else 0.
logdet : (...) array_like
    The natural log of the absolute value of the determinant.

If the determinant is zero, then `sign` will be 0 and `logdet` will be
-Inf. In all cases, the determinant is equal to ``sign * np.exp(logdet)``.

See Also
--------
det

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

.. versionadded:: 1.6.0

The determinant is computed via LU factorization using the LAPACK
routine ``z/dgetrf``.


Examples
--------
The determinant of a 2-D array ``[[a, b], [c, d]]`` is ``ad - bc``:

>>> a = np.array([[1, 2], [3, 4]])
>>> (sign, logdet) = np.linalg.slogdet(a)
>>> (sign, logdet)
(-1, 0.69314718055994529) # may vary
>>> sign * np.exp(logdet)
-2.0

Computing log-determinants for a stack of matrices:

>>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
>>> a.shape
(3, 2, 2)
>>> sign, logdet = np.linalg.slogdet(a)
>>> (sign, logdet)
(array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))
>>> sign * np.exp(logdet)
array([-2., -3., -8.])

This routine succeeds where ordinary `det` does not:

>>> np.linalg.det(np.eye(500) * 0.1)
0.0
>>> np.linalg.slogdet(np.eye(500) * 0.1)
(1, -1151.2925464970228)
*)

val solve : b:[`Ndarray of [>`Ndarray] Obj.t | `PyObject of Py.Object.t] -> Py.Object.t -> Py.Object.t
(**
Solve a linear matrix equation, or system of linear scalar equations.

Computes the 'exact' solution, `x`, of the well-determined, i.e., full
rank, linear matrix equation `ax = b`.

Parameters
----------
a : (..., M, M) array_like
    Coefficient matrix.
b : {(..., M,), (..., M, K)}, array_like
    Ordinate or 'dependent variable' values.

Returns
-------
x : {(..., M,), (..., M, K)} ndarray
    Solution to the system a x = b.  Returned shape is identical to `b`.

Raises
------
LinAlgError
    If `a` is singular or not square.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The solutions are computed using LAPACK routine ``_gesv``.

`a` must be square and of full-rank, i.e., all rows (or, equivalently,
columns) must be linearly independent; if either is not true, use
`lstsq` for the least-squares best 'solution' of the
system/equation.

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
       FL, Academic Press, Inc., 1980, pg. 22.

Examples
--------
Solve the system of equations ``3 * x0 + x1 = 9`` and ``x0 + 2 * x1 = 8``:

>>> a = np.array([[3,1], [1,2]])
>>> b = np.array([9,8])
>>> x = np.linalg.solve(a, b)
>>> x
array([2.,  3.])

Check that the solution is correct:

>>> np.allclose(np.dot(a, x), b)
True
*)

val sqrt : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the non-negative square-root of an array, element-wise.

Parameters
----------
x : array_like
    The values whose square-roots are required.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    An array of the same shape as `x`, containing the positive
    square-root of each element in `x`.  If any element in `x` is
    complex, a complex array is returned (and the square-roots of
    negative reals are calculated).  If all of the elements in `x`
    are real, so is `y`, with negative elements returning ``nan``.
    If `out` was provided, `y` is a reference to it.
    This is a scalar if `x` is a scalar.

See Also
--------
lib.scimath.sqrt
    A version which returns complex numbers when given negative reals.

Notes
-----
*sqrt* has--consistent with common convention--as its branch cut the
real 'interval' [`-inf`, 0), and is continuous from above on it.
A branch cut is a curve in the complex plane across which a given
complex function fails to be continuous.

Examples
--------
>>> np.sqrt([1,4,9])
array([ 1.,  2.,  3.])

>>> np.sqrt([4, -1, -3+4J])
array([ 2.+0.j,  0.+1.j,  1.+2.j])

>>> np.sqrt([4, -1, np.inf])
array([ 2., nan, inf])
*)

val sum : ?axis:int list -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> ?initial:[`F of float | `I of int | `Bool of bool | `S of string] -> ?where:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Sum of array elements over a given axis.

Parameters
----------
a : array_like
    Elements to sum.
axis : None or int or tuple of ints, optional
    Axis or axes along which a sum is performed.  The default,
    axis=None, will sum all of the elements of the input array.  If
    axis is negative it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If axis is a tuple of ints, a sum is performed on all of the axes
    specified in the tuple instead of a single axis or all the axes as
    before.
dtype : dtype, optional
    The type of the returned array and of the accumulator in which the
    elements are summed.  The dtype of `a` is used by default unless `a`
    has an integer dtype of less precision than the default platform
    integer.  In that case, if `a` is signed then the platform integer
    is used while if `a` is unsigned then an unsigned integer of the
    same precision as the platform integer is used.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output, but the type of the output
    values will be cast if necessary.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `sum` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.
initial : scalar, optional
    Starting value for the sum. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to include in the sum. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.17.0

Returns
-------
sum_along_axis : ndarray
    An array with the same shape as `a`, with the specified
    axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar
    is returned.  If an output array is specified, a reference to
    `out` is returned.

See Also
--------
ndarray.sum : Equivalent method.

add.reduce : Equivalent functionality of `add`.

cumsum : Cumulative sum of array elements.

trapz : Integration of array values using the composite trapezoidal rule.

mean, average

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

The sum of an empty array is the neutral element 0:

>>> np.sum([])
0.0

For floating point numbers the numerical precision of sum (and
``np.add.reduce``) is in general limited by directly adding each number
individually to the result causing rounding errors in every step.
However, often numpy will use a  numerically better approach (partial
pairwise summation) leading to improved precision in many use-cases.
This improved precision is always provided when no ``axis`` is given.
When ``axis`` is given, it will depend on which axis is summed.
Technically, to provide the best speed possible, the improved precision
is only used when the summation is along the fast axis in memory.
Note that the exact precision may vary depending on other parameters.
In contrast to NumPy, Python's ``math.fsum`` function uses a slower but
more precise approach to summation.
Especially when summing a large number of lower precision floating point
numbers, such as ``float32``, numerical errors can become significant.
In such cases it can be advisable to use `dtype='float64'` to use a higher
precision for the output.

Examples
--------
>>> np.sum([0.5, 1.5])
2.0
>>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)
1
>>> np.sum([[0, 1], [0, 5]])
6
>>> np.sum([[0, 1], [0, 5]], axis=0)
array([0, 6])
>>> np.sum([[0, 1], [0, 5]], axis=1)
array([1, 5])
>>> np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)
array([1., 5.])

If the accumulator is too small, overflow occurs:

>>> np.ones(128, dtype=np.int8).sum(dtype=np.int8)
-128

You can also start the sum with a value other than zero:

>>> np.sum([10], initial=5)
15
*)

val svd : ?full_matrices:bool -> ?compute_uv:bool -> ?hermitian:bool -> Py.Object.t -> (Py.Object.t * Py.Object.t * Py.Object.t)
(**
Singular Value Decomposition.

When `a` is a 2D array, it is factorized as ``u @ np.diag(s) @ vh
= (u * s) @ vh``, where `u` and `vh` are 2D unitary arrays and `s` is a 1D
array of `a`'s singular values. When `a` is higher-dimensional, SVD is
applied in stacked mode as explained below.

Parameters
----------
a : (..., M, N) array_like
    A real or complex array with ``a.ndim >= 2``.
full_matrices : bool, optional
    If True (default), `u` and `vh` have the shapes ``(..., M, M)`` and
    ``(..., N, N)``, respectively.  Otherwise, the shapes are
    ``(..., M, K)`` and ``(..., K, N)``, respectively, where
    ``K = min(M, N)``.
compute_uv : bool, optional
    Whether or not to compute `u` and `vh` in addition to `s`.  True
    by default.
hermitian : bool, optional
    If True, `a` is assumed to be Hermitian (symmetric if real-valued),
    enabling a more efficient method for finding singular values.
    Defaults to False.

    .. versionadded:: 1.17.0

Returns
-------
u : { (..., M, M), (..., M, K) } array
    Unitary array(s). The first ``a.ndim - 2`` dimensions have the same
    size as those of the input `a`. The size of the last two dimensions
    depends on the value of `full_matrices`. Only returned when
    `compute_uv` is True.
s : (..., K) array
    Vector(s) with the singular values, within each vector sorted in
    descending order. The first ``a.ndim - 2`` dimensions have the same
    size as those of the input `a`.
vh : { (..., N, N), (..., K, N) } array
    Unitary array(s). The first ``a.ndim - 2`` dimensions have the same
    size as those of the input `a`. The size of the last two dimensions
    depends on the value of `full_matrices`. Only returned when
    `compute_uv` is True.

Raises
------
LinAlgError
    If SVD computation does not converge.

Notes
-----

.. versionchanged:: 1.8.0
   Broadcasting rules apply, see the `numpy.linalg` documentation for
   details.

The decomposition is performed using LAPACK routine ``_gesdd``.

SVD is usually described for the factorization of a 2D matrix :math:`A`.
The higher-dimensional case will be discussed below. In the 2D case, SVD is
written as :math:`A = U S V^H`, where :math:`A = a`, :math:`U= u`,
:math:`S= \mathtt{np.diag}(s)` and :math:`V^H = vh`. The 1D array `s`
contains the singular values of `a` and `u` and `vh` are unitary. The rows
of `vh` are the eigenvectors of :math:`A^H A` and the columns of `u` are
the eigenvectors of :math:`A A^H`. In both cases the corresponding
(possibly non-zero) eigenvalues are given by ``s**2``.

If `a` has more than two dimensions, then broadcasting rules apply, as
explained in :ref:`routines.linalg-broadcasting`. This means that SVD is
working in 'stacked' mode: it iterates over all indices of the first
``a.ndim - 2`` dimensions and for each combination SVD is applied to the
last two indices. The matrix `a` can be reconstructed from the
decomposition with either ``(u * s[..., None, :]) @ vh`` or
``u @ (s[..., None] * vh)``. (The ``@`` operator can be replaced by the
function ``np.matmul`` for python versions below 3.5.)

If `a` is a ``matrix`` object (as opposed to an ``ndarray``), then so are
all the return values.

Examples
--------
>>> a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)
>>> b = np.random.randn(2, 7, 8, 3) + 1j*np.random.randn(2, 7, 8, 3)

Reconstruction based on full SVD, 2D case:

>>> u, s, vh = np.linalg.svd(a, full_matrices=True)
>>> u.shape, s.shape, vh.shape
((9, 9), (6,), (6, 6))
>>> np.allclose(a, np.dot(u[:, :6] * s, vh))
True
>>> smat = np.zeros((9, 6), dtype=complex)
>>> smat[:6, :6] = np.diag(s)
>>> np.allclose(a, np.dot(u, np.dot(smat, vh)))
True

Reconstruction based on reduced SVD, 2D case:

>>> u, s, vh = np.linalg.svd(a, full_matrices=False)
>>> u.shape, s.shape, vh.shape
((9, 6), (6,), (6, 6))
>>> np.allclose(a, np.dot(u * s, vh))
True
>>> smat = np.diag(s)
>>> np.allclose(a, np.dot(u, np.dot(smat, vh)))
True

Reconstruction based on full SVD, 4D case:

>>> u, s, vh = np.linalg.svd(b, full_matrices=True)
>>> u.shape, s.shape, vh.shape
((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))
>>> np.allclose(b, np.matmul(u[..., :3] * s[..., None, :], vh))
True
>>> np.allclose(b, np.matmul(u[..., :3], s[..., None] * vh))
True

Reconstruction based on reduced SVD, 4D case:

>>> u, s, vh = np.linalg.svd(b, full_matrices=False)
>>> u.shape, s.shape, vh.shape
((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))
>>> np.allclose(b, np.matmul(u * s[..., None, :], vh))
True
>>> np.allclose(b, np.matmul(u, s[..., None] * vh))
True
*)

val swapaxes : axis1:int -> axis2:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Interchange two axes of an array.

Parameters
----------
a : array_like
    Input array.
axis1 : int
    First axis.
axis2 : int
    Second axis.

Returns
-------
a_swapped : ndarray
    For NumPy >= 1.10.0, if `a` is an ndarray, then a view of `a` is
    returned; otherwise a new array is created. For earlier NumPy
    versions a view of `a` is returned only if the order of the
    axes is changed, otherwise the input array is returned.

Examples
--------
>>> x = np.array([[1,2,3]])
>>> np.swapaxes(x,0,1)
array([[1],
       [2],
       [3]])

>>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])
>>> x
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])

>>> np.swapaxes(x,0,2)
array([[[0, 4],
        [2, 6]],
       [[1, 5],
        [3, 7]]])
*)

val tensorinv : ?ind:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the 'inverse' of an N-dimensional array.

The result is an inverse for `a` relative to the tensordot operation
``tensordot(a, b, ind)``, i. e., up to floating-point accuracy,
``tensordot(tensorinv(a), a, ind)`` is the 'identity' tensor for the
tensordot operation.

Parameters
----------
a : array_like
    Tensor to 'invert'. Its shape must be 'square', i. e.,
    ``prod(a.shape[:ind]) == prod(a.shape[ind:])``.
ind : int, optional
    Number of first indices that are involved in the inverse sum.
    Must be a positive integer, default is 2.

Returns
-------
b : ndarray
    `a`'s tensordot inverse, shape ``a.shape[ind:] + a.shape[:ind]``.

Raises
------
LinAlgError
    If `a` is singular or not 'square' (in the above sense).

See Also
--------
numpy.tensordot, tensorsolve

Examples
--------
>>> a = np.eye(4*6)
>>> a.shape = (4, 6, 8, 3)
>>> ainv = np.linalg.tensorinv(a, ind=2)
>>> ainv.shape
(8, 3, 4, 6)
>>> b = np.random.randn(4, 6)
>>> np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))
True

>>> a = np.eye(4*6)
>>> a.shape = (24, 8, 3)
>>> ainv = np.linalg.tensorinv(a, ind=1)
>>> ainv.shape
(8, 3, 24)
>>> b = np.random.randn(24)
>>> np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))
True
*)

val tensorsolve : ?axes:int list -> b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Solve the tensor equation ``a x = b`` for x.

It is assumed that all indices of `x` are summed over in the product,
together with the rightmost indices of `a`, as is done in, for example,
``tensordot(a, x, axes=b.ndim)``.

Parameters
----------
a : array_like
    Coefficient tensor, of shape ``b.shape + Q``. `Q`, a tuple, equals
    the shape of that sub-tensor of `a` consisting of the appropriate
    number of its rightmost indices, and must be such that
    ``prod(Q) == prod(b.shape)`` (in which sense `a` is said to be
    'square').
b : array_like
    Right-hand tensor, which can be of any shape.
axes : tuple of ints, optional
    Axes in `a` to reorder to the right, before inversion.
    If None (default), no reordering is done.

Returns
-------
x : ndarray, shape Q

Raises
------
LinAlgError
    If `a` is singular or not 'square' (in the above sense).

See Also
--------
numpy.tensordot, tensorinv, numpy.einsum

Examples
--------
>>> a = np.eye(2*3*4)
>>> a.shape = (2*3, 4, 2, 3, 4)
>>> b = np.random.randn(2*3, 4)
>>> x = np.linalg.tensorsolve(a, b)
>>> x.shape
(2, 3, 4)
>>> np.allclose(np.tensordot(a, x, axes=3), b)
True
*)

val transpose : Py.Object.t -> Py.Object.t
(**
Transpose each matrix in a stack of matrices.

Unlike np.transpose, this only swaps the last two axes, rather than all of
them

Parameters
----------
a : (...,M,N) array_like

Returns
-------
aT : (...,N,M) ndarray
*)

val triu : ?k:Py.Object.t -> m:Py.Object.t -> unit -> Py.Object.t
(**
Upper triangle of an array.

Return a copy of a matrix with the elements below the `k`-th diagonal
zeroed.

Please refer to the documentation for `tril` for further details.

See Also
--------
tril : lower triangle of an array

Examples
--------
>>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 0,  8,  9],
       [ 0,  0, 12]])
*)

val zeros : ?dtype:Dtype.t -> ?order:[`C | `F] -> int list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
zeros(shape, dtype=float, order='C')

Return a new array of given shape and type, filled with zeros.

Parameters
----------
shape : int or tuple of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: 'C'
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of zeros with the given shape, dtype, and order.

See Also
--------
zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.

Examples
--------
>>> np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])

>>> np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])

>>> np.zeros((2, 1))
array([[ 0.],
       [ 0.]])

>>> s = (2,2)
>>> np.zeros(s)
array([[ 0.,  0.],
       [ 0.,  0.]])

>>> np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
      dtype=[('x', '<i4'), ('y', '<i4')])
*)


end

val cholesky : Py.Object.t -> Py.Object.t
(**
Cholesky decomposition.

Return the Cholesky decomposition, `L * L.H`, of the square matrix `a`,
where `L` is lower-triangular and .H is the conjugate transpose operator
(which is the ordinary transpose if `a` is real-valued).  `a` must be
Hermitian (symmetric if real-valued) and positive-definite.  Only `L` is
actually returned.

Parameters
----------
a : (..., M, M) array_like
    Hermitian (symmetric if all elements are real), positive-definite
    input matrix.

Returns
-------
L : (..., M, M) array_like
    Upper or lower-triangular Cholesky factor of `a`.  Returns a
    matrix object if `a` is a matrix object.

Raises
------
LinAlgError
   If the decomposition fails, for example, if `a` is not
   positive-definite.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The Cholesky decomposition is often used as a fast way of solving

.. math:: A \mathbf{x} = \mathbf{b}

(when `A` is both Hermitian/symmetric and positive-definite).

First, we solve for :math:`\mathbf{y}` in

.. math:: L \mathbf{y} = \mathbf{b},

and then for :math:`\mathbf{x}` in

.. math:: L.H \mathbf{x} = \mathbf{y}.

Examples
--------
>>> A = np.array([[1,-2j],[2j,5]])
>>> A
array([[ 1.+0.j, -0.-2.j],
       [ 0.+2.j,  5.+0.j]])
>>> L = np.linalg.cholesky(A)
>>> L
array([[1.+0.j, 0.+0.j],
       [0.+2.j, 1.+0.j]])
>>> np.dot(L, L.T.conj()) # verify that L * L.H = A
array([[1.+0.j, 0.-2.j],
       [0.+2.j, 5.+0.j]])
>>> A = [[1,-2j],[2j,5]] # what happens if A is only array_like?
>>> np.linalg.cholesky(A) # an ndarray object is returned
array([[1.+0.j, 0.+0.j],
       [0.+2.j, 1.+0.j]])
>>> # But a matrix object is returned if A is a matrix object
>>> np.linalg.cholesky(np.matrix(A))
matrix([[ 1.+0.j,  0.+0.j],
        [ 0.+2.j,  1.+0.j]])
*)

val cond : ?p:[`Two | `One | `Fro | `PyObject of Py.Object.t] -> Py.Object.t -> Py.Object.t
(**
Compute the condition number of a matrix.

This function is capable of returning the condition number using
one of seven different norms, depending on the value of `p` (see
Parameters below).

Parameters
----------
x : (..., M, N) array_like
    The matrix whose condition number is sought.
p : {None, 1, -1, 2, -2, inf, -inf, 'fro'}, optional
    Order of the norm:

    =====  ============================
    p      norm for matrices
    =====  ============================
    None   2-norm, computed directly using the ``SVD``
    'fro'  Frobenius norm
    inf    max(sum(abs(x), axis=1))
    -inf   min(sum(abs(x), axis=1))
    1      max(sum(abs(x), axis=0))
    -1     min(sum(abs(x), axis=0))
    2      2-norm (largest sing. value)
    -2     smallest singular value
    =====  ============================

    inf means the numpy.inf object, and the Frobenius norm is
    the root-of-sum-of-squares norm.

Returns
-------
c : {float, inf}
    The condition number of the matrix. May be infinite.

See Also
--------
numpy.linalg.norm

Notes
-----
The condition number of `x` is defined as the norm of `x` times the
norm of the inverse of `x` [1]_; the norm can be the usual L2-norm
(root-of-sum-of-squares) or one of a number of other matrix norms.

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, Orlando, FL,
       Academic Press, Inc., 1980, pg. 285.

Examples
--------
>>> from numpy import linalg as LA
>>> a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])
>>> a
array([[ 1,  0, -1],
       [ 0,  1,  0],
       [ 1,  0,  1]])
>>> LA.cond(a)
1.4142135623730951
>>> LA.cond(a, 'fro')
3.1622776601683795
>>> LA.cond(a, np.inf)
2.0
>>> LA.cond(a, -np.inf)
1.0
>>> LA.cond(a, 1)
2.0
>>> LA.cond(a, -1)
1.0
>>> LA.cond(a, 2)
1.4142135623730951
>>> LA.cond(a, -2)
0.70710678118654746 # may vary
>>> min(LA.svd(a, compute_uv=False))*min(LA.svd(LA.inv(a), compute_uv=False))
0.70710678118654746 # may vary
*)

val det : Py.Object.t -> Py.Object.t
(**
Compute the determinant of an array.

Parameters
----------
a : (..., M, M) array_like
    Input array to compute determinants for.

Returns
-------
det : (...) array_like
    Determinant of `a`.

See Also
--------
slogdet : Another way to represent the determinant, more suitable
  for large matrices where underflow/overflow may occur.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The determinant is computed via LU factorization using the LAPACK
routine ``z/dgetrf``.

Examples
--------
The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:

>>> a = np.array([[1, 2], [3, 4]])
>>> np.linalg.det(a)
-2.0 # may vary

Computing determinants for a stack of matrices:

>>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
>>> a.shape
(3, 2, 2)
>>> np.linalg.det(a)
array([-2., -3., -8.])
*)

val eig : Py.Object.t -> (Py.Object.t * Py.Object.t)
(**
Compute the eigenvalues and right eigenvectors of a square array.

Parameters
----------
a : (..., M, M) array
    Matrices for which the eigenvalues and right eigenvectors will
    be computed

Returns
-------
w : (..., M) array
    The eigenvalues, each repeated according to its multiplicity.
    The eigenvalues are not necessarily ordered. The resulting
    array will be of complex type, unless the imaginary part is
    zero in which case it will be cast to a real type. When `a`
    is real the resulting eigenvalues will be real (0 imaginary
    part) or occur in conjugate pairs

v : (..., M, M) array
    The normalized (unit 'length') eigenvectors, such that the
    column ``v[:,i]`` is the eigenvector corresponding to the
    eigenvalue ``w[i]``.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eigvals : eigenvalues of a non-symmetric array.

eigh : eigenvalues and eigenvectors of a real symmetric or complex
       Hermitian (conjugate symmetric) array.

eigvalsh : eigenvalues of a real symmetric or complex Hermitian
           (conjugate symmetric) array.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

This is implemented using the ``_geev`` LAPACK routines which compute
the eigenvalues and eigenvectors of general square arrays.

The number `w` is an eigenvalue of `a` if there exists a vector
`v` such that ``dot(a,v) = w * v``. Thus, the arrays `a`, `w`, and
`v` satisfy the equations ``dot(a[:,:], v[:,i]) = w[i] * v[:,i]``
for :math:`i \in \{0,...,M-1\}`.

The array `v` of eigenvectors may not be of maximum rank, that is, some
of the columns may be linearly dependent, although round-off error may
obscure that fact. If the eigenvalues are all different, then theoretically
the eigenvectors are linearly independent. Likewise, the (complex-valued)
matrix of eigenvectors `v` is unitary if the matrix `a` is normal, i.e.,
if ``dot(a, a.H) = dot(a.H, a)``, where `a.H` denotes the conjugate
transpose of `a`.

Finally, it is emphasized that `v` consists of the *right* (as in
right-hand side) eigenvectors of `a`.  A vector `y` satisfying
``dot(y.T, a) = z * y.T`` for some number `z` is called a *left*
eigenvector of `a`, and, in general, the left and right eigenvectors
of a matrix are not necessarily the (perhaps conjugate) transposes
of each other.

References
----------
G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando, FL,
Academic Press, Inc., 1980, Various pp.

Examples
--------
>>> from numpy import linalg as LA

(Almost) trivial example with real e-values and e-vectors.

>>> w, v = LA.eig(np.diag((1, 2, 3)))
>>> w; v
array([1., 2., 3.])
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])

Real matrix possessing complex e-values and e-vectors; note that the
e-values are complex conjugates of each other.

>>> w, v = LA.eig(np.array([[1, -1], [1, 1]]))
>>> w; v
array([1.+1.j, 1.-1.j])
array([[0.70710678+0.j        , 0.70710678-0.j        ],
       [0.        -0.70710678j, 0.        +0.70710678j]])

Complex-valued matrix with real e-values (but complex-valued e-vectors);
note that ``a.conj().T == a``, i.e., `a` is Hermitian.

>>> a = np.array([[1, 1j], [-1j, 1]])
>>> w, v = LA.eig(a)
>>> w; v
array([2.+0.j, 0.+0.j])
array([[ 0.        +0.70710678j,  0.70710678+0.j        ], # may vary
       [ 0.70710678+0.j        , -0.        +0.70710678j]])

Be careful about round-off error!

>>> a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])
>>> # Theor. e-values are 1 +/- 1e-9
>>> w, v = LA.eig(a)
>>> w; v
array([1., 1.])
array([[1., 0.],
       [0., 1.]])
*)

val eigh : ?uplo:[`L | `U] -> Py.Object.t -> (Py.Object.t * Py.Object.t)
(**
Return the eigenvalues and eigenvectors of a complex Hermitian
(conjugate symmetric) or a real symmetric matrix.

Returns two objects, a 1-D array containing the eigenvalues of `a`, and
a 2-D square array or matrix (depending on the input type) of the
corresponding eigenvectors (in columns).

Parameters
----------
a : (..., M, M) array
    Hermitian or real symmetric matrices whose eigenvalues and
    eigenvectors are to be computed.
UPLO : {'L', 'U'}, optional
    Specifies whether the calculation is done with the lower triangular
    part of `a` ('L', default) or the upper triangular part ('U').
    Irrespective of this value only the real parts of the diagonal will
    be considered in the computation to preserve the notion of a Hermitian
    matrix. It therefore follows that the imaginary part of the diagonal
    will always be treated as zero.

Returns
-------
w : (..., M) ndarray
    The eigenvalues in ascending order, each repeated according to
    its multiplicity.
v : {(..., M, M) ndarray, (..., M, M) matrix}
    The column ``v[:, i]`` is the normalized eigenvector corresponding
    to the eigenvalue ``w[i]``.  Will return a matrix object if `a` is
    a matrix object.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eigvalsh : eigenvalues of real symmetric or complex Hermitian
           (conjugate symmetric) arrays.
eig : eigenvalues and right eigenvectors for non-symmetric arrays.
eigvals : eigenvalues of non-symmetric arrays.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The eigenvalues/eigenvectors are computed using LAPACK routines ``_syevd``,
``_heevd``.

The eigenvalues of real symmetric or complex Hermitian matrices are
always real. [1]_ The array `v` of (column) eigenvectors is unitary
and `a`, `w`, and `v` satisfy the equations
``dot(a, v[:, i]) = w[i] * v[:, i]``.

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
       FL, Academic Press, Inc., 1980, pg. 222.

Examples
--------
>>> from numpy import linalg as LA
>>> a = np.array([[1, -2j], [2j, 5]])
>>> a
array([[ 1.+0.j, -0.-2.j],
       [ 0.+2.j,  5.+0.j]])
>>> w, v = LA.eigh(a)
>>> w; v
array([0.17157288, 5.82842712])
array([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary
       [ 0.        +0.38268343j,  0.        -0.92387953j]])

>>> np.dot(a, v[:, 0]) - w[0] * v[:, 0] # verify 1st e-val/vec pair
array([5.55111512e-17+0.0000000e+00j, 0.00000000e+00+1.2490009e-16j])
>>> np.dot(a, v[:, 1]) - w[1] * v[:, 1] # verify 2nd e-val/vec pair
array([0.+0.j, 0.+0.j])

>>> A = np.matrix(a) # what happens if input is a matrix object
>>> A
matrix([[ 1.+0.j, -0.-2.j],
        [ 0.+2.j,  5.+0.j]])
>>> w, v = LA.eigh(A)
>>> w; v
array([0.17157288, 5.82842712])
matrix([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary
        [ 0.        +0.38268343j,  0.        -0.92387953j]])

>>> # demonstrate the treatment of the imaginary part of the diagonal
>>> a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
>>> a
array([[5.+2.j, 9.-2.j],
       [0.+2.j, 2.-1.j]])
>>> # with UPLO='L' this is numerically equivalent to using LA.eig() with:
>>> b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
>>> b
array([[5.+0.j, 0.-2.j],
       [0.+2.j, 2.+0.j]])
>>> wa, va = LA.eigh(a)
>>> wb, vb = LA.eig(b)
>>> wa; wb
array([1., 6.])
array([6.+0.j, 1.+0.j])
>>> va; vb
array([[-0.4472136 +0.j        , -0.89442719+0.j        ], # may vary
       [ 0.        +0.89442719j,  0.        -0.4472136j ]])
array([[ 0.89442719+0.j       , -0.        +0.4472136j],
       [-0.        +0.4472136j,  0.89442719+0.j       ]])
*)

val eigvals : Py.Object.t -> Py.Object.t
(**
Compute the eigenvalues of a general matrix.

Main difference between `eigvals` and `eig`: the eigenvectors aren't
returned.

Parameters
----------
a : (..., M, M) array_like
    A complex- or real-valued matrix whose eigenvalues will be computed.

Returns
-------
w : (..., M,) ndarray
    The eigenvalues, each repeated according to its multiplicity.
    They are not necessarily ordered, nor are they necessarily
    real for real matrices.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eig : eigenvalues and right eigenvectors of general arrays
eigvalsh : eigenvalues of real symmetric or complex Hermitian
           (conjugate symmetric) arrays.
eigh : eigenvalues and eigenvectors of real symmetric or complex
       Hermitian (conjugate symmetric) arrays.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

This is implemented using the ``_geev`` LAPACK routines which compute
the eigenvalues and eigenvectors of general square arrays.

Examples
--------
Illustration, using the fact that the eigenvalues of a diagonal matrix
are its diagonal elements, that multiplying a matrix on the left
by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
of `Q`), preserves the eigenvalues of the 'middle' matrix.  In other words,
if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
``A``:

>>> from numpy import linalg as LA
>>> x = np.random.random()
>>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
>>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
(1.0, 1.0, 0.0)

Now multiply a diagonal matrix by ``Q`` on one side and by ``Q.T`` on the other:

>>> D = np.diag((-1,1))
>>> LA.eigvals(D)
array([-1.,  1.])
>>> A = np.dot(Q, D)
>>> A = np.dot(A, Q.T)
>>> LA.eigvals(A)
array([ 1., -1.]) # random
*)

val eigvalsh : ?uplo:[`L | `U] -> Py.Object.t -> Py.Object.t
(**
Compute the eigenvalues of a complex Hermitian or real symmetric matrix.

Main difference from eigh: the eigenvectors are not computed.

Parameters
----------
a : (..., M, M) array_like
    A complex- or real-valued matrix whose eigenvalues are to be
    computed.
UPLO : {'L', 'U'}, optional
    Specifies whether the calculation is done with the lower triangular
    part of `a` ('L', default) or the upper triangular part ('U').
    Irrespective of this value only the real parts of the diagonal will
    be considered in the computation to preserve the notion of a Hermitian
    matrix. It therefore follows that the imaginary part of the diagonal
    will always be treated as zero.

Returns
-------
w : (..., M,) ndarray
    The eigenvalues in ascending order, each repeated according to
    its multiplicity.

Raises
------
LinAlgError
    If the eigenvalue computation does not converge.

See Also
--------
eigh : eigenvalues and eigenvectors of real symmetric or complex Hermitian
       (conjugate symmetric) arrays.
eigvals : eigenvalues of general real or complex arrays.
eig : eigenvalues and right eigenvectors of general real or complex
      arrays.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The eigenvalues are computed using LAPACK routines ``_syevd``, ``_heevd``.

Examples
--------
>>> from numpy import linalg as LA
>>> a = np.array([[1, -2j], [2j, 5]])
>>> LA.eigvalsh(a)
array([ 0.17157288,  5.82842712]) # may vary

>>> # demonstrate the treatment of the imaginary part of the diagonal
>>> a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
>>> a
array([[5.+2.j, 9.-2.j],
       [0.+2.j, 2.-1.j]])
>>> # with UPLO='L' this is numerically equivalent to using LA.eigvals()
>>> # with:
>>> b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
>>> b
array([[5.+0.j, 0.-2.j],
       [0.+2.j, 2.+0.j]])
>>> wa = LA.eigvalsh(a)
>>> wb = LA.eigvals(b)
>>> wa; wb
array([1., 6.])
array([6.+0.j, 1.+0.j])
*)

val inv : Py.Object.t -> Py.Object.t
(**
Compute the (multiplicative) inverse of a matrix.

Given a square matrix `a`, return the matrix `ainv` satisfying
``dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])``.

Parameters
----------
a : (..., M, M) array_like
    Matrix to be inverted.

Returns
-------
ainv : (..., M, M) ndarray or matrix
    (Multiplicative) inverse of the matrix `a`.

Raises
------
LinAlgError
    If `a` is not square or inversion fails.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

Examples
--------
>>> from numpy.linalg import inv
>>> a = np.array([[1., 2.], [3., 4.]])
>>> ainv = inv(a)
>>> np.allclose(np.dot(a, ainv), np.eye(2))
True
>>> np.allclose(np.dot(ainv, a), np.eye(2))
True

If a is a matrix object, then the return value is a matrix as well:

>>> ainv = inv(np.matrix(a))
>>> ainv
matrix([[-2. ,  1. ],
        [ 1.5, -0.5]])

Inverses of several matrices can be computed at once:

>>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
>>> inv(a)
array([[[-2.  ,  1.  ],
        [ 1.5 , -0.5 ]],
       [[-1.25,  0.75],
        [ 0.75, -0.25]]])
*)

val lstsq : ?rcond:float -> b:Py.Object.t -> [>`Ndarray] Obj.t -> (Py.Object.t * Py.Object.t * int * Py.Object.t)
(**
Return the least-squares solution to a linear matrix equation.

Solves the equation :math:`a x = b` by computing a vector `x` that
minimizes the squared Euclidean 2-norm :math:`\| b - a x \|^2_2`.
The equation may be under-, well-, or over-determined (i.e., the
number of linearly independent rows of `a` can be less than, equal
to, or greater than its number of linearly independent columns).
If `a` is square and of full rank, then `x` (but for round-off error)
is the 'exact' solution of the equation.

Parameters
----------
a : (M, N) array_like
    'Coefficient' matrix.
b : {(M,), (M, K)} array_like
    Ordinate or 'dependent variable' values. If `b` is two-dimensional,
    the least-squares solution is calculated for each of the `K` columns
    of `b`.
rcond : float, optional
    Cut-off ratio for small singular values of `a`.
    For the purposes of rank determination, singular values are treated
    as zero if they are smaller than `rcond` times the largest singular
    value of `a`.

    .. versionchanged:: 1.14.0
       If not set, a FutureWarning is given. The previous default
       of ``-1`` will use the machine precision as `rcond` parameter,
       the new default will use the machine precision times `max(M, N)`.
       To silence the warning and use the new default, use ``rcond=None``,
       to keep using the old behavior, use ``rcond=-1``.

Returns
-------
x : {(N,), (N, K)} ndarray
    Least-squares solution. If `b` is two-dimensional,
    the solutions are in the `K` columns of `x`.
residuals : {(1,), (K,), (0,)} ndarray
    Sums of residuals; squared Euclidean 2-norm for each column in
    ``b - a*x``.
    If the rank of `a` is < N or M <= N, this is an empty array.
    If `b` is 1-dimensional, this is a (1,) shape array.
    Otherwise the shape is (K,).
rank : int
    Rank of matrix `a`.
s : (min(M, N),) ndarray
    Singular values of `a`.

Raises
------
LinAlgError
    If computation does not converge.

Notes
-----
If `b` is a matrix, then all array results are returned as matrices.

Examples
--------
Fit a line, ``y = mx + c``, through some noisy data-points:

>>> x = np.array([0, 1, 2, 3])
>>> y = np.array([-1, 0.2, 0.9, 2.1])

By examining the coefficients, we see that the line should have a
gradient of roughly 1 and cut the y-axis at, more or less, -1.

We can rewrite the line equation as ``y = Ap``, where ``A = [[x 1]]``
and ``p = [[m], [c]]``.  Now use `lstsq` to solve for `p`:

>>> A = np.vstack([x, np.ones(len(x))]).T
>>> A
array([[ 0.,  1.],
       [ 1.,  1.],
       [ 2.,  1.],
       [ 3.,  1.]])

>>> m, c = np.linalg.lstsq(A, y, rcond=None)[0]
>>> m, c
(1.0 -0.95) # may vary

Plot the data along with the fitted line:

>>> import matplotlib.pyplot as plt
>>> _ = plt.plot(x, y, 'o', label='Original data', markersize=10)
>>> _ = plt.plot(x, m*x + c, 'r', label='Fitted line')
>>> _ = plt.legend()
>>> plt.show()
*)

val matrix_power : n:int -> Py.Object.t -> Py.Object.t
(**
Raise a square matrix to the (integer) power `n`.

For positive integers `n`, the power is computed by repeated matrix
squarings and matrix multiplications. If ``n == 0``, the identity matrix
of the same shape as M is returned. If ``n < 0``, the inverse
is computed and then raised to the ``abs(n)``.

.. note:: Stacks of object matrices are not currently supported.

Parameters
----------
a : (..., M, M) array_like
    Matrix to be 'powered'.
n : int
    The exponent can be any integer or long integer, positive,
    negative, or zero.

Returns
-------
a**n : (..., M, M) ndarray or matrix object
    The return value is the same shape and type as `M`;
    if the exponent is positive or zero then the type of the
    elements is the same as those of `M`. If the exponent is
    negative the elements are floating-point.

Raises
------
LinAlgError
    For matrices that are not square or that (for negative powers) cannot
    be inverted numerically.

Examples
--------
>>> from numpy.linalg import matrix_power
>>> i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit
>>> matrix_power(i, 3) # should = -i
array([[ 0, -1],
       [ 1,  0]])
>>> matrix_power(i, 0)
array([[1, 0],
       [0, 1]])
>>> matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements
array([[ 0.,  1.],
       [-1.,  0.]])

Somewhat more sophisticated example

>>> q = np.zeros((4, 4))
>>> q[0:2, 0:2] = -i
>>> q[2:4, 2:4] = i
>>> q # one of the three quaternion units not equal to 1
array([[ 0., -1.,  0.,  0.],
       [ 1.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  1.],
       [ 0.,  0., -1.,  0.]])
>>> matrix_power(q, 2) # = -np.eye(4)
array([[-1.,  0.,  0.,  0.],
       [ 0., -1.,  0.,  0.],
       [ 0.,  0., -1.,  0.],
       [ 0.,  0.,  0., -1.]])
*)

val matrix_rank : ?tol:[`F of float | `T_array_like of Py.Object.t] -> ?hermitian:bool -> m:Py.Object.t -> unit -> Py.Object.t
(**
Return matrix rank of array using SVD method

Rank of the array is the number of singular values of the array that are
greater than `tol`.

.. versionchanged:: 1.14
   Can now operate on stacks of matrices

Parameters
----------
M : {(M,), (..., M, N)} array_like
    Input vector or stack of matrices.
tol : (...) array_like, float, optional
    Threshold below which SVD values are considered zero. If `tol` is
    None, and ``S`` is an array with singular values for `M`, and
    ``eps`` is the epsilon value for datatype of ``S``, then `tol` is
    set to ``S.max() * max(M.shape) * eps``.

    .. versionchanged:: 1.14
       Broadcasted against the stack of matrices
hermitian : bool, optional
    If True, `M` is assumed to be Hermitian (symmetric if real-valued),
    enabling a more efficient method for finding singular values.
    Defaults to False.

    .. versionadded:: 1.14

Returns
-------
rank : (...) array_like
    Rank of M.

Notes
-----
The default threshold to detect rank deficiency is a test on the magnitude
of the singular values of `M`.  By default, we identify singular values less
than ``S.max() * max(M.shape) * eps`` as indicating rank deficiency (with
the symbols defined above). This is the algorithm MATLAB uses [1].  It also
appears in *Numerical recipes* in the discussion of SVD solutions for linear
least squares [2].

This default threshold is designed to detect rank deficiency accounting for
the numerical errors of the SVD computation.  Imagine that there is a column
in `M` that is an exact (in floating point) linear combination of other
columns in `M`. Computing the SVD on `M` will not produce a singular value
exactly equal to 0 in general: any difference of the smallest SVD value from
0 will be caused by numerical imprecision in the calculation of the SVD.
Our threshold for small SVD values takes this numerical imprecision into
account, and the default threshold will detect such numerical rank
deficiency.  The threshold may declare a matrix `M` rank deficient even if
the linear combination of some columns of `M` is not exactly equal to
another column of `M` but only numerically very close to another column of
`M`.

We chose our default threshold because it is in wide use.  Other thresholds
are possible.  For example, elsewhere in the 2007 edition of *Numerical
recipes* there is an alternative threshold of ``S.max() *
np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)``. The authors describe
this threshold as being based on 'expected roundoff error' (p 71).

The thresholds above deal with floating point roundoff error in the
calculation of the SVD.  However, you may have more information about the
sources of error in `M` that would make you consider other tolerance values
to detect *effective* rank deficiency.  The most useful measure of the
tolerance depends on the operations you intend to use on your matrix.  For
example, if your data come from uncertain measurements with uncertainties
greater than floating point epsilon, choosing a tolerance near that
uncertainty may be preferable.  The tolerance may be absolute if the
uncertainties are absolute rather than relative.

References
----------
.. [1] MATLAB reference documention, 'Rank'
       https://www.mathworks.com/help/techdoc/ref/rank.html
.. [2] W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery,
       'Numerical Recipes (3rd edition)', Cambridge University Press, 2007,
       page 795.

Examples
--------
>>> from numpy.linalg import matrix_rank
>>> matrix_rank(np.eye(4)) # Full rank matrix
4
>>> I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix
>>> matrix_rank(I)
3
>>> matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0
1
>>> matrix_rank(np.zeros((4,)))
0
*)

val multi_dot : Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the dot product of two or more arrays in a single function call,
while automatically selecting the fastest evaluation order.

`multi_dot` chains `numpy.dot` and uses optimal parenthesization
of the matrices [1]_ [2]_. Depending on the shapes of the matrices,
this can speed up the multiplication a lot.

If the first argument is 1-D it is treated as a row vector.
If the last argument is 1-D it is treated as a column vector.
The other arguments must be 2-D.

Think of `multi_dot` as::

    def multi_dot(arrays): return functools.reduce(np.dot, arrays)


Parameters
----------
arrays : sequence of array_like
    If the first argument is 1-D it is treated as row vector.
    If the last argument is 1-D it is treated as column vector.
    The other arguments must be 2-D.

Returns
-------
output : ndarray
    Returns the dot product of the supplied arrays.

See Also
--------
dot : dot multiplication with two arguments.

References
----------

.. [1] Cormen, 'Introduction to Algorithms', Chapter 15.2, p. 370-378
.. [2] https://en.wikipedia.org/wiki/Matrix_chain_multiplication

Examples
--------
`multi_dot` allows you to write::

>>> from numpy.linalg import multi_dot
>>> # Prepare some data
>>> A = np.random.random((10000, 100))
>>> B = np.random.random((100, 1000))
>>> C = np.random.random((1000, 5))
>>> D = np.random.random((5, 333))
>>> # the actual dot multiplication
>>> _ = multi_dot([A, B, C, D])

instead of::

>>> _ = np.dot(np.dot(np.dot(A, B), C), D)
>>> # or
>>> _ = A.dot(B).dot(C).dot(D)

Notes
-----
The cost for a matrix multiplication can be calculated with the
following function::

    def cost(A, B):
        return A.shape[0] * A.shape[1] * B.shape[1]

Assume we have three matrices
:math:`A_{10x100}, B_{100x5}, C_{5x50}`.

The costs for the two different parenthesizations are as follows::

    cost((AB)C) = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500
    cost(A(BC)) = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000
*)

val norm : ?ord:[`Nuc | `PyObject of Py.Object.t | `Fro] -> ?axis:[`I of int | `T2_tuple_of_ints of Py.Object.t] -> ?keepdims:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Matrix or vector norm.

This function is able to return one of eight different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the ``ord`` parameter.

Parameters
----------
x : array_like
    Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
    is None. If both `axis` and `ord` are None, the 2-norm of
    ``x.ravel`` will be returned.
ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
    Order of the norm (see table under ``Notes``). inf means numpy's
    `inf` object. The default is None.
axis : {None, int, 2-tuple of ints}, optional.
    If `axis` is an integer, it specifies the axis of `x` along which to
    compute the vector norms.  If `axis` is a 2-tuple, it specifies the
    axes that hold 2-D matrices, and the matrix norms of these matrices
    are computed.  If `axis` is None then either a vector norm (when `x`
    is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
    is None.

    .. versionadded:: 1.8.0

keepdims : bool, optional
    If this is set to True, the axes which are normed over are left in the
    result as dimensions with size one.  With this option the result will
    broadcast correctly against the original `x`.

    .. versionadded:: 1.10.0

Returns
-------
n : float or ndarray
    Norm of the matrix or vector(s).

Notes
-----
For values of ``ord <= 0``, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.

The following norms can be calculated:

=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
'nuc'  nuclear norm                  --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)**ord)**(1./ord)
=====  ============================  ==========================

The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

The nuclear norm is the sum of the singular values.

References
----------
.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
       Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15

Examples
--------
>>> from numpy import linalg as LA
>>> a = np.arange(9) - 4
>>> a
array([-4, -3, -2, ...,  2,  3,  4])
>>> b = a.reshape((3, 3))
>>> b
array([[-4, -3, -2],
       [-1,  0,  1],
       [ 2,  3,  4]])

>>> LA.norm(a)
7.745966692414834
>>> LA.norm(b)
7.745966692414834
>>> LA.norm(b, 'fro')
7.745966692414834
>>> LA.norm(a, np.inf)
4.0
>>> LA.norm(b, np.inf)
9.0
>>> LA.norm(a, -np.inf)
0.0
>>> LA.norm(b, -np.inf)
2.0

>>> LA.norm(a, 1)
20.0
>>> LA.norm(b, 1)
7.0
>>> LA.norm(a, -1)
-4.6566128774142013e-010
>>> LA.norm(b, -1)
6.0
>>> LA.norm(a, 2)
7.745966692414834
>>> LA.norm(b, 2)
7.3484692283495345

>>> LA.norm(a, -2)
0.0
>>> LA.norm(b, -2)
1.8570331885190563e-016 # may vary
>>> LA.norm(a, 3)
5.8480354764257312 # may vary
>>> LA.norm(a, -3)
0.0

Using the `axis` argument to compute vector norms:

>>> c = np.array([[ 1, 2, 3],
...               [-1, 1, 4]])
>>> LA.norm(c, axis=0)
array([ 1.41421356,  2.23606798,  5.        ])
>>> LA.norm(c, axis=1)
array([ 3.74165739,  4.24264069])
>>> LA.norm(c, ord=1, axis=1)
array([ 6.,  6.])

Using the `axis` argument to compute matrix norms:

>>> m = np.arange(8).reshape(2,2,2)
>>> LA.norm(m, axis=(1,2))
array([  3.74165739,  11.22497216])
>>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
(3.7416573867739413, 11.224972160321824)
*)

val pinv : ?rcond:Py.Object.t -> ?hermitian:bool -> Py.Object.t -> Py.Object.t
(**
Compute the (Moore-Penrose) pseudo-inverse of a matrix.

Calculate the generalized inverse of a matrix using its
singular-value decomposition (SVD) and including all
*large* singular values.

.. versionchanged:: 1.14
   Can now operate on stacks of matrices

Parameters
----------
a : (..., M, N) array_like
    Matrix or stack of matrices to be pseudo-inverted.
rcond : (...) array_like of float
    Cutoff for small singular values.
    Singular values less than or equal to
    ``rcond * largest_singular_value`` are set to zero.
    Broadcasts against the stack of matrices.
hermitian : bool, optional
    If True, `a` is assumed to be Hermitian (symmetric if real-valued),
    enabling a more efficient method for finding singular values.
    Defaults to False.

    .. versionadded:: 1.17.0

Returns
-------
B : (..., N, M) ndarray
    The pseudo-inverse of `a`. If `a` is a `matrix` instance, then so
    is `B`.

Raises
------
LinAlgError
    If the SVD computation does not converge.

Notes
-----
The pseudo-inverse of a matrix A, denoted :math:`A^+`, is
defined as: 'the matrix that 'solves' [the least-squares problem]
:math:`Ax = b`,' i.e., if :math:`\bar{x}` is said solution, then
:math:`A^+` is that matrix such that :math:`\bar{x} = A^+b`.

It can be shown that if :math:`Q_1 \Sigma Q_2^T = A` is the singular
value decomposition of A, then
:math:`A^+ = Q_2 \Sigma^+ Q_1^T`, where :math:`Q_{1,2}` are
orthogonal matrices, :math:`\Sigma` is a diagonal matrix consisting
of A's so-called singular values, (followed, typically, by
zeros), and then :math:`\Sigma^+` is simply the diagonal matrix
consisting of the reciprocals of A's singular values
(again, followed by zeros). [1]_

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
       FL, Academic Press, Inc., 1980, pp. 139-142.

Examples
--------
The following example checks that ``a * a+ * a == a`` and
``a+ * a * a+ == a+``:

>>> a = np.random.randn(9, 6)
>>> B = np.linalg.pinv(a)
>>> np.allclose(a, np.dot(a, np.dot(B, a)))
True
>>> np.allclose(B, np.dot(B, np.dot(a, B)))
True
*)

val qr : ?mode:[`Reduced | `Complete | `R | `Raw] -> [>`Ndarray] Obj.t -> (Py.Object.t * Py.Object.t)
(**
Compute the qr factorization of a matrix.

Factor the matrix `a` as *qr*, where `q` is orthonormal and `r` is
upper-triangular.

Parameters
----------
a : array_like, shape (M, N)
    Matrix to be factored.
mode : {'reduced', 'complete', 'r', 'raw'}, optional
    If K = min(M, N), then

    * 'reduced'  : returns q, r with dimensions (M, K), (K, N) (default)
    * 'complete' : returns q, r with dimensions (M, M), (M, N)
    * 'r'        : returns r only with dimensions (K, N)
    * 'raw'      : returns h, tau with dimensions (N, M), (K,)

    The options 'reduced', 'complete, and 'raw' are new in numpy 1.8,
    see the notes for more information. The default is 'reduced', and to
    maintain backward compatibility with earlier versions of numpy both
    it and the old default 'full' can be omitted. Note that array h
    returned in 'raw' mode is transposed for calling Fortran. The
    'economic' mode is deprecated.  The modes 'full' and 'economic' may
    be passed using only the first letter for backwards compatibility,
    but all others must be spelled out. See the Notes for more
    explanation.


Returns
-------
q : ndarray of float or complex, optional
    A matrix with orthonormal columns. When mode = 'complete' the
    result is an orthogonal/unitary matrix depending on whether or not
    a is real/complex. The determinant may be either +/- 1 in that
    case.
r : ndarray of float or complex, optional
    The upper-triangular matrix.
(h, tau) : ndarrays of np.double or np.cdouble, optional
    The array h contains the Householder reflectors that generate q
    along with r. The tau array contains scaling factors for the
    reflectors. In the deprecated  'economic' mode only h is returned.

Raises
------
LinAlgError
    If factoring fails.

Notes
-----
This is an interface to the LAPACK routines ``dgeqrf``, ``zgeqrf``,
``dorgqr``, and ``zungqr``.

For more information on the qr factorization, see for example:
https://en.wikipedia.org/wiki/QR_factorization

Subclasses of `ndarray` are preserved except for the 'raw' mode. So if
`a` is of type `matrix`, all the return values will be matrices too.

New 'reduced', 'complete', and 'raw' options for mode were added in
NumPy 1.8.0 and the old option 'full' was made an alias of 'reduced'.  In
addition the options 'full' and 'economic' were deprecated.  Because
'full' was the previous default and 'reduced' is the new default,
backward compatibility can be maintained by letting `mode` default.
The 'raw' option was added so that LAPACK routines that can multiply
arrays by q using the Householder reflectors can be used. Note that in
this case the returned arrays are of type np.double or np.cdouble and
the h array is transposed to be FORTRAN compatible.  No routines using
the 'raw' return are currently exposed by numpy, but some are available
in lapack_lite and just await the necessary work.

Examples
--------
>>> a = np.random.randn(9, 6)
>>> q, r = np.linalg.qr(a)
>>> np.allclose(a, np.dot(q, r))  # a does equal qr
True
>>> r2 = np.linalg.qr(a, mode='r')
>>> np.allclose(r, r2)  # mode='r' returns the same r as mode='full'
True

Example illustrating a common use of `qr`: solving of least squares
problems

What are the least-squares-best `m` and `y0` in ``y = y0 + mx`` for
the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points
and you'll see that it should be y0 = 0, m = 1.)  The answer is provided
by solving the over-determined matrix equation ``Ax = b``, where::

  A = array([[0, 1], [1, 1], [1, 1], [2, 1]])
  x = array([[y0], [m]])
  b = array([[1], [0], [2], [1]])

If A = qr such that q is orthonormal (which is always possible via
Gram-Schmidt), then ``x = inv(r) * (q.T) * b``.  (In numpy practice,
however, we simply use `lstsq`.)

>>> A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])
>>> A
array([[0, 1],
       [1, 1],
       [1, 1],
       [2, 1]])
>>> b = np.array([1, 0, 2, 1])
>>> q, r = np.linalg.qr(A)
>>> p = np.dot(q.T, b)
>>> np.dot(np.linalg.inv(r), p)
array([  1.1e-16,   1.0e+00])
*)

val slogdet : Py.Object.t -> (Py.Object.t * Py.Object.t)
(**
Compute the sign and (natural) logarithm of the determinant of an array.

If an array has a very small or very large determinant, then a call to
`det` may overflow or underflow. This routine is more robust against such
issues, because it computes the logarithm of the determinant rather than
the determinant itself.

Parameters
----------
a : (..., M, M) array_like
    Input array, has to be a square 2-D array.

Returns
-------
sign : (...) array_like
    A number representing the sign of the determinant. For a real matrix,
    this is 1, 0, or -1. For a complex matrix, this is a complex number
    with absolute value 1 (i.e., it is on the unit circle), or else 0.
logdet : (...) array_like
    The natural log of the absolute value of the determinant.

If the determinant is zero, then `sign` will be 0 and `logdet` will be
-Inf. In all cases, the determinant is equal to ``sign * np.exp(logdet)``.

See Also
--------
det

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

.. versionadded:: 1.6.0

The determinant is computed via LU factorization using the LAPACK
routine ``z/dgetrf``.


Examples
--------
The determinant of a 2-D array ``[[a, b], [c, d]]`` is ``ad - bc``:

>>> a = np.array([[1, 2], [3, 4]])
>>> (sign, logdet) = np.linalg.slogdet(a)
>>> (sign, logdet)
(-1, 0.69314718055994529) # may vary
>>> sign * np.exp(logdet)
-2.0

Computing log-determinants for a stack of matrices:

>>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
>>> a.shape
(3, 2, 2)
>>> sign, logdet = np.linalg.slogdet(a)
>>> (sign, logdet)
(array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))
>>> sign * np.exp(logdet)
array([-2., -3., -8.])

This routine succeeds where ordinary `det` does not:

>>> np.linalg.det(np.eye(500) * 0.1)
0.0
>>> np.linalg.slogdet(np.eye(500) * 0.1)
(1, -1151.2925464970228)
*)

val solve : b:[`Ndarray of [>`Ndarray] Obj.t | `PyObject of Py.Object.t] -> Py.Object.t -> Py.Object.t
(**
Solve a linear matrix equation, or system of linear scalar equations.

Computes the 'exact' solution, `x`, of the well-determined, i.e., full
rank, linear matrix equation `ax = b`.

Parameters
----------
a : (..., M, M) array_like
    Coefficient matrix.
b : {(..., M,), (..., M, K)}, array_like
    Ordinate or 'dependent variable' values.

Returns
-------
x : {(..., M,), (..., M, K)} ndarray
    Solution to the system a x = b.  Returned shape is identical to `b`.

Raises
------
LinAlgError
    If `a` is singular or not square.

Notes
-----

.. versionadded:: 1.8.0

Broadcasting rules apply, see the `numpy.linalg` documentation for
details.

The solutions are computed using LAPACK routine ``_gesv``.

`a` must be square and of full-rank, i.e., all rows (or, equivalently,
columns) must be linearly independent; if either is not true, use
`lstsq` for the least-squares best 'solution' of the
system/equation.

References
----------
.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
       FL, Academic Press, Inc., 1980, pg. 22.

Examples
--------
Solve the system of equations ``3 * x0 + x1 = 9`` and ``x0 + 2 * x1 = 8``:

>>> a = np.array([[3,1], [1,2]])
>>> b = np.array([9,8])
>>> x = np.linalg.solve(a, b)
>>> x
array([2.,  3.])

Check that the solution is correct:

>>> np.allclose(np.dot(a, x), b)
True
*)

val svd : ?full_matrices:bool -> ?compute_uv:bool -> ?hermitian:bool -> Py.Object.t -> (Py.Object.t * Py.Object.t * Py.Object.t)
(**
Singular Value Decomposition.

When `a` is a 2D array, it is factorized as ``u @ np.diag(s) @ vh
= (u * s) @ vh``, where `u` and `vh` are 2D unitary arrays and `s` is a 1D
array of `a`'s singular values. When `a` is higher-dimensional, SVD is
applied in stacked mode as explained below.

Parameters
----------
a : (..., M, N) array_like
    A real or complex array with ``a.ndim >= 2``.
full_matrices : bool, optional
    If True (default), `u` and `vh` have the shapes ``(..., M, M)`` and
    ``(..., N, N)``, respectively.  Otherwise, the shapes are
    ``(..., M, K)`` and ``(..., K, N)``, respectively, where
    ``K = min(M, N)``.
compute_uv : bool, optional
    Whether or not to compute `u` and `vh` in addition to `s`.  True
    by default.
hermitian : bool, optional
    If True, `a` is assumed to be Hermitian (symmetric if real-valued),
    enabling a more efficient method for finding singular values.
    Defaults to False.

    .. versionadded:: 1.17.0

Returns
-------
u : { (..., M, M), (..., M, K) } array
    Unitary array(s). The first ``a.ndim - 2`` dimensions have the same
    size as those of the input `a`. The size of the last two dimensions
    depends on the value of `full_matrices`. Only returned when
    `compute_uv` is True.
s : (..., K) array
    Vector(s) with the singular values, within each vector sorted in
    descending order. The first ``a.ndim - 2`` dimensions have the same
    size as those of the input `a`.
vh : { (..., N, N), (..., K, N) } array
    Unitary array(s). The first ``a.ndim - 2`` dimensions have the same
    size as those of the input `a`. The size of the last two dimensions
    depends on the value of `full_matrices`. Only returned when
    `compute_uv` is True.

Raises
------
LinAlgError
    If SVD computation does not converge.

Notes
-----

.. versionchanged:: 1.8.0
   Broadcasting rules apply, see the `numpy.linalg` documentation for
   details.

The decomposition is performed using LAPACK routine ``_gesdd``.

SVD is usually described for the factorization of a 2D matrix :math:`A`.
The higher-dimensional case will be discussed below. In the 2D case, SVD is
written as :math:`A = U S V^H`, where :math:`A = a`, :math:`U= u`,
:math:`S= \mathtt{np.diag}(s)` and :math:`V^H = vh`. The 1D array `s`
contains the singular values of `a` and `u` and `vh` are unitary. The rows
of `vh` are the eigenvectors of :math:`A^H A` and the columns of `u` are
the eigenvectors of :math:`A A^H`. In both cases the corresponding
(possibly non-zero) eigenvalues are given by ``s**2``.

If `a` has more than two dimensions, then broadcasting rules apply, as
explained in :ref:`routines.linalg-broadcasting`. This means that SVD is
working in 'stacked' mode: it iterates over all indices of the first
``a.ndim - 2`` dimensions and for each combination SVD is applied to the
last two indices. The matrix `a` can be reconstructed from the
decomposition with either ``(u * s[..., None, :]) @ vh`` or
``u @ (s[..., None] * vh)``. (The ``@`` operator can be replaced by the
function ``np.matmul`` for python versions below 3.5.)

If `a` is a ``matrix`` object (as opposed to an ``ndarray``), then so are
all the return values.

Examples
--------
>>> a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)
>>> b = np.random.randn(2, 7, 8, 3) + 1j*np.random.randn(2, 7, 8, 3)

Reconstruction based on full SVD, 2D case:

>>> u, s, vh = np.linalg.svd(a, full_matrices=True)
>>> u.shape, s.shape, vh.shape
((9, 9), (6,), (6, 6))
>>> np.allclose(a, np.dot(u[:, :6] * s, vh))
True
>>> smat = np.zeros((9, 6), dtype=complex)
>>> smat[:6, :6] = np.diag(s)
>>> np.allclose(a, np.dot(u, np.dot(smat, vh)))
True

Reconstruction based on reduced SVD, 2D case:

>>> u, s, vh = np.linalg.svd(a, full_matrices=False)
>>> u.shape, s.shape, vh.shape
((9, 6), (6,), (6, 6))
>>> np.allclose(a, np.dot(u * s, vh))
True
>>> smat = np.diag(s)
>>> np.allclose(a, np.dot(u, np.dot(smat, vh)))
True

Reconstruction based on full SVD, 4D case:

>>> u, s, vh = np.linalg.svd(b, full_matrices=True)
>>> u.shape, s.shape, vh.shape
((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))
>>> np.allclose(b, np.matmul(u[..., :3] * s[..., None, :], vh))
True
>>> np.allclose(b, np.matmul(u[..., :3], s[..., None] * vh))
True

Reconstruction based on reduced SVD, 4D case:

>>> u, s, vh = np.linalg.svd(b, full_matrices=False)
>>> u.shape, s.shape, vh.shape
((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))
>>> np.allclose(b, np.matmul(u * s[..., None, :], vh))
True
>>> np.allclose(b, np.matmul(u, s[..., None] * vh))
True
*)

val tensorinv : ?ind:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the 'inverse' of an N-dimensional array.

The result is an inverse for `a` relative to the tensordot operation
``tensordot(a, b, ind)``, i. e., up to floating-point accuracy,
``tensordot(tensorinv(a), a, ind)`` is the 'identity' tensor for the
tensordot operation.

Parameters
----------
a : array_like
    Tensor to 'invert'. Its shape must be 'square', i. e.,
    ``prod(a.shape[:ind]) == prod(a.shape[ind:])``.
ind : int, optional
    Number of first indices that are involved in the inverse sum.
    Must be a positive integer, default is 2.

Returns
-------
b : ndarray
    `a`'s tensordot inverse, shape ``a.shape[ind:] + a.shape[:ind]``.

Raises
------
LinAlgError
    If `a` is singular or not 'square' (in the above sense).

See Also
--------
numpy.tensordot, tensorsolve

Examples
--------
>>> a = np.eye(4*6)
>>> a.shape = (4, 6, 8, 3)
>>> ainv = np.linalg.tensorinv(a, ind=2)
>>> ainv.shape
(8, 3, 4, 6)
>>> b = np.random.randn(4, 6)
>>> np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))
True

>>> a = np.eye(4*6)
>>> a.shape = (24, 8, 3)
>>> ainv = np.linalg.tensorinv(a, ind=1)
>>> ainv.shape
(8, 3, 24)
>>> b = np.random.randn(24)
>>> np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))
True
*)

val tensorsolve : ?axes:int list -> b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Solve the tensor equation ``a x = b`` for x.

It is assumed that all indices of `x` are summed over in the product,
together with the rightmost indices of `a`, as is done in, for example,
``tensordot(a, x, axes=b.ndim)``.

Parameters
----------
a : array_like
    Coefficient tensor, of shape ``b.shape + Q``. `Q`, a tuple, equals
    the shape of that sub-tensor of `a` consisting of the appropriate
    number of its rightmost indices, and must be such that
    ``prod(Q) == prod(b.shape)`` (in which sense `a` is said to be
    'square').
b : array_like
    Right-hand tensor, which can be of any shape.
axes : tuple of ints, optional
    Axes in `a` to reorder to the right, before inversion.
    If None (default), no reordering is done.

Returns
-------
x : ndarray, shape Q

Raises
------
LinAlgError
    If `a` is singular or not 'square' (in the above sense).

See Also
--------
numpy.tensordot, tensorinv, numpy.einsum

Examples
--------
>>> a = np.eye(2*3*4)
>>> a.shape = (2*3, 4, 2, 3, 4)
>>> b = np.random.randn(2*3, 4)
>>> x = np.linalg.tensorsolve(a, b)
>>> x.shape
(2, 3, 4)
>>> np.allclose(np.tensordot(a, x, axes=3), b)
True
*)


end

module Ma : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

module MAError : sig
type tag = [`MAError]
type t = [`BaseException | `MAError | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module MaskError : sig
type tag = [`MaskError]
type t = [`BaseException | `MaskError | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module MaskedArray : sig
type tag = [`MaskedArray]
type t = [`ArrayLike | `MaskedArray | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?data:[>`Ndarray] Obj.t -> ?mask:Py.Object.t -> ?dtype:Dtype.t -> ?copy:bool -> ?subok:bool -> ?ndmin:int -> ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> ?keep_mask:bool -> ?hard_mask:bool -> ?shrink:bool -> ?order:[`C | `F | `A] -> ?options:(string * Py.Object.t) list -> unit -> t
(**
An array class with possibly masked values.

Masked values of True exclude the corresponding element from any
computation.

Construction::

  x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
                  ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
                  shrink=True, order=None)

Parameters
----------
data : array_like
    Input data.
mask : sequence, optional
    Mask. Must be convertible to an array of booleans with the same
    shape as `data`. True indicates a masked (i.e. invalid) data.
dtype : dtype, optional
    Data type of the output.
    If `dtype` is None, the type of the data argument (``data.dtype``)
    is used. If `dtype` is not None and different from ``data.dtype``,
    a copy is performed.
copy : bool, optional
    Whether to copy the input data (True), or to use a reference instead.
    Default is False.
subok : bool, optional
    Whether to return a subclass of `MaskedArray` if possible (True) or a
    plain `MaskedArray`. Default is True.
ndmin : int, optional
    Minimum number of dimensions. Default is 0.
fill_value : scalar, optional
    Value used to fill in the masked values when necessary.
    If None, a default based on the data-type is used.
keep_mask : bool, optional
    Whether to combine `mask` with the mask of the input data, if any
    (True), or to use only `mask` for the output (False). Default is True.
hard_mask : bool, optional
    Whether to use a hard mask or not. With a hard mask, masked values
    cannot be unmasked. Default is False.
shrink : bool, optional
    Whether to force compression of an empty mask. Default is True.
order : {'C', 'F', 'A'}, optional
    Specify the order of the array.  If order is 'C', then the array
    will be in C-contiguous order (last-index varies the fastest).
    If order is 'F', then the returned array will be in
    Fortran-contiguous order (first-index varies the fastest).
    If order is 'A' (default), then the returned array may be
    in any order (either C-, Fortran-contiguous, or even discontiguous),
    unless a copy is required, in which case it will be C-contiguous.
*)

val __getitem__ : indx:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
x.__getitem__(y) <==> x[y]

Return the item described by i, as a masked array.
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Implement iter(self).
*)

val __setitem__ : indx:Py.Object.t -> value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
x.__setitem__(i, y) <==> x[i]=y

Set item described by index. If value is masked, masks those
locations.
*)

val all : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns True if all elements evaluate to True.

The output array is masked where all the values along the given axis
are masked: if the output would have been a scalar and that all the
values are masked, then the output is `masked`.

Refer to `numpy.all` for full documentation.

See Also
--------
numpy.ndarray.all : corresponding function for ndarrays
numpy.all : equivalent function

Examples
--------
>>> np.ma.array([1,2,3]).all()
True
>>> a = np.ma.array([1,2,3], mask=True)
>>> (a.all() is np.ma.masked)
True
*)

val anom : ?axis:int -> ?dtype:Dtype.t -> [> tag] Obj.t -> Py.Object.t
(**
Compute the anomalies (deviations from the arithmetic mean)
along the given axis.

Returns an array of anomalies, with the same shape as the input and
where the arithmetic mean is computed along the given axis.

Parameters
----------
axis : int, optional
    Axis over which the anomalies are taken.
    The default is to use the mean of the flattened array as reference.
dtype : dtype, optional
    Type to use in computing the variance. For arrays of integer type
     the default is float32; for arrays of float types it is the same as
     the array type.

See Also
--------
mean : Compute the mean of the array.

Examples
--------
>>> a = np.ma.array([1,2,3])
>>> a.anom()
masked_array(data=[-1.,  0.,  1.],
             mask=False,
       fill_value=1e+20)
*)

val any : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns True if any of the elements of `a` evaluate to True.

Masked values are considered as False during computation.

Refer to `numpy.any` for full documentation.

See Also
--------
numpy.ndarray.any : corresponding function for ndarrays
numpy.any : equivalent function
*)

val argmax : ?axis:int -> ?fill_value:Py.Object.t -> ?out:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns array of indices of the maximum values along the given axis.
Masked values are treated as if they had the value fill_value.

Parameters
----------
axis : {None, integer}
    If None, the index is into the flattened array, otherwise along
    the specified axis
fill_value : {var}, optional
    Value used to fill in the masked values.  If None, the output of
    maximum_fill_value(self._data) is used instead.
out : {None, array}, optional
    Array into which the result can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

Returns
-------
index_array : {integer_array}

Examples
--------
>>> a = np.arange(6).reshape(2,3)
>>> a.argmax()
5
>>> a.argmax(0)
array([1, 1, 1])
>>> a.argmax(1)
array([2, 2])
*)

val argmin : ?axis:int -> ?fill_value:Py.Object.t -> ?out:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return array of indices to the minimum values along the given axis.

Parameters
----------
axis : {None, integer}
    If None, the index is into the flattened array, otherwise along
    the specified axis
fill_value : {var}, optional
    Value used to fill in the masked values.  If None, the output of
    minimum_fill_value(self._data) is used instead.
out : {None, array}, optional
    Array into which the result can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

Returns
-------
ndarray or scalar
    If multi-dimension input, returns a new ndarray of indices to the
    minimum values along the given axis.  Otherwise, returns a scalar
    of index to the minimum values along the given axis.

Examples
--------
>>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])
>>> x.shape = (2,2)
>>> x
masked_array(
  data=[[--, --],
        [2, 3]],
  mask=[[ True,  True],
        [False, False]],
  fill_value=999999)
>>> x.argmin(axis=0, fill_value=-1)
array([0, 0])
>>> x.argmin(axis=0, fill_value=9)
array([1, 1])
*)

val argpartition : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.argpartition(kth, axis=-1, kind='introselect', order=None)

Returns the indices that would partition this array.

Refer to `numpy.argpartition` for full documentation.

.. versionadded:: 1.8.0

See Also
--------
numpy.argpartition : equivalent function
*)

val argsort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[>`Ndarray] Obj.t -> ?endwith:bool -> ?fill_value:Py.Object.t -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an ndarray of indices that sort the array along the
specified axis.  Masked values are filled beforehand to
`fill_value`.

Parameters
----------
axis : int, optional
    Axis along which to sort. If None, the default, the flattened array
    is used.

    ..  versionchanged:: 1.13.0
        Previously, the default was documented to be -1, but that was
        in error. At some future date, the default will change to -1, as
        originally intended.
        Until then, the axis should be given explicitly when
        ``arr.ndim > 1``, to avoid a FutureWarning.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    The sorting algorithm used.
order : list, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  Not all fields need be
    specified.
endwith : {True, False}, optional
    Whether missing values (if any) should be treated as the largest values
    (True) or the smallest values (False)
    When the array contains unmasked values at the same extremes of the
    datatype, the ordering of these values and the masked values is
    undefined.
fill_value : {var}, optional
    Value used internally for the masked values.
    If ``fill_value`` is not None, it supersedes ``endwith``.

Returns
-------
index_array : ndarray, int
    Array of indices that sort `a` along the specified axis.
    In other words, ``a[index_array]`` yields a sorted `a`.

See Also
--------
MaskedArray.sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
numpy.ndarray.sort : Inplace sort.

Notes
-----
See `sort` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.ma.array([3,2,1], mask=[False, False, True])
>>> a
masked_array(data=[3, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.argsort()
array([1, 0, 2])
*)

val astype : ?order:[`C | `F | `A | `K] -> ?casting:[`No | `Equiv | `Safe | `Same_kind | `Unsafe] -> ?subok:Py.Object.t -> ?copy:bool -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)

Copy of the array, cast to a specified type.

Parameters
----------
dtype : str or dtype
    Typecode or data-type to which the array is cast.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout order of the result.
    'C' means C order, 'F' means Fortran order, 'A'
    means 'F' order if all the arrays are Fortran contiguous,
    'C' order otherwise, and 'K' means as close to the
    order the array elements appear in memory as possible.
    Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'unsafe'
    for backwards compatibility.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.
subok : bool, optional
    If True, then sub-classes will be passed-through (default), otherwise
    the returned array will be forced to be a base-class array.
copy : bool, optional
    By default, astype always returns a newly allocated array. If this
    is set to false, and the `dtype`, `order`, and `subok`
    requirements are satisfied, the input array is returned instead
    of a copy.

Returns
-------
arr_t : ndarray
    Unless `copy` is False and the other conditions for returning the input
    array are satisfied (see description for `copy` input parameter), `arr_t`
    is a new array of the same shape as the input array, with dtype, order
    given by `dtype`, `order`.

Notes
-----
.. versionchanged:: 1.17.0
   Casting between a simple data type and a structured one is possible only
   for 'unsafe' casting.  Casting to multiple fields is allowed, but
   casting from multiple fields is not.

.. versionchanged:: 1.9.0
   Casting from numeric to string types in 'safe' casting mode requires
   that the string dtype length is long enough to store the max
   integer/float value converted.

Raises
------
ComplexWarning
    When casting from complex to float or int. To avoid this,
    one should use ``a.real.astype(t)``.

Examples
--------
>>> x = np.array([1, 2, 2.5])
>>> x
array([1. ,  2. ,  2.5])

>>> x.astype(int)
array([1, 2, 2])
*)

val byteswap : ?inplace:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.byteswap(inplace=False)

Swap the bytes of the array elements

Toggle between low-endian and big-endian data representation by
returning a byteswapped array, optionally swapped in-place.
Arrays of byte-strings are not swapped. The real and imaginary
parts of a complex number are swapped individually.

Parameters
----------
inplace : bool, optional
    If ``True``, swap bytes in-place, default is ``False``.

Returns
-------
out : ndarray
    The byteswapped array. If `inplace` is ``True``, this is
    a view to self.

Examples
--------
>>> A = np.array([1, 256, 8755], dtype=np.int16)
>>> list(map(hex, A))
['0x1', '0x100', '0x2233']
>>> A.byteswap(inplace=True)
array([  256,     1, 13090], dtype=int16)
>>> list(map(hex, A))
['0x100', '0x1', '0x3322']

Arrays of byte-strings are not swapped

>>> A = np.array([b'ceg', b'fac'])
>>> A.byteswap()
array([b'ceg', b'fac'], dtype='|S3')

``A.newbyteorder().byteswap()`` produces an array with the same values
  but different representation in memory

>>> A = np.array([1, 2, 3])
>>> A.view(np.uint8)
array([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
       0, 0], dtype=uint8)
>>> A.newbyteorder().byteswap(inplace=True)
array([1, 2, 3])
>>> A.view(np.uint8)
array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
       0, 3], dtype=uint8)
*)

val choose : ?out:Py.Object.t -> ?mode:Py.Object.t -> choices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.choose(choices, out=None, mode='raise')

Use an index array to construct a new array from a set of choices.

Refer to `numpy.choose` for full documentation.

See Also
--------
numpy.choose : equivalent function
*)

val clip : ?min:Py.Object.t -> ?max:Py.Object.t -> ?out:Py.Object.t -> ?kwargs:(string * Py.Object.t) list -> [> tag] Obj.t -> Py.Object.t
(**
a.clip(min=None, max=None, out=None, **kwargs)

Return an array whose values are limited to ``[min, max]``.
One of max or min must be given.

Refer to `numpy.clip` for full documentation.

See Also
--------
numpy.clip : equivalent function
*)

val compress : ?axis:int -> ?out:Py.Object.t -> condition:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return `a` where condition is ``True``.

If condition is a `MaskedArray`, missing values are considered
as ``False``.

Parameters
----------
condition : var
    Boolean 1-d array selecting which entries to return. If len(condition)
    is less than the size of a along the axis, then output is truncated
    to length of condition array.
axis : {None, int}, optional
    Axis along which the operation must be performed.
out : {None, ndarray}, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type will be cast if
    necessary.

Returns
-------
result : MaskedArray
    A :class:`MaskedArray` object.

Notes
-----
Please note the difference with :meth:`compressed` !
The output of :meth:`compress` has a mask, the output of
:meth:`compressed` does not.

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.compress([1, 0, 1])
masked_array(data=[1, 3],
             mask=[False, False],
       fill_value=999999)

>>> x.compress([1, 0, 1], axis=1)
masked_array(
  data=[[1, 3],
        [--, --],
        [7, 9]],
  mask=[[False, False],
        [ True,  True],
        [False, False]],
  fill_value=999999)
*)

val compressed : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return all the non-masked data as a 1-D array.

Returns
-------
data : ndarray
    A new `ndarray` holding the non-masked data is returned.

Notes
-----
The result is **not** a MaskedArray!

Examples
--------
>>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)
>>> x.compressed()
array([0, 1])
>>> type(x.compressed())
<class 'numpy.ndarray'>
*)

val copy : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.copy(order='C')

Return a copy of the array.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout of the copy. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible. (Note that this function and :func:`numpy.copy` are very
    similar, but have different default values for their order=
    arguments.)

See also
--------
numpy.copy
numpy.copyto

Examples
--------
>>> x = np.array([[1,2,3],[4,5,6]], order='F')

>>> y = x.copy()

>>> x.fill(0)

>>> x
array([[0, 0, 0],
       [0, 0, 0]])

>>> y
array([[1, 2, 3],
       [4, 5, 6]])

>>> y.flags['C_CONTIGUOUS']
True
*)

val count : ?axis:int list -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Count the non-masked elements of the array along the given axis.

Parameters
----------
axis : None or int or tuple of ints, optional
    Axis or axes along which the count is performed.
    The default, None, performs the count over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.10.0

    If this is a tuple of ints, the count is performed on multiple
    axes, instead of a single axis or all the axes as before.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
result : ndarray or scalar
    An array with the same shape as the input array, with the specified
    axis removed. If the array is a 0-d array, or if `axis` is None, a
    scalar is returned.

See Also
--------
count_masked : Count masked elements in array or along a given axis.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.arange(6).reshape((2, 3))
>>> a[1, :] = ma.masked
>>> a
masked_array(
  data=[[0, 1, 2],
        [--, --, --]],
  mask=[[False, False, False],
        [ True,  True,  True]],
  fill_value=999999)
>>> a.count()
3

When the `axis` keyword is specified an array of appropriate size is
returned.

>>> a.count(axis=0)
array([1, 1, 1])
>>> a.count(axis=1)
array([3, 0])
*)

val cumprod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the cumulative product of the array elements over the given axis.

Masked values are set to 1 internally during the computation.
However, their position is saved, and the result will be masked at
the same locations.

Refer to `numpy.cumprod` for full documentation.

Notes
-----
The mask is lost if `out` is not a valid MaskedArray !

Arithmetic is modular when using integer types, and no error is
raised on overflow.

See Also
--------
numpy.ndarray.cumprod : corresponding function for ndarrays
numpy.cumprod : equivalent function
*)

val cumsum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the cumulative sum of the array elements over the given axis.

Masked values are set to 0 internally during the computation.
However, their position is saved, and the result will be masked at
the same locations.

Refer to `numpy.cumsum` for full documentation.

Notes
-----
The mask is lost if `out` is not a valid :class:`MaskedArray` !

Arithmetic is modular when using integer types, and no error is
raised on overflow.

See Also
--------
numpy.ndarray.cumsum : corresponding function for ndarrays
numpy.cumsum : equivalent function

Examples
--------
>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])
>>> marr.cumsum()
masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],
             mask=[False, False, False,  True,  True,  True, False, False,
                   False, False],
       fill_value=999999)
*)

val diagonal : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.diagonal(offset=0, axis1=0, axis2=1)

Return specified diagonals. In NumPy 1.9 the returned array is a
read-only view instead of a copy as in previous NumPy versions.  In
a future version the read-only restriction will be removed.

Refer to :func:`numpy.diagonal` for full documentation.

See Also
--------
numpy.diagonal : equivalent function
*)

val dot : ?out:Py.Object.t -> ?strict:bool -> b:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.dot(b, out=None)

Masked dot product of two arrays. Note that `out` and `strict` are
located in different positions than in `ma.dot`. In order to
maintain compatibility with the functional version, it is
recommended that the optional arguments be treated as keyword only.
At some point that may be mandatory.

.. versionadded:: 1.10.0

Parameters
----------
b : masked_array_like
    Inputs array.
out : masked_array, optional
    Output argument. This must have the exact kind that would be
    returned if it was not used. In particular, it must have the
    right type, must be C-contiguous, and its dtype must be the
    dtype that would be returned for `ma.dot(a,b)`. This is a
    performance feature. Therefore, if these conditions are not
    met, an exception is raised, instead of attempting to be
    flexible.
strict : bool, optional
    Whether masked data are propagated (True) or set to 0 (False)
    for the computation. Default is False.  Propagating the mask
    means that if a masked value appears in a row or column, the
    whole row or column is considered masked.

    .. versionadded:: 1.10.2

See Also
--------
numpy.ma.dot : equivalent function
*)

val dump : file:[`Path of Py.Object.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.dump(file)

Dump a pickle of the array to the specified file.
The array can be read back with pickle.load or numpy.load.

Parameters
----------
file : str or Path
    A string naming the dump file.

    .. versionchanged:: 1.17.0
        `pathlib.Path` objects are now accepted.
*)

val fill : value:[`F of float | `I of int | `Bool of bool | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.fill(value)

Fill the array with a scalar value.

Parameters
----------
value : scalar
    All elements of `a` will be assigned this value.

Examples
--------
>>> a = np.array([1, 2])
>>> a.fill(0)
>>> a
array([0, 0])
>>> a = np.empty(2)
>>> a.fill(1)
>>> a
array([1.,  1.])
*)

val filled : ?fill_value:[>`Ndarray] Obj.t -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a copy of self, with masked values filled with a given value.
**However**, if there are no masked values to fill, self will be
returned instead as an ndarray.

Parameters
----------
fill_value : array_like, optional
    The value to use for invalid entries. Can be scalar or non-scalar.
    If non-scalar, the resulting ndarray must be broadcastable over
    input array. Default is None, in which case, the `fill_value`
    attribute of the array is used instead.

Returns
-------
filled_array : ndarray
    A copy of ``self`` with invalid entries replaced by *fill_value*
    (be it the function argument or the attribute of ``self``), or
    ``self`` itself as an ndarray if there are no invalid entries to
    be replaced.

Notes
-----
The result is **not** a MaskedArray!

Examples
--------
>>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)
>>> x.filled()
array([   1,    2, -999,    4, -999])
>>> x.filled(fill_value=1000)
array([   1,    2, 1000,    4, 1000])
>>> type(x.filled())
<class 'numpy.ndarray'>

Subclassing is preserved. This means that if, e.g., the data part of
the masked array is a recarray, `filled` returns a recarray:

>>> x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)
>>> m = np.ma.array(x, mask=[(True, False), (False, True)])
>>> m.filled()
rec.array([(999999,      2), (    -3, 999999)],
          dtype=[('f0', '<i8'), ('f1', '<i8')])
*)

val flatten : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.flatten(order='C')

Return a copy of the array collapsed into one dimension.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    'C' means to flatten in row-major (C-style) order.
    'F' means to flatten in column-major (Fortran-
    style) order. 'A' means to flatten in column-major
    order if `a` is Fortran *contiguous* in memory,
    row-major order otherwise. 'K' means to flatten
    `a` in the order the elements occur in memory.
    The default is 'C'.

Returns
-------
y : ndarray
    A copy of the input array, flattened to one dimension.

See Also
--------
ravel : Return a flattened array.
flat : A 1-D flat iterator over the array.

Examples
--------
>>> a = np.array([[1,2], [3,4]])
>>> a.flatten()
array([1, 2, 3, 4])
>>> a.flatten('F')
array([1, 3, 2, 4])
*)

val get_fill_value : [> tag] Obj.t -> Py.Object.t
(**
The filling value of the masked array is a scalar. When setting, None
will set to a default based on the data type.

Examples
--------
>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:
...     np.ma.array([0, 1], dtype=dt).get_fill_value()
...
999999
999999
1e+20
(1e+20+0j)

>>> x = np.ma.array([0, 1.], fill_value=-np.inf)
>>> x.fill_value
-inf
>>> x.fill_value = np.pi
>>> x.fill_value
3.1415926535897931 # may vary

Reset to default:

>>> x.fill_value = None
>>> x.fill_value
1e+20
*)

val get_imag : [> tag] Obj.t -> Py.Object.t
(**
The imaginary part of the masked array.

This property is a view on the imaginary part of this `MaskedArray`.

See Also
--------
real

Examples
--------
>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
>>> x.imag
masked_array(data=[1.0, --, 1.6],
             mask=[False,  True, False],
       fill_value=1e+20)
*)

val get_real : [> tag] Obj.t -> Py.Object.t
(**
The real part of the masked array.

This property is a view on the real part of this `MaskedArray`.

See Also
--------
imag

Examples
--------
>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
>>> x.real
masked_array(data=[1.0, --, 3.45],
             mask=[False,  True, False],
       fill_value=1e+20)
*)

val getfield : ?offset:int -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.getfield(dtype, offset=0)

Returns a field of the given array as a certain type.

A field is a view of the array data with a given data-type. The values in
the view are determined by the given type and the offset into the current
array in bytes. The offset needs to be such that the view dtype fits in the
array dtype; for example an array of dtype complex128 has 16-byte elements.
If taking a view with a 32-bit integer (4 bytes), the offset needs to be
between 0 and 12 bytes.

Parameters
----------
dtype : str or dtype
    The data type of the view. The dtype size of the view can not be larger
    than that of the array itself.
offset : int
    Number of bytes to skip before beginning the element view.

Examples
--------
>>> x = np.diag([1.+1.j]*2)
>>> x[1, 1] = 2 + 4.j
>>> x
array([[1.+1.j,  0.+0.j],
       [0.+0.j,  2.+4.j]])
>>> x.getfield(np.float64)
array([[1.,  0.],
       [0.,  2.]])

By choosing an offset of 8 bytes we can select the complex part of the
array for our view:

>>> x.getfield(np.float64, offset=8)
array([[1.,  0.],
       [0.,  4.]])
*)

val harden_mask : [> tag] Obj.t -> Py.Object.t
(**
Force the mask to hard.

Whether the mask of a masked array is hard or soft is determined by
its `hardmask` property. `harden_mask` sets `hardmask` to True.

See Also
--------
hardmask
*)

val ids : [> tag] Obj.t -> Py.Object.t
(**
Return the addresses of the data and mask areas.

Parameters
----------
None

Examples
--------
>>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])
>>> x.ids()
(166670640, 166659832) # may vary

If the array has no mask, the address of `nomask` is returned. This address
is typically not close to the data in memory:

>>> x = np.ma.array([1, 2, 3])
>>> x.ids()
(166691080, 3083169284L) # may vary
*)

val iscontiguous : [> tag] Obj.t -> Py.Object.t
(**
Return a boolean indicating whether the data is contiguous.

Parameters
----------
None

Examples
--------
>>> x = np.ma.array([1, 2, 3])
>>> x.iscontiguous()
True

`iscontiguous` returns one of the flags of the masked array:

>>> x.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : True
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
*)

val item : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.item( *args)

Copy an element of an array to a standard Python scalar and return it.

Parameters
----------
\*args : Arguments (variable number and type)

    * none: in this case, the method only works for arrays
      with one element (`a.size == 1`), which element is
      copied into a standard Python scalar object and returned.

    * int_type: this argument is interpreted as a flat index into
      the array, specifying which element to copy and return.

    * tuple of int_types: functions as does a single int_type argument,
      except that the argument is interpreted as an nd-index into the
      array.

Returns
-------
z : Standard Python scalar object
    A copy of the specified element of the array as a suitable
    Python scalar

Notes
-----
When the data type of `a` is longdouble or clongdouble, item() returns
a scalar array object because there is no available Python scalar that
would not lose information. Void arrays return a buffer object for item(),
unless fields are defined, in which case a tuple is returned.

`item` is very similar to a[args], except, instead of an array scalar,
a standard Python scalar is returned. This can be useful for speeding up
access to elements of the array and doing arithmetic on elements of the
array using Python's optimized math.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.item(3)
1
>>> x.item(7)
0
>>> x.item((0, 1))
2
>>> x.item((2, 2))
1
*)

val itemset : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.itemset( *args)

Insert scalar into an array (scalar is cast to array's dtype, if possible)

There must be at least 1 argument, and define the last argument
as *item*.  Then, ``a.itemset( *args)`` is equivalent to but faster
than ``a[args] = item``.  The item should be a scalar value and `args`
must select a single item in the array `a`.

Parameters
----------
\*args : Arguments
    If one argument: a scalar, only used in case `a` is of size 1.
    If two arguments: the last argument is the value to be set
    and must be a scalar, the first argument specifies a single array
    element location. It is either an int or a tuple.

Notes
-----
Compared to indexing syntax, `itemset` provides some speed increase
for placing a scalar into a particular location in an `ndarray`,
if you must do this.  However, generally this is discouraged:
among other problems, it complicates the appearance of the code.
Also, when using `itemset` (and `item`) inside a loop, be sure
to assign the methods to a local variable to avoid the attribute
look-up at each loop iteration.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.itemset(4, 0)
>>> x.itemset((2, 2), 9)
>>> x
array([[2, 2, 6],
       [1, 0, 6],
       [1, 0, 9]])
*)

val max : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the maximum along a given axis.

Parameters
----------
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
fill_value : {var}, optional
    Value used to fill in the masked values.
    If None, use the output of maximum_fill_value().
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
amax : array_like
    New array holding the result.
    If ``out`` was specified, ``out`` is returned.

See Also
--------
maximum_fill_value
    Returns the maximum filling value for a given datatype.
*)

val mean : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns the average of the array elements along given axis.

Masked entries are ignored, and result elements which are not
finite will be masked.

Refer to `numpy.mean` for full documentation.

See Also
--------
numpy.ndarray.mean : corresponding function for ndarrays
numpy.mean : Equivalent function
numpy.ma.average: Weighted average.

Examples
--------
>>> a = np.ma.array([1,2,3], mask=[False, False, True])
>>> a
masked_array(data=[1, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.mean()
1.5
*)

val min : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the minimum along a given axis.

Parameters
----------
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must be of
    the same shape and buffer length as the expected output.
fill_value : {var}, optional
    Value used to fill in the masked values.
    If None, use the output of `minimum_fill_value`.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
amin : array_like
    New array holding the result.
    If ``out`` was specified, ``out`` is returned.

See Also
--------
minimum_fill_value
    Returns the minimum filling value for a given datatype.
*)

val mini : ?axis:int -> [> tag] Obj.t -> Py.Object.t
(**
Return the array minimum along the specified axis.

.. deprecated:: 1.13.0
   This function is identical to both:

    * ``self.min(keepdims=True, axis=axis).squeeze(axis=axis)``
    * ``np.ma.minimum.reduce(self, axis=axis)``

   Typically though, ``self.min(axis=axis)`` is sufficient.

Parameters
----------
axis : int, optional
    The axis along which to find the minima. Default is None, in which case
    the minimum value in the whole array is returned.

Returns
-------
min : scalar or MaskedArray
    If `axis` is None, the result is a scalar. Otherwise, if `axis` is
    given and the array is at least 2-D, the result is a masked array with
    dimension one smaller than the array on which `mini` is called.

Examples
--------
>>> x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)
>>> x
masked_array(
  data=[[0, --],
        [2, 3],
        [4, --]],
  mask=[[False,  True],
        [False, False],
        [False,  True]],
  fill_value=999999)
>>> x.mini()
masked_array(data=0,
             mask=False,
       fill_value=999999)
>>> x.mini(axis=0)
masked_array(data=[0, 3],
             mask=[False, False],
       fill_value=999999)
>>> x.mini(axis=1)
masked_array(data=[0, 2, 4],
             mask=[False, False, False],
       fill_value=999999)

There is a small difference between `mini` and `min`:

>>> x[:,1].mini(axis=0)
masked_array(data=3,
             mask=False,
       fill_value=999999)
>>> x[:,1].min(axis=0)
3
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arr.newbyteorder(new_order='S')

Return the array with the same data viewed with a different byte order.

Equivalent to::

    arr.view(arr.dtype.newbytorder(new_order))

Changes are also made in all fields and sub-arrays of the array data
type.



Parameters
----------
new_order : string, optional
    Byte order to force; a value from the byte order specifications
    below. `new_order` codes can be any of:

    * 'S' - swap dtype from current to opposite endian
    * {'<', 'L'} - little endian
    * {'>', 'B'} - big endian
    * {'=', 'N'} - native order
    * {'|', 'I'} - ignore (no change to byte order)

    The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_arr : array
    New array object with the dtype reflecting given change to the
    byte order.
*)

val nonzero : [> tag] Obj.t -> Py.Object.t
(**
Return the indices of unmasked elements that are not zero.

Returns a tuple of arrays, one for each dimension, containing the
indices of the non-zero elements in that dimension. The corresponding
non-zero values can be obtained with::

    a[a.nonzero()]

To group the indices by element, rather than dimension, use
instead::

    np.transpose(a.nonzero())

The result of this is always a 2d array, with a row for each non-zero
element.

Parameters
----------
None

Returns
-------
tuple_of_arrays : tuple
    Indices of elements that are non-zero.

See Also
--------
numpy.nonzero :
    Function operating on ndarrays.
flatnonzero :
    Return indices that are non-zero in the flattened version of the input
    array.
numpy.ndarray.nonzero :
    Equivalent ndarray method.
count_nonzero :
    Counts the number of non-zero elements in the input array.

Examples
--------
>>> import numpy.ma as ma
>>> x = ma.array(np.eye(3))
>>> x
masked_array(
  data=[[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]],
  mask=False,
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 1, 2]), array([0, 1, 2]))

Masked elements are ignored.

>>> x[1, 1] = ma.masked
>>> x
masked_array(
  data=[[1.0, 0.0, 0.0],
        [0.0, --, 0.0],
        [0.0, 0.0, 1.0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 2]), array([0, 2]))

Indices can also be grouped by element.

>>> np.transpose(x.nonzero())
array([[0, 0],
       [2, 2]])

A common use for ``nonzero`` is to find the indices of an array, where
a condition is True.  Given an array `a`, the condition `a` > 3 is a
boolean array and since False is interpreted as 0, ma.nonzero(a > 3)
yields the indices of the `a` where the condition is true.

>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])
>>> a > 3
masked_array(
  data=[[False, False, False],
        [ True,  True,  True],
        [ True,  True,  True]],
  mask=False,
  fill_value=True)
>>> ma.nonzero(a > 3)
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))

The ``nonzero`` method of the condition array can also be called.

>>> (a > 3).nonzero()
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
*)

val partition : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.partition(kth, axis=-1, kind='introselect', order=None)

Rearranges the elements in the array in such a way that the value of the
element in kth position is in the position it would be in a sorted array.
All elements smaller than the kth element are moved before this element and
all equal or greater are moved behind it. The ordering of the elements in
the two partitions is undefined.

.. versionadded:: 1.8.0

Parameters
----------
kth : int or sequence of ints
    Element index to partition by. The kth element value will be in its
    final sorted position and all smaller elements will be moved before it
    and all equal or greater elements behind it.
    The order of all elements in the partitions is undefined.
    If provided with a sequence of kth it will partition all elements
    indexed by kth of them into their sorted position at once.
axis : int, optional
    Axis along which to sort. Default is -1, which means sort along the
    last axis.
kind : {'introselect'}, optional
    Selection algorithm. Default is 'introselect'.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc. A single field can
    be specified as a string, and not all fields need to be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

See Also
--------
numpy.partition : Return a parititioned copy of an array.
argpartition : Indirect partition.
sort : Full sort.

Notes
-----
See ``np.partition`` for notes on the different algorithms.

Examples
--------
>>> a = np.array([3, 4, 2, 1])
>>> a.partition(3)
>>> a
array([2, 1, 3, 4])

>>> a.partition((1, 3))
>>> a
array([1, 2, 3, 4])
*)

val prod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the product of the array elements over the given axis.

Masked elements are set to 1 internally for computation.

Refer to `numpy.prod` for full documentation.

Notes
-----
Arithmetic is modular when using integer types, and no error is raised
on overflow.

See Also
--------
numpy.ndarray.prod : corresponding function for ndarrays
numpy.prod : equivalent function
*)

val ptp : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return (maximum - minimum) along the given dimension
(i.e. peak-to-peak value).

Parameters
----------
axis : {None, int}, optional
    Axis along which to find the peaks.  If None (default) the
    flattened array is used.
out : {None, array_like}, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary.
fill_value : {var}, optional
    Value used to fill in the masked values.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
ptp : ndarray.
    A new array holding the result, unless ``out`` was
    specified, in which case a reference to ``out`` is returned.
*)

val put : ?mode:[`Raise | `Wrap | `Clip] -> indices:Py.Object.t -> values:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Set storage-indexed locations to corresponding values.

Sets self._data.flat[n] = values[n] for each n in indices.
If `values` is shorter than `indices` then it will repeat.
If `values` has some masked values, the initial mask is updated
in consequence, else the corresponding values are unmasked.

Parameters
----------
indices : 1-D array_like
    Target indices, interpreted as integers.
values : array_like
    Values to place in self._data copy at target indices.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.
    'raise' : raise an error.
    'wrap' : wrap around.
    'clip' : clip to the range.

Notes
-----
`values` can be a scalar or length 1 array.

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.put([0,4,8],[10,20,30])
>>> x
masked_array(
  data=[[10, --, 3],
        [--, 20, --],
        [7, --, 30]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)

>>> x.put(4,999)
>>> x
masked_array(
  data=[[10, --, 3],
        [--, 999, --],
        [7, --, 30]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
*)

val ravel : ?order:[`C | `F | `A | `K] -> [> tag] Obj.t -> Py.Object.t
(**
Returns a 1D version of self, as a view.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    The elements of `a` are read using this index order. 'C' means to
    index the elements in C-like order, with the last axis index
    changing fastest, back to the first axis index changing slowest.
    'F' means to index the elements in Fortran-like index order, with
    the first index changing fastest, and the last index changing
    slowest. Note that the 'C' and 'F' options take no account of the
    memory layout of the underlying array, and only refer to the order
    of axis indexing.  'A' means to read the elements in Fortran-like
    index order if `m` is Fortran *contiguous* in memory, C-like order
    otherwise.  'K' means to read the elements in the order they occur
    in memory, except for reversing the data when strides are negative.
    By default, 'C' index order is used.

Returns
-------
MaskedArray
    Output view is of shape ``(self.size,)`` (or
    ``(np.ma.product(self.shape),)``).

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.ravel()
masked_array(data=[1, --, 3, --, 5, --, 7, --, 9],
             mask=[False,  True, False,  True, False,  True, False,  True,
                   False],
       fill_value=999999)
*)

val repeat : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.repeat(repeats, axis=None)

Repeat elements of an array.

Refer to `numpy.repeat` for full documentation.

See Also
--------
numpy.repeat : equivalent function
*)

val reshape : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Give a new shape to the array without changing its data.

Returns a masked array containing the same data, but with a new shape.
The result is a view on the original array; if this is not possible, a
ValueError is raised.

Parameters
----------
shape : int or tuple of ints
    The new shape should be compatible with the original shape. If an
    integer is supplied, then the result will be a 1-D array of that
    length.
order : {'C', 'F'}, optional
    Determines whether the array data should be viewed as in C
    (row-major) or FORTRAN (column-major) order.

Returns
-------
reshaped_array : array
    A new view on the array.

See Also
--------
reshape : Equivalent function in the masked array module.
numpy.ndarray.reshape : Equivalent method on ndarray object.
numpy.reshape : Equivalent function in the NumPy module.

Notes
-----
The reshaping operation cannot guarantee that a copy will not be made,
to modify the shape in place, use ``a.shape = s``

Examples
--------
>>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])
>>> x
masked_array(
  data=[[--, 2],
        [3, --]],
  mask=[[ True, False],
        [False,  True]],
  fill_value=999999)
>>> x = x.reshape((4,1))
>>> x
masked_array(
  data=[[--],
        [2],
        [3],
        [--]],
  mask=[[ True],
        [False],
        [False],
        [ True]],
  fill_value=999999)
*)

val resize : ?refcheck:Py.Object.t -> ?order:Py.Object.t -> newshape:int list -> [> tag] Obj.t -> Py.Object.t
(**
.. warning::

    This method does nothing, except raise a ValueError exception. A
    masked array does not own its data and therefore cannot safely be
    resized in place. Use the `numpy.ma.resize` function instead.

This method is difficult to implement safely and may be deprecated in
future releases of NumPy.
*)

val round : ?decimals:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return each element rounded to the given number of decimals.

Refer to `numpy.around` for full documentation.

See Also
--------
numpy.ndarray.around : corresponding function for ndarrays
numpy.around : equivalent function
*)

val searchsorted : ?side:Py.Object.t -> ?sorter:Py.Object.t -> v:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.searchsorted(v, side='left', sorter=None)

Find indices where elements of v should be inserted in a to maintain order.

For full documentation, see `numpy.searchsorted`

See Also
--------
numpy.searchsorted : equivalent function
*)

val set_fill_value : ?value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
The filling value of the masked array is a scalar. When setting, None
will set to a default based on the data type.

Examples
--------
>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:
...     np.ma.array([0, 1], dtype=dt).get_fill_value()
...
999999
999999
1e+20
(1e+20+0j)

>>> x = np.ma.array([0, 1.], fill_value=-np.inf)
>>> x.fill_value
-inf
>>> x.fill_value = np.pi
>>> x.fill_value
3.1415926535897931 # may vary

Reset to default:

>>> x.fill_value = None
>>> x.fill_value
1e+20
*)

val setfield : ?offset:int -> val_:Py.Object.t -> dtype:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.setfield(val, dtype, offset=0)

Put a value into a specified place in a field defined by a data-type.

Place `val` into `a`'s field defined by `dtype` and beginning `offset`
bytes into the field.

Parameters
----------
val : object
    Value to be placed in field.
dtype : dtype object
    Data-type of the field in which to place `val`.
offset : int, optional
    The number of bytes into the field at which to place `val`.

Returns
-------
None

See Also
--------
getfield

Examples
--------
>>> x = np.eye(3)
>>> x.getfield(np.float64)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
>>> x.setfield(3, np.int32)
>>> x.getfield(np.int32)
array([[3, 3, 3],
       [3, 3, 3],
       [3, 3, 3]], dtype=int32)
>>> x
array([[1.0e+000, 1.5e-323, 1.5e-323],
       [1.5e-323, 1.0e+000, 1.5e-323],
       [1.5e-323, 1.5e-323, 1.0e+000]])
>>> x.setfield(np.eye(3), np.int32)
>>> x
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
*)

val setflags : ?write:bool -> ?align:bool -> ?uic:bool -> [> tag] Obj.t -> Py.Object.t
(**
a.setflags(write=None, align=None, uic=None)

Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
respectively.

These Boolean-valued flags affect how numpy interprets the memory
area used by `a` (see Notes below). The ALIGNED flag can only
be set to True if the data is actually aligned according to the type.
The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
to True. The flag WRITEABLE can only be set to True if the array owns its
own memory, or the ultimate owner of the memory exposes a writeable buffer
interface, or is a string. (The exception for string is made so that
unpickling can be done without copying memory.)

Parameters
----------
write : bool, optional
    Describes whether or not `a` can be written to.
align : bool, optional
    Describes whether or not `a` is aligned properly for its type.
uic : bool, optional
    Describes whether or not `a` is a copy of another 'base' array.

Notes
-----
Array flags provide information about how the memory area used
for the array is to be interpreted. There are 7 Boolean flags
in use, only four of which can be changed by the user:
WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.

WRITEABLE (W) the data area can be written to;

ALIGNED (A) the data and strides are aligned appropriately for the hardware
(as determined by the compiler);

UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;

WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
called, the base array will be updated with the contents of this array.

All flags can be accessed using the single (upper case) letter as well
as the full name.

Examples
--------
>>> y = np.array([[3, 1, 7],
...               [2, 0, 0],
...               [8, 5, 9]])
>>> y
array([[3, 1, 7],
       [2, 0, 0],
       [8, 5, 9]])
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(write=0, align=0)
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : False
  ALIGNED : False
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(uic=1)
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: cannot set WRITEBACKIFCOPY flag to True
*)

val shrink_mask : [> tag] Obj.t -> Py.Object.t
(**
Reduce a mask to nomask when possible.

Parameters
----------
None

Returns
-------
None

Examples
--------
>>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)
>>> x.mask
array([[False, False],
       [False, False]])
>>> x.shrink_mask()
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> x.mask
False
*)

val soften_mask : [> tag] Obj.t -> Py.Object.t
(**
Force the mask to soft.

Whether the mask of a masked array is hard or soft is determined by
its `hardmask` property. `soften_mask` sets `hardmask` to False.

See Also
--------
hardmask
*)

val sort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[>`Ndarray] Obj.t -> ?endwith:bool -> ?fill_value:Py.Object.t -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Sort the array, in-place

Parameters
----------
a : array_like
    Array to be sorted.
axis : int, optional
    Axis along which to sort. If None, the array is flattened before
    sorting. The default is -1, which sorts along the last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    The sorting algorithm used.
order : list, optional
    When `a` is a structured array, this argument specifies which fields
    to compare first, second, and so on.  This list does not need to
    include all of the fields.
endwith : {True, False}, optional
    Whether missing values (if any) should be treated as the largest values
    (True) or the smallest values (False)
    When the array contains unmasked values sorting at the same extremes of the
    datatype, the ordering of these values and the masked values is
    undefined.
fill_value : {var}, optional
    Value used internally for the masked values.
    If ``fill_value`` is not None, it supersedes ``endwith``.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
numpy.ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.

Notes
-----
See ``sort`` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Default
>>> a.sort()
>>> a
masked_array(data=[1, 3, 5, --, --],
             mask=[False, False, False,  True,  True],
       fill_value=999999)

>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Put missing values in the front
>>> a.sort(endwith=False)
>>> a
masked_array(data=[--, --, 1, 3, 5],
             mask=[ True,  True, False, False, False],
       fill_value=999999)

>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # fill_value takes over endwith
>>> a.sort(endwith=False, fill_value=3)
>>> a
masked_array(data=[1, --, --, 3, 5],
             mask=[False,  True,  True, False, False],
       fill_value=999999)
*)

val squeeze : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.squeeze(axis=None)

Remove single-dimensional entries from the shape of `a`.

Refer to `numpy.squeeze` for full documentation.

See Also
--------
numpy.squeeze : equivalent function
*)

val std : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?ddof:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns the standard deviation of the array elements along given axis.

Masked entries are ignored.

Refer to `numpy.std` for full documentation.

See Also
--------
numpy.ndarray.std : corresponding function for ndarrays
numpy.std : Equivalent function
*)

val sum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the sum of the array elements over the given axis.

Masked elements are set to 0 internally.

Refer to `numpy.sum` for full documentation.

See Also
--------
numpy.ndarray.sum : corresponding function for ndarrays
numpy.sum : equivalent function

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.sum()
25
>>> x.sum(axis=1)
masked_array(data=[4, 5, 16],
             mask=[False, False, False],
       fill_value=999999)
>>> x.sum(axis=0)
masked_array(data=[8, 5, 12],
             mask=[False, False, False],
       fill_value=999999)
>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))
<class 'numpy.int64'>
*)

val swapaxes : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.swapaxes(axis1, axis2)

Return a view of the array with `axis1` and `axis2` interchanged.

Refer to `numpy.swapaxes` for full documentation.

See Also
--------
numpy.swapaxes : equivalent function
*)

val take : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?mode:Py.Object.t -> indices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
        
*)

val tobytes : ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> ?order:[`C | `F | `A] -> [> tag] Obj.t -> Py.Object.t
(**
Return the array data as a string containing the raw bytes in the array.

The array is filled with a fill value before the string conversion.

.. versionadded:: 1.9.0

Parameters
----------
fill_value : scalar, optional
    Value used to fill in the masked values. Default is None, in which
    case `MaskedArray.fill_value` is used.
order : {'C','F','A'}, optional
    Order of the data item in the copy. Default is 'C'.

    - 'C'   -- C order (row major).
    - 'F'   -- Fortran order (column major).
    - 'A'   -- Any, current order of array.
    - None  -- Same as 'A'.

See Also
--------
numpy.ndarray.tobytes
tolist, tofile

Notes
-----
As for `ndarray.tobytes`, information about the shape, dtype, etc.,
but also about `fill_value`, will be lost.

Examples
--------
>>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
>>> x.tobytes()
b'\x01\x00\x00\x00\x00\x00\x00\x00?B\x0f\x00\x00\x00\x00\x00?B\x0f\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00'
*)

val tofile : ?sep:Py.Object.t -> ?format:Py.Object.t -> fid:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Save a masked array to a file in binary format.

.. warning::
  This function is not implemented yet.

Raises
------
NotImplementedError
    When `tofile` is called.
*)

val toflex : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Transforms a masked array into a flexible-type array.

The flexible type array that is returned will have two fields:

* the ``_data`` field stores the ``_data`` part of the array.
* the ``_mask`` field stores the ``_mask`` part of the array.

Parameters
----------
None

Returns
-------
record : ndarray
    A new flexible-type `ndarray` with two fields: the first element
    containing a value, the second element containing the corresponding
    mask boolean. The returned record shape matches self.shape.

Notes
-----
A side-effect of transforming a masked array into a flexible `ndarray` is
that meta information (``fill_value``, ...) will be lost.

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.toflex()
array([[(1, False), (2,  True), (3, False)],
       [(4,  True), (5, False), (6,  True)],
       [(7, False), (8,  True), (9, False)]],
      dtype=[('_data', '<i8'), ('_mask', '?')])
*)

val tolist : ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the data portion of the masked array as a hierarchical Python list.

Data items are converted to the nearest compatible Python type.
Masked values are converted to `fill_value`. If `fill_value` is None,
the corresponding entries in the output list will be ``None``.

Parameters
----------
fill_value : scalar, optional
    The value to use for invalid entries. Default is None.

Returns
-------
result : list
    The Python list representation of the masked array.

Examples
--------
>>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)
>>> x.tolist()
[[1, None, 3], [None, 5, None], [7, None, 9]]
>>> x.tolist(-999)
[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]
*)

val tostring : ?fill_value:Py.Object.t -> ?order:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
This function is a compatibility alias for tobytes. Despite its name it
returns bytes not strings.
*)

val trace : ?offset:Py.Object.t -> ?axis1:Py.Object.t -> ?axis2:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)

Return the sum along diagonals of the array.

Refer to `numpy.trace` for full documentation.

See Also
--------
numpy.trace : equivalent function
*)

val transpose : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.transpose( *axes)

Returns a view of the array with axes transposed.

For a 1-D array this has no effect, as a transposed vector is simply the
same vector. To convert a 1-D array into a 2D column vector, an additional
dimension must be added. `np.atleast2d(a).T` achieves this, as does
`a[:, np.newaxis]`.
For a 2-D array, this is a standard matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
``a.shape = (i[0], i[1], ... i[n-2], i[n-1])``, then
``a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.

Parameters
----------
axes : None, tuple of ints, or `n` ints

 * None or no argument: reverses the order of the axes.

 * tuple of ints: `i` in the `j`-th place in the tuple means `a`'s
   `i`-th axis becomes `a.transpose()`'s `j`-th axis.

 * `n` ints: same as an n-tuple of the same ints (this form is
   intended simply as a 'convenience' alternative to the tuple form)

Returns
-------
out : ndarray
    View of `a`, with axes suitably permuted.

See Also
--------
ndarray.T : Array property returning the array transposed.
ndarray.reshape : Give a new shape to an array without changing its data.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> a
array([[1, 2],
       [3, 4]])
>>> a.transpose()
array([[1, 3],
       [2, 4]])
>>> a.transpose((1, 0))
array([[1, 3],
       [2, 4]])
>>> a.transpose(1, 0)
array([[1, 3],
       [2, 4]])
*)

val unshare_mask : [> tag] Obj.t -> Py.Object.t
(**
Copy the mask and set the sharedmask flag to False.

Whether the mask is shared between masked arrays can be seen from
the `sharedmask` property. `unshare_mask` ensures the mask is not shared.
A copy of the mask is only made if it was shared.

See Also
--------
sharedmask
*)

val var : ?axis:int list -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?ddof:int -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the variance along the specified axis.

Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.

Parameters
----------
a : array_like
    Array containing numbers whose variance is desired.  If `a` is not an
    array, a conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which the variance is computed.  The default is to
    compute the variance of the flattened array.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a variance is performed over multiple axes,
    instead of a single axis or all the axes as before.
dtype : data-type, optional
    Type to use in computing the variance.  For arrays of integer type
    the default is `float64`; for arrays of float types it is the same as
    the array type.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output, but the type is cast if
    necessary.
ddof : int, optional
    'Delta Degrees of Freedom': the divisor used in the calculation is
    ``N - ddof``, where ``N`` represents the number of elements. By
    default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `var` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
variance : ndarray, see dtype parameter above
    If ``out=None``, returns a new array containing the variance;
    otherwise, a reference to the output array is returned.

See Also
--------
std, mean, nanmean, nanstd, nanvar
ufuncs-output-type

Notes
-----
The variance is the average of the squared deviations from the mean,
i.e.,  ``var = mean(abs(x - x.mean())**2)``.

The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
If, however, `ddof` is specified, the divisor ``N - ddof`` is used
instead.  In standard statistical practice, ``ddof=1`` provides an
unbiased estimator of the variance of a hypothetical infinite population.
``ddof=0`` provides a maximum likelihood estimate of the variance for
normally distributed variables.

Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.

For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32` (see example
below).  Specifying a higher-accuracy accumulator using the ``dtype``
keyword can alleviate this issue.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> np.var(a)
1.25
>>> np.var(a, axis=0)
array([1.,  1.])
>>> np.var(a, axis=1)
array([0.25,  0.25])

In single precision, var() can be inaccurate:

>>> a = np.zeros((2, 512*512), dtype=np.float32)
>>> a[0, :] = 1.0
>>> a[1, :] = 0.1
>>> np.var(a)
0.20250003

Computing the variance in float64 is more accurate:

>>> np.var(a, dtype=np.float64)
0.20249999932944759 # may vary
>>> ((1-0.55)**2 + (0.1-0.55)**2)/2
0.2025
*)

val view : ?dtype:[`Dtype of Dtype.t | `Ndarray_sub_class of Py.Object.t] -> ?type_:Py.Object.t -> ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> [> tag] Obj.t -> Py.Object.t
(**
Return a view of the MaskedArray data.

Parameters
----------
dtype : data-type or ndarray sub-class, optional
    Data-type descriptor of the returned view, e.g., float32 or int16.
    The default, None, results in the view having the same data-type
    as `a`. As with ``ndarray.view``, dtype can also be specified as
    an ndarray sub-class, which then specifies the type of the
    returned object (this is equivalent to setting the ``type``
    parameter).
type : Python type, optional
    Type of the returned view, either ndarray or a subclass.  The
    default None results in type preservation.
fill_value : scalar, optional
    The value to use for invalid entries (None by default).
    If None, then this argument is inferred from the passed `dtype`, or
    in its absence the original array, as discussed in the notes below.

See Also
--------
numpy.ndarray.view : Equivalent method on ndarray object.

Notes
-----

``a.view()`` is used two different ways:

``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
of the array's memory with a different data-type.  This can cause a
reinterpretation of the bytes of memory.

``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
returns an instance of `ndarray_subclass` that looks at the same array
(same shape, dtype, etc.)  This does not cause a reinterpretation of the
memory.

If `fill_value` is not specified, but `dtype` is specified (and is not
an ndarray sub-class), the `fill_value` of the MaskedArray will be
reset. If neither `fill_value` nor `dtype` are specified (or if
`dtype` is an ndarray sub-class), then the fill value is preserved.
Finally, if `fill_value` is specified, but `dtype` is not, the fill
value is set to the specified value.

For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of
bytes per entry than the previous dtype (for example, converting a
regular array to a structured array), then the behavior of the view
cannot be predicted just from the superficial appearance of ``a`` (shown
by ``print(a)``). It also depends on exactly how ``a`` is stored in
memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus
defined as a slice or transpose, etc., the view may give different
results.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Mvoid : sig
type tag = [`Mvoid]
type t = [`ArrayLike | `Mvoid | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?mask:Py.Object.t -> ?dtype:Py.Object.t -> ?fill_value:Py.Object.t -> ?hardmask:Py.Object.t -> ?copy:Py.Object.t -> ?subok:Py.Object.t -> data:Py.Object.t -> unit -> t
(**
Fake a 'void' object to use for masked array with structured dtypes.
*)

val __getitem__ : indx:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Get the index.
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Defines an iterator for mvoid
*)

val __setitem__ : indx:Py.Object.t -> value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
x.__setitem__(i, y) <==> x[i]=y

Set item described by index. If value is masked, masks those
locations.
*)

val all : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns True if all elements evaluate to True.

The output array is masked where all the values along the given axis
are masked: if the output would have been a scalar and that all the
values are masked, then the output is `masked`.

Refer to `numpy.all` for full documentation.

See Also
--------
numpy.ndarray.all : corresponding function for ndarrays
numpy.all : equivalent function

Examples
--------
>>> np.ma.array([1,2,3]).all()
True
>>> a = np.ma.array([1,2,3], mask=True)
>>> (a.all() is np.ma.masked)
True
*)

val anom : ?axis:int -> ?dtype:Dtype.t -> [> tag] Obj.t -> Py.Object.t
(**
Compute the anomalies (deviations from the arithmetic mean)
along the given axis.

Returns an array of anomalies, with the same shape as the input and
where the arithmetic mean is computed along the given axis.

Parameters
----------
axis : int, optional
    Axis over which the anomalies are taken.
    The default is to use the mean of the flattened array as reference.
dtype : dtype, optional
    Type to use in computing the variance. For arrays of integer type
     the default is float32; for arrays of float types it is the same as
     the array type.

See Also
--------
mean : Compute the mean of the array.

Examples
--------
>>> a = np.ma.array([1,2,3])
>>> a.anom()
masked_array(data=[-1.,  0.,  1.],
             mask=False,
       fill_value=1e+20)
*)

val any : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns True if any of the elements of `a` evaluate to True.

Masked values are considered as False during computation.

Refer to `numpy.any` for full documentation.

See Also
--------
numpy.ndarray.any : corresponding function for ndarrays
numpy.any : equivalent function
*)

val argmax : ?axis:int -> ?fill_value:Py.Object.t -> ?out:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns array of indices of the maximum values along the given axis.
Masked values are treated as if they had the value fill_value.

Parameters
----------
axis : {None, integer}
    If None, the index is into the flattened array, otherwise along
    the specified axis
fill_value : {var}, optional
    Value used to fill in the masked values.  If None, the output of
    maximum_fill_value(self._data) is used instead.
out : {None, array}, optional
    Array into which the result can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

Returns
-------
index_array : {integer_array}

Examples
--------
>>> a = np.arange(6).reshape(2,3)
>>> a.argmax()
5
>>> a.argmax(0)
array([1, 1, 1])
>>> a.argmax(1)
array([2, 2])
*)

val argmin : ?axis:int -> ?fill_value:Py.Object.t -> ?out:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return array of indices to the minimum values along the given axis.

Parameters
----------
axis : {None, integer}
    If None, the index is into the flattened array, otherwise along
    the specified axis
fill_value : {var}, optional
    Value used to fill in the masked values.  If None, the output of
    minimum_fill_value(self._data) is used instead.
out : {None, array}, optional
    Array into which the result can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

Returns
-------
ndarray or scalar
    If multi-dimension input, returns a new ndarray of indices to the
    minimum values along the given axis.  Otherwise, returns a scalar
    of index to the minimum values along the given axis.

Examples
--------
>>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])
>>> x.shape = (2,2)
>>> x
masked_array(
  data=[[--, --],
        [2, 3]],
  mask=[[ True,  True],
        [False, False]],
  fill_value=999999)
>>> x.argmin(axis=0, fill_value=-1)
array([0, 0])
>>> x.argmin(axis=0, fill_value=9)
array([1, 1])
*)

val argpartition : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.argpartition(kth, axis=-1, kind='introselect', order=None)

Returns the indices that would partition this array.

Refer to `numpy.argpartition` for full documentation.

.. versionadded:: 1.8.0

See Also
--------
numpy.argpartition : equivalent function
*)

val argsort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[>`Ndarray] Obj.t -> ?endwith:bool -> ?fill_value:Py.Object.t -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an ndarray of indices that sort the array along the
specified axis.  Masked values are filled beforehand to
`fill_value`.

Parameters
----------
axis : int, optional
    Axis along which to sort. If None, the default, the flattened array
    is used.

    ..  versionchanged:: 1.13.0
        Previously, the default was documented to be -1, but that was
        in error. At some future date, the default will change to -1, as
        originally intended.
        Until then, the axis should be given explicitly when
        ``arr.ndim > 1``, to avoid a FutureWarning.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    The sorting algorithm used.
order : list, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  Not all fields need be
    specified.
endwith : {True, False}, optional
    Whether missing values (if any) should be treated as the largest values
    (True) or the smallest values (False)
    When the array contains unmasked values at the same extremes of the
    datatype, the ordering of these values and the masked values is
    undefined.
fill_value : {var}, optional
    Value used internally for the masked values.
    If ``fill_value`` is not None, it supersedes ``endwith``.

Returns
-------
index_array : ndarray, int
    Array of indices that sort `a` along the specified axis.
    In other words, ``a[index_array]`` yields a sorted `a`.

See Also
--------
MaskedArray.sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
numpy.ndarray.sort : Inplace sort.

Notes
-----
See `sort` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.ma.array([3,2,1], mask=[False, False, True])
>>> a
masked_array(data=[3, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.argsort()
array([1, 0, 2])
*)

val astype : ?order:[`C | `F | `A | `K] -> ?casting:[`No | `Equiv | `Safe | `Same_kind | `Unsafe] -> ?subok:Py.Object.t -> ?copy:bool -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)

Copy of the array, cast to a specified type.

Parameters
----------
dtype : str or dtype
    Typecode or data-type to which the array is cast.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout order of the result.
    'C' means C order, 'F' means Fortran order, 'A'
    means 'F' order if all the arrays are Fortran contiguous,
    'C' order otherwise, and 'K' means as close to the
    order the array elements appear in memory as possible.
    Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'unsafe'
    for backwards compatibility.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.
subok : bool, optional
    If True, then sub-classes will be passed-through (default), otherwise
    the returned array will be forced to be a base-class array.
copy : bool, optional
    By default, astype always returns a newly allocated array. If this
    is set to false, and the `dtype`, `order`, and `subok`
    requirements are satisfied, the input array is returned instead
    of a copy.

Returns
-------
arr_t : ndarray
    Unless `copy` is False and the other conditions for returning the input
    array are satisfied (see description for `copy` input parameter), `arr_t`
    is a new array of the same shape as the input array, with dtype, order
    given by `dtype`, `order`.

Notes
-----
.. versionchanged:: 1.17.0
   Casting between a simple data type and a structured one is possible only
   for 'unsafe' casting.  Casting to multiple fields is allowed, but
   casting from multiple fields is not.

.. versionchanged:: 1.9.0
   Casting from numeric to string types in 'safe' casting mode requires
   that the string dtype length is long enough to store the max
   integer/float value converted.

Raises
------
ComplexWarning
    When casting from complex to float or int. To avoid this,
    one should use ``a.real.astype(t)``.

Examples
--------
>>> x = np.array([1, 2, 2.5])
>>> x
array([1. ,  2. ,  2.5])

>>> x.astype(int)
array([1, 2, 2])
*)

val byteswap : ?inplace:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.byteswap(inplace=False)

Swap the bytes of the array elements

Toggle between low-endian and big-endian data representation by
returning a byteswapped array, optionally swapped in-place.
Arrays of byte-strings are not swapped. The real and imaginary
parts of a complex number are swapped individually.

Parameters
----------
inplace : bool, optional
    If ``True``, swap bytes in-place, default is ``False``.

Returns
-------
out : ndarray
    The byteswapped array. If `inplace` is ``True``, this is
    a view to self.

Examples
--------
>>> A = np.array([1, 256, 8755], dtype=np.int16)
>>> list(map(hex, A))
['0x1', '0x100', '0x2233']
>>> A.byteswap(inplace=True)
array([  256,     1, 13090], dtype=int16)
>>> list(map(hex, A))
['0x100', '0x1', '0x3322']

Arrays of byte-strings are not swapped

>>> A = np.array([b'ceg', b'fac'])
>>> A.byteswap()
array([b'ceg', b'fac'], dtype='|S3')

``A.newbyteorder().byteswap()`` produces an array with the same values
  but different representation in memory

>>> A = np.array([1, 2, 3])
>>> A.view(np.uint8)
array([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
       0, 0], dtype=uint8)
>>> A.newbyteorder().byteswap(inplace=True)
array([1, 2, 3])
>>> A.view(np.uint8)
array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
       0, 3], dtype=uint8)
*)

val choose : ?out:Py.Object.t -> ?mode:Py.Object.t -> choices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.choose(choices, out=None, mode='raise')

Use an index array to construct a new array from a set of choices.

Refer to `numpy.choose` for full documentation.

See Also
--------
numpy.choose : equivalent function
*)

val clip : ?min:Py.Object.t -> ?max:Py.Object.t -> ?out:Py.Object.t -> ?kwargs:(string * Py.Object.t) list -> [> tag] Obj.t -> Py.Object.t
(**
a.clip(min=None, max=None, out=None, **kwargs)

Return an array whose values are limited to ``[min, max]``.
One of max or min must be given.

Refer to `numpy.clip` for full documentation.

See Also
--------
numpy.clip : equivalent function
*)

val compress : ?axis:int -> ?out:Py.Object.t -> condition:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return `a` where condition is ``True``.

If condition is a `MaskedArray`, missing values are considered
as ``False``.

Parameters
----------
condition : var
    Boolean 1-d array selecting which entries to return. If len(condition)
    is less than the size of a along the axis, then output is truncated
    to length of condition array.
axis : {None, int}, optional
    Axis along which the operation must be performed.
out : {None, ndarray}, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type will be cast if
    necessary.

Returns
-------
result : MaskedArray
    A :class:`MaskedArray` object.

Notes
-----
Please note the difference with :meth:`compressed` !
The output of :meth:`compress` has a mask, the output of
:meth:`compressed` does not.

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.compress([1, 0, 1])
masked_array(data=[1, 3],
             mask=[False, False],
       fill_value=999999)

>>> x.compress([1, 0, 1], axis=1)
masked_array(
  data=[[1, 3],
        [--, --],
        [7, 9]],
  mask=[[False, False],
        [ True,  True],
        [False, False]],
  fill_value=999999)
*)

val compressed : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return all the non-masked data as a 1-D array.

Returns
-------
data : ndarray
    A new `ndarray` holding the non-masked data is returned.

Notes
-----
The result is **not** a MaskedArray!

Examples
--------
>>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)
>>> x.compressed()
array([0, 1])
>>> type(x.compressed())
<class 'numpy.ndarray'>
*)

val conj : [> tag] Obj.t -> Py.Object.t
(**
a.conj()

Complex-conjugate all elements.

Refer to `numpy.conjugate` for full documentation.

See Also
--------
numpy.conjugate : equivalent function
*)

val conjugate : [> tag] Obj.t -> Py.Object.t
(**
a.conjugate()

Return the complex conjugate, element-wise.

Refer to `numpy.conjugate` for full documentation.

See Also
--------
numpy.conjugate : equivalent function
*)

val copy : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.copy(order='C')

Return a copy of the array.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout of the copy. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible. (Note that this function and :func:`numpy.copy` are very
    similar, but have different default values for their order=
    arguments.)

See also
--------
numpy.copy
numpy.copyto

Examples
--------
>>> x = np.array([[1,2,3],[4,5,6]], order='F')

>>> y = x.copy()

>>> x.fill(0)

>>> x
array([[0, 0, 0],
       [0, 0, 0]])

>>> y
array([[1, 2, 3],
       [4, 5, 6]])

>>> y.flags['C_CONTIGUOUS']
True
*)

val count : ?axis:int list -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Count the non-masked elements of the array along the given axis.

Parameters
----------
axis : None or int or tuple of ints, optional
    Axis or axes along which the count is performed.
    The default, None, performs the count over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.10.0

    If this is a tuple of ints, the count is performed on multiple
    axes, instead of a single axis or all the axes as before.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
result : ndarray or scalar
    An array with the same shape as the input array, with the specified
    axis removed. If the array is a 0-d array, or if `axis` is None, a
    scalar is returned.

See Also
--------
count_masked : Count masked elements in array or along a given axis.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.arange(6).reshape((2, 3))
>>> a[1, :] = ma.masked
>>> a
masked_array(
  data=[[0, 1, 2],
        [--, --, --]],
  mask=[[False, False, False],
        [ True,  True,  True]],
  fill_value=999999)
>>> a.count()
3

When the `axis` keyword is specified an array of appropriate size is
returned.

>>> a.count(axis=0)
array([1, 1, 1])
>>> a.count(axis=1)
array([3, 0])
*)

val cumprod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the cumulative product of the array elements over the given axis.

Masked values are set to 1 internally during the computation.
However, their position is saved, and the result will be masked at
the same locations.

Refer to `numpy.cumprod` for full documentation.

Notes
-----
The mask is lost if `out` is not a valid MaskedArray !

Arithmetic is modular when using integer types, and no error is
raised on overflow.

See Also
--------
numpy.ndarray.cumprod : corresponding function for ndarrays
numpy.cumprod : equivalent function
*)

val cumsum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the cumulative sum of the array elements over the given axis.

Masked values are set to 0 internally during the computation.
However, their position is saved, and the result will be masked at
the same locations.

Refer to `numpy.cumsum` for full documentation.

Notes
-----
The mask is lost if `out` is not a valid :class:`MaskedArray` !

Arithmetic is modular when using integer types, and no error is
raised on overflow.

See Also
--------
numpy.ndarray.cumsum : corresponding function for ndarrays
numpy.cumsum : equivalent function

Examples
--------
>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])
>>> marr.cumsum()
masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],
             mask=[False, False, False,  True,  True,  True, False, False,
                   False, False],
       fill_value=999999)
*)

val diagonal : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.diagonal(offset=0, axis1=0, axis2=1)

Return specified diagonals. In NumPy 1.9 the returned array is a
read-only view instead of a copy as in previous NumPy versions.  In
a future version the read-only restriction will be removed.

Refer to :func:`numpy.diagonal` for full documentation.

See Also
--------
numpy.diagonal : equivalent function
*)

val dot : ?out:Py.Object.t -> ?strict:bool -> b:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.dot(b, out=None)

Masked dot product of two arrays. Note that `out` and `strict` are
located in different positions than in `ma.dot`. In order to
maintain compatibility with the functional version, it is
recommended that the optional arguments be treated as keyword only.
At some point that may be mandatory.

.. versionadded:: 1.10.0

Parameters
----------
b : masked_array_like
    Inputs array.
out : masked_array, optional
    Output argument. This must have the exact kind that would be
    returned if it was not used. In particular, it must have the
    right type, must be C-contiguous, and its dtype must be the
    dtype that would be returned for `ma.dot(a,b)`. This is a
    performance feature. Therefore, if these conditions are not
    met, an exception is raised, instead of attempting to be
    flexible.
strict : bool, optional
    Whether masked data are propagated (True) or set to 0 (False)
    for the computation. Default is False.  Propagating the mask
    means that if a masked value appears in a row or column, the
    whole row or column is considered masked.

    .. versionadded:: 1.10.2

See Also
--------
numpy.ma.dot : equivalent function
*)

val dump : file:[`Path of Py.Object.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.dump(file)

Dump a pickle of the array to the specified file.
The array can be read back with pickle.load or numpy.load.

Parameters
----------
file : str or Path
    A string naming the dump file.

    .. versionchanged:: 1.17.0
        `pathlib.Path` objects are now accepted.
*)

val dumps : [> tag] Obj.t -> Py.Object.t
(**
a.dumps()

Returns the pickle of the array as a string.
pickle.loads or numpy.loads will convert the string back to an array.

Parameters
----------
None
*)

val fill : value:[`F of float | `I of int | `Bool of bool | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.fill(value)

Fill the array with a scalar value.

Parameters
----------
value : scalar
    All elements of `a` will be assigned this value.

Examples
--------
>>> a = np.array([1, 2])
>>> a.fill(0)
>>> a
array([0, 0])
>>> a = np.empty(2)
>>> a.fill(1)
>>> a
array([1.,  1.])
*)

val filled : ?fill_value:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy with masked fields filled with a given value.

Parameters
----------
fill_value : array_like, optional
    The value to use for invalid entries. Can be scalar or
    non-scalar. If latter is the case, the filled array should
    be broadcastable over input array. Default is None, in
    which case the `fill_value` attribute is used instead.

Returns
-------
filled_void
    A `np.void` object

See Also
--------
MaskedArray.filled
*)

val flatten : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.flatten(order='C')

Return a copy of the array collapsed into one dimension.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    'C' means to flatten in row-major (C-style) order.
    'F' means to flatten in column-major (Fortran-
    style) order. 'A' means to flatten in column-major
    order if `a` is Fortran *contiguous* in memory,
    row-major order otherwise. 'K' means to flatten
    `a` in the order the elements occur in memory.
    The default is 'C'.

Returns
-------
y : ndarray
    A copy of the input array, flattened to one dimension.

See Also
--------
ravel : Return a flattened array.
flat : A 1-D flat iterator over the array.

Examples
--------
>>> a = np.array([[1,2], [3,4]])
>>> a.flatten()
array([1, 2, 3, 4])
>>> a.flatten('F')
array([1, 3, 2, 4])
*)

val get_fill_value : [> tag] Obj.t -> Py.Object.t
(**
The filling value of the masked array is a scalar. When setting, None
will set to a default based on the data type.

Examples
--------
>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:
...     np.ma.array([0, 1], dtype=dt).get_fill_value()
...
999999
999999
1e+20
(1e+20+0j)

>>> x = np.ma.array([0, 1.], fill_value=-np.inf)
>>> x.fill_value
-inf
>>> x.fill_value = np.pi
>>> x.fill_value
3.1415926535897931 # may vary

Reset to default:

>>> x.fill_value = None
>>> x.fill_value
1e+20
*)

val get_imag : [> tag] Obj.t -> Py.Object.t
(**
The imaginary part of the masked array.

This property is a view on the imaginary part of this `MaskedArray`.

See Also
--------
real

Examples
--------
>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
>>> x.imag
masked_array(data=[1.0, --, 1.6],
             mask=[False,  True, False],
       fill_value=1e+20)
*)

val get_real : [> tag] Obj.t -> Py.Object.t
(**
The real part of the masked array.

This property is a view on the real part of this `MaskedArray`.

See Also
--------
imag

Examples
--------
>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
>>> x.real
masked_array(data=[1.0, --, 3.45],
             mask=[False,  True, False],
       fill_value=1e+20)
*)

val getfield : ?offset:int -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.getfield(dtype, offset=0)

Returns a field of the given array as a certain type.

A field is a view of the array data with a given data-type. The values in
the view are determined by the given type and the offset into the current
array in bytes. The offset needs to be such that the view dtype fits in the
array dtype; for example an array of dtype complex128 has 16-byte elements.
If taking a view with a 32-bit integer (4 bytes), the offset needs to be
between 0 and 12 bytes.

Parameters
----------
dtype : str or dtype
    The data type of the view. The dtype size of the view can not be larger
    than that of the array itself.
offset : int
    Number of bytes to skip before beginning the element view.

Examples
--------
>>> x = np.diag([1.+1.j]*2)
>>> x[1, 1] = 2 + 4.j
>>> x
array([[1.+1.j,  0.+0.j],
       [0.+0.j,  2.+4.j]])
>>> x.getfield(np.float64)
array([[1.,  0.],
       [0.,  2.]])

By choosing an offset of 8 bytes we can select the complex part of the
array for our view:

>>> x.getfield(np.float64, offset=8)
array([[1.,  0.],
       [0.,  4.]])
*)

val harden_mask : [> tag] Obj.t -> Py.Object.t
(**
Force the mask to hard.

Whether the mask of a masked array is hard or soft is determined by
its `hardmask` property. `harden_mask` sets `hardmask` to True.

See Also
--------
hardmask
*)

val ids : [> tag] Obj.t -> Py.Object.t
(**
Return the addresses of the data and mask areas.

Parameters
----------
None

Examples
--------
>>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])
>>> x.ids()
(166670640, 166659832) # may vary

If the array has no mask, the address of `nomask` is returned. This address
is typically not close to the data in memory:

>>> x = np.ma.array([1, 2, 3])
>>> x.ids()
(166691080, 3083169284L) # may vary
*)

val iscontiguous : [> tag] Obj.t -> Py.Object.t
(**
Return a boolean indicating whether the data is contiguous.

Parameters
----------
None

Examples
--------
>>> x = np.ma.array([1, 2, 3])
>>> x.iscontiguous()
True

`iscontiguous` returns one of the flags of the masked array:

>>> x.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : True
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
*)

val item : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.item( *args)

Copy an element of an array to a standard Python scalar and return it.

Parameters
----------
\*args : Arguments (variable number and type)

    * none: in this case, the method only works for arrays
      with one element (`a.size == 1`), which element is
      copied into a standard Python scalar object and returned.

    * int_type: this argument is interpreted as a flat index into
      the array, specifying which element to copy and return.

    * tuple of int_types: functions as does a single int_type argument,
      except that the argument is interpreted as an nd-index into the
      array.

Returns
-------
z : Standard Python scalar object
    A copy of the specified element of the array as a suitable
    Python scalar

Notes
-----
When the data type of `a` is longdouble or clongdouble, item() returns
a scalar array object because there is no available Python scalar that
would not lose information. Void arrays return a buffer object for item(),
unless fields are defined, in which case a tuple is returned.

`item` is very similar to a[args], except, instead of an array scalar,
a standard Python scalar is returned. This can be useful for speeding up
access to elements of the array and doing arithmetic on elements of the
array using Python's optimized math.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.item(3)
1
>>> x.item(7)
0
>>> x.item((0, 1))
2
>>> x.item((2, 2))
1
*)

val itemset : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.itemset( *args)

Insert scalar into an array (scalar is cast to array's dtype, if possible)

There must be at least 1 argument, and define the last argument
as *item*.  Then, ``a.itemset( *args)`` is equivalent to but faster
than ``a[args] = item``.  The item should be a scalar value and `args`
must select a single item in the array `a`.

Parameters
----------
\*args : Arguments
    If one argument: a scalar, only used in case `a` is of size 1.
    If two arguments: the last argument is the value to be set
    and must be a scalar, the first argument specifies a single array
    element location. It is either an int or a tuple.

Notes
-----
Compared to indexing syntax, `itemset` provides some speed increase
for placing a scalar into a particular location in an `ndarray`,
if you must do this.  However, generally this is discouraged:
among other problems, it complicates the appearance of the code.
Also, when using `itemset` (and `item`) inside a loop, be sure
to assign the methods to a local variable to avoid the attribute
look-up at each loop iteration.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.itemset(4, 0)
>>> x.itemset((2, 2), 9)
>>> x
array([[2, 2, 6],
       [1, 0, 6],
       [1, 0, 9]])
*)

val max : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the maximum along a given axis.

Parameters
----------
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
fill_value : {var}, optional
    Value used to fill in the masked values.
    If None, use the output of maximum_fill_value().
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
amax : array_like
    New array holding the result.
    If ``out`` was specified, ``out`` is returned.

See Also
--------
maximum_fill_value
    Returns the maximum filling value for a given datatype.
*)

val mean : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns the average of the array elements along given axis.

Masked entries are ignored, and result elements which are not
finite will be masked.

Refer to `numpy.mean` for full documentation.

See Also
--------
numpy.ndarray.mean : corresponding function for ndarrays
numpy.mean : Equivalent function
numpy.ma.average: Weighted average.

Examples
--------
>>> a = np.ma.array([1,2,3], mask=[False, False, True])
>>> a
masked_array(data=[1, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.mean()
1.5
*)

val min : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the minimum along a given axis.

Parameters
----------
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must be of
    the same shape and buffer length as the expected output.
fill_value : {var}, optional
    Value used to fill in the masked values.
    If None, use the output of `minimum_fill_value`.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
amin : array_like
    New array holding the result.
    If ``out`` was specified, ``out`` is returned.

See Also
--------
minimum_fill_value
    Returns the minimum filling value for a given datatype.
*)

val mini : ?axis:int -> [> tag] Obj.t -> Py.Object.t
(**
Return the array minimum along the specified axis.

.. deprecated:: 1.13.0
   This function is identical to both:

    * ``self.min(keepdims=True, axis=axis).squeeze(axis=axis)``
    * ``np.ma.minimum.reduce(self, axis=axis)``

   Typically though, ``self.min(axis=axis)`` is sufficient.

Parameters
----------
axis : int, optional
    The axis along which to find the minima. Default is None, in which case
    the minimum value in the whole array is returned.

Returns
-------
min : scalar or MaskedArray
    If `axis` is None, the result is a scalar. Otherwise, if `axis` is
    given and the array is at least 2-D, the result is a masked array with
    dimension one smaller than the array on which `mini` is called.

Examples
--------
>>> x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)
>>> x
masked_array(
  data=[[0, --],
        [2, 3],
        [4, --]],
  mask=[[False,  True],
        [False, False],
        [False,  True]],
  fill_value=999999)
>>> x.mini()
masked_array(data=0,
             mask=False,
       fill_value=999999)
>>> x.mini(axis=0)
masked_array(data=[0, 3],
             mask=[False, False],
       fill_value=999999)
>>> x.mini(axis=1)
masked_array(data=[0, 2, 4],
             mask=[False, False, False],
       fill_value=999999)

There is a small difference between `mini` and `min`:

>>> x[:,1].mini(axis=0)
masked_array(data=3,
             mask=False,
       fill_value=999999)
>>> x[:,1].min(axis=0)
3
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arr.newbyteorder(new_order='S')

Return the array with the same data viewed with a different byte order.

Equivalent to::

    arr.view(arr.dtype.newbytorder(new_order))

Changes are also made in all fields and sub-arrays of the array data
type.



Parameters
----------
new_order : string, optional
    Byte order to force; a value from the byte order specifications
    below. `new_order` codes can be any of:

    * 'S' - swap dtype from current to opposite endian
    * {'<', 'L'} - little endian
    * {'>', 'B'} - big endian
    * {'=', 'N'} - native order
    * {'|', 'I'} - ignore (no change to byte order)

    The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_arr : array
    New array object with the dtype reflecting given change to the
    byte order.
*)

val nonzero : [> tag] Obj.t -> Py.Object.t
(**
Return the indices of unmasked elements that are not zero.

Returns a tuple of arrays, one for each dimension, containing the
indices of the non-zero elements in that dimension. The corresponding
non-zero values can be obtained with::

    a[a.nonzero()]

To group the indices by element, rather than dimension, use
instead::

    np.transpose(a.nonzero())

The result of this is always a 2d array, with a row for each non-zero
element.

Parameters
----------
None

Returns
-------
tuple_of_arrays : tuple
    Indices of elements that are non-zero.

See Also
--------
numpy.nonzero :
    Function operating on ndarrays.
flatnonzero :
    Return indices that are non-zero in the flattened version of the input
    array.
numpy.ndarray.nonzero :
    Equivalent ndarray method.
count_nonzero :
    Counts the number of non-zero elements in the input array.

Examples
--------
>>> import numpy.ma as ma
>>> x = ma.array(np.eye(3))
>>> x
masked_array(
  data=[[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]],
  mask=False,
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 1, 2]), array([0, 1, 2]))

Masked elements are ignored.

>>> x[1, 1] = ma.masked
>>> x
masked_array(
  data=[[1.0, 0.0, 0.0],
        [0.0, --, 0.0],
        [0.0, 0.0, 1.0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 2]), array([0, 2]))

Indices can also be grouped by element.

>>> np.transpose(x.nonzero())
array([[0, 0],
       [2, 2]])

A common use for ``nonzero`` is to find the indices of an array, where
a condition is True.  Given an array `a`, the condition `a` > 3 is a
boolean array and since False is interpreted as 0, ma.nonzero(a > 3)
yields the indices of the `a` where the condition is true.

>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])
>>> a > 3
masked_array(
  data=[[False, False, False],
        [ True,  True,  True],
        [ True,  True,  True]],
  mask=False,
  fill_value=True)
>>> ma.nonzero(a > 3)
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))

The ``nonzero`` method of the condition array can also be called.

>>> (a > 3).nonzero()
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
*)

val partition : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.partition(kth, axis=-1, kind='introselect', order=None)

Rearranges the elements in the array in such a way that the value of the
element in kth position is in the position it would be in a sorted array.
All elements smaller than the kth element are moved before this element and
all equal or greater are moved behind it. The ordering of the elements in
the two partitions is undefined.

.. versionadded:: 1.8.0

Parameters
----------
kth : int or sequence of ints
    Element index to partition by. The kth element value will be in its
    final sorted position and all smaller elements will be moved before it
    and all equal or greater elements behind it.
    The order of all elements in the partitions is undefined.
    If provided with a sequence of kth it will partition all elements
    indexed by kth of them into their sorted position at once.
axis : int, optional
    Axis along which to sort. Default is -1, which means sort along the
    last axis.
kind : {'introselect'}, optional
    Selection algorithm. Default is 'introselect'.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc. A single field can
    be specified as a string, and not all fields need to be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

See Also
--------
numpy.partition : Return a parititioned copy of an array.
argpartition : Indirect partition.
sort : Full sort.

Notes
-----
See ``np.partition`` for notes on the different algorithms.

Examples
--------
>>> a = np.array([3, 4, 2, 1])
>>> a.partition(3)
>>> a
array([2, 1, 3, 4])

>>> a.partition((1, 3))
>>> a
array([1, 2, 3, 4])
*)

val prod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the product of the array elements over the given axis.

Masked elements are set to 1 internally for computation.

Refer to `numpy.prod` for full documentation.

Notes
-----
Arithmetic is modular when using integer types, and no error is raised
on overflow.

See Also
--------
numpy.ndarray.prod : corresponding function for ndarrays
numpy.prod : equivalent function
*)

val ptp : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return (maximum - minimum) along the given dimension
(i.e. peak-to-peak value).

Parameters
----------
axis : {None, int}, optional
    Axis along which to find the peaks.  If None (default) the
    flattened array is used.
out : {None, array_like}, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary.
fill_value : {var}, optional
    Value used to fill in the masked values.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
ptp : ndarray.
    A new array holding the result, unless ``out`` was
    specified, in which case a reference to ``out`` is returned.
*)

val put : ?mode:[`Raise | `Wrap | `Clip] -> indices:Py.Object.t -> values:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Set storage-indexed locations to corresponding values.

Sets self._data.flat[n] = values[n] for each n in indices.
If `values` is shorter than `indices` then it will repeat.
If `values` has some masked values, the initial mask is updated
in consequence, else the corresponding values are unmasked.

Parameters
----------
indices : 1-D array_like
    Target indices, interpreted as integers.
values : array_like
    Values to place in self._data copy at target indices.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.
    'raise' : raise an error.
    'wrap' : wrap around.
    'clip' : clip to the range.

Notes
-----
`values` can be a scalar or length 1 array.

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.put([0,4,8],[10,20,30])
>>> x
masked_array(
  data=[[10, --, 3],
        [--, 20, --],
        [7, --, 30]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)

>>> x.put(4,999)
>>> x
masked_array(
  data=[[10, --, 3],
        [--, 999, --],
        [7, --, 30]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
*)

val ravel : ?order:[`C | `F | `A | `K] -> [> tag] Obj.t -> Py.Object.t
(**
Returns a 1D version of self, as a view.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    The elements of `a` are read using this index order. 'C' means to
    index the elements in C-like order, with the last axis index
    changing fastest, back to the first axis index changing slowest.
    'F' means to index the elements in Fortran-like index order, with
    the first index changing fastest, and the last index changing
    slowest. Note that the 'C' and 'F' options take no account of the
    memory layout of the underlying array, and only refer to the order
    of axis indexing.  'A' means to read the elements in Fortran-like
    index order if `m` is Fortran *contiguous* in memory, C-like order
    otherwise.  'K' means to read the elements in the order they occur
    in memory, except for reversing the data when strides are negative.
    By default, 'C' index order is used.

Returns
-------
MaskedArray
    Output view is of shape ``(self.size,)`` (or
    ``(np.ma.product(self.shape),)``).

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.ravel()
masked_array(data=[1, --, 3, --, 5, --, 7, --, 9],
             mask=[False,  True, False,  True, False,  True, False,  True,
                   False],
       fill_value=999999)
*)

val repeat : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.repeat(repeats, axis=None)

Repeat elements of an array.

Refer to `numpy.repeat` for full documentation.

See Also
--------
numpy.repeat : equivalent function
*)

val reshape : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Give a new shape to the array without changing its data.

Returns a masked array containing the same data, but with a new shape.
The result is a view on the original array; if this is not possible, a
ValueError is raised.

Parameters
----------
shape : int or tuple of ints
    The new shape should be compatible with the original shape. If an
    integer is supplied, then the result will be a 1-D array of that
    length.
order : {'C', 'F'}, optional
    Determines whether the array data should be viewed as in C
    (row-major) or FORTRAN (column-major) order.

Returns
-------
reshaped_array : array
    A new view on the array.

See Also
--------
reshape : Equivalent function in the masked array module.
numpy.ndarray.reshape : Equivalent method on ndarray object.
numpy.reshape : Equivalent function in the NumPy module.

Notes
-----
The reshaping operation cannot guarantee that a copy will not be made,
to modify the shape in place, use ``a.shape = s``

Examples
--------
>>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])
>>> x
masked_array(
  data=[[--, 2],
        [3, --]],
  mask=[[ True, False],
        [False,  True]],
  fill_value=999999)
>>> x = x.reshape((4,1))
>>> x
masked_array(
  data=[[--],
        [2],
        [3],
        [--]],
  mask=[[ True],
        [False],
        [False],
        [ True]],
  fill_value=999999)
*)

val resize : ?refcheck:Py.Object.t -> ?order:Py.Object.t -> newshape:int list -> [> tag] Obj.t -> Py.Object.t
(**
.. warning::

    This method does nothing, except raise a ValueError exception. A
    masked array does not own its data and therefore cannot safely be
    resized in place. Use the `numpy.ma.resize` function instead.

This method is difficult to implement safely and may be deprecated in
future releases of NumPy.
*)

val round : ?decimals:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return each element rounded to the given number of decimals.

Refer to `numpy.around` for full documentation.

See Also
--------
numpy.ndarray.around : corresponding function for ndarrays
numpy.around : equivalent function
*)

val searchsorted : ?side:Py.Object.t -> ?sorter:Py.Object.t -> v:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.searchsorted(v, side='left', sorter=None)

Find indices where elements of v should be inserted in a to maintain order.

For full documentation, see `numpy.searchsorted`

See Also
--------
numpy.searchsorted : equivalent function
*)

val set_fill_value : ?value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
None
*)

val setfield : ?offset:int -> val_:Py.Object.t -> dtype:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.setfield(val, dtype, offset=0)

Put a value into a specified place in a field defined by a data-type.

Place `val` into `a`'s field defined by `dtype` and beginning `offset`
bytes into the field.

Parameters
----------
val : object
    Value to be placed in field.
dtype : dtype object
    Data-type of the field in which to place `val`.
offset : int, optional
    The number of bytes into the field at which to place `val`.

Returns
-------
None

See Also
--------
getfield

Examples
--------
>>> x = np.eye(3)
>>> x.getfield(np.float64)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
>>> x.setfield(3, np.int32)
>>> x.getfield(np.int32)
array([[3, 3, 3],
       [3, 3, 3],
       [3, 3, 3]], dtype=int32)
>>> x
array([[1.0e+000, 1.5e-323, 1.5e-323],
       [1.5e-323, 1.0e+000, 1.5e-323],
       [1.5e-323, 1.5e-323, 1.0e+000]])
>>> x.setfield(np.eye(3), np.int32)
>>> x
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
*)

val setflags : ?write:bool -> ?align:bool -> ?uic:bool -> [> tag] Obj.t -> Py.Object.t
(**
a.setflags(write=None, align=None, uic=None)

Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
respectively.

These Boolean-valued flags affect how numpy interprets the memory
area used by `a` (see Notes below). The ALIGNED flag can only
be set to True if the data is actually aligned according to the type.
The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
to True. The flag WRITEABLE can only be set to True if the array owns its
own memory, or the ultimate owner of the memory exposes a writeable buffer
interface, or is a string. (The exception for string is made so that
unpickling can be done without copying memory.)

Parameters
----------
write : bool, optional
    Describes whether or not `a` can be written to.
align : bool, optional
    Describes whether or not `a` is aligned properly for its type.
uic : bool, optional
    Describes whether or not `a` is a copy of another 'base' array.

Notes
-----
Array flags provide information about how the memory area used
for the array is to be interpreted. There are 7 Boolean flags
in use, only four of which can be changed by the user:
WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.

WRITEABLE (W) the data area can be written to;

ALIGNED (A) the data and strides are aligned appropriately for the hardware
(as determined by the compiler);

UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;

WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
called, the base array will be updated with the contents of this array.

All flags can be accessed using the single (upper case) letter as well
as the full name.

Examples
--------
>>> y = np.array([[3, 1, 7],
...               [2, 0, 0],
...               [8, 5, 9]])
>>> y
array([[3, 1, 7],
       [2, 0, 0],
       [8, 5, 9]])
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(write=0, align=0)
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : False
  ALIGNED : False
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(uic=1)
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: cannot set WRITEBACKIFCOPY flag to True
*)

val shrink_mask : [> tag] Obj.t -> Py.Object.t
(**
Reduce a mask to nomask when possible.

Parameters
----------
None

Returns
-------
None

Examples
--------
>>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)
>>> x.mask
array([[False, False],
       [False, False]])
>>> x.shrink_mask()
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> x.mask
False
*)

val soften_mask : [> tag] Obj.t -> Py.Object.t
(**
Force the mask to soft.

Whether the mask of a masked array is hard or soft is determined by
its `hardmask` property. `soften_mask` sets `hardmask` to False.

See Also
--------
hardmask
*)

val sort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[>`Ndarray] Obj.t -> ?endwith:bool -> ?fill_value:Py.Object.t -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Sort the array, in-place

Parameters
----------
a : array_like
    Array to be sorted.
axis : int, optional
    Axis along which to sort. If None, the array is flattened before
    sorting. The default is -1, which sorts along the last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    The sorting algorithm used.
order : list, optional
    When `a` is a structured array, this argument specifies which fields
    to compare first, second, and so on.  This list does not need to
    include all of the fields.
endwith : {True, False}, optional
    Whether missing values (if any) should be treated as the largest values
    (True) or the smallest values (False)
    When the array contains unmasked values sorting at the same extremes of the
    datatype, the ordering of these values and the masked values is
    undefined.
fill_value : {var}, optional
    Value used internally for the masked values.
    If ``fill_value`` is not None, it supersedes ``endwith``.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
numpy.ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.

Notes
-----
See ``sort`` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Default
>>> a.sort()
>>> a
masked_array(data=[1, 3, 5, --, --],
             mask=[False, False, False,  True,  True],
       fill_value=999999)

>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Put missing values in the front
>>> a.sort(endwith=False)
>>> a
masked_array(data=[--, --, 1, 3, 5],
             mask=[ True,  True, False, False, False],
       fill_value=999999)

>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # fill_value takes over endwith
>>> a.sort(endwith=False, fill_value=3)
>>> a
masked_array(data=[1, --, --, 3, 5],
             mask=[False,  True,  True, False, False],
       fill_value=999999)
*)

val squeeze : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.squeeze(axis=None)

Remove single-dimensional entries from the shape of `a`.

Refer to `numpy.squeeze` for full documentation.

See Also
--------
numpy.squeeze : equivalent function
*)

val std : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?ddof:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns the standard deviation of the array elements along given axis.

Masked entries are ignored.

Refer to `numpy.std` for full documentation.

See Also
--------
numpy.ndarray.std : corresponding function for ndarrays
numpy.std : Equivalent function
*)

val sum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the sum of the array elements over the given axis.

Masked elements are set to 0 internally.

Refer to `numpy.sum` for full documentation.

See Also
--------
numpy.ndarray.sum : corresponding function for ndarrays
numpy.sum : equivalent function

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.sum()
25
>>> x.sum(axis=1)
masked_array(data=[4, 5, 16],
             mask=[False, False, False],
       fill_value=999999)
>>> x.sum(axis=0)
masked_array(data=[8, 5, 12],
             mask=[False, False, False],
       fill_value=999999)
>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))
<class 'numpy.int64'>
*)

val swapaxes : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.swapaxes(axis1, axis2)

Return a view of the array with `axis1` and `axis2` interchanged.

Refer to `numpy.swapaxes` for full documentation.

See Also
--------
numpy.swapaxes : equivalent function
*)

val take : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?mode:Py.Object.t -> indices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
        
*)

val tobytes : ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> ?order:[`C | `F | `A] -> [> tag] Obj.t -> Py.Object.t
(**
Return the array data as a string containing the raw bytes in the array.

The array is filled with a fill value before the string conversion.

.. versionadded:: 1.9.0

Parameters
----------
fill_value : scalar, optional
    Value used to fill in the masked values. Default is None, in which
    case `MaskedArray.fill_value` is used.
order : {'C','F','A'}, optional
    Order of the data item in the copy. Default is 'C'.

    - 'C'   -- C order (row major).
    - 'F'   -- Fortran order (column major).
    - 'A'   -- Any, current order of array.
    - None  -- Same as 'A'.

See Also
--------
numpy.ndarray.tobytes
tolist, tofile

Notes
-----
As for `ndarray.tobytes`, information about the shape, dtype, etc.,
but also about `fill_value`, will be lost.

Examples
--------
>>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
>>> x.tobytes()
b'\x01\x00\x00\x00\x00\x00\x00\x00?B\x0f\x00\x00\x00\x00\x00?B\x0f\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00'
*)

val tofile : ?sep:Py.Object.t -> ?format:Py.Object.t -> fid:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Save a masked array to a file in binary format.

.. warning::
  This function is not implemented yet.

Raises
------
NotImplementedError
    When `tofile` is called.
*)

val toflex : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Transforms a masked array into a flexible-type array.

The flexible type array that is returned will have two fields:

* the ``_data`` field stores the ``_data`` part of the array.
* the ``_mask`` field stores the ``_mask`` part of the array.

Parameters
----------
None

Returns
-------
record : ndarray
    A new flexible-type `ndarray` with two fields: the first element
    containing a value, the second element containing the corresponding
    mask boolean. The returned record shape matches self.shape.

Notes
-----
A side-effect of transforming a masked array into a flexible `ndarray` is
that meta information (``fill_value``, ...) will be lost.

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.toflex()
array([[(1, False), (2,  True), (3, False)],
       [(4,  True), (5, False), (6,  True)],
       [(7, False), (8,  True), (9, False)]],
      dtype=[('_data', '<i8'), ('_mask', '?')])
*)

val tolist : [> tag] Obj.t -> Py.Object.t
(**
Transforms the mvoid object into a tuple.

Masked fields are replaced by None.

Returns
-------
returned_tuple
    Tuple of fields
    
*)

val tostring : ?fill_value:Py.Object.t -> ?order:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
This function is a compatibility alias for tobytes. Despite its name it
returns bytes not strings.
*)

val trace : ?offset:Py.Object.t -> ?axis1:Py.Object.t -> ?axis2:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)

Return the sum along diagonals of the array.

Refer to `numpy.trace` for full documentation.

See Also
--------
numpy.trace : equivalent function
*)

val transpose : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.transpose( *axes)

Returns a view of the array with axes transposed.

For a 1-D array this has no effect, as a transposed vector is simply the
same vector. To convert a 1-D array into a 2D column vector, an additional
dimension must be added. `np.atleast2d(a).T` achieves this, as does
`a[:, np.newaxis]`.
For a 2-D array, this is a standard matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
``a.shape = (i[0], i[1], ... i[n-2], i[n-1])``, then
``a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.

Parameters
----------
axes : None, tuple of ints, or `n` ints

 * None or no argument: reverses the order of the axes.

 * tuple of ints: `i` in the `j`-th place in the tuple means `a`'s
   `i`-th axis becomes `a.transpose()`'s `j`-th axis.

 * `n` ints: same as an n-tuple of the same ints (this form is
   intended simply as a 'convenience' alternative to the tuple form)

Returns
-------
out : ndarray
    View of `a`, with axes suitably permuted.

See Also
--------
ndarray.T : Array property returning the array transposed.
ndarray.reshape : Give a new shape to an array without changing its data.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> a
array([[1, 2],
       [3, 4]])
>>> a.transpose()
array([[1, 3],
       [2, 4]])
>>> a.transpose((1, 0))
array([[1, 3],
       [2, 4]])
>>> a.transpose(1, 0)
array([[1, 3],
       [2, 4]])
*)

val unshare_mask : [> tag] Obj.t -> Py.Object.t
(**
Copy the mask and set the sharedmask flag to False.

Whether the mask is shared between masked arrays can be seen from
the `sharedmask` property. `unshare_mask` ensures the mask is not shared.
A copy of the mask is only made if it was shared.

See Also
--------
sharedmask
*)

val var : ?axis:int list -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?ddof:int -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the variance along the specified axis.

Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.

Parameters
----------
a : array_like
    Array containing numbers whose variance is desired.  If `a` is not an
    array, a conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which the variance is computed.  The default is to
    compute the variance of the flattened array.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a variance is performed over multiple axes,
    instead of a single axis or all the axes as before.
dtype : data-type, optional
    Type to use in computing the variance.  For arrays of integer type
    the default is `float64`; for arrays of float types it is the same as
    the array type.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output, but the type is cast if
    necessary.
ddof : int, optional
    'Delta Degrees of Freedom': the divisor used in the calculation is
    ``N - ddof``, where ``N`` represents the number of elements. By
    default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `var` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
variance : ndarray, see dtype parameter above
    If ``out=None``, returns a new array containing the variance;
    otherwise, a reference to the output array is returned.

See Also
--------
std, mean, nanmean, nanstd, nanvar
ufuncs-output-type

Notes
-----
The variance is the average of the squared deviations from the mean,
i.e.,  ``var = mean(abs(x - x.mean())**2)``.

The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
If, however, `ddof` is specified, the divisor ``N - ddof`` is used
instead.  In standard statistical practice, ``ddof=1`` provides an
unbiased estimator of the variance of a hypothetical infinite population.
``ddof=0`` provides a maximum likelihood estimate of the variance for
normally distributed variables.

Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.

For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32` (see example
below).  Specifying a higher-accuracy accumulator using the ``dtype``
keyword can alleviate this issue.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> np.var(a)
1.25
>>> np.var(a, axis=0)
array([1.,  1.])
>>> np.var(a, axis=1)
array([0.25,  0.25])

In single precision, var() can be inaccurate:

>>> a = np.zeros((2, 512*512), dtype=np.float32)
>>> a[0, :] = 1.0
>>> a[1, :] = 0.1
>>> np.var(a)
0.20250003

Computing the variance in float64 is more accurate:

>>> np.var(a, dtype=np.float64)
0.20249999932944759 # may vary
>>> ((1-0.55)**2 + (0.1-0.55)**2)/2
0.2025
*)

val view : ?dtype:[`Dtype of Dtype.t | `Ndarray_sub_class of Py.Object.t] -> ?type_:Py.Object.t -> ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> [> tag] Obj.t -> Py.Object.t
(**
Return a view of the MaskedArray data.

Parameters
----------
dtype : data-type or ndarray sub-class, optional
    Data-type descriptor of the returned view, e.g., float32 or int16.
    The default, None, results in the view having the same data-type
    as `a`. As with ``ndarray.view``, dtype can also be specified as
    an ndarray sub-class, which then specifies the type of the
    returned object (this is equivalent to setting the ``type``
    parameter).
type : Python type, optional
    Type of the returned view, either ndarray or a subclass.  The
    default None results in type preservation.
fill_value : scalar, optional
    The value to use for invalid entries (None by default).
    If None, then this argument is inferred from the passed `dtype`, or
    in its absence the original array, as discussed in the notes below.

See Also
--------
numpy.ndarray.view : Equivalent method on ndarray object.

Notes
-----

``a.view()`` is used two different ways:

``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
of the array's memory with a different data-type.  This can cause a
reinterpretation of the bytes of memory.

``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
returns an instance of `ndarray_subclass` that looks at the same array
(same shape, dtype, etc.)  This does not cause a reinterpretation of the
memory.

If `fill_value` is not specified, but `dtype` is specified (and is not
an ndarray sub-class), the `fill_value` of the MaskedArray will be
reset. If neither `fill_value` nor `dtype` are specified (or if
`dtype` is an ndarray sub-class), then the fill value is preserved.
Finally, if `fill_value` is specified, but `dtype` is not, the fill
value is set to the specified value.

For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of
bytes per entry than the previous dtype (for example, converting a
regular array to a structured array), then the behavior of the view
cannot be predicted just from the superficial appearance of ``a`` (shown
by ``print(a)``). It also depends on exactly how ``a`` is stored in
memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus
defined as a slice or transpose, etc., the view may give different
results.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Extras : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

module AxisConcatenator : sig
type tag = [`AxisConcatenator]
type t = [`AxisConcatenator | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?axis:Py.Object.t -> ?matrix:Py.Object.t -> ?ndmin:Py.Object.t -> ?trans1d:Py.Object.t -> unit -> t
(**
Translates slice objects to concatenation along an axis.

For detailed documentation on usage, see `r_`.
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
None
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module MAxisConcatenator : sig
type tag = [`MAxisConcatenator]
type t = [`MAxisConcatenator | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?axis:Py.Object.t -> ?matrix:Py.Object.t -> ?ndmin:Py.Object.t -> ?trans1d:Py.Object.t -> unit -> t
(**
Translate slice objects to concatenation along an axis.

For documentation on usage, see `mr_class`.

See Also
--------
mr_class
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
None
*)

val makemat : arr:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
matrix(data, dtype=None, copy=True)

.. note:: It is no longer recommended to use this class, even for linear
          algebra. Instead use regular arrays. The class may be removed
          in the future.

Returns a matrix from an array-like object, or from a string of data.
A matrix is a specialized 2-D array that retains its 2-D nature
through operations.  It has certain special operators, such as ``*``
(matrix multiplication) and ``**`` (matrix power).

Parameters
----------
data : array_like or string
   If `data` is a string, it is interpreted as a matrix with commas
   or spaces separating columns, and semicolons separating rows.
dtype : data-type
   Data-type of the output matrix.
copy : bool
   If `data` is already an `ndarray`, then this flag determines
   whether the data is copied (the default), or whether a view is
   constructed.

See Also
--------
array

Examples
--------
>>> a = np.matrix('1 2; 3 4')
>>> a
matrix([[1, 2],
        [3, 4]])

>>> np.matrix([[1, 2], [3, 4]])
matrix([[1, 2],
        [3, 4]])
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Mr_class : sig
type tag = [`Mr_class]
type t = [`Mr_class | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Translate slice objects to concatenation along the first axis.

This is the masked array version of `lib.index_tricks.RClass`.

See Also
--------
lib.index_tricks.RClass

Examples
--------
>>> np.ma.mr_[np.ma.array([1,2,3]), 0, 0, np.ma.array([4,5,6])]
masked_array(data=[1, 2, 3, ..., 4, 5, 6],
             mask=False,
       fill_value=999999)
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
None
*)

val makemat : arr:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
matrix(data, dtype=None, copy=True)

.. note:: It is no longer recommended to use this class, even for linear
          algebra. Instead use regular arrays. The class may be removed
          in the future.

Returns a matrix from an array-like object, or from a string of data.
A matrix is a specialized 2-D array that retains its 2-D nature
through operations.  It has certain special operators, such as ``*``
(matrix multiplication) and ``**`` (matrix power).

Parameters
----------
data : array_like or string
   If `data` is a string, it is interpreted as a matrix with commas
   or spaces separating columns, and semicolons separating rows.
dtype : data-type
   Data-type of the output matrix.
copy : bool
   If `data` is already an `ndarray`, then this flag determines
   whether the data is copied (the default), or whether a view is
   constructed.

See Also
--------
array

Examples
--------
>>> a = np.matrix('1 2; 3 4')
>>> a
matrix([[1, 2],
        [3, 4]])

>>> np.matrix([[1, 2], [3, 4]])
matrix([[1, 2],
        [3, 4]])
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Ma : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

module MaskedArrayFutureWarning : sig
type tag = [`MaskedArrayFutureWarning]
type t = [`BaseException | `MaskedArrayFutureWarning | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module MaskedConstant : sig
type tag = [`MaskedConstant]
type t = [`ArrayLike | `MaskedConstant | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
An array class with possibly masked values.

Masked values of True exclude the corresponding element from any
computation.

Construction::

  x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
                  ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
                  shrink=True, order=None)

Parameters
----------
data : array_like
    Input data.
mask : sequence, optional
    Mask. Must be convertible to an array of booleans with the same
    shape as `data`. True indicates a masked (i.e. invalid) data.
dtype : dtype, optional
    Data type of the output.
    If `dtype` is None, the type of the data argument (``data.dtype``)
    is used. If `dtype` is not None and different from ``data.dtype``,
    a copy is performed.
copy : bool, optional
    Whether to copy the input data (True), or to use a reference instead.
    Default is False.
subok : bool, optional
    Whether to return a subclass of `MaskedArray` if possible (True) or a
    plain `MaskedArray`. Default is True.
ndmin : int, optional
    Minimum number of dimensions. Default is 0.
fill_value : scalar, optional
    Value used to fill in the masked values when necessary.
    If None, a default based on the data-type is used.
keep_mask : bool, optional
    Whether to combine `mask` with the mask of the input data, if any
    (True), or to use only `mask` for the output (False). Default is True.
hard_mask : bool, optional
    Whether to use a hard mask or not. With a hard mask, masked values
    cannot be unmasked. Default is False.
shrink : bool, optional
    Whether to force compression of an empty mask. Default is True.
order : {'C', 'F', 'A'}, optional
    Specify the order of the array.  If order is 'C', then the array
    will be in C-contiguous order (last-index varies the fastest).
    If order is 'F', then the returned array will be in
    Fortran-contiguous order (first-index varies the fastest).
    If order is 'A' (default), then the returned array may be
    in any order (either C-, Fortran-contiguous, or even discontiguous),
    unless a copy is required, in which case it will be C-contiguous.
*)

val __getitem__ : indx:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
x.__getitem__(y) <==> x[y]

Return the item described by i, as a masked array.
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Implement iter(self).
*)

val __setitem__ : indx:Py.Object.t -> value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
x.__setitem__(i, y) <==> x[i]=y

Set item described by index. If value is masked, masks those
locations.
*)

val all : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns True if all elements evaluate to True.

The output array is masked where all the values along the given axis
are masked: if the output would have been a scalar and that all the
values are masked, then the output is `masked`.

Refer to `numpy.all` for full documentation.

See Also
--------
numpy.ndarray.all : corresponding function for ndarrays
numpy.all : equivalent function

Examples
--------
>>> np.ma.array([1,2,3]).all()
True
>>> a = np.ma.array([1,2,3], mask=True)
>>> (a.all() is np.ma.masked)
True
*)

val anom : ?axis:int -> ?dtype:Dtype.t -> [> tag] Obj.t -> Py.Object.t
(**
Compute the anomalies (deviations from the arithmetic mean)
along the given axis.

Returns an array of anomalies, with the same shape as the input and
where the arithmetic mean is computed along the given axis.

Parameters
----------
axis : int, optional
    Axis over which the anomalies are taken.
    The default is to use the mean of the flattened array as reference.
dtype : dtype, optional
    Type to use in computing the variance. For arrays of integer type
     the default is float32; for arrays of float types it is the same as
     the array type.

See Also
--------
mean : Compute the mean of the array.

Examples
--------
>>> a = np.ma.array([1,2,3])
>>> a.anom()
masked_array(data=[-1.,  0.,  1.],
             mask=False,
       fill_value=1e+20)
*)

val any : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns True if any of the elements of `a` evaluate to True.

Masked values are considered as False during computation.

Refer to `numpy.any` for full documentation.

See Also
--------
numpy.ndarray.any : corresponding function for ndarrays
numpy.any : equivalent function
*)

val argmax : ?axis:int -> ?fill_value:Py.Object.t -> ?out:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns array of indices of the maximum values along the given axis.
Masked values are treated as if they had the value fill_value.

Parameters
----------
axis : {None, integer}
    If None, the index is into the flattened array, otherwise along
    the specified axis
fill_value : {var}, optional
    Value used to fill in the masked values.  If None, the output of
    maximum_fill_value(self._data) is used instead.
out : {None, array}, optional
    Array into which the result can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

Returns
-------
index_array : {integer_array}

Examples
--------
>>> a = np.arange(6).reshape(2,3)
>>> a.argmax()
5
>>> a.argmax(0)
array([1, 1, 1])
>>> a.argmax(1)
array([2, 2])
*)

val argmin : ?axis:int -> ?fill_value:Py.Object.t -> ?out:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return array of indices to the minimum values along the given axis.

Parameters
----------
axis : {None, integer}
    If None, the index is into the flattened array, otherwise along
    the specified axis
fill_value : {var}, optional
    Value used to fill in the masked values.  If None, the output of
    minimum_fill_value(self._data) is used instead.
out : {None, array}, optional
    Array into which the result can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

Returns
-------
ndarray or scalar
    If multi-dimension input, returns a new ndarray of indices to the
    minimum values along the given axis.  Otherwise, returns a scalar
    of index to the minimum values along the given axis.

Examples
--------
>>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])
>>> x.shape = (2,2)
>>> x
masked_array(
  data=[[--, --],
        [2, 3]],
  mask=[[ True,  True],
        [False, False]],
  fill_value=999999)
>>> x.argmin(axis=0, fill_value=-1)
array([0, 0])
>>> x.argmin(axis=0, fill_value=9)
array([1, 1])
*)

val argpartition : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.argpartition(kth, axis=-1, kind='introselect', order=None)

Returns the indices that would partition this array.

Refer to `numpy.argpartition` for full documentation.

.. versionadded:: 1.8.0

See Also
--------
numpy.argpartition : equivalent function
*)

val argsort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[>`Ndarray] Obj.t -> ?endwith:bool -> ?fill_value:Py.Object.t -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an ndarray of indices that sort the array along the
specified axis.  Masked values are filled beforehand to
`fill_value`.

Parameters
----------
axis : int, optional
    Axis along which to sort. If None, the default, the flattened array
    is used.

    ..  versionchanged:: 1.13.0
        Previously, the default was documented to be -1, but that was
        in error. At some future date, the default will change to -1, as
        originally intended.
        Until then, the axis should be given explicitly when
        ``arr.ndim > 1``, to avoid a FutureWarning.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    The sorting algorithm used.
order : list, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  Not all fields need be
    specified.
endwith : {True, False}, optional
    Whether missing values (if any) should be treated as the largest values
    (True) or the smallest values (False)
    When the array contains unmasked values at the same extremes of the
    datatype, the ordering of these values and the masked values is
    undefined.
fill_value : {var}, optional
    Value used internally for the masked values.
    If ``fill_value`` is not None, it supersedes ``endwith``.

Returns
-------
index_array : ndarray, int
    Array of indices that sort `a` along the specified axis.
    In other words, ``a[index_array]`` yields a sorted `a`.

See Also
--------
MaskedArray.sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
numpy.ndarray.sort : Inplace sort.

Notes
-----
See `sort` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.ma.array([3,2,1], mask=[False, False, True])
>>> a
masked_array(data=[3, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.argsort()
array([1, 0, 2])
*)

val astype : ?order:[`C | `F | `A | `K] -> ?casting:[`No | `Equiv | `Safe | `Same_kind | `Unsafe] -> ?subok:Py.Object.t -> ?copy:bool -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)

Copy of the array, cast to a specified type.

Parameters
----------
dtype : str or dtype
    Typecode or data-type to which the array is cast.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout order of the result.
    'C' means C order, 'F' means Fortran order, 'A'
    means 'F' order if all the arrays are Fortran contiguous,
    'C' order otherwise, and 'K' means as close to the
    order the array elements appear in memory as possible.
    Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'unsafe'
    for backwards compatibility.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.
subok : bool, optional
    If True, then sub-classes will be passed-through (default), otherwise
    the returned array will be forced to be a base-class array.
copy : bool, optional
    By default, astype always returns a newly allocated array. If this
    is set to false, and the `dtype`, `order`, and `subok`
    requirements are satisfied, the input array is returned instead
    of a copy.

Returns
-------
arr_t : ndarray
    Unless `copy` is False and the other conditions for returning the input
    array are satisfied (see description for `copy` input parameter), `arr_t`
    is a new array of the same shape as the input array, with dtype, order
    given by `dtype`, `order`.

Notes
-----
.. versionchanged:: 1.17.0
   Casting between a simple data type and a structured one is possible only
   for 'unsafe' casting.  Casting to multiple fields is allowed, but
   casting from multiple fields is not.

.. versionchanged:: 1.9.0
   Casting from numeric to string types in 'safe' casting mode requires
   that the string dtype length is long enough to store the max
   integer/float value converted.

Raises
------
ComplexWarning
    When casting from complex to float or int. To avoid this,
    one should use ``a.real.astype(t)``.

Examples
--------
>>> x = np.array([1, 2, 2.5])
>>> x
array([1. ,  2. ,  2.5])

>>> x.astype(int)
array([1, 2, 2])
*)

val byteswap : ?inplace:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.byteswap(inplace=False)

Swap the bytes of the array elements

Toggle between low-endian and big-endian data representation by
returning a byteswapped array, optionally swapped in-place.
Arrays of byte-strings are not swapped. The real and imaginary
parts of a complex number are swapped individually.

Parameters
----------
inplace : bool, optional
    If ``True``, swap bytes in-place, default is ``False``.

Returns
-------
out : ndarray
    The byteswapped array. If `inplace` is ``True``, this is
    a view to self.

Examples
--------
>>> A = np.array([1, 256, 8755], dtype=np.int16)
>>> list(map(hex, A))
['0x1', '0x100', '0x2233']
>>> A.byteswap(inplace=True)
array([  256,     1, 13090], dtype=int16)
>>> list(map(hex, A))
['0x100', '0x1', '0x3322']

Arrays of byte-strings are not swapped

>>> A = np.array([b'ceg', b'fac'])
>>> A.byteswap()
array([b'ceg', b'fac'], dtype='|S3')

``A.newbyteorder().byteswap()`` produces an array with the same values
  but different representation in memory

>>> A = np.array([1, 2, 3])
>>> A.view(np.uint8)
array([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
       0, 0], dtype=uint8)
>>> A.newbyteorder().byteswap(inplace=True)
array([1, 2, 3])
>>> A.view(np.uint8)
array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
       0, 3], dtype=uint8)
*)

val choose : ?out:Py.Object.t -> ?mode:Py.Object.t -> choices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.choose(choices, out=None, mode='raise')

Use an index array to construct a new array from a set of choices.

Refer to `numpy.choose` for full documentation.

See Also
--------
numpy.choose : equivalent function
*)

val clip : ?min:Py.Object.t -> ?max:Py.Object.t -> ?out:Py.Object.t -> ?kwargs:(string * Py.Object.t) list -> [> tag] Obj.t -> Py.Object.t
(**
a.clip(min=None, max=None, out=None, **kwargs)

Return an array whose values are limited to ``[min, max]``.
One of max or min must be given.

Refer to `numpy.clip` for full documentation.

See Also
--------
numpy.clip : equivalent function
*)

val compress : ?axis:int -> ?out:Py.Object.t -> condition:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return `a` where condition is ``True``.

If condition is a `MaskedArray`, missing values are considered
as ``False``.

Parameters
----------
condition : var
    Boolean 1-d array selecting which entries to return. If len(condition)
    is less than the size of a along the axis, then output is truncated
    to length of condition array.
axis : {None, int}, optional
    Axis along which the operation must be performed.
out : {None, ndarray}, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type will be cast if
    necessary.

Returns
-------
result : MaskedArray
    A :class:`MaskedArray` object.

Notes
-----
Please note the difference with :meth:`compressed` !
The output of :meth:`compress` has a mask, the output of
:meth:`compressed` does not.

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.compress([1, 0, 1])
masked_array(data=[1, 3],
             mask=[False, False],
       fill_value=999999)

>>> x.compress([1, 0, 1], axis=1)
masked_array(
  data=[[1, 3],
        [--, --],
        [7, 9]],
  mask=[[False, False],
        [ True,  True],
        [False, False]],
  fill_value=999999)
*)

val compressed : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return all the non-masked data as a 1-D array.

Returns
-------
data : ndarray
    A new `ndarray` holding the non-masked data is returned.

Notes
-----
The result is **not** a MaskedArray!

Examples
--------
>>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)
>>> x.compressed()
array([0, 1])
>>> type(x.compressed())
<class 'numpy.ndarray'>
*)

val copy : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
Copy is a no-op on the maskedconstant, as it is a scalar 
*)

val count : ?axis:int list -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Count the non-masked elements of the array along the given axis.

Parameters
----------
axis : None or int or tuple of ints, optional
    Axis or axes along which the count is performed.
    The default, None, performs the count over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.10.0

    If this is a tuple of ints, the count is performed on multiple
    axes, instead of a single axis or all the axes as before.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
result : ndarray or scalar
    An array with the same shape as the input array, with the specified
    axis removed. If the array is a 0-d array, or if `axis` is None, a
    scalar is returned.

See Also
--------
count_masked : Count masked elements in array or along a given axis.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.arange(6).reshape((2, 3))
>>> a[1, :] = ma.masked
>>> a
masked_array(
  data=[[0, 1, 2],
        [--, --, --]],
  mask=[[False, False, False],
        [ True,  True,  True]],
  fill_value=999999)
>>> a.count()
3

When the `axis` keyword is specified an array of appropriate size is
returned.

>>> a.count(axis=0)
array([1, 1, 1])
>>> a.count(axis=1)
array([3, 0])
*)

val cumprod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the cumulative product of the array elements over the given axis.

Masked values are set to 1 internally during the computation.
However, their position is saved, and the result will be masked at
the same locations.

Refer to `numpy.cumprod` for full documentation.

Notes
-----
The mask is lost if `out` is not a valid MaskedArray !

Arithmetic is modular when using integer types, and no error is
raised on overflow.

See Also
--------
numpy.ndarray.cumprod : corresponding function for ndarrays
numpy.cumprod : equivalent function
*)

val cumsum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the cumulative sum of the array elements over the given axis.

Masked values are set to 0 internally during the computation.
However, their position is saved, and the result will be masked at
the same locations.

Refer to `numpy.cumsum` for full documentation.

Notes
-----
The mask is lost if `out` is not a valid :class:`MaskedArray` !

Arithmetic is modular when using integer types, and no error is
raised on overflow.

See Also
--------
numpy.ndarray.cumsum : corresponding function for ndarrays
numpy.cumsum : equivalent function

Examples
--------
>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])
>>> marr.cumsum()
masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],
             mask=[False, False, False,  True,  True,  True, False, False,
                   False, False],
       fill_value=999999)
*)

val diagonal : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.diagonal(offset=0, axis1=0, axis2=1)

Return specified diagonals. In NumPy 1.9 the returned array is a
read-only view instead of a copy as in previous NumPy versions.  In
a future version the read-only restriction will be removed.

Refer to :func:`numpy.diagonal` for full documentation.

See Also
--------
numpy.diagonal : equivalent function
*)

val dot : ?out:Py.Object.t -> ?strict:bool -> b:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.dot(b, out=None)

Masked dot product of two arrays. Note that `out` and `strict` are
located in different positions than in `ma.dot`. In order to
maintain compatibility with the functional version, it is
recommended that the optional arguments be treated as keyword only.
At some point that may be mandatory.

.. versionadded:: 1.10.0

Parameters
----------
b : masked_array_like
    Inputs array.
out : masked_array, optional
    Output argument. This must have the exact kind that would be
    returned if it was not used. In particular, it must have the
    right type, must be C-contiguous, and its dtype must be the
    dtype that would be returned for `ma.dot(a,b)`. This is a
    performance feature. Therefore, if these conditions are not
    met, an exception is raised, instead of attempting to be
    flexible.
strict : bool, optional
    Whether masked data are propagated (True) or set to 0 (False)
    for the computation. Default is False.  Propagating the mask
    means that if a masked value appears in a row or column, the
    whole row or column is considered masked.

    .. versionadded:: 1.10.2

See Also
--------
numpy.ma.dot : equivalent function
*)

val dump : file:[`Path of Py.Object.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.dump(file)

Dump a pickle of the array to the specified file.
The array can be read back with pickle.load or numpy.load.

Parameters
----------
file : str or Path
    A string naming the dump file.

    .. versionchanged:: 1.17.0
        `pathlib.Path` objects are now accepted.
*)

val fill : value:[`F of float | `I of int | `Bool of bool | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.fill(value)

Fill the array with a scalar value.

Parameters
----------
value : scalar
    All elements of `a` will be assigned this value.

Examples
--------
>>> a = np.array([1, 2])
>>> a.fill(0)
>>> a
array([0, 0])
>>> a = np.empty(2)
>>> a.fill(1)
>>> a
array([1.,  1.])
*)

val filled : ?fill_value:[>`Ndarray] Obj.t -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a copy of self, with masked values filled with a given value.
**However**, if there are no masked values to fill, self will be
returned instead as an ndarray.

Parameters
----------
fill_value : array_like, optional
    The value to use for invalid entries. Can be scalar or non-scalar.
    If non-scalar, the resulting ndarray must be broadcastable over
    input array. Default is None, in which case, the `fill_value`
    attribute of the array is used instead.

Returns
-------
filled_array : ndarray
    A copy of ``self`` with invalid entries replaced by *fill_value*
    (be it the function argument or the attribute of ``self``), or
    ``self`` itself as an ndarray if there are no invalid entries to
    be replaced.

Notes
-----
The result is **not** a MaskedArray!

Examples
--------
>>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)
>>> x.filled()
array([   1,    2, -999,    4, -999])
>>> x.filled(fill_value=1000)
array([   1,    2, 1000,    4, 1000])
>>> type(x.filled())
<class 'numpy.ndarray'>

Subclassing is preserved. This means that if, e.g., the data part of
the masked array is a recarray, `filled` returns a recarray:

>>> x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)
>>> m = np.ma.array(x, mask=[(True, False), (False, True)])
>>> m.filled()
rec.array([(999999,      2), (    -3, 999999)],
          dtype=[('f0', '<i8'), ('f1', '<i8')])
*)

val flatten : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.flatten(order='C')

Return a copy of the array collapsed into one dimension.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    'C' means to flatten in row-major (C-style) order.
    'F' means to flatten in column-major (Fortran-
    style) order. 'A' means to flatten in column-major
    order if `a` is Fortran *contiguous* in memory,
    row-major order otherwise. 'K' means to flatten
    `a` in the order the elements occur in memory.
    The default is 'C'.

Returns
-------
y : ndarray
    A copy of the input array, flattened to one dimension.

See Also
--------
ravel : Return a flattened array.
flat : A 1-D flat iterator over the array.

Examples
--------
>>> a = np.array([[1,2], [3,4]])
>>> a.flatten()
array([1, 2, 3, 4])
>>> a.flatten('F')
array([1, 3, 2, 4])
*)

val get_fill_value : [> tag] Obj.t -> Py.Object.t
(**
The filling value of the masked array is a scalar. When setting, None
will set to a default based on the data type.

Examples
--------
>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:
...     np.ma.array([0, 1], dtype=dt).get_fill_value()
...
999999
999999
1e+20
(1e+20+0j)

>>> x = np.ma.array([0, 1.], fill_value=-np.inf)
>>> x.fill_value
-inf
>>> x.fill_value = np.pi
>>> x.fill_value
3.1415926535897931 # may vary

Reset to default:

>>> x.fill_value = None
>>> x.fill_value
1e+20
*)

val get_imag : [> tag] Obj.t -> Py.Object.t
(**
The imaginary part of the masked array.

This property is a view on the imaginary part of this `MaskedArray`.

See Also
--------
real

Examples
--------
>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
>>> x.imag
masked_array(data=[1.0, --, 1.6],
             mask=[False,  True, False],
       fill_value=1e+20)
*)

val get_real : [> tag] Obj.t -> Py.Object.t
(**
The real part of the masked array.

This property is a view on the real part of this `MaskedArray`.

See Also
--------
imag

Examples
--------
>>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
>>> x.real
masked_array(data=[1.0, --, 3.45],
             mask=[False,  True, False],
       fill_value=1e+20)
*)

val getfield : ?offset:int -> dtype:[`Dtype of Dtype.t | `S of string] -> [> tag] Obj.t -> Py.Object.t
(**
a.getfield(dtype, offset=0)

Returns a field of the given array as a certain type.

A field is a view of the array data with a given data-type. The values in
the view are determined by the given type and the offset into the current
array in bytes. The offset needs to be such that the view dtype fits in the
array dtype; for example an array of dtype complex128 has 16-byte elements.
If taking a view with a 32-bit integer (4 bytes), the offset needs to be
between 0 and 12 bytes.

Parameters
----------
dtype : str or dtype
    The data type of the view. The dtype size of the view can not be larger
    than that of the array itself.
offset : int
    Number of bytes to skip before beginning the element view.

Examples
--------
>>> x = np.diag([1.+1.j]*2)
>>> x[1, 1] = 2 + 4.j
>>> x
array([[1.+1.j,  0.+0.j],
       [0.+0.j,  2.+4.j]])
>>> x.getfield(np.float64)
array([[1.,  0.],
       [0.,  2.]])

By choosing an offset of 8 bytes we can select the complex part of the
array for our view:

>>> x.getfield(np.float64, offset=8)
array([[1.,  0.],
       [0.,  4.]])
*)

val harden_mask : [> tag] Obj.t -> Py.Object.t
(**
Force the mask to hard.

Whether the mask of a masked array is hard or soft is determined by
its `hardmask` property. `harden_mask` sets `hardmask` to True.

See Also
--------
hardmask
*)

val ids : [> tag] Obj.t -> Py.Object.t
(**
Return the addresses of the data and mask areas.

Parameters
----------
None

Examples
--------
>>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])
>>> x.ids()
(166670640, 166659832) # may vary

If the array has no mask, the address of `nomask` is returned. This address
is typically not close to the data in memory:

>>> x = np.ma.array([1, 2, 3])
>>> x.ids()
(166691080, 3083169284L) # may vary
*)

val iscontiguous : [> tag] Obj.t -> Py.Object.t
(**
Return a boolean indicating whether the data is contiguous.

Parameters
----------
None

Examples
--------
>>> x = np.ma.array([1, 2, 3])
>>> x.iscontiguous()
True

`iscontiguous` returns one of the flags of the masked array:

>>> x.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : True
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
*)

val item : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.item( *args)

Copy an element of an array to a standard Python scalar and return it.

Parameters
----------
\*args : Arguments (variable number and type)

    * none: in this case, the method only works for arrays
      with one element (`a.size == 1`), which element is
      copied into a standard Python scalar object and returned.

    * int_type: this argument is interpreted as a flat index into
      the array, specifying which element to copy and return.

    * tuple of int_types: functions as does a single int_type argument,
      except that the argument is interpreted as an nd-index into the
      array.

Returns
-------
z : Standard Python scalar object
    A copy of the specified element of the array as a suitable
    Python scalar

Notes
-----
When the data type of `a` is longdouble or clongdouble, item() returns
a scalar array object because there is no available Python scalar that
would not lose information. Void arrays return a buffer object for item(),
unless fields are defined, in which case a tuple is returned.

`item` is very similar to a[args], except, instead of an array scalar,
a standard Python scalar is returned. This can be useful for speeding up
access to elements of the array and doing arithmetic on elements of the
array using Python's optimized math.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.item(3)
1
>>> x.item(7)
0
>>> x.item((0, 1))
2
>>> x.item((2, 2))
1
*)

val itemset : Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.itemset( *args)

Insert scalar into an array (scalar is cast to array's dtype, if possible)

There must be at least 1 argument, and define the last argument
as *item*.  Then, ``a.itemset( *args)`` is equivalent to but faster
than ``a[args] = item``.  The item should be a scalar value and `args`
must select a single item in the array `a`.

Parameters
----------
\*args : Arguments
    If one argument: a scalar, only used in case `a` is of size 1.
    If two arguments: the last argument is the value to be set
    and must be a scalar, the first argument specifies a single array
    element location. It is either an int or a tuple.

Notes
-----
Compared to indexing syntax, `itemset` provides some speed increase
for placing a scalar into a particular location in an `ndarray`,
if you must do this.  However, generally this is discouraged:
among other problems, it complicates the appearance of the code.
Also, when using `itemset` (and `item`) inside a loop, be sure
to assign the methods to a local variable to avoid the attribute
look-up at each loop iteration.

Examples
--------
>>> np.random.seed(123)
>>> x = np.random.randint(9, size=(3, 3))
>>> x
array([[2, 2, 6],
       [1, 3, 6],
       [1, 0, 1]])
>>> x.itemset(4, 0)
>>> x.itemset((2, 2), 9)
>>> x
array([[2, 2, 6],
       [1, 0, 6],
       [1, 0, 9]])
*)

val max : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the maximum along a given axis.

Parameters
----------
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
fill_value : {var}, optional
    Value used to fill in the masked values.
    If None, use the output of maximum_fill_value().
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
amax : array_like
    New array holding the result.
    If ``out`` was specified, ``out`` is returned.

See Also
--------
maximum_fill_value
    Returns the maximum filling value for a given datatype.
*)

val mean : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns the average of the array elements along given axis.

Masked entries are ignored, and result elements which are not
finite will be masked.

Refer to `numpy.mean` for full documentation.

See Also
--------
numpy.ndarray.mean : corresponding function for ndarrays
numpy.mean : Equivalent function
numpy.ma.average: Weighted average.

Examples
--------
>>> a = np.ma.array([1,2,3], mask=[False, False, True])
>>> a
masked_array(data=[1, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.mean()
1.5
*)

val min : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the minimum along a given axis.

Parameters
----------
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must be of
    the same shape and buffer length as the expected output.
fill_value : {var}, optional
    Value used to fill in the masked values.
    If None, use the output of `minimum_fill_value`.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
amin : array_like
    New array holding the result.
    If ``out`` was specified, ``out`` is returned.

See Also
--------
minimum_fill_value
    Returns the minimum filling value for a given datatype.
*)

val mini : ?axis:int -> [> tag] Obj.t -> Py.Object.t
(**
Return the array minimum along the specified axis.

.. deprecated:: 1.13.0
   This function is identical to both:

    * ``self.min(keepdims=True, axis=axis).squeeze(axis=axis)``
    * ``np.ma.minimum.reduce(self, axis=axis)``

   Typically though, ``self.min(axis=axis)`` is sufficient.

Parameters
----------
axis : int, optional
    The axis along which to find the minima. Default is None, in which case
    the minimum value in the whole array is returned.

Returns
-------
min : scalar or MaskedArray
    If `axis` is None, the result is a scalar. Otherwise, if `axis` is
    given and the array is at least 2-D, the result is a masked array with
    dimension one smaller than the array on which `mini` is called.

Examples
--------
>>> x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)
>>> x
masked_array(
  data=[[0, --],
        [2, 3],
        [4, --]],
  mask=[[False,  True],
        [False, False],
        [False,  True]],
  fill_value=999999)
>>> x.mini()
masked_array(data=0,
             mask=False,
       fill_value=999999)
>>> x.mini(axis=0)
masked_array(data=[0, 3],
             mask=[False, False],
       fill_value=999999)
>>> x.mini(axis=1)
masked_array(data=[0, 2, 4],
             mask=[False, False, False],
       fill_value=999999)

There is a small difference between `mini` and `min`:

>>> x[:,1].mini(axis=0)
masked_array(data=3,
             mask=False,
       fill_value=999999)
>>> x[:,1].min(axis=0)
3
*)

val newbyteorder : ?new_order:string -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arr.newbyteorder(new_order='S')

Return the array with the same data viewed with a different byte order.

Equivalent to::

    arr.view(arr.dtype.newbytorder(new_order))

Changes are also made in all fields and sub-arrays of the array data
type.



Parameters
----------
new_order : string, optional
    Byte order to force; a value from the byte order specifications
    below. `new_order` codes can be any of:

    * 'S' - swap dtype from current to opposite endian
    * {'<', 'L'} - little endian
    * {'>', 'B'} - big endian
    * {'=', 'N'} - native order
    * {'|', 'I'} - ignore (no change to byte order)

    The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of `new_order` for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.


Returns
-------
new_arr : array
    New array object with the dtype reflecting given change to the
    byte order.
*)

val nonzero : [> tag] Obj.t -> Py.Object.t
(**
Return the indices of unmasked elements that are not zero.

Returns a tuple of arrays, one for each dimension, containing the
indices of the non-zero elements in that dimension. The corresponding
non-zero values can be obtained with::

    a[a.nonzero()]

To group the indices by element, rather than dimension, use
instead::

    np.transpose(a.nonzero())

The result of this is always a 2d array, with a row for each non-zero
element.

Parameters
----------
None

Returns
-------
tuple_of_arrays : tuple
    Indices of elements that are non-zero.

See Also
--------
numpy.nonzero :
    Function operating on ndarrays.
flatnonzero :
    Return indices that are non-zero in the flattened version of the input
    array.
numpy.ndarray.nonzero :
    Equivalent ndarray method.
count_nonzero :
    Counts the number of non-zero elements in the input array.

Examples
--------
>>> import numpy.ma as ma
>>> x = ma.array(np.eye(3))
>>> x
masked_array(
  data=[[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]],
  mask=False,
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 1, 2]), array([0, 1, 2]))

Masked elements are ignored.

>>> x[1, 1] = ma.masked
>>> x
masked_array(
  data=[[1.0, 0.0, 0.0],
        [0.0, --, 0.0],
        [0.0, 0.0, 1.0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 2]), array([0, 2]))

Indices can also be grouped by element.

>>> np.transpose(x.nonzero())
array([[0, 0],
       [2, 2]])

A common use for ``nonzero`` is to find the indices of an array, where
a condition is True.  Given an array `a`, the condition `a` > 3 is a
boolean array and since False is interpreted as 0, ma.nonzero(a > 3)
yields the indices of the `a` where the condition is true.

>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])
>>> a > 3
masked_array(
  data=[[False, False, False],
        [ True,  True,  True],
        [ True,  True,  True]],
  mask=False,
  fill_value=True)
>>> ma.nonzero(a > 3)
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))

The ``nonzero`` method of the condition array can also be called.

>>> (a > 3).nonzero()
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
*)

val partition : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.partition(kth, axis=-1, kind='introselect', order=None)

Rearranges the elements in the array in such a way that the value of the
element in kth position is in the position it would be in a sorted array.
All elements smaller than the kth element are moved before this element and
all equal or greater are moved behind it. The ordering of the elements in
the two partitions is undefined.

.. versionadded:: 1.8.0

Parameters
----------
kth : int or sequence of ints
    Element index to partition by. The kth element value will be in its
    final sorted position and all smaller elements will be moved before it
    and all equal or greater elements behind it.
    The order of all elements in the partitions is undefined.
    If provided with a sequence of kth it will partition all elements
    indexed by kth of them into their sorted position at once.
axis : int, optional
    Axis along which to sort. Default is -1, which means sort along the
    last axis.
kind : {'introselect'}, optional
    Selection algorithm. Default is 'introselect'.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc. A single field can
    be specified as a string, and not all fields need to be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

See Also
--------
numpy.partition : Return a parititioned copy of an array.
argpartition : Indirect partition.
sort : Full sort.

Notes
-----
See ``np.partition`` for notes on the different algorithms.

Examples
--------
>>> a = np.array([3, 4, 2, 1])
>>> a.partition(3)
>>> a
array([2, 1, 3, 4])

>>> a.partition((1, 3))
>>> a
array([1, 2, 3, 4])
*)

val prod : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the product of the array elements over the given axis.

Masked elements are set to 1 internally for computation.

Refer to `numpy.prod` for full documentation.

Notes
-----
Arithmetic is modular when using integer types, and no error is raised
on overflow.

See Also
--------
numpy.ndarray.prod : corresponding function for ndarrays
numpy.prod : equivalent function
*)

val ptp : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return (maximum - minimum) along the given dimension
(i.e. peak-to-peak value).

Parameters
----------
axis : {None, int}, optional
    Axis along which to find the peaks.  If None (default) the
    flattened array is used.
out : {None, array_like}, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary.
fill_value : {var}, optional
    Value used to fill in the masked values.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
ptp : ndarray.
    A new array holding the result, unless ``out`` was
    specified, in which case a reference to ``out`` is returned.
*)

val put : ?mode:[`Raise | `Wrap | `Clip] -> indices:Py.Object.t -> values:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Set storage-indexed locations to corresponding values.

Sets self._data.flat[n] = values[n] for each n in indices.
If `values` is shorter than `indices` then it will repeat.
If `values` has some masked values, the initial mask is updated
in consequence, else the corresponding values are unmasked.

Parameters
----------
indices : 1-D array_like
    Target indices, interpreted as integers.
values : array_like
    Values to place in self._data copy at target indices.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.
    'raise' : raise an error.
    'wrap' : wrap around.
    'clip' : clip to the range.

Notes
-----
`values` can be a scalar or length 1 array.

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.put([0,4,8],[10,20,30])
>>> x
masked_array(
  data=[[10, --, 3],
        [--, 20, --],
        [7, --, 30]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)

>>> x.put(4,999)
>>> x
masked_array(
  data=[[10, --, 3],
        [--, 999, --],
        [7, --, 30]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
*)

val ravel : ?order:[`C | `F | `A | `K] -> [> tag] Obj.t -> Py.Object.t
(**
Returns a 1D version of self, as a view.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    The elements of `a` are read using this index order. 'C' means to
    index the elements in C-like order, with the last axis index
    changing fastest, back to the first axis index changing slowest.
    'F' means to index the elements in Fortran-like index order, with
    the first index changing fastest, and the last index changing
    slowest. Note that the 'C' and 'F' options take no account of the
    memory layout of the underlying array, and only refer to the order
    of axis indexing.  'A' means to read the elements in Fortran-like
    index order if `m` is Fortran *contiguous* in memory, C-like order
    otherwise.  'K' means to read the elements in the order they occur
    in memory, except for reversing the data when strides are negative.
    By default, 'C' index order is used.

Returns
-------
MaskedArray
    Output view is of shape ``(self.size,)`` (or
    ``(np.ma.product(self.shape),)``).

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.ravel()
masked_array(data=[1, --, 3, --, 5, --, 7, --, 9],
             mask=[False,  True, False,  True, False,  True, False,  True,
                   False],
       fill_value=999999)
*)

val repeat : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.repeat(repeats, axis=None)

Repeat elements of an array.

Refer to `numpy.repeat` for full documentation.

See Also
--------
numpy.repeat : equivalent function
*)

val reshape : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Give a new shape to the array without changing its data.

Returns a masked array containing the same data, but with a new shape.
The result is a view on the original array; if this is not possible, a
ValueError is raised.

Parameters
----------
shape : int or tuple of ints
    The new shape should be compatible with the original shape. If an
    integer is supplied, then the result will be a 1-D array of that
    length.
order : {'C', 'F'}, optional
    Determines whether the array data should be viewed as in C
    (row-major) or FORTRAN (column-major) order.

Returns
-------
reshaped_array : array
    A new view on the array.

See Also
--------
reshape : Equivalent function in the masked array module.
numpy.ndarray.reshape : Equivalent method on ndarray object.
numpy.reshape : Equivalent function in the NumPy module.

Notes
-----
The reshaping operation cannot guarantee that a copy will not be made,
to modify the shape in place, use ``a.shape = s``

Examples
--------
>>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])
>>> x
masked_array(
  data=[[--, 2],
        [3, --]],
  mask=[[ True, False],
        [False,  True]],
  fill_value=999999)
>>> x = x.reshape((4,1))
>>> x
masked_array(
  data=[[--],
        [2],
        [3],
        [--]],
  mask=[[ True],
        [False],
        [False],
        [ True]],
  fill_value=999999)
*)

val resize : ?refcheck:Py.Object.t -> ?order:Py.Object.t -> newshape:int list -> [> tag] Obj.t -> Py.Object.t
(**
.. warning::

    This method does nothing, except raise a ValueError exception. A
    masked array does not own its data and therefore cannot safely be
    resized in place. Use the `numpy.ma.resize` function instead.

This method is difficult to implement safely and may be deprecated in
future releases of NumPy.
*)

val round : ?decimals:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return each element rounded to the given number of decimals.

Refer to `numpy.around` for full documentation.

See Also
--------
numpy.ndarray.around : corresponding function for ndarrays
numpy.around : equivalent function
*)

val searchsorted : ?side:Py.Object.t -> ?sorter:Py.Object.t -> v:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.searchsorted(v, side='left', sorter=None)

Find indices where elements of v should be inserted in a to maintain order.

For full documentation, see `numpy.searchsorted`

See Also
--------
numpy.searchsorted : equivalent function
*)

val set_fill_value : ?value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
The filling value of the masked array is a scalar. When setting, None
will set to a default based on the data type.

Examples
--------
>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:
...     np.ma.array([0, 1], dtype=dt).get_fill_value()
...
999999
999999
1e+20
(1e+20+0j)

>>> x = np.ma.array([0, 1.], fill_value=-np.inf)
>>> x.fill_value
-inf
>>> x.fill_value = np.pi
>>> x.fill_value
3.1415926535897931 # may vary

Reset to default:

>>> x.fill_value = None
>>> x.fill_value
1e+20
*)

val setfield : ?offset:int -> val_:Py.Object.t -> dtype:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.setfield(val, dtype, offset=0)

Put a value into a specified place in a field defined by a data-type.

Place `val` into `a`'s field defined by `dtype` and beginning `offset`
bytes into the field.

Parameters
----------
val : object
    Value to be placed in field.
dtype : dtype object
    Data-type of the field in which to place `val`.
offset : int, optional
    The number of bytes into the field at which to place `val`.

Returns
-------
None

See Also
--------
getfield

Examples
--------
>>> x = np.eye(3)
>>> x.getfield(np.float64)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
>>> x.setfield(3, np.int32)
>>> x.getfield(np.int32)
array([[3, 3, 3],
       [3, 3, 3],
       [3, 3, 3]], dtype=int32)
>>> x
array([[1.0e+000, 1.5e-323, 1.5e-323],
       [1.5e-323, 1.0e+000, 1.5e-323],
       [1.5e-323, 1.5e-323, 1.0e+000]])
>>> x.setfield(np.eye(3), np.int32)
>>> x
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
*)

val setflags : ?write:bool -> ?align:bool -> ?uic:bool -> [> tag] Obj.t -> Py.Object.t
(**
a.setflags(write=None, align=None, uic=None)

Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
respectively.

These Boolean-valued flags affect how numpy interprets the memory
area used by `a` (see Notes below). The ALIGNED flag can only
be set to True if the data is actually aligned according to the type.
The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
to True. The flag WRITEABLE can only be set to True if the array owns its
own memory, or the ultimate owner of the memory exposes a writeable buffer
interface, or is a string. (The exception for string is made so that
unpickling can be done without copying memory.)

Parameters
----------
write : bool, optional
    Describes whether or not `a` can be written to.
align : bool, optional
    Describes whether or not `a` is aligned properly for its type.
uic : bool, optional
    Describes whether or not `a` is a copy of another 'base' array.

Notes
-----
Array flags provide information about how the memory area used
for the array is to be interpreted. There are 7 Boolean flags
in use, only four of which can be changed by the user:
WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.

WRITEABLE (W) the data area can be written to;

ALIGNED (A) the data and strides are aligned appropriately for the hardware
(as determined by the compiler);

UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;

WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
called, the base array will be updated with the contents of this array.

All flags can be accessed using the single (upper case) letter as well
as the full name.

Examples
--------
>>> y = np.array([[3, 1, 7],
...               [2, 0, 0],
...               [8, 5, 9]])
>>> y
array([[3, 1, 7],
       [2, 0, 0],
       [8, 5, 9]])
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(write=0, align=0)
>>> y.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : False
  ALIGNED : False
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
>>> y.setflags(uic=1)
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: cannot set WRITEBACKIFCOPY flag to True
*)

val shrink_mask : [> tag] Obj.t -> Py.Object.t
(**
Reduce a mask to nomask when possible.

Parameters
----------
None

Returns
-------
None

Examples
--------
>>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)
>>> x.mask
array([[False, False],
       [False, False]])
>>> x.shrink_mask()
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> x.mask
False
*)

val soften_mask : [> tag] Obj.t -> Py.Object.t
(**
Force the mask to soft.

Whether the mask of a masked array is hard or soft is determined by
its `hardmask` property. `soften_mask` sets `hardmask` to False.

See Also
--------
hardmask
*)

val sort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[>`Ndarray] Obj.t -> ?endwith:bool -> ?fill_value:Py.Object.t -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Sort the array, in-place

Parameters
----------
a : array_like
    Array to be sorted.
axis : int, optional
    Axis along which to sort. If None, the array is flattened before
    sorting. The default is -1, which sorts along the last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    The sorting algorithm used.
order : list, optional
    When `a` is a structured array, this argument specifies which fields
    to compare first, second, and so on.  This list does not need to
    include all of the fields.
endwith : {True, False}, optional
    Whether missing values (if any) should be treated as the largest values
    (True) or the smallest values (False)
    When the array contains unmasked values sorting at the same extremes of the
    datatype, the ordering of these values and the masked values is
    undefined.
fill_value : {var}, optional
    Value used internally for the masked values.
    If ``fill_value`` is not None, it supersedes ``endwith``.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
numpy.ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.

Notes
-----
See ``sort`` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Default
>>> a.sort()
>>> a
masked_array(data=[1, 3, 5, --, --],
             mask=[False, False, False,  True,  True],
       fill_value=999999)

>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Put missing values in the front
>>> a.sort(endwith=False)
>>> a
masked_array(data=[--, --, 1, 3, 5],
             mask=[ True,  True, False, False, False],
       fill_value=999999)

>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # fill_value takes over endwith
>>> a.sort(endwith=False, fill_value=3)
>>> a
masked_array(data=[1, --, --, 3, 5],
             mask=[False,  True,  True, False, False],
       fill_value=999999)
*)

val squeeze : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.squeeze(axis=None)

Remove single-dimensional entries from the shape of `a`.

Refer to `numpy.squeeze` for full documentation.

See Also
--------
numpy.squeeze : equivalent function
*)

val std : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?ddof:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Returns the standard deviation of the array elements along given axis.

Masked entries are ignored.

Refer to `numpy.std` for full documentation.

See Also
--------
numpy.ndarray.std : corresponding function for ndarrays
numpy.std : Equivalent function
*)

val sum : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> ?keepdims:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return the sum of the array elements over the given axis.

Masked elements are set to 0 internally.

Refer to `numpy.sum` for full documentation.

See Also
--------
numpy.ndarray.sum : corresponding function for ndarrays
numpy.sum : equivalent function

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.sum()
25
>>> x.sum(axis=1)
masked_array(data=[4, 5, 16],
             mask=[False, False, False],
       fill_value=999999)
>>> x.sum(axis=0)
masked_array(data=[8, 5, 12],
             mask=[False, False, False],
       fill_value=999999)
>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))
<class 'numpy.int64'>
*)

val swapaxes : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> Py.Object.t
(**
a.swapaxes(axis1, axis2)

Return a view of the array with `axis1` and `axis2` interchanged.

Refer to `numpy.swapaxes` for full documentation.

See Also
--------
numpy.swapaxes : equivalent function
*)

val take : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?mode:Py.Object.t -> indices:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
        
*)

val tobytes : ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> ?order:[`C | `F | `A] -> [> tag] Obj.t -> Py.Object.t
(**
Return the array data as a string containing the raw bytes in the array.

The array is filled with a fill value before the string conversion.

.. versionadded:: 1.9.0

Parameters
----------
fill_value : scalar, optional
    Value used to fill in the masked values. Default is None, in which
    case `MaskedArray.fill_value` is used.
order : {'C','F','A'}, optional
    Order of the data item in the copy. Default is 'C'.

    - 'C'   -- C order (row major).
    - 'F'   -- Fortran order (column major).
    - 'A'   -- Any, current order of array.
    - None  -- Same as 'A'.

See Also
--------
numpy.ndarray.tobytes
tolist, tofile

Notes
-----
As for `ndarray.tobytes`, information about the shape, dtype, etc.,
but also about `fill_value`, will be lost.

Examples
--------
>>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
>>> x.tobytes()
b'\x01\x00\x00\x00\x00\x00\x00\x00?B\x0f\x00\x00\x00\x00\x00?B\x0f\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00'
*)

val tofile : ?sep:Py.Object.t -> ?format:Py.Object.t -> fid:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Save a masked array to a file in binary format.

.. warning::
  This function is not implemented yet.

Raises
------
NotImplementedError
    When `tofile` is called.
*)

val toflex : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Transforms a masked array into a flexible-type array.

The flexible type array that is returned will have two fields:

* the ``_data`` field stores the ``_data`` part of the array.
* the ``_mask`` field stores the ``_mask`` part of the array.

Parameters
----------
None

Returns
-------
record : ndarray
    A new flexible-type `ndarray` with two fields: the first element
    containing a value, the second element containing the corresponding
    mask boolean. The returned record shape matches self.shape.

Notes
-----
A side-effect of transforming a masked array into a flexible `ndarray` is
that meta information (``fill_value``, ...) will be lost.

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.toflex()
array([[(1, False), (2,  True), (3, False)],
       [(4,  True), (5, False), (6,  True)],
       [(7, False), (8,  True), (9, False)]],
      dtype=[('_data', '<i8'), ('_mask', '?')])
*)

val tolist : ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the data portion of the masked array as a hierarchical Python list.

Data items are converted to the nearest compatible Python type.
Masked values are converted to `fill_value`. If `fill_value` is None,
the corresponding entries in the output list will be ``None``.

Parameters
----------
fill_value : scalar, optional
    The value to use for invalid entries. Default is None.

Returns
-------
result : list
    The Python list representation of the masked array.

Examples
--------
>>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)
>>> x.tolist()
[[1, None, 3], [None, 5, None], [7, None, 9]]
>>> x.tolist(-999)
[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]
*)

val tostring : ?fill_value:Py.Object.t -> ?order:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
This function is a compatibility alias for tobytes. Despite its name it
returns bytes not strings.
*)

val trace : ?offset:Py.Object.t -> ?axis1:Py.Object.t -> ?axis2:Py.Object.t -> ?dtype:Py.Object.t -> ?out:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)

Return the sum along diagonals of the array.

Refer to `numpy.trace` for full documentation.

See Also
--------
numpy.trace : equivalent function
*)

val transpose : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
a.transpose( *axes)

Returns a view of the array with axes transposed.

For a 1-D array this has no effect, as a transposed vector is simply the
same vector. To convert a 1-D array into a 2D column vector, an additional
dimension must be added. `np.atleast2d(a).T` achieves this, as does
`a[:, np.newaxis]`.
For a 2-D array, this is a standard matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
``a.shape = (i[0], i[1], ... i[n-2], i[n-1])``, then
``a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.

Parameters
----------
axes : None, tuple of ints, or `n` ints

 * None or no argument: reverses the order of the axes.

 * tuple of ints: `i` in the `j`-th place in the tuple means `a`'s
   `i`-th axis becomes `a.transpose()`'s `j`-th axis.

 * `n` ints: same as an n-tuple of the same ints (this form is
   intended simply as a 'convenience' alternative to the tuple form)

Returns
-------
out : ndarray
    View of `a`, with axes suitably permuted.

See Also
--------
ndarray.T : Array property returning the array transposed.
ndarray.reshape : Give a new shape to an array without changing its data.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> a
array([[1, 2],
       [3, 4]])
>>> a.transpose()
array([[1, 3],
       [2, 4]])
>>> a.transpose((1, 0))
array([[1, 3],
       [2, 4]])
>>> a.transpose(1, 0)
array([[1, 3],
       [2, 4]])
*)

val unshare_mask : [> tag] Obj.t -> Py.Object.t
(**
Copy the mask and set the sharedmask flag to False.

Whether the mask is shared between masked arrays can be seen from
the `sharedmask` property. `unshare_mask` ensures the mask is not shared.
A copy of the mask is only made if it was shared.

See Also
--------
sharedmask
*)

val var : ?axis:int list -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?ddof:int -> ?keepdims:bool -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the variance along the specified axis.

Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.

Parameters
----------
a : array_like
    Array containing numbers whose variance is desired.  If `a` is not an
    array, a conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which the variance is computed.  The default is to
    compute the variance of the flattened array.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a variance is performed over multiple axes,
    instead of a single axis or all the axes as before.
dtype : data-type, optional
    Type to use in computing the variance.  For arrays of integer type
    the default is `float64`; for arrays of float types it is the same as
    the array type.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output, but the type is cast if
    necessary.
ddof : int, optional
    'Delta Degrees of Freedom': the divisor used in the calculation is
    ``N - ddof``, where ``N`` represents the number of elements. By
    default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `var` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
variance : ndarray, see dtype parameter above
    If ``out=None``, returns a new array containing the variance;
    otherwise, a reference to the output array is returned.

See Also
--------
std, mean, nanmean, nanstd, nanvar
ufuncs-output-type

Notes
-----
The variance is the average of the squared deviations from the mean,
i.e.,  ``var = mean(abs(x - x.mean())**2)``.

The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
If, however, `ddof` is specified, the divisor ``N - ddof`` is used
instead.  In standard statistical practice, ``ddof=1`` provides an
unbiased estimator of the variance of a hypothetical infinite population.
``ddof=0`` provides a maximum likelihood estimate of the variance for
normally distributed variables.

Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.

For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32` (see example
below).  Specifying a higher-accuracy accumulator using the ``dtype``
keyword can alleviate this issue.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> np.var(a)
1.25
>>> np.var(a, axis=0)
array([1.,  1.])
>>> np.var(a, axis=1)
array([0.25,  0.25])

In single precision, var() can be inaccurate:

>>> a = np.zeros((2, 512*512), dtype=np.float32)
>>> a[0, :] = 1.0
>>> a[1, :] = 0.1
>>> np.var(a)
0.20250003

Computing the variance in float64 is more accurate:

>>> np.var(a, dtype=np.float64)
0.20249999932944759 # may vary
>>> ((1-0.55)**2 + (0.1-0.55)**2)/2
0.2025
*)

val view : ?dtype:[`Dtype of Dtype.t | `Ndarray_sub_class of Py.Object.t] -> ?type_:Py.Object.t -> ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> [> tag] Obj.t -> Py.Object.t
(**
Return a view of the MaskedArray data.

Parameters
----------
dtype : data-type or ndarray sub-class, optional
    Data-type descriptor of the returned view, e.g., float32 or int16.
    The default, None, results in the view having the same data-type
    as `a`. As with ``ndarray.view``, dtype can also be specified as
    an ndarray sub-class, which then specifies the type of the
    returned object (this is equivalent to setting the ``type``
    parameter).
type : Python type, optional
    Type of the returned view, either ndarray or a subclass.  The
    default None results in type preservation.
fill_value : scalar, optional
    The value to use for invalid entries (None by default).
    If None, then this argument is inferred from the passed `dtype`, or
    in its absence the original array, as discussed in the notes below.

See Also
--------
numpy.ndarray.view : Equivalent method on ndarray object.

Notes
-----

``a.view()`` is used two different ways:

``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
of the array's memory with a different data-type.  This can cause a
reinterpretation of the bytes of memory.

``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
returns an instance of `ndarray_subclass` that looks at the same array
(same shape, dtype, etc.)  This does not cause a reinterpretation of the
memory.

If `fill_value` is not specified, but `dtype` is specified (and is not
an ndarray sub-class), the `fill_value` of the MaskedArray will be
reset. If neither `fill_value` nor `dtype` are specified (or if
`dtype` is an ndarray sub-class), then the fill value is preserved.
Finally, if `fill_value` is specified, but `dtype` is not, the fill
value is set to the specified value.

For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of
bytes per entry than the previous dtype (for example, converting a
regular array to a structured array), then the behavior of the view
cannot be predicted just from the superficial appearance of ``a`` (shown
by ``print(a)``). It also depends on exactly how ``a`` is stored in
memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus
defined as a slice or transpose, etc., the view may give different
results.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module MaskedIterator : sig
type tag = [`MaskedIterator]
type t = [`MaskedIterator | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : Py.Object.t -> t
(**
Flat iterator object to iterate over masked arrays.

A `MaskedIterator` iterator is returned by ``x.flat`` for any masked array
`x`. It allows iterating over the array as if it were a 1-D array,
either in a for-loop or by calling its `next` method.

Iteration is done in C-contiguous style, with the last index varying the
fastest. The iterator can also be indexed using basic slicing or
advanced indexing.

See Also
--------
MaskedArray.flat : Return a flat iterator over an array.
MaskedArray.flatten : Returns a flattened copy of an array.

Notes
-----
`MaskedIterator` is not exported by the `ma` module. Instead of
instantiating a `MaskedIterator` directly, use `MaskedArray.flat`.

Examples
--------
>>> x = np.ma.array(arange(6).reshape(2, 3))
>>> fl = x.flat
>>> type(fl)
<class 'numpy.ma.core.MaskedIterator'>
>>> for item in fl:
...     print(item)
...
0
1
2
3
4
5

Extracting more than a single element b indexing the `MaskedIterator`
returns a masked array:

>>> fl[2:4]
masked_array(data = [2 3],
             mask = False,
       fill_value = 999999)
*)

val __getitem__ : indx:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
None
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
None
*)

val __setitem__ : index:Py.Object.t -> value:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
None
*)

val next : [> tag] Obj.t -> Py.Object.t
(**
Return the next value, or raise StopIteration.

Examples
--------
>>> x = np.ma.array([3, 2], mask=[0, 1])
>>> fl = x.flat
>>> next(fl)
3
>>> next(fl)
masked
>>> next(fl)
Traceback (most recent call last):
  ...
StopIteration
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Bytes : sig
type tag = [`Bytes]
type t = [`Bytes | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : Py.Object.t -> t
(**
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer
*)

val __getitem__ : key:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return self[key].
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
Implement iter(self).
*)

val center : ?fillchar:Py.Object.t -> width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a centered string of length width.

Padding is done using the specified fill character.
*)

val count : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.count(sub[, start[, end]]) -> int

Return the number of non-overlapping occurrences of subsection sub in
bytes B[start:end].  Optional arguments start and end are interpreted
as in slice notation.
*)

val decode : ?encoding:Py.Object.t -> ?errors:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Decode the bytes using the codec registered for encoding.

encoding
  The encoding with which to decode the bytes.
errors
  The error handling scheme to use for the handling of decoding errors.
  The default is 'strict' meaning that decoding errors raise a
  UnicodeDecodeError. Other possible values are 'ignore' and 'replace'
  as well as any other name registered with codecs.register_error that
  can handle UnicodeDecodeErrors.
*)

val endswith : ?start:Py.Object.t -> ?end_:Py.Object.t -> suffix:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.endswith(suffix[, start[, end]]) -> bool

Return True if B ends with the specified suffix, False otherwise.
With optional start, test B beginning at that position.
With optional end, stop comparing B at that position.
suffix can also be a tuple of bytes to try.
*)

val expandtabs : ?tabsize:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy where all tab characters are expanded using spaces.

If tabsize is not given, a tab size of 8 characters is assumed.
*)

val find : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.find(sub[, start[, end]]) -> int

Return the lowest index in B where subsection sub is found,
such that sub is contained within B[start,end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.
*)

val fromhex : string:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Create a bytes object from a string of hexadecimal numbers.

Spaces between two numbers are accepted.
Example: bytes.fromhex('B9 01EF') -> b'\\xb9\\x01\\xef'.
*)

val index : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.index(sub[, start[, end]]) -> int

Return the lowest index in B where subsection sub is found,
such that sub is contained within B[start,end].  Optional
arguments start and end are interpreted as in slice notation.

Raises ValueError when the subsection is not found.
*)

val join : iterable_of_bytes:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Concatenate any number of bytes objects.

The bytes whose method is called is inserted in between each pair.

The result is returned as a new bytes object.

Example: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.
*)

val ljust : ?fillchar:Py.Object.t -> width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a left-justified string of length width.

Padding is done using the specified fill character.
*)

val lstrip : ?bytes:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Strip leading bytes contained in the argument.

If the argument is omitted or None, strip leading  ASCII whitespace.
*)

val partition : sep:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Partition the bytes into three parts using the given separator.

This will search for the separator sep in the bytes. If the separator is found,
returns a 3-tuple containing the part before the separator, the separator
itself, and the part after it.

If the separator is not found, returns a 3-tuple containing the original bytes
object and two empty bytes objects.
*)

val replace : ?count:Py.Object.t -> old:Py.Object.t -> new_:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy with all occurrences of substring old replaced by new.

  count
    Maximum number of occurrences to replace.
    -1 (the default value) means replace all occurrences.

If the optional argument count is given, only the first count occurrences are
replaced.
*)

val rfind : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.rfind(sub[, start[, end]]) -> int

Return the highest index in B where subsection sub is found,
such that sub is contained within B[start,end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.
*)

val rindex : ?start:Py.Object.t -> ?end_:Py.Object.t -> sub:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.rindex(sub[, start[, end]]) -> int

Return the highest index in B where subsection sub is found,
such that sub is contained within B[start,end].  Optional
arguments start and end are interpreted as in slice notation.

Raise ValueError when the subsection is not found.
*)

val rjust : ?fillchar:Py.Object.t -> width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a right-justified string of length width.

Padding is done using the specified fill character.
*)

val rpartition : sep:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Partition the bytes into three parts using the given separator.

This will search for the separator sep in the bytes, starting at the end. If
the separator is found, returns a 3-tuple containing the part before the
separator, the separator itself, and the part after it.

If the separator is not found, returns a 3-tuple containing two empty bytes
objects and the original bytes object.
*)

val rsplit : ?sep:Py.Object.t -> ?maxsplit:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a list of the sections in the bytes, using sep as the delimiter.

  sep
    The delimiter according which to split the bytes.
    None (the default value) means split on ASCII whitespace characters
    (space, tab, return, newline, formfeed, vertical tab).
  maxsplit
    Maximum number of splits to do.
    -1 (the default value) means no limit.

Splitting is done starting at the end of the bytes and working to the front.
*)

val rstrip : ?bytes:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Strip trailing bytes contained in the argument.

If the argument is omitted or None, strip trailing ASCII whitespace.
*)

val split : ?sep:Py.Object.t -> ?maxsplit:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a list of the sections in the bytes, using sep as the delimiter.

sep
  The delimiter according which to split the bytes.
  None (the default value) means split on ASCII whitespace characters
  (space, tab, return, newline, formfeed, vertical tab).
maxsplit
  Maximum number of splits to do.
  -1 (the default value) means no limit.
*)

val splitlines : ?keepends:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a list of the lines in the bytes, breaking at line boundaries.

Line breaks are not included in the resulting list unless keepends is given and
true.
*)

val startswith : ?start:Py.Object.t -> ?end_:Py.Object.t -> prefix:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
B.startswith(prefix[, start[, end]]) -> bool

Return True if B starts with the specified prefix, False otherwise.
With optional start, test B beginning at that position.
With optional end, stop comparing B at that position.
prefix can also be a tuple of bytes to try.
*)

val strip : ?bytes:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Strip leading and trailing bytes contained in the argument.

If the argument is omitted or None, strip leading and trailing ASCII whitespace.
*)

val translate : ?delete:Py.Object.t -> table:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Return a copy with each character mapped by the given translation table.

  table
    Translation table, which must be a bytes object of length 256.

All characters occurring in the optional argument delete are removed.
The remaining characters are mapped through the given translation table.
*)

val zfill : width:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Pad a numeric string with zeros on the left, to fill a field of the given width.

The original string is never truncated.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Recursive : sig
type tag = [`Recursive]
type t = [`Object | `Recursive] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : Py.Object.t -> t
(**
A decorator class for recursive nested functions.
Naive recursive nested functions hold a reference to themselves:

def outer( *args):
    def stringify_leaky(arg0, *arg1):
        if len(arg1) > 0:
            return stringify_leaky( *arg1)  # <- HERE
        return str(arg0)
    stringify_leaky( *args)

This design pattern creates a reference cycle that is difficult for a
garbage collector to resolve. The decorator class prevents the
cycle by passing the nested function in as an argument `self`:

def outer( *args):
    @recursive
    def stringify(self, arg0, *arg1):
        if len(arg1) > 0:
            return self( *arg1)
        return str(arg0)
    stringify( *args)
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

val abs : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Calculate the absolute value element-wise.

``np.abs`` is a shorthand for this function.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
absolute : ndarray
    An ndarray containing the absolute value of
    each element in `x`.  For complex input, ``a + ib``, the
    absolute value is :math:`\sqrt{ a^2 + b^2 }`.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> x = np.array([-1.2, 1.2])
>>> np.absolute(x)
array([ 1.2,  1.2])
>>> np.absolute(1.2 + 1j)
1.5620499351813308

Plot the function over ``[-10, 10]``:

>>> import matplotlib.pyplot as plt

>>> x = np.linspace(start=-10, stop=10, num=101)
>>> plt.plot(x, np.absolute(x))
>>> plt.show()

Plot the function over the complex plane:

>>> xx = x + 1j * x[:, np.newaxis]
>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
>>> plt.show()
*)

val absolute : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Calculate the absolute value element-wise.

``np.abs`` is a shorthand for this function.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
absolute : ndarray
    An ndarray containing the absolute value of
    each element in `x`.  For complex input, ``a + ib``, the
    absolute value is :math:`\sqrt{ a^2 + b^2 }`.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> x = np.array([-1.2, 1.2])
>>> np.absolute(x)
array([ 1.2,  1.2])
>>> np.absolute(1.2 + 1j)
1.5620499351813308

Plot the function over ``[-10, 10]``:

>>> import matplotlib.pyplot as plt

>>> x = np.linspace(start=-10, stop=10, num=101)
>>> plt.plot(x, np.absolute(x))
>>> plt.show()

Plot the function over the complex plane:

>>> xx = x + 1j * x[:, np.newaxis]
>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
>>> plt.show()
*)

val add : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Add arguments element-wise.

Parameters
----------
x1, x2 : array_like
    The arrays to be added. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
add : ndarray or scalar
    The sum of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
Equivalent to `x1` + `x2` in terms of array broadcasting.

Examples
--------
>>> np.add(1.0, 4.0)
5.0
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.add(x1, x2)
array([[  0.,   2.,   4.],
       [  3.,   5.,   7.],
       [  6.,   8.,  10.]])
*)

val all : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
all(self, axis=None, out=None, keepdims=<no value>)

Returns True if all elements evaluate to True.

The output array is masked where all the values along the given axis
are masked: if the output would have been a scalar and that all the
values are masked, then the output is `masked`.

Refer to `numpy.all` for full documentation.

See Also
--------
numpy.ndarray.all : corresponding function for ndarrays
numpy.all : equivalent function

Examples
--------
>>> np.ma.array([1,2,3]).all()
True
>>> a = np.ma.array([1,2,3], mask=True)
>>> (a.all() is np.ma.masked)
True
*)

val allclose : ?masked_equal:bool -> ?rtol:float -> ?atol:float -> b:Py.Object.t -> Py.Object.t -> bool
(**
Returns True if two arrays are element-wise equal within a tolerance.

This function is equivalent to `allclose` except that masked values
are treated as equal (default) or unequal, depending on the `masked_equal`
argument.

Parameters
----------
a, b : array_like
    Input arrays to compare.
masked_equal : bool, optional
    Whether masked values in `a` and `b` are considered equal (True) or not
    (False). They are considered equal by default.
rtol : float, optional
    Relative tolerance. The relative difference is equal to ``rtol * b``.
    Default is 1e-5.
atol : float, optional
    Absolute tolerance. The absolute difference is equal to `atol`.
    Default is 1e-8.

Returns
-------
y : bool
    Returns True if the two arrays are equal within the given
    tolerance, False otherwise. If either array contains NaN, then
    False is returned.

See Also
--------
all, any
numpy.allclose : the non-masked `allclose`.

Notes
-----
If the following equation is element-wise True, then `allclose` returns
True::

  absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))

Return True if all elements of `a` and `b` are equal subject to
given tolerances.

Examples
--------
>>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
>>> a
masked_array(data=[10000000000.0, 1e-07, --],
             mask=[False, False,  True],
       fill_value=1e+20)
>>> b = np.ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])
>>> np.ma.allclose(a, b)
False

>>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
>>> b = np.ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])
>>> np.ma.allclose(a, b)
True
>>> np.ma.allclose(a, b, masked_equal=False)
False

Masked values are not compared directly.

>>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
>>> b = np.ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])
>>> np.ma.allclose(a, b)
True
>>> np.ma.allclose(a, b, masked_equal=False)
False
*)

val allequal : ?fill_value:bool -> b:Py.Object.t -> Py.Object.t -> bool
(**
Return True if all entries of a and b are equal, using
fill_value as a truth value where either or both are masked.

Parameters
----------
a, b : array_like
    Input arrays to compare.
fill_value : bool, optional
    Whether masked values in a or b are considered equal (True) or not
    (False).

Returns
-------
y : bool
    Returns True if the two arrays are equal within the given
    tolerance, False otherwise. If either array contains NaN,
    then False is returned.

See Also
--------
all, any
numpy.ma.allclose

Examples
--------
>>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
>>> a
masked_array(data=[10000000000.0, 1e-07, --],
             mask=[False, False,  True],
       fill_value=1e+20)

>>> b = np.array([1e10, 1e-7, -42.0])
>>> b
array([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])
>>> np.ma.allequal(a, b, fill_value=False)
False
>>> np.ma.allequal(a, b)
True
*)

val alltrue : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> target:Py.Object.t -> unit -> Py.Object.t
(**
Reduce `target` along the given `axis`.
*)

val amax : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> ?initial:[`F of float | `I of int | `Bool of bool | `S of string] -> ?where:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the maximum of an array or maximum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, the maximum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `amax` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

initial : scalar, optional
    The minimum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to compare for the maximum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.17.0

Returns
-------
amax : ndarray or scalar
    Maximum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amin :
    The minimum value of an array along a given axis, propagating any NaNs.
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
argmax :
    Return the indices of the maximum values.

nanmin, minimum, fmin

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.

Don't use `amax` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
``amax(a, axis=0)``.

Examples
--------
>>> a = np.arange(4).reshape((2,2))
>>> a
array([[0, 1],
       [2, 3]])
>>> np.amax(a)           # Maximum of the flattened array
3
>>> np.amax(a, axis=0)   # Maxima along the first axis
array([2, 3])
>>> np.amax(a, axis=1)   # Maxima along the second axis
array([1, 3])
>>> np.amax(a, where=[False, True], initial=-1, axis=0)
array([-1,  3])
>>> b = np.arange(5, dtype=float)
>>> b[2] = np.NaN
>>> np.amax(b)
nan
>>> np.amax(b, where=~np.isnan(b), initial=-1)
4.0
>>> np.nanmax(b)
4.0

You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:

>>> np.max([[-50], [10]], axis=-1, initial=0)
array([ 0, 10])

Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.

>>> np.max([5], initial=6)
6
>>> max([5], default=6)
5
*)

val amin : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> ?initial:[`F of float | `I of int | `Bool of bool | `S of string] -> ?where:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the minimum of an array or minimum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, the minimum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `amin` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

initial : scalar, optional
    The maximum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to compare for the minimum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.17.0

Returns
-------
amin : ndarray or scalar
    Minimum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amax :
    The maximum value of an array along a given axis, propagating any NaNs.
nanmin :
    The minimum value of an array along a given axis, ignoring any NaNs.
minimum :
    Element-wise minimum of two arrays, propagating any NaNs.
fmin :
    Element-wise minimum of two arrays, ignoring any NaNs.
argmin :
    Return the indices of the minimum values.

nanmax, maximum, fmax

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.

Don't use `amin` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
``amin(a, axis=0)``.

Examples
--------
>>> a = np.arange(4).reshape((2,2))
>>> a
array([[0, 1],
       [2, 3]])
>>> np.amin(a)           # Minimum of the flattened array
0
>>> np.amin(a, axis=0)   # Minima along the first axis
array([0, 1])
>>> np.amin(a, axis=1)   # Minima along the second axis
array([0, 2])
>>> np.amin(a, where=[False, True], initial=10, axis=0)
array([10,  1])

>>> b = np.arange(5, dtype=float)
>>> b[2] = np.NaN
>>> np.amin(b)
nan
>>> np.amin(b, where=~np.isnan(b), initial=10)
0.0
>>> np.nanmin(b)
0.0

>>> np.min([[-50], [10]], axis=-1, initial=0)
array([-50,   0])

Notice that the initial value is used as one of the elements for which the
minimum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.

Notice that this isn't the same as Python's ``default`` argument.

>>> np.min([6], initial=5)
5
>>> min([6], default=5)
6
*)

val angle : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the angle of the complex argument.

Parameters
----------
z : array_like
    A complex number or sequence of complex numbers.
deg : bool, optional
    Return angle in degrees if True, radians if False (default).

Returns
-------
angle : ndarray or scalar
    The counterclockwise angle from the positive real axis on the complex
    plane in the range ``(-pi, pi]``, with dtype as numpy.float64.

    ..versionchanged:: 1.16.0
        This function works on subclasses of ndarray like `ma.array`.

See Also
--------
arctan2
absolute

Examples
--------
>>> np.angle([1.0, 1.0j, 1+1j])               # in radians
array([ 0.        ,  1.57079633,  0.78539816]) # may vary
>>> np.angle(1+1j, deg=True)                  # in degrees
45.0
*)

val anom : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
anom(self, axis=None, dtype=None)

Compute the anomalies (deviations from the arithmetic mean)
along the given axis.

Returns an array of anomalies, with the same shape as the input and
where the arithmetic mean is computed along the given axis.

Parameters
----------
axis : int, optional
    Axis over which the anomalies are taken.
    The default is to use the mean of the flattened array as reference.
dtype : dtype, optional
    Type to use in computing the variance. For arrays of integer type
     the default is float32; for arrays of float types it is the same as
     the array type.

See Also
--------
mean : Compute the mean of the array.

Examples
--------
>>> a = np.ma.array([1,2,3])
>>> a.anom()
masked_array(data=[-1.,  0.,  1.],
             mask=False,
       fill_value=1e+20)
*)

val anomalies : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
anom(self, axis=None, dtype=None)

Compute the anomalies (deviations from the arithmetic mean)
along the given axis.

Returns an array of anomalies, with the same shape as the input and
where the arithmetic mean is computed along the given axis.

Parameters
----------
axis : int, optional
    Axis over which the anomalies are taken.
    The default is to use the mean of the flattened array as reference.
dtype : dtype, optional
    Type to use in computing the variance. For arrays of integer type
     the default is float32; for arrays of float types it is the same as
     the array type.

See Also
--------
mean : Compute the mean of the array.

Examples
--------
>>> a = np.ma.array([1,2,3])
>>> a.anom()
masked_array(data=[-1.,  0.,  1.],
             mask=False,
       fill_value=1e+20)
*)

val any : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
any(self, axis=None, out=None, keepdims=<no value>)

Returns True if any of the elements of `a` evaluate to True.

Masked values are considered as False during computation.

Refer to `numpy.any` for full documentation.

See Also
--------
numpy.ndarray.any : corresponding function for ndarrays
numpy.any : equivalent function
*)

val append : ?axis:int -> b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Append values to the end of an array.

.. versionadded:: 1.9.0

Parameters
----------
a : array_like
    Values are appended to a copy of this array.
b : array_like
    These values are appended to a copy of `a`.  It must be of the
    correct shape (the same shape as `a`, excluding `axis`).  If `axis`
    is not specified, `b` can be any shape and will be flattened
    before use.
axis : int, optional
    The axis along which `v` are appended.  If `axis` is not given,
    both `a` and `b` are flattened before use.

Returns
-------
append : MaskedArray
    A copy of `a` with `b` appended to `axis`.  Note that `append`
    does not occur in-place: a new array is allocated and filled.  If
    `axis` is None, the result is a flattened array.

See Also
--------
numpy.append : Equivalent function in the top-level NumPy module.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.masked_values([1, 2, 3], 2)
>>> b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)
>>> ma.append(a, b)
masked_array(data=[1, --, 3, 4, 5, 6, --, 8, 9],
             mask=[False,  True, False, False, False, False,  True, False,
                   False],
       fill_value=999999)
*)

val arange : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arange([start,] stop[, step,], dtype=None)

Return evenly spaced values within a given interval.

Values are generated within the half-open interval ``[start, stop)``
(in other words, the interval including `start` but excluding `stop`).
For integer arguments the function is equivalent to the Python built-in
`range` function, but returns an ndarray rather than a list.

When using a non-integer step, such as 0.1, the results will often not
be consistent.  It is better to use `numpy.linspace` for these cases.

Parameters
----------
start : number, optional
    Start of interval.  The interval includes this value.  The default
    start value is 0.
stop : number
    End of interval.  The interval does not include this value, except
    in some cases where `step` is not an integer and floating point
    round-off affects the length of `out`.
step : number, optional
    Spacing between values.  For any output `out`, this is the distance
    between two adjacent values, ``out[i+1] - out[i]``.  The default
    step size is 1.  If `step` is specified as a position argument,
    `start` must also be given.
dtype : dtype
    The type of the output array.  If `dtype` is not given, infer the data
    type from the other input arguments.

Returns
-------
arange : ndarray
    Array of evenly spaced values.

    For floating point arguments, the length of the result is
    ``ceil((stop - start)/step)``.  Because of floating point overflow,
    this rule may result in the last element of `out` being greater
    than `stop`.

See Also
--------
numpy.linspace : Evenly spaced numbers with careful handling of endpoints.
numpy.ogrid: Arrays of evenly spaced numbers in N-dimensions.
numpy.mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.

Examples
--------
>>> np.arange(3)
array([0, 1, 2])
>>> np.arange(3.0)
array([ 0.,  1.,  2.])
>>> np.arange(3,7)
array([3, 4, 5, 6])
>>> np.arange(3,7,2)
array([3, 5])
*)

val arccos : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Trigonometric inverse cosine, element-wise.

The inverse of `cos` so that, if ``y = cos(x)``, then ``x = arccos(y)``.

Parameters
----------
x : array_like
    `x`-coordinate on the unit circle.
    For real arguments, the domain is [-1, 1].
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
angle : ndarray
    The angle of the ray intersecting the unit circle at the given
    `x`-coordinate in radians [0, pi].
    This is a scalar if `x` is a scalar.

See Also
--------
cos, arctan, arcsin, emath.arccos

Notes
-----
`arccos` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `cos(z) = x`. The convention is to return
the angle `z` whose real part lies in `[0, pi]`.

For real-valued input data types, `arccos` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arccos` is a complex analytic function that
has branch cuts `[-inf, -1]` and `[1, inf]` and is continuous from
above on the former and from below on the latter.

The inverse `cos` is also known as `acos` or cos^-1.

References
----------
M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/

Examples
--------
We expect the arccos of 1 to be 0, and of -1 to be pi:

>>> np.arccos([1, -1])
array([ 0.        ,  3.14159265])

Plot arccos:

>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-1, 1, num=100)
>>> plt.plot(x, np.arccos(x))
>>> plt.axis('tight')
>>> plt.show()
*)

val arccosh : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Inverse hyperbolic cosine, element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
arccosh : ndarray
    Array of the same shape as `x`.
    This is a scalar if `x` is a scalar.

See Also
--------

cosh, arcsinh, sinh, arctanh, tanh

Notes
-----
`arccosh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `cosh(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi, pi]` and the real part in
``[0, inf]``.

For real-valued input data types, `arccosh` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arccosh` is a complex analytical function that
has a branch cut `[-inf, 1]` and is continuous from above on it.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Inverse hyperbolic function',
       https://en.wikipedia.org/wiki/Arccosh

Examples
--------
>>> np.arccosh([np.e, 10.0])
array([ 1.65745445,  2.99322285])
>>> np.arccosh(1)
0.0
*)

val arcsin : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Inverse sine, element-wise.

Parameters
----------
x : array_like
    `y`-coordinate on the unit circle.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
angle : ndarray
    The inverse sine of each element in `x`, in radians and in the
    closed interval ``[-pi/2, pi/2]``.
    This is a scalar if `x` is a scalar.

See Also
--------
sin, cos, arccos, tan, arctan, arctan2, emath.arcsin

Notes
-----
`arcsin` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that :math:`sin(z) = x`.  The convention is to
return the angle `z` whose real part lies in [-pi/2, pi/2].

For real-valued input data types, *arcsin* always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arcsin` is a complex analytic function that
has, by convention, the branch cuts [-inf, -1] and [1, inf]  and is
continuous from above on the former and from below on the latter.

The inverse sine is also known as `asin` or sin^{-1}.

References
----------
Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,
10th printing, New York: Dover, 1964, pp. 79ff.
http://www.math.sfu.ca/~cbm/aands/

Examples
--------
>>> np.arcsin(1)     # pi/2
1.5707963267948966
>>> np.arcsin(-1)    # -pi/2
-1.5707963267948966
>>> np.arcsin(0)
0.0
*)

val arcsinh : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Inverse hyperbolic sine element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Array of the same shape as `x`.
    This is a scalar if `x` is a scalar.

Notes
-----
`arcsinh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `sinh(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi/2, pi/2]`.

For real-valued input data types, `arcsinh` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
returns ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arccos` is a complex analytical function that
has branch cuts `[1j, infj]` and `[-1j, -infj]` and is continuous from
the right on the former and from the left on the latter.

The inverse hyperbolic sine is also known as `asinh` or ``sinh^-1``.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Inverse hyperbolic function',
       https://en.wikipedia.org/wiki/Arcsinh

Examples
--------
>>> np.arcsinh(np.array([np.e, 10.0]))
array([ 1.72538256,  2.99822295])
*)

val arctan : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Trigonometric inverse tangent, element-wise.

The inverse of tan, so that if ``y = tan(x)`` then ``x = arctan(y)``.

Parameters
----------
x : array_like
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Out has the same shape as `x`.  Its real part is in
    ``[-pi/2, pi/2]`` (``arctan(+/-inf)`` returns ``+/-pi/2``).
    This is a scalar if `x` is a scalar.

See Also
--------
arctan2 : The 'four quadrant' arctan of the angle formed by (`x`, `y`)
    and the positive `x`-axis.
angle : Argument of complex values.

Notes
-----
`arctan` is a multi-valued function: for each `x` there are infinitely
many numbers `z` such that tan(`z`) = `x`.  The convention is to return
the angle `z` whose real part lies in [-pi/2, pi/2].

For real-valued input data types, `arctan` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arctan` is a complex analytic function that
has [`1j, infj`] and [`-1j, -infj`] as branch cuts, and is continuous
from the left on the former and from the right on the latter.

The inverse tangent is also known as `atan` or tan^{-1}.

References
----------
Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,
10th printing, New York: Dover, 1964, pp. 79.
http://www.math.sfu.ca/~cbm/aands/

Examples
--------
We expect the arctan of 0 to be 0, and of 1 to be pi/4:

>>> np.arctan([0, 1])
array([ 0.        ,  0.78539816])

>>> np.pi/4
0.78539816339744828

Plot arctan:

>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-10, 10)
>>> plt.plot(x, np.arctan(x))
>>> plt.axis('tight')
>>> plt.show()
*)

val arctan2 : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Element-wise arc tangent of ``x1/x2`` choosing the quadrant correctly.

The quadrant (i.e., branch) is chosen so that ``arctan2(x1, x2)`` is
the signed angle in radians between the ray ending at the origin and
passing through the point (1,0), and the ray ending at the origin and
passing through the point (`x2`, `x1`).  (Note the role reversal: the
'`y`-coordinate' is the first function parameter, the '`x`-coordinate'
is the second.)  By IEEE convention, this function is defined for
`x2` = +/-0 and for either or both of `x1` and `x2` = +/-inf (see
Notes for specific values).

This function is not defined for complex-valued arguments; for the
so-called argument of complex values, use `angle`.

Parameters
----------
x1 : array_like, real-valued
    `y`-coordinates.
x2 : array_like, real-valued
    `x`-coordinates. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
angle : ndarray
    Array of angles in radians, in the range ``[-pi, pi]``.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
arctan, tan, angle

Notes
-----
*arctan2* is identical to the `atan2` function of the underlying
C library.  The following special values are defined in the C
standard: [1]_

====== ====== ================
`x1`   `x2`   `arctan2(x1,x2)`
====== ====== ================
+/- 0  +0     +/- 0
+/- 0  -0     +/- pi
 > 0   +/-inf +0 / +pi
 < 0   +/-inf -0 / -pi
+/-inf +inf   +/- (pi/4)
+/-inf -inf   +/- (3*pi/4)
====== ====== ================

Note that +0 and -0 are distinct floating point numbers, as are +inf
and -inf.

References
----------
.. [1] ISO/IEC standard 9899:1999, 'Programming language C.'

Examples
--------
Consider four points in different quadrants:

>>> x = np.array([-1, +1, +1, -1])
>>> y = np.array([-1, -1, +1, +1])
>>> np.arctan2(y, x) * 180 / np.pi
array([-135.,  -45.,   45.,  135.])

Note the order of the parameters. `arctan2` is defined also when `x2` = 0
and at several other special points, obtaining values in
the range ``[-pi, pi]``:

>>> np.arctan2([1., -1.], [0., 0.])
array([ 1.57079633, -1.57079633])
>>> np.arctan2([0., 0., np.inf], [+0., -0., np.inf])
array([ 0.        ,  3.14159265,  0.78539816])
*)

val arctanh : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Inverse hyperbolic tangent element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Array of the same shape as `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
emath.arctanh

Notes
-----
`arctanh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `tanh(z) = x`. The convention is to return
the `z` whose imaginary part lies in `[-pi/2, pi/2]`.

For real-valued input data types, `arctanh` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arctanh` is a complex analytical function
that has branch cuts `[-1, -inf]` and `[1, inf]` and is continuous from
above on the former and from below on the latter.

The inverse hyperbolic tangent is also known as `atanh` or ``tanh^-1``.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Inverse hyperbolic function',
       https://en.wikipedia.org/wiki/Arctanh

Examples
--------
>>> np.arctanh([0, -0.5])
array([ 0.        , -0.54930614])
*)

val argmax : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
argmax(self, axis=None, fill_value=None, out=None)

Returns array of indices of the maximum values along the given axis.
Masked values are treated as if they had the value fill_value.

Parameters
----------
axis : {None, integer}
    If None, the index is into the flattened array, otherwise along
    the specified axis
fill_value : {var}, optional
    Value used to fill in the masked values.  If None, the output of
    maximum_fill_value(self._data) is used instead.
out : {None, array}, optional
    Array into which the result can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

Returns
-------
index_array : {integer_array}

Examples
--------
>>> a = np.arange(6).reshape(2,3)
>>> a.argmax()
5
>>> a.argmax(0)
array([1, 1, 1])
>>> a.argmax(1)
array([2, 2])
*)

val argmin : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
argmin(self, axis=None, fill_value=None, out=None)

Return array of indices to the minimum values along the given axis.

Parameters
----------
axis : {None, integer}
    If None, the index is into the flattened array, otherwise along
    the specified axis
fill_value : {var}, optional
    Value used to fill in the masked values.  If None, the output of
    minimum_fill_value(self._data) is used instead.
out : {None, array}, optional
    Array into which the result can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

Returns
-------
ndarray or scalar
    If multi-dimension input, returns a new ndarray of indices to the
    minimum values along the given axis.  Otherwise, returns a scalar
    of index to the minimum values along the given axis.

Examples
--------
>>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])
>>> x.shape = (2,2)
>>> x
masked_array(
  data=[[--, --],
        [2, 3]],
  mask=[[ True,  True],
        [False, False]],
  fill_value=999999)
>>> x.argmin(axis=0, fill_value=-1)
array([0, 0])
>>> x.argmin(axis=0, fill_value=9)
array([1, 1])
*)

val argsort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[>`Ndarray] Obj.t -> ?endwith:bool -> ?fill_value:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an ndarray of indices that sort the array along the
specified axis.  Masked values are filled beforehand to
`fill_value`.

Parameters
----------
axis : int, optional
    Axis along which to sort. If None, the default, the flattened array
    is used.

    ..  versionchanged:: 1.13.0
        Previously, the default was documented to be -1, but that was
        in error. At some future date, the default will change to -1, as
        originally intended.
        Until then, the axis should be given explicitly when
        ``arr.ndim > 1``, to avoid a FutureWarning.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    The sorting algorithm used.
order : list, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  Not all fields need be
    specified.
endwith : {True, False}, optional
    Whether missing values (if any) should be treated as the largest values
    (True) or the smallest values (False)
    When the array contains unmasked values at the same extremes of the
    datatype, the ordering of these values and the masked values is
    undefined.
fill_value : {var}, optional
    Value used internally for the masked values.
    If ``fill_value`` is not None, it supersedes ``endwith``.

Returns
-------
index_array : ndarray, int
    Array of indices that sort `a` along the specified axis.
    In other words, ``a[index_array]`` yields a sorted `a`.

See Also
--------
MaskedArray.sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
numpy.ndarray.sort : Inplace sort.

Notes
-----
See `sort` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.ma.array([3,2,1], mask=[False, False, True])
>>> a
masked_array(data=[3, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.argsort()
array([1, 0, 2])
*)

val around : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
Round an array to the given number of decimals.

See Also
--------
around : equivalent function; see for details.
*)

val array : ?dtype:Dtype.t -> ?copy:bool -> ?order:[`C | `F | `A] -> ?mask:Py.Object.t -> ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> ?keep_mask:bool -> ?hard_mask:bool -> ?shrink:bool -> ?subok:bool -> ?ndmin:int -> data:[>`Ndarray] Obj.t -> unit -> Py.Object.t
(**
An array class with possibly masked values.

Masked values of True exclude the corresponding element from any
computation.

Construction::

  x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
                  ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
                  shrink=True, order=None)

Parameters
----------
data : array_like
    Input data.
mask : sequence, optional
    Mask. Must be convertible to an array of booleans with the same
    shape as `data`. True indicates a masked (i.e. invalid) data.
dtype : dtype, optional
    Data type of the output.
    If `dtype` is None, the type of the data argument (``data.dtype``)
    is used. If `dtype` is not None and different from ``data.dtype``,
    a copy is performed.
copy : bool, optional
    Whether to copy the input data (True), or to use a reference instead.
    Default is False.
subok : bool, optional
    Whether to return a subclass of `MaskedArray` if possible (True) or a
    plain `MaskedArray`. Default is True.
ndmin : int, optional
    Minimum number of dimensions. Default is 0.
fill_value : scalar, optional
    Value used to fill in the masked values when necessary.
    If None, a default based on the data-type is used.
keep_mask : bool, optional
    Whether to combine `mask` with the mask of the input data, if any
    (True), or to use only `mask` for the output (False). Default is True.
hard_mask : bool, optional
    Whether to use a hard mask or not. With a hard mask, masked values
    cannot be unmasked. Default is False.
shrink : bool, optional
    Whether to force compression of an empty mask. Default is True.
order : {'C', 'F', 'A'}, optional
    Specify the order of the array.  If order is 'C', then the array
    will be in C-contiguous order (last-index varies the fastest).
    If order is 'F', then the returned array will be in
    Fortran-contiguous order (first-index varies the fastest).
    If order is 'A' (default), then the returned array may be
    in any order (either C-, Fortran-contiguous, or even discontiguous),
    unless a copy is required, in which case it will be C-contiguous.
*)

val asanyarray : ?dtype:Dtype.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Convert the input to a masked array, conserving subclasses.

If `a` is a subclass of `MaskedArray`, its class is conserved.
No copy is performed if the input is already an `ndarray`.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.
dtype : dtype, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major ('C') or column-major ('FORTRAN') memory
    representation.  Default is 'C'.

Returns
-------
out : MaskedArray
    MaskedArray interpretation of `a`.

See Also
--------
asarray : Similar to `asanyarray`, but does not conserve subclass.

Examples
--------
>>> x = np.arange(10.).reshape(2, 5)
>>> x
array([[0., 1., 2., 3., 4.],
       [5., 6., 7., 8., 9.]])
>>> np.ma.asanyarray(x)
masked_array(
  data=[[0., 1., 2., 3., 4.],
        [5., 6., 7., 8., 9.]],
  mask=False,
  fill_value=1e+20)
>>> type(np.ma.asanyarray(x))
<class 'numpy.ma.core.MaskedArray'>
*)

val asarray : ?dtype:Dtype.t -> ?order:[`C | `F] -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Convert the input to a masked array of the given data-type.

No copy is performed if the input is already an `ndarray`. If `a` is
a subclass of `MaskedArray`, a base class `MaskedArray` is returned.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to a masked array. This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists, ndarrays and masked arrays.
dtype : dtype, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major ('C') or column-major ('FORTRAN') memory
    representation.  Default is 'C'.

Returns
-------
out : MaskedArray
    Masked array interpretation of `a`.

See Also
--------
asanyarray : Similar to `asarray`, but conserves subclasses.

Examples
--------
>>> x = np.arange(10.).reshape(2, 5)
>>> x
array([[0., 1., 2., 3., 4.],
       [5., 6., 7., 8., 9.]])
>>> np.ma.asarray(x)
masked_array(
  data=[[0., 1., 2., 3., 4.],
        [5., 6., 7., 8., 9.]],
  mask=False,
  fill_value=1e+20)
>>> type(np.ma.asarray(x))
<class 'numpy.ma.core.MaskedArray'>
*)

val bitwise_and : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the bit-wise AND of two arrays element-wise.

Computes the bit-wise AND of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``&``.

Parameters
----------
x1, x2 : array_like
    Only integer and boolean types are handled. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Result.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_and
bitwise_or
bitwise_xor
binary_repr :
    Return the binary representation of the input number as a string.

Examples
--------
The number 13 is represented by ``00001101``.  Likewise, 17 is
represented by ``00010001``.  The bit-wise AND of 13 and 17 is
therefore ``000000001``, or 1:

>>> np.bitwise_and(13, 17)
1

>>> np.bitwise_and(14, 13)
12
>>> np.binary_repr(12)
'1100'
>>> np.bitwise_and([14,3], 13)
array([12,  1])

>>> np.bitwise_and([11,7], [4,25])
array([0, 1])
>>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))
array([ 2,  4, 16])
>>> np.bitwise_and([True, True], [False, True])
array([False,  True])
*)

val bitwise_or : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the bit-wise OR of two arrays element-wise.

Computes the bit-wise OR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``|``.

Parameters
----------
x1, x2 : array_like
    Only integer and boolean types are handled. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Result.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_or
bitwise_and
bitwise_xor
binary_repr :
    Return the binary representation of the input number as a string.

Examples
--------
The number 13 has the binaray representation ``00001101``. Likewise,
16 is represented by ``00010000``.  The bit-wise OR of 13 and 16 is
then ``000111011``, or 29:

>>> np.bitwise_or(13, 16)
29
>>> np.binary_repr(29)
'11101'

>>> np.bitwise_or(32, 2)
34
>>> np.bitwise_or([33, 4], 1)
array([33,  5])
>>> np.bitwise_or([33, 4], [1, 2])
array([33,  6])

>>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))
array([  6,   5, 255])
>>> np.array([2, 5, 255]) | np.array([4, 4, 4])
array([  6,   5, 255])
>>> np.bitwise_or(np.array([2, 5, 255, 2147483647], dtype=np.int32),
...               np.array([4, 4, 4, 2147483647], dtype=np.int32))
array([         6,          5,        255, 2147483647])
>>> np.bitwise_or([True, True], [False, True])
array([ True,  True])
*)

val bitwise_xor : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the bit-wise XOR of two arrays element-wise.

Computes the bit-wise XOR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``^``.

Parameters
----------
x1, x2 : array_like
    Only integer and boolean types are handled. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Result.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_xor
bitwise_and
bitwise_or
binary_repr :
    Return the binary representation of the input number as a string.

Examples
--------
The number 13 is represented by ``00001101``. Likewise, 17 is
represented by ``00010001``.  The bit-wise XOR of 13 and 17 is
therefore ``00011100``, or 28:

>>> np.bitwise_xor(13, 17)
28
>>> np.binary_repr(28)
'11100'

>>> np.bitwise_xor(31, 5)
26
>>> np.bitwise_xor([31,3], 5)
array([26,  6])

>>> np.bitwise_xor([31,3], [5,6])
array([26,  5])
>>> np.bitwise_xor([True, True], [False, True])
array([ True, False])
*)

val ceil : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the ceiling of the input, element-wise.

The ceil of the scalar `x` is the smallest integer `i`, such that
`i >= x`.  It is often denoted as :math:`\lceil x \rceil`.

Parameters
----------
x : array_like
    Input data.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The ceiling of each element in `x`, with `float` dtype.
    This is a scalar if `x` is a scalar.

See Also
--------
floor, trunc, rint

Examples
--------
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.ceil(a)
array([-1., -1., -0.,  1.,  2.,  2.,  2.])
*)

val choose : ?out:[>`Ndarray] Obj.t -> ?mode:[`Raise | `Wrap | `Clip] -> indices:Py.Object.t -> choices:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Use an index array to construct a new array from a set of choices.

Given an array of integers and a set of n choice arrays, this method
will create a new array that merges each of the choice arrays.  Where a
value in `a` is i, the new array will have the value that choices[i]
contains in the same place.

Parameters
----------
a : ndarray of ints
    This array must contain integers in ``[0, n-1]``, where n is the
    number of choices.
choices : sequence of arrays
    Choice arrays. The index array and all of the choices should be
    broadcastable to the same shape.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and `dtype`.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.

    * 'raise' : raise an error
    * 'wrap' : wrap around
    * 'clip' : clip to the range

Returns
-------
merged_array : array

See Also
--------
choose : equivalent function

Examples
--------
>>> choice = np.array([[1,1,1], [2,2,2], [3,3,3]])
>>> a = np.array([2, 1, 0])
>>> np.ma.choose(a, choice)
masked_array(data=[3, 2, 1],
             mask=False,
       fill_value=999999)
*)

val clip : ?out:[>`Ndarray] Obj.t -> ?kwargs:(string * Py.Object.t) list -> a_min:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string | `None] -> a_max:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string | `None] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Clip (limit) the values in an array.

Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of ``[0, 1]``
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.

Equivalent to but faster than ``np.maximum(a_min, np.minimum(a, a_max))``.
No check is performed to ensure ``a_min < a_max``.

Parameters
----------
a : array_like
    Array containing elements to clip.
a_min : scalar or array_like or None
    Minimum value. If None, clipping is not performed on lower
    interval edge. Not more than one of `a_min` and `a_max` may be
    None.
a_max : scalar or array_like or None
    Maximum value. If None, clipping is not performed on upper
    interval edge. Not more than one of `a_min` and `a_max` may be
    None. If `a_min` or `a_max` are array_like, then the three
    arrays will be broadcasted to match their shapes.
out : ndarray, optional
    The results will be placed in this array. It may be the input
    array for in-place clipping.  `out` must be of the right shape
    to hold the output.  Its type is preserved.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

    .. versionadded:: 1.17.0

Returns
-------
clipped_array : ndarray
    An array with the elements of `a`, but where values
    < `a_min` are replaced with `a_min`, and those > `a_max`
    with `a_max`.

See Also
--------
ufuncs-output-type

Examples
--------
>>> a = np.arange(10)
>>> np.clip(a, 1, 8)
array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.clip(a, 3, 6, out=a)
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])
*)

val common_fill_value : b:Py.Object.t -> Py.Object.t -> Py.Object.t option
(**
Return the common filling value of two masked arrays, if any.

If ``a.fill_value == b.fill_value``, return the fill value,
otherwise return None.

Parameters
----------
a, b : MaskedArray
    The masked arrays for which to compare fill values.

Returns
-------
fill_value : scalar or None
    The common fill value, or None.

Examples
--------
>>> x = np.ma.array([0, 1.], fill_value=3)
>>> y = np.ma.array([0, 1.], fill_value=3)
>>> np.ma.common_fill_value(x, y)
3.0
*)

val compress : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
compress(self, condition, axis=None, out=None)

Return `a` where condition is ``True``.

If condition is a `MaskedArray`, missing values are considered
as ``False``.

Parameters
----------
condition : var
    Boolean 1-d array selecting which entries to return. If len(condition)
    is less than the size of a along the axis, then output is truncated
    to length of condition array.
axis : {None, int}, optional
    Axis along which the operation must be performed.
out : {None, ndarray}, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type will be cast if
    necessary.

Returns
-------
result : MaskedArray
    A :class:`MaskedArray` object.

Notes
-----
Please note the difference with :meth:`compressed` !
The output of :meth:`compress` has a mask, the output of
:meth:`compressed` does not.

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.compress([1, 0, 1])
masked_array(data=[1, 3],
             mask=[False, False],
       fill_value=999999)

>>> x.compress([1, 0, 1], axis=1)
masked_array(
  data=[[1, 3],
        [--, --],
        [7, 9]],
  mask=[[False, False],
        [ True,  True],
        [False, False]],
  fill_value=999999)
*)

val compressed : Py.Object.t -> Py.Object.t
(**
Return all the non-masked data as a 1-D array.

This function is equivalent to calling the 'compressed' method of a
`MaskedArray`, see `MaskedArray.compressed` for details.

See Also
--------
MaskedArray.compressed
    Equivalent method.
*)

val concatenate : ?axis:int -> arrays:Py.Object.t -> unit -> Py.Object.t
(**
Concatenate a sequence of arrays along the given axis.

Parameters
----------
arrays : sequence of array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int, optional
    The axis along which the arrays will be joined. Default is 0.

Returns
-------
result : MaskedArray
    The concatenated array with any masked entries preserved.

See Also
--------
numpy.concatenate : Equivalent function in the top-level NumPy module.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.arange(3)
>>> a[1] = ma.masked
>>> b = ma.arange(2, 5)
>>> a
masked_array(data=[0, --, 2],
             mask=[False,  True, False],
       fill_value=999999)
>>> b
masked_array(data=[2, 3, 4],
             mask=False,
       fill_value=999999)
>>> ma.concatenate([a, b])
masked_array(data=[0, --, 2, 2, 3, 4],
             mask=[False,  True, False, False, False, False],
       fill_value=999999)
*)

val conjugate : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the complex conjugate, element-wise.

The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.

Parameters
----------
x : array_like
    Input value.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The complex conjugate of `x`, with same dtype as `y`.
    This is a scalar if `x` is a scalar.

Notes
-----
`conj` is an alias for `conjugate`:

>>> np.conj is np.conjugate
True

Examples
--------
>>> np.conjugate(1+2j)
(1-2j)

>>> x = np.eye(2) + 1j * np.eye(2)
>>> np.conjugate(x)
array([[ 1.-1.j,  0.-0.j],
       [ 0.-0.j,  1.-1.j]])
*)

val convolve : ?mode:[`Valid | `Same | `Full] -> ?propagate_mask:bool -> v:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Returns the discrete, linear convolution of two one-dimensional sequences.

Parameters
----------
a, v : array_like
    Input sequences.
mode : {'valid', 'same', 'full'}, optional
    Refer to the `np.convolve` docstring.
propagate_mask : bool
    If True, then if any masked element is included in the sum for a result
    element, then the result is masked.
    If False, then the result element is only masked if no non-masked cells
    contribute towards it

Returns
-------
out : MaskedArray
    Discrete, linear convolution of `a` and `v`.

See Also
--------
numpy.convolve : Equivalent function in the top-level NumPy module.
*)

val copy : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
copy(self, *args, **params)
a.copy(order='C')

    Return a copy of the array.

    Parameters
    ----------
    order : {'C', 'F', 'A', 'K'}, optional
        Controls the memory layout of the copy. 'C' means C-order,
        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
        'C' otherwise. 'K' means match the layout of `a` as closely
        as possible. (Note that this function and :func:`numpy.copy` are very
        similar, but have different default values for their order=
        arguments.)

    See also
    --------
    numpy.copy
    numpy.copyto

    Examples
    --------
    >>> x = np.array([[1,2,3],[4,5,6]], order='F')

    >>> y = x.copy()

    >>> x.fill(0)

    >>> x
    array([[0, 0, 0],
           [0, 0, 0]])

    >>> y
    array([[1, 2, 3],
           [4, 5, 6]])

    >>> y.flags['C_CONTIGUOUS']
    True
*)

val correlate : ?mode:[`Valid | `Same | `Full] -> ?propagate_mask:bool -> v:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Cross-correlation of two 1-dimensional sequences.

Parameters
----------
a, v : array_like
    Input sequences.
mode : {'valid', 'same', 'full'}, optional
    Refer to the `np.convolve` docstring.  Note that the default
    is 'valid', unlike `convolve`, which uses 'full'.
propagate_mask : bool
    If True, then a result element is masked if any masked element contributes towards it.
    If False, then a result element is only masked if no non-masked element
    contribute towards it

Returns
-------
out : MaskedArray
    Discrete cross-correlation of `a` and `v`.

See Also
--------
numpy.correlate : Equivalent function in the top-level NumPy module.
*)

val cos : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Cosine element-wise.

Parameters
----------
x : array_like
    Input array in radians.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding cosine values.
    This is a scalar if `x` is a scalar.

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.

Examples
--------
>>> np.cos(np.array([0, np.pi/2, np.pi]))
array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])
>>>
>>> # Example of providing the optional output parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.cos([0.1], out1)
>>> out2 is out1
True
>>>
>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
*)

val cosh : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Hyperbolic cosine, element-wise.

Equivalent to ``1/2 * (np.exp(x) + np.exp(-x))`` and ``np.cos(1j*x)``.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array of same shape as `x`.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> np.cosh(0)
1.0

The hyperbolic cosine describes the shape of a hanging cable:

>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-4, 4, 1000)
>>> plt.plot(x, np.cosh(x))
>>> plt.show()
*)

val count : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
count(self, axis=None, keepdims=<no value>)

Count the non-masked elements of the array along the given axis.

Parameters
----------
axis : None or int or tuple of ints, optional
    Axis or axes along which the count is performed.
    The default, None, performs the count over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.10.0

    If this is a tuple of ints, the count is performed on multiple
    axes, instead of a single axis or all the axes as before.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
result : ndarray or scalar
    An array with the same shape as the input array, with the specified
    axis removed. If the array is a 0-d array, or if `axis` is None, a
    scalar is returned.

See Also
--------
count_masked : Count masked elements in array or along a given axis.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.arange(6).reshape((2, 3))
>>> a[1, :] = ma.masked
>>> a
masked_array(
  data=[[0, 1, 2],
        [--, --, --]],
  mask=[[False, False, False],
        [ True,  True,  True]],
  fill_value=999999)
>>> a.count()
3

When the `axis` keyword is specified an array of appropriate size is
returned.

>>> a.count(axis=0)
array([1, 1, 1])
>>> a.count(axis=1)
array([3, 0])
*)

val cumprod : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
cumprod(self, axis=None, dtype=None, out=None)

Return the cumulative product of the array elements over the given axis.

Masked values are set to 1 internally during the computation.
However, their position is saved, and the result will be masked at
the same locations.

Refer to `numpy.cumprod` for full documentation.

Notes
-----
The mask is lost if `out` is not a valid MaskedArray !

Arithmetic is modular when using integer types, and no error is
raised on overflow.

See Also
--------
numpy.ndarray.cumprod : corresponding function for ndarrays
numpy.cumprod : equivalent function
*)

val cumsum : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
cumsum(self, axis=None, dtype=None, out=None)

Return the cumulative sum of the array elements over the given axis.

Masked values are set to 0 internally during the computation.
However, their position is saved, and the result will be masked at
the same locations.

Refer to `numpy.cumsum` for full documentation.

Notes
-----
The mask is lost if `out` is not a valid :class:`MaskedArray` !

Arithmetic is modular when using integer types, and no error is
raised on overflow.

See Also
--------
numpy.ndarray.cumsum : corresponding function for ndarrays
numpy.cumsum : equivalent function

Examples
--------
>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])
>>> marr.cumsum()
masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],
             mask=[False, False, False,  True,  True,  True, False, False,
                   False, False],
       fill_value=999999)
*)

val default_fill_value : [`I of int | `Ndarray of [>`Ndarray] Obj.t | `F of float | `Bool of bool | `Dtype of Dtype.t | `S of string] -> Py.Object.t
(**
Return the default fill value for the argument object.

The default filling value depends on the datatype of the input
array or the type of the input scalar:

   ========  ========
   datatype  default
   ========  ========
   bool      True
   int       999999
   float     1.e20
   complex   1.e20+0j
   object    '?'
   string    'N/A'
   ========  ========

For structured types, a structured scalar is returned, with each field the
default fill value for its type.

For subarray types, the fill value is an array of the same size containing
the default scalar fill value.

Parameters
----------
obj : ndarray, dtype or scalar
    The array data-type or scalar for which the default fill value
    is returned.

Returns
-------
fill_value : scalar
    The default fill value.

Examples
--------
>>> np.ma.default_fill_value(1)
999999
>>> np.ma.default_fill_value(np.array([1.1, 2., np.pi]))
1e+20
>>> np.ma.default_fill_value(np.dtype(complex))
(1e+20+0j)
*)

val diag : ?k:Py.Object.t -> v:Py.Object.t -> unit -> Py.Object.t
(**
Extract a diagonal or construct a diagonal array.

This function is the equivalent of `numpy.diag` that takes masked
values into account, see `numpy.diag` for details.

See Also
--------
numpy.diag : Equivalent function for ndarrays.
*)

val diagonal : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
diagonal(self, *args, **params)
a.diagonal(offset=0, axis1=0, axis2=1)

    Return specified diagonals. In NumPy 1.9 the returned array is a
    read-only view instead of a copy as in previous NumPy versions.  In
    a future version the read-only restriction will be removed.

    Refer to :func:`numpy.diagonal` for full documentation.

    See Also
    --------
    numpy.diagonal : equivalent function
*)

val diff : ?n:int -> ?axis:int -> ?prepend:Py.Object.t -> ?append:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Calculate the n-th discrete difference along the given axis.

The first difference is given by ``out[i] = a[i+1] - a[i]`` along
the given axis, higher differences are calculated by using `diff`
recursively.

Parameters
----------
a : array_like
    Input array
n : int, optional
    The number of times values are differenced. If zero, the input
    is returned as-is.
axis : int, optional
    The axis along which the difference is taken, default is the
    last axis.
prepend, append : array_like, optional
    Values to prepend or append to `a` along axis prior to
    performing the difference.  Scalar values are expanded to
    arrays with length 1 in the direction of axis and the shape
    of the input array in along all other axes.  Otherwise the
    dimension and shape must match `a` except along axis.

    .. versionadded:: 1.16.0

Returns
-------
diff : ndarray
    The n-th differences. The shape of the output is the same as `a`
    except along `axis` where the dimension is smaller by `n`. The
    type of the output is the same as the type of the difference
    between any two elements of `a`. This is the same as the type of
    `a` in most cases. A notable exception is `datetime64`, which
    results in a `timedelta64` output array.

See Also
--------
gradient, ediff1d, cumsum

Notes
-----
Type is preserved for boolean arrays, so the result will contain
`False` when consecutive elements are the same and `True` when they
differ.

For unsigned integer arrays, the results will also be unsigned. This
should not be surprising, as the result is consistent with
calculating the difference directly:

>>> u8_arr = np.array([1, 0], dtype=np.uint8)
>>> np.diff(u8_arr)
array([255], dtype=uint8)
>>> u8_arr[1,...] - u8_arr[0,...]
255

If this is not desirable, then the array should be cast to a larger
integer type first:

>>> i16_arr = u8_arr.astype(np.int16)
>>> np.diff(i16_arr)
array([-1], dtype=int16)

Examples
--------
>>> x = np.array([1, 2, 4, 7, 0])
>>> np.diff(x)
array([ 1,  2,  3, -7])
>>> np.diff(x, n=2)
array([  1,   1, -10])

>>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
>>> np.diff(x)
array([[2, 3, 4],
       [5, 1, 2]])
>>> np.diff(x, axis=0)
array([[-1,  2,  0, -2]])

>>> x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)
>>> np.diff(x)
array([1, 1], dtype='timedelta64[D]')
*)

val divide : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Returns a true division of the inputs, element-wise.

Instead of the Python traditional 'floor division', this returns a true
division.  True division adjusts the output type to present the best
answer, regardless of input types.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
The floor division operator ``//`` was added in Python 2.2 making
``//`` and ``/`` equivalent operators.  The default floor division
operation of ``/`` can be replaced by true division with ``from
__future__ import division``.

In Python 3.0, ``//`` is the floor division operator and ``/`` the
true division operator.  The ``true_divide(x1, x2)`` function is
equivalent to true division in Python.

Examples
--------
>>> x = np.arange(5)
>>> np.true_divide(x, 4)
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])

>>> x//4
array([0, 0, 0, 0, 1])

>>> from __future__ import division
>>> x/4
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
>>> x//4
array([0, 0, 0, 0, 1])
*)

val doc_note : initialdoc:Py.Object.t -> note:Py.Object.t -> unit -> Py.Object.t
(**
Adds a Notes section to an existing docstring.
*)

val dot : ?strict:bool -> ?out:Py.Object.t -> b:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Return the dot product of two arrays.

This function is the equivalent of `numpy.dot` that takes masked values
into account. Note that `strict` and `out` are in different position
than in the method version. In order to maintain compatibility with the
corresponding method, it is recommended that the optional arguments be
treated as keyword only.  At some point that may be mandatory.

.. note::
  Works only with 2-D arrays at the moment.


Parameters
----------
a, b : masked_array_like
    Inputs arrays.
strict : bool, optional
    Whether masked data are propagated (True) or set to 0 (False) for
    the computation. Default is False.  Propagating the mask means that
    if a masked value appears in a row or column, the whole row or
    column is considered masked.
out : masked_array, optional
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for `dot(a,b)`. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.

    .. versionadded:: 1.10.2

See Also
--------
numpy.dot : Equivalent function for ndarrays.

Examples
--------
>>> a = np.ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])
>>> b = np.ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])
>>> np.ma.dot(a, b)
masked_array(
  data=[[21, 26],
        [45, 64]],
  mask=[[False, False],
        [False, False]],
  fill_value=999999)
>>> np.ma.dot(a, b, strict=True)
masked_array(
  data=[[--, --],
        [--, 64]],
  mask=[[ True,  True],
        [ True, False]],
  fill_value=999999)
*)

val empty : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
empty(shape, dtype=float, order='C')

Return a new array of given shape and type, without initializing entries.

Parameters
----------
shape : int or tuple of int
    Shape of the empty array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    Desired output data-type for the array, e.g, `numpy.int8`. Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: 'C'
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data of the given shape, dtype, and
    order.  Object arrays will be initialized to None.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Notes
-----
`empty`, unlike `zeros`, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.

Examples
--------
>>> np.empty([2, 2])
array([[ -9.74499359e+001,   6.69583040e-309],
       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized

>>> np.empty([2, 2], dtype=int)
array([[-1073741821, -1067949133],
       [  496041986,    19249760]])                     #uninitialized
*)

val empty_like : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
empty_like( *args, **kwargs)

empty_like(prototype, dtype=None, order='K', subok=True, shape=None)

Return a new array with the same shape and type as a given array.

Parameters
----------
prototype : array_like
    The shape and data-type of `prototype` define these same attributes
    of the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if ``prototype`` is Fortran
    contiguous, 'C' otherwise. 'K' means match the layout of ``prototype``
    as closely as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of 'a', otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data with the same
    shape and type as `prototype`.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.

Notes
-----
This function does *not* initialize the returned array; to do that use
`zeros_like` or `ones_like` instead.  It may be marginally faster than
the functions that do set the array values.

Examples
--------
>>> a = ([1,2,3], [4,5,6])                         # a is array-like
>>> np.empty_like(a)
array([[-1073741821, -1073741821,           3],    # uninitialized
       [          0,           0, -1073741821]])
>>> a = np.array([[1., 2., 3.],[4.,5.,6.]])
>>> np.empty_like(a)
array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized
       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])
*)

val equal : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return (x1 == x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
not_equal, greater_equal, less_equal, greater, less

Examples
--------
>>> np.equal([0, 1, 3], np.arange(3))
array([ True,  True, False])

What is compared are values, not types. So an int (1) and an array of
length one can evaluate as True:

>>> np.equal(1, np.ones(1))
array([ True])
*)

val exp : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Calculate the exponential of all elements in the input array.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise exponential of `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
expm1 : Calculate ``exp(x) - 1`` for all elements in the array.
exp2  : Calculate ``2**x`` for all elements in the array.

Notes
-----
The irrational number ``e`` is also known as Euler's number.  It is
approximately 2.718281, and is the base of the natural logarithm,
``ln`` (this means that, if :math:`x = \ln y = \log_e y`,
then :math:`e^x = y`. For real input, ``exp(x)`` is always positive.

For complex arguments, ``x = a + ib``, we can write
:math:`e^x = e^a e^{ib}`.  The first term, :math:`e^a`, is already
known (it is the real argument, described above).  The second term,
:math:`e^{ib}`, is :math:`\cos b + i \sin b`, a function with
magnitude 1 and a periodic phase.

References
----------
.. [1] Wikipedia, 'Exponential function',
       https://en.wikipedia.org/wiki/Exponential_function
.. [2] M. Abramovitz and I. A. Stegun, 'Handbook of Mathematical Functions
       with Formulas, Graphs, and Mathematical Tables,' Dover, 1964, p. 69,
       http://www.math.sfu.ca/~cbm/aands/page_69.htm

Examples
--------
Plot the magnitude and phase of ``exp(x)`` in the complex plane:

>>> import matplotlib.pyplot as plt

>>> x = np.linspace(-2*np.pi, 2*np.pi, 100)
>>> xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
>>> out = np.exp(xx)

>>> plt.subplot(121)
>>> plt.imshow(np.abs(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')
>>> plt.title('Magnitude of exp(x)')

>>> plt.subplot(122)
>>> plt.imshow(np.angle(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')
>>> plt.title('Phase (angle) of exp(x)')
>>> plt.show()
*)

val expand_dims : axis:int list -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Expand the shape of an array.

Insert a new axis that will appear at the `axis` position in the expanded
array shape.

Parameters
----------
a : array_like
    Input array.
axis : int or tuple of ints
    Position in the expanded axes where the new axis (or axes) is placed.

    .. deprecated:: 1.13.0
        Passing an axis where ``axis > a.ndim`` will be treated as
        ``axis == a.ndim``, and passing ``axis < -a.ndim - 1`` will
        be treated as ``axis == 0``. This behavior is deprecated.

    .. versionchanged:: 1.18.0
        A tuple of axes is now supported.  Out of range axes as
        described above are now forbidden and raise an `AxisError`.

Returns
-------
result : ndarray
    View of `a` with the number of dimensions increased.

See Also
--------
squeeze : The inverse operation, removing singleton dimensions
reshape : Insert, remove, and combine dimensions, and resize existing ones
doc.indexing, atleast_1d, atleast_2d, atleast_3d

Examples
--------
>>> x = np.array([1, 2])
>>> x.shape
(2,)

The following is equivalent to ``x[np.newaxis, :]`` or ``x[np.newaxis]``:

>>> y = np.expand_dims(x, axis=0)
>>> y
array([[1, 2]])
>>> y.shape
(1, 2)

The following is equivalent to ``x[:, np.newaxis]``:

>>> y = np.expand_dims(x, axis=1)
>>> y
array([[1],
       [2]])
>>> y.shape
(2, 1)

``axis`` may also be a tuple:

>>> y = np.expand_dims(x, axis=(0, 1))
>>> y
array([[[1, 2]]])

>>> y = np.expand_dims(x, axis=(2, 0))
>>> y
array([[[1],
        [2]]])

Note that some examples may use ``None`` instead of ``np.newaxis``.  These
are the same objects:

>>> np.newaxis is None
True
*)

val fabs : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the absolute values element-wise.

This function returns the absolute values (positive magnitude) of the
data in `x`. Complex values are not handled, use `absolute` to find the
absolute values of complex data.

Parameters
----------
x : array_like
    The array of numbers for which the absolute values are required. If
    `x` is a scalar, the result `y` will also be a scalar.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The absolute values of `x`, the returned values are always floats.
    This is a scalar if `x` is a scalar.

See Also
--------
absolute : Absolute values including `complex` types.

Examples
--------
>>> np.fabs(-1)
1.0
>>> np.fabs([-1.2, 1.2])
array([ 1.2,  1.2])
*)

val filled : ?fill_value:[>`Ndarray] Obj.t -> [`MaskedArray of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return input as an array with masked data replaced by a fill value.

If `a` is not a `MaskedArray`, `a` itself is returned.
If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to
``a.fill_value``.

Parameters
----------
a : MaskedArray or array_like
    An input object.
fill_value : array_like, optional.
    Can be scalar or non-scalar. If non-scalar, the
    resulting filled array should be broadcastable
    over input array. Default is None.

Returns
-------
a : ndarray
    The filled array.

See Also
--------
compressed

Examples
--------
>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
...                                                   [1, 0, 0],
...                                                   [0, 0, 0]])
>>> x.filled()
array([[999999,      1,      2],
       [999999,      4,      5],
       [     6,      7,      8]])
>>> x.filled(fill_value=333)
array([[333,   1,   2],
       [333,   4,   5],
       [  6,   7,   8]])
>>> x.filled(fill_value=np.arange(3))
array([[0, 1, 2],
       [0, 4, 5],
       [6, 7, 8]])
*)

val fix_invalid : ?mask:Py.Object.t -> ?copy:bool -> ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Return input with invalid data masked and replaced by a fill value.

Invalid data means values of `nan`, `inf`, etc.

Parameters
----------
a : array_like
    Input array, a (subclass of) ndarray.
mask : sequence, optional
    Mask. Must be convertible to an array of booleans with the same
    shape as `data`. True indicates a masked (i.e. invalid) data.
copy : bool, optional
    Whether to use a copy of `a` (True) or to fix `a` in place (False).
    Default is True.
fill_value : scalar, optional
    Value used for fixing invalid data. Default is None, in which case
    the ``a.fill_value`` is used.

Returns
-------
b : MaskedArray
    The input array with invalid entries fixed.

Notes
-----
A copy is performed by default.

Examples
--------
>>> x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)
>>> x
masked_array(data=[--, -1.0, nan, inf],
             mask=[ True, False, False, False],
       fill_value=1e+20)
>>> np.ma.fix_invalid(x)
masked_array(data=[--, -1.0, --, --],
             mask=[ True, False,  True,  True],
       fill_value=1e+20)

>>> fixed = np.ma.fix_invalid(x)
>>> fixed.data
array([ 1.e+00, -1.e+00,  1.e+20,  1.e+20])
>>> x.data
array([ 1., -1., nan, inf])
*)

val flatten_mask : [>`Ndarray] Obj.t -> Py.Object.t
(**
Returns a completely flattened version of the mask, where nested fields
are collapsed.

Parameters
----------
mask : array_like
    Input array, which will be interpreted as booleans.

Returns
-------
flattened_mask : ndarray of bools
    The flattened input.

Examples
--------
>>> mask = np.array([0, 0, 1])
>>> np.ma.flatten_mask(mask)
array([False, False,  True])

>>> mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])
>>> np.ma.flatten_mask(mask)
array([False, False, False,  True])

>>> mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]
>>> mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)
>>> np.ma.flatten_mask(mask)
array([False, False, False, False, False,  True])
*)

val flatten_structured_array : Py.Object.t -> Py.Object.t
(**
Flatten a structured array.

The data type of the output is chosen such that it can represent all of the
(nested) fields.

Parameters
----------
a : structured array

Returns
-------
output : masked array or ndarray
    A flattened masked array if the input is a masked array, otherwise a
    standard ndarray.

Examples
--------
>>> ndtype = [('a', int), ('b', float)]
>>> a = np.array([(1, 1), (2, 2)], dtype=ndtype)
>>> np.ma.flatten_structured_array(a)
array([[1., 1.],
       [2., 2.]])
*)

val floor : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the floor of the input, element-wise.

The floor of the scalar `x` is the largest integer `i`, such that
`i <= x`.  It is often denoted as :math:`\lfloor x \rfloor`.

Parameters
----------
x : array_like
    Input data.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The floor of each element in `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
ceil, trunc, rint

Notes
-----
Some spreadsheet programs calculate the 'floor-towards-zero', in other
words ``floor(-2.5) == -2``.  NumPy instead uses the definition of
`floor` where `floor(-2.5) == -3`.

Examples
--------
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.floor(a)
array([-2., -2., -1.,  0.,  1.,  1.,  2.])
*)

val floor_divide : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the largest integer smaller or equal to the division of the inputs.
It is equivalent to the Python ``//`` operator and pairs with the
Python ``%`` (`remainder`), function so that ``a = a % b + b * (a // b)``
up to roundoff.

Parameters
----------
x1 : array_like
    Numerator.
x2 : array_like
    Denominator. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    y = floor(`x1`/`x2`)
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
remainder : Remainder complementary to floor_divide.
divmod : Simultaneous floor division and remainder.
divide : Standard division.
floor : Round a number to the nearest integer toward minus infinity.
ceil : Round a number to the nearest integer toward infinity.

Examples
--------
>>> np.floor_divide(7,3)
2
>>> np.floor_divide([1., 2., 3., 4.], 2.5)
array([ 0.,  0.,  1.,  1.])
*)

val fmod : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the element-wise remainder of division.

This is the NumPy implementation of the C library function fmod, the
remainder has the same sign as the dividend `x1`. It is equivalent to
the Matlab(TM) ``rem`` function and should not be confused with the
Python modulus operator ``x1 % x2``.

Parameters
----------
x1 : array_like
    Dividend.
x2 : array_like
    Divisor. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : array_like
    The remainder of the division of `x1` by `x2`.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
remainder : Equivalent to the Python ``%`` operator.
divide

Notes
-----
The result of the modulo operation for negative dividend and divisors
is bound by conventions. For `fmod`, the sign of result is the sign of
the dividend, while for `remainder` the sign of the result is the sign
of the divisor. The `fmod` function is equivalent to the Matlab(TM)
``rem`` function.

Examples
--------
>>> np.fmod([-3, -2, -1, 1, 2, 3], 2)
array([-1,  0, -1,  1,  0,  1])
>>> np.remainder([-3, -2, -1, 1, 2, 3], 2)
array([1, 0, 1, 1, 0, 1])

>>> np.fmod([5, 3], [2, 2.])
array([ 1.,  1.])
>>> a = np.arange(-3, 3).reshape(3, 2)
>>> a
array([[-3, -2],
       [-1,  0],
       [ 1,  2]])
>>> np.fmod(a, [2,2])
array([[-1,  0],
       [-1,  0],
       [ 1,  0]])
*)

val formatargspec : ?varargs:Py.Object.t -> ?varkw:Py.Object.t -> ?defaults:Py.Object.t -> ?formatarg:Py.Object.t -> ?formatvarargs:Py.Object.t -> ?formatvarkw:Py.Object.t -> ?formatvalue:Py.Object.t -> ?join:Py.Object.t -> args:Py.Object.t -> unit -> Py.Object.t
(**
Format an argument spec from the 4 values returned by getargspec.

The first four arguments are (args, varargs, varkw, defaults).  The
other four arguments are the corresponding optional formatting functions
that are called to turn names and values into strings.  The ninth
argument is an optional function to format the sequence of arguments.
*)

val frombuffer : ?params:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
frombuffer(buffer, dtype=float, count=-1, offset=0)

Interpret a buffer as a 1-dimensional array.

Parameters
----------
buffer : buffer_like
    An object that exposes the buffer interface.
dtype : data-type, optional
    Data-type of the returned array; default: float.
count : int, optional
    Number of items to read. ``-1`` means all data in the buffer.
offset : int, optional
    Start reading the buffer from this offset (in bytes); default: 0.

Notes
-----
If the buffer has data that is not in machine byte-order, this should
be specified as part of the data-type, e.g.::

  >>> dt = np.dtype(int)
  >>> dt = dt.newbyteorder('>')
  >>> np.frombuffer(buf, dtype=dt) # doctest: +SKIP

The data of the resulting array will not be byteswapped, but will be
interpreted correctly.

Examples
--------
>>> s = b'hello world'
>>> np.frombuffer(s, dtype='S1', count=5, offset=6)
array([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')

>>> np.frombuffer(b'\x01\x02', dtype=np.uint8)
array([1, 2], dtype=uint8)
>>> np.frombuffer(b'\x01\x02\x03\x04\x05', dtype=np.uint8, count=3)
array([1, 2, 3], dtype=uint8)
*)

val fromfile : ?dtype:Py.Object.t -> ?count:Py.Object.t -> ?sep:Py.Object.t -> file:Py.Object.t -> unit -> Py.Object.t
(**
None
*)

val fromflex : [>`Ndarray] Obj.t -> Py.Object.t
(**
Build a masked array from a suitable flexible-type array.

The input array has to have a data-type with ``_data`` and ``_mask``
fields. This type of array is output by `MaskedArray.toflex`.

Parameters
----------
fxarray : ndarray
    The structured input array, containing ``_data`` and ``_mask``
    fields. If present, other fields are discarded.

Returns
-------
result : MaskedArray
    The constructed masked array.

See Also
--------
MaskedArray.toflex : Build a flexible-type array from a masked array.

Examples
--------
>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[0] + [1, 0] * 4)
>>> rec = x.toflex()
>>> rec
array([[(0, False), (1,  True), (2, False)],
       [(3,  True), (4, False), (5,  True)],
       [(6, False), (7,  True), (8, False)]],
      dtype=[('_data', '<i8'), ('_mask', '?')])
>>> x2 = np.ma.fromflex(rec)
>>> x2
masked_array(
  data=[[0, --, 2],
        [--, 4, --],
        [6, --, 8]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)

Extra fields can be present in the structured array but are discarded:

>>> dt = [('_data', '<i4'), ('_mask', '|b1'), ('field3', '<f4')]
>>> rec2 = np.zeros((2, 2), dtype=dt)
>>> rec2
array([[(0, False, 0.), (0, False, 0.)],
       [(0, False, 0.), (0, False, 0.)]],
      dtype=[('_data', '<i4'), ('_mask', '?'), ('field3', '<f4')])
>>> y = np.ma.fromflex(rec2)
>>> y
masked_array(
  data=[[0, 0],
        [0, 0]],
  mask=[[False, False],
        [False, False]],
  fill_value=999999,
  dtype=int32)
*)

val fromfunction : ?params:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
fromfunction(function, shape, **kwargs)

Construct an array by executing a function over each coordinate.

The resulting array therefore has a value ``fn(x, y, z)`` at
coordinate ``(x, y, z)``.

Parameters
----------
function : callable
    The function is called with N parameters, where N is the rank of
    `shape`.  Each parameter represents the coordinates of the array
    varying along a specific axis.  For example, if `shape`
    were ``(2, 2)``, then the parameters would be
    ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``
shape : (N,) tuple of ints
    Shape of the output array, which also determines the shape of
    the coordinate arrays passed to `function`.
dtype : data-type, optional
    Data-type of the coordinate arrays passed to `function`.
    By default, `dtype` is float.

Returns
-------
fromfunction : any
    The result of the call to `function` is passed back directly.
    Therefore the shape of `fromfunction` is completely determined by
    `function`.  If `function` returns a scalar value, the shape of
    `fromfunction` would not match the `shape` parameter.

See Also
--------
indices, meshgrid

Notes
-----
Keywords other than `dtype` are passed to `function`.

Examples
--------
>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
array([[ True, False, False],
       [False,  True, False],
       [False, False,  True]])

>>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)
array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])
*)

val get_data : ?subok:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the data of a masked array as an ndarray.

Return the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,
else return `a` as a ndarray or subclass (depending on `subok`) if not.

Parameters
----------
a : array_like
    Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.
subok : bool
    Whether to force the output to be a `pure` ndarray (False) or to
    return a subclass of ndarray if appropriate (True, default).

See Also
--------
getmask : Return the mask of a masked array, or nomask.
getmaskarray : Return the mask of a masked array, or full array of False.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getdata(a)
array([[1, 2],
       [3, 4]])

Equivalently use the ``MaskedArray`` `data` attribute.

>>> a.data
array([[1, 2],
       [3, 4]])
*)

val get_fill_value : Py.Object.t -> Py.Object.t
(**
Return the filling value of a, if any.  Otherwise, returns the
default filling value for that type.
*)

val get_mask : [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the mask of a masked array, or nomask.

Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the
mask is not `nomask`, else return `nomask`. To guarantee a full array
of booleans of the same shape as a, use `getmaskarray`.

Parameters
----------
a : array_like
    Input `MaskedArray` for which the mask is required.

See Also
--------
getdata : Return the data of a masked array as an ndarray.
getmaskarray : Return the mask of a masked array, or full array of False.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getmask(a)
array([[False,  True],
       [False, False]])

Equivalently use the `MaskedArray` `mask` attribute.

>>> a.mask
array([[False,  True],
       [False, False]])

Result when mask == `nomask`

>>> b = ma.masked_array([[1,2],[3,4]])
>>> b
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> ma.nomask
False
>>> ma.getmask(b) == ma.nomask
True
>>> b.mask == ma.nomask
True
*)

val get_masked_subclass : Py.Object.t list -> Py.Object.t
(**
Return the youngest subclass of MaskedArray from a list of (masked) arrays.

In case of siblings, the first listed takes over.
*)

val get_object_signature : Py.Object.t -> Py.Object.t
(**
Get the signature from obj
*)

val getargspec : Py.Object.t -> Py.Object.t
(**
Get the names and default values of a function's arguments.

A tuple of four things is returned: (args, varargs, varkw, defaults).
'args' is a list of the argument names (it may contain nested lists).
'varargs' and 'varkw' are the names of the * and ** arguments or None.
'defaults' is an n-tuple of the default values of the last n arguments.
*)

val getdata : ?subok:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the data of a masked array as an ndarray.

Return the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,
else return `a` as a ndarray or subclass (depending on `subok`) if not.

Parameters
----------
a : array_like
    Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.
subok : bool
    Whether to force the output to be a `pure` ndarray (False) or to
    return a subclass of ndarray if appropriate (True, default).

See Also
--------
getmask : Return the mask of a masked array, or nomask.
getmaskarray : Return the mask of a masked array, or full array of False.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getdata(a)
array([[1, 2],
       [3, 4]])

Equivalently use the ``MaskedArray`` `data` attribute.

>>> a.data
array([[1, 2],
       [3, 4]])
*)

val getmask : [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the mask of a masked array, or nomask.

Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the
mask is not `nomask`, else return `nomask`. To guarantee a full array
of booleans of the same shape as a, use `getmaskarray`.

Parameters
----------
a : array_like
    Input `MaskedArray` for which the mask is required.

See Also
--------
getdata : Return the data of a masked array as an ndarray.
getmaskarray : Return the mask of a masked array, or full array of False.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getmask(a)
array([[False,  True],
       [False, False]])

Equivalently use the `MaskedArray` `mask` attribute.

>>> a.mask
array([[False,  True],
       [False, False]])

Result when mask == `nomask`

>>> b = ma.masked_array([[1,2],[3,4]])
>>> b
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> ma.nomask
False
>>> ma.getmask(b) == ma.nomask
True
>>> b.mask == ma.nomask
True
*)

val getmaskarray : [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the mask of a masked array, or full boolean array of False.

Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and
the mask is not `nomask`, else return a full boolean array of False of
the same shape as `arr`.

Parameters
----------
arr : array_like
    Input `MaskedArray` for which the mask is required.

See Also
--------
getmask : Return the mask of a masked array, or nomask.
getdata : Return the data of a masked array as an ndarray.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getmaskarray(a)
array([[False,  True],
       [False, False]])

Result when mask == ``nomask``

>>> b = ma.masked_array([[1,2],[3,4]])
>>> b
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> ma.getmaskarray(b)
array([[False, False],
       [False, False]])
*)

val greater : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the truth value of (x1 > x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.


See Also
--------
greater_equal, less, less_equal, equal, not_equal

Examples
--------
>>> np.greater([4,2],[2,2])
array([ True, False])

If the inputs are ndarrays, then np.greater is equivalent to '>'.

>>> a = np.array([4,2])
>>> b = np.array([2,2])
>>> a > b
array([ True, False])
*)

val greater_equal : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the truth value of (x1 >= x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : bool or ndarray of bool
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
greater, less, less_equal, equal, not_equal

Examples
--------
>>> np.greater_equal([4, 2, 1], [2, 2, 2])
array([ True, True, False])
*)

val harden_mask : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
harden_mask(self)

Force the mask to hard.

Whether the mask of a masked array is hard or soft is determined by
its `hardmask` property. `harden_mask` sets `hardmask` to True.

See Also
--------
hardmask
*)

val hypot : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Given the 'legs' of a right triangle, return its hypotenuse.

Equivalent to ``sqrt(x1**2 + x2**2)``, element-wise.  If `x1` or
`x2` is scalar_like (i.e., unambiguously cast-able to a scalar type),
it is broadcast for use with each element of the other argument.
(See Examples)

Parameters
----------
x1, x2 : array_like
    Leg of the triangle(s). If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
z : ndarray
    The hypotenuse of the triangle(s).
    This is a scalar if both `x1` and `x2` are scalars.

Examples
--------
>>> np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])

Example showing broadcast of scalar_like argument:

>>> np.hypot(3*np.ones((3, 3)), [4])
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])
*)

val identity : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
identity(n, dtype=None)

Return the identity array.

The identity array is a square array with ones on
the main diagonal.

Parameters
----------
n : int
    Number of rows (and columns) in `n` x `n` output.
dtype : data-type, optional
    Data-type of the output.  Defaults to ``float``.

Returns
-------
out : ndarray
    `n` x `n` array with its main diagonal set to one,
    and all other elements 0.

Examples
--------
>>> np.identity(3)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
*)

val ids : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
ids(self)

Return the addresses of the data and mask areas.

Parameters
----------
None

Examples
--------
>>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])
>>> x.ids()
(166670640, 166659832) # may vary

If the array has no mask, the address of `nomask` is returned. This address
is typically not close to the data in memory:

>>> x = np.ma.array([1, 2, 3])
>>> x.ids()
(166691080, 3083169284L) # may vary
*)

val indices : ?dtype:Dtype.t -> ?sparse:bool -> dimensions:int list -> unit -> Py.Object.t
(**
Return an array representing the indices of a grid.

Compute an array where the subarrays contain index values 0, 1, ...
varying only along the corresponding axis.

Parameters
----------
dimensions : sequence of ints
    The shape of the grid.
dtype : dtype, optional
    Data type of the result.
sparse : boolean, optional
    Return a sparse representation of the grid instead of a dense
    representation. Default is False.

    .. versionadded:: 1.17

Returns
-------
grid : one ndarray or tuple of ndarrays
    If sparse is False:
        Returns one array of grid indices,
        ``grid.shape = (len(dimensions),) + tuple(dimensions)``.
    If sparse is True:
        Returns a tuple of arrays, with
        ``grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)`` with
        dimensions[i] in the ith place

See Also
--------
mgrid, ogrid, meshgrid

Notes
-----
The output shape in the dense case is obtained by prepending the number
of dimensions in front of the tuple of dimensions, i.e. if `dimensions`
is a tuple ``(r0, ..., rN-1)`` of length ``N``, the output shape is
``(N, r0, ..., rN-1)``.

The subarrays ``grid[k]`` contains the N-D array of indices along the
``k-th`` axis. Explicitly::

    grid[k, i0, i1, ..., iN-1] = ik

Examples
--------
>>> grid = np.indices((2, 3))
>>> grid.shape
(2, 2, 3)
>>> grid[0]        # row indices
array([[0, 0, 0],
       [1, 1, 1]])
>>> grid[1]        # column indices
array([[0, 1, 2],
       [0, 1, 2]])

The indices can be used as an index into an array.

>>> x = np.arange(20).reshape(5, 4)
>>> row, col = np.indices((2, 3))
>>> x[row, col]
array([[0, 1, 2],
       [4, 5, 6]])

Note that it would be more straightforward in the above example to
extract the required elements directly with ``x[:2, :3]``.

If sparse is set to true, the grid will be returned in a sparse
representation.

>>> i, j = np.indices((2, 3), sparse=True)
>>> i.shape
(2, 1)
>>> j.shape
(1, 3)
>>> i        # row indices
array([[0],
       [1]])
>>> j        # column indices
array([[0, 1, 2]])
*)

val inner : b:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
inner(a, b)

Inner product of two arrays.

Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.

Parameters
----------
a, b : array_like
    If `a` and `b` are nonscalar, their last dimensions must match.

Returns
-------
out : ndarray
    `out.shape = a.shape[:-1] + b.shape[:-1]`

Raises
------
ValueError
    If the last dimension of `a` and `b` has different size.

See Also
--------
tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of `b`.
einsum : Einstein summation convention.

Notes
-----
Masked values are replaced by 0.

For vectors (1-D arrays) it computes the ordinary inner-product::

    np.inner(a, b) = sum(a[:]*b[:])

More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::

    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))

or explicitly::

    np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
         = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])

In addition `a` or `b` may be scalars, in which case::

   np.inner(a,b) = a*b

Examples
--------
Ordinary inner product for vectors:

>>> a = np.array([1,2,3])
>>> b = np.array([0,1,0])
>>> np.inner(a, b)
2

A multidimensional example:

>>> a = np.arange(24).reshape((2,3,4))
>>> b = np.arange(4)
>>> np.inner(a, b)
array([[ 14,  38,  62],
       [ 86, 110, 134]])

An example where `b` is a scalar:

>>> np.inner(np.eye(2), 7)
array([[7., 0.],
       [0., 7.]])
*)

val innerproduct : b:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
inner(a, b)

Inner product of two arrays.

Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.

Parameters
----------
a, b : array_like
    If `a` and `b` are nonscalar, their last dimensions must match.

Returns
-------
out : ndarray
    `out.shape = a.shape[:-1] + b.shape[:-1]`

Raises
------
ValueError
    If the last dimension of `a` and `b` has different size.

See Also
--------
tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of `b`.
einsum : Einstein summation convention.

Notes
-----
Masked values are replaced by 0.

For vectors (1-D arrays) it computes the ordinary inner-product::

    np.inner(a, b) = sum(a[:]*b[:])

More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::

    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))

or explicitly::

    np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
         = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])

In addition `a` or `b` may be scalars, in which case::

   np.inner(a,b) = a*b

Examples
--------
Ordinary inner product for vectors:

>>> a = np.array([1,2,3])
>>> b = np.array([0,1,0])
>>> np.inner(a, b)
2

A multidimensional example:

>>> a = np.arange(24).reshape((2,3,4))
>>> b = np.arange(4)
>>> np.inner(a, b)
array([[ 14,  38,  62],
       [ 86, 110, 134]])

An example where `b` is a scalar:

>>> np.inner(np.eye(2), 7)
array([[7., 0.],
       [0., 7.]])
*)

val isMA : Py.Object.t -> bool
(**
Test whether input is an instance of MaskedArray.

This function returns True if `x` is an instance of MaskedArray
and returns False otherwise.  Any object is accepted as input.

Parameters
----------
x : object
    Object to test.

Returns
-------
result : bool
    True if `x` is a MaskedArray.

See Also
--------
isMA : Alias to isMaskedArray.
isarray : Alias to isMaskedArray.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.eye(3, 3)
>>> a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
>>> m = ma.masked_values(a, 0)
>>> m
masked_array(
  data=[[1.0, --, --],
        [--, 1.0, --],
        [--, --, 1.0]],
  mask=[[False,  True,  True],
        [ True, False,  True],
        [ True,  True, False]],
  fill_value=0.0)
>>> ma.isMaskedArray(a)
False
>>> ma.isMaskedArray(m)
True
>>> ma.isMaskedArray([0, 1, 2])
False
*)

val isMaskedArray : Py.Object.t -> bool
(**
Test whether input is an instance of MaskedArray.

This function returns True if `x` is an instance of MaskedArray
and returns False otherwise.  Any object is accepted as input.

Parameters
----------
x : object
    Object to test.

Returns
-------
result : bool
    True if `x` is a MaskedArray.

See Also
--------
isMA : Alias to isMaskedArray.
isarray : Alias to isMaskedArray.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.eye(3, 3)
>>> a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
>>> m = ma.masked_values(a, 0)
>>> m
masked_array(
  data=[[1.0, --, --],
        [--, 1.0, --],
        [--, --, 1.0]],
  mask=[[False,  True,  True],
        [ True, False,  True],
        [ True,  True, False]],
  fill_value=0.0)
>>> ma.isMaskedArray(a)
False
>>> ma.isMaskedArray(m)
True
>>> ma.isMaskedArray([0, 1, 2])
False
*)

val is_mask : [>`Ndarray] Obj.t -> bool
(**
Return True if m is a valid, standard mask.

This function does not check the contents of the input, only that the
type is MaskType. In particular, this function returns False if the
mask has a flexible dtype.

Parameters
----------
m : array_like
    Array to test.

Returns
-------
result : bool
    True if `m.dtype.type` is MaskType, False otherwise.

See Also
--------
isMaskedArray : Test whether input is an instance of MaskedArray.

Examples
--------
>>> import numpy.ma as ma
>>> m = ma.masked_equal([0, 1, 0, 2, 3], 0)
>>> m
masked_array(data=[--, 1, --, 2, 3],
             mask=[ True, False,  True, False, False],
       fill_value=0)
>>> ma.is_mask(m)
False
>>> ma.is_mask(m.mask)
True

Input must be an ndarray (or have similar attributes)
for it to be considered a valid mask.

>>> m = [False, True, False]
>>> ma.is_mask(m)
False
>>> m = np.array([False, True, False])
>>> m
array([False,  True, False])
>>> ma.is_mask(m)
True

Arrays with complex dtypes don't return True.

>>> dtype = np.dtype({'names':['monty', 'pithon'],
...                   'formats':[bool, bool]})
>>> dtype
dtype([('monty', '|b1'), ('pithon', '|b1')])
>>> m = np.array([(True, False), (False, True), (True, False)],
...              dtype=dtype)
>>> m
array([( True, False), (False,  True), ( True, False)],
      dtype=[('monty', '?'), ('pithon', '?')])
>>> ma.is_mask(m)
False
*)

val is_masked : [>`Ndarray] Obj.t -> bool
(**
Determine whether input has masked values.

Accepts any object as input, but always returns False unless the
input is a MaskedArray containing masked values.

Parameters
----------
x : array_like
    Array to check for masked values.

Returns
-------
result : bool
    True if `x` is a MaskedArray with masked values, False otherwise.

Examples
--------
>>> import numpy.ma as ma
>>> x = ma.masked_equal([0, 1, 0, 2, 3], 0)
>>> x
masked_array(data=[--, 1, --, 2, 3],
             mask=[ True, False,  True, False, False],
       fill_value=0)
>>> ma.is_masked(x)
True
>>> x = ma.masked_equal([0, 1, 0, 2, 3], 42)
>>> x
masked_array(data=[0, 1, 0, 2, 3],
             mask=False,
       fill_value=42)
>>> ma.is_masked(x)
False

Always returns False if `x` isn't a MaskedArray.

>>> x = [False, True, False]
>>> ma.is_masked(x)
False
>>> x = 'a string'
>>> ma.is_masked(x)
False
*)

val is_string_or_list_of_strings : Py.Object.t -> Py.Object.t
(**
None
*)

val isarray : Py.Object.t -> bool
(**
Test whether input is an instance of MaskedArray.

This function returns True if `x` is an instance of MaskedArray
and returns False otherwise.  Any object is accepted as input.

Parameters
----------
x : object
    Object to test.

Returns
-------
result : bool
    True if `x` is a MaskedArray.

See Also
--------
isMA : Alias to isMaskedArray.
isarray : Alias to isMaskedArray.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.eye(3, 3)
>>> a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
>>> m = ma.masked_values(a, 0)
>>> m
masked_array(
  data=[[1.0, --, --],
        [--, 1.0, --],
        [--, --, 1.0]],
  mask=[[False,  True,  True],
        [ True, False,  True],
        [ True,  True, False]],
  fill_value=0.0)
>>> ma.isMaskedArray(a)
False
>>> ma.isMaskedArray(m)
True
>>> ma.isMaskedArray([0, 1, 2])
False
*)

val iscomplexobj : Py.Object.t -> bool
(**
Check for a complex type or an array of complex numbers.

The type of the input is checked, not the value. Even if the input
has an imaginary part equal to zero, `iscomplexobj` evaluates to True.

Parameters
----------
x : any
    The input can be of any type and shape.

Returns
-------
iscomplexobj : bool
    The return value, True if `x` is of a complex type or has at least
    one complex element.

See Also
--------
isrealobj, iscomplex

Examples
--------
>>> np.iscomplexobj(1)
False
>>> np.iscomplexobj(1+0j)
True
>>> np.iscomplexobj([3, 1+0j, True])
True
*)

val left_shift : n:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Shift the bits of an integer to the left.

This is the masked array version of `numpy.left_shift`, for details
see that function.

See Also
--------
numpy.left_shift
*)

val less : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the truth value of (x1 < x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
greater, less_equal, greater_equal, equal, not_equal

Examples
--------
>>> np.less([1, 2], [2, 2])
array([ True, False])
*)

val less_equal : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the truth value of (x1 =< x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
greater, less, greater_equal, equal, not_equal

Examples
--------
>>> np.less_equal([4, 2, 1], [2, 2, 2])
array([False,  True,  True])
*)

val log : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Natural logarithm, element-wise.

The natural logarithm `log` is the inverse of the exponential function,
so that `log(exp(x)) = x`. The natural logarithm is logarithm in base
`e`.

Parameters
----------
x : array_like
    Input value.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The natural logarithm of `x`, element-wise.
    This is a scalar if `x` is a scalar.

See Also
--------
log10, log2, log1p, emath.log

Notes
-----
Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `exp(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log` always returns real output. For
each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it. `log`
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Logarithm'. https://en.wikipedia.org/wiki/Logarithm

Examples
--------
>>> np.log([1, np.e, np.e**2, 0])
array([  0.,   1.,   2., -Inf])
*)

val log10 : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the base 10 logarithm of the input array, element-wise.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The logarithm to the base 10 of `x`, element-wise. NaNs are
    returned where x is negative.
    This is a scalar if `x` is a scalar.

See Also
--------
emath.log10

Notes
-----
Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `10**z = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log10` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log10` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it.
`log10` handles the floating-point negative zero as an infinitesimal
negative number, conforming to the C99 standard.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Logarithm'. https://en.wikipedia.org/wiki/Logarithm

Examples
--------
>>> np.log10([1e-15, -3.])
array([-15.,  nan])
*)

val log2 : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Base-2 logarithm of `x`.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    Base-2 logarithm of `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
log, log10, log1p, emath.log2

Notes
-----
.. versionadded:: 1.3.0

Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `2**z = x`. The convention is to return the `z`
whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log2` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log2` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it. `log2`
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.

Examples
--------
>>> x = np.array([0, 1, 2, 2**4])
>>> np.log2(x)
array([-Inf,   0.,   1.,   4.])

>>> xi = np.array([0+1.j, 1, 2+0.j, 4.j])
>>> np.log2(xi)
array([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])
*)

val logical_and : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the truth value of x1 AND x2 element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or bool
    Boolean result of the logical AND operation applied to the elements
    of `x1` and `x2`; the shape is determined by broadcasting.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_or, logical_not, logical_xor
bitwise_and

Examples
--------
>>> np.logical_and(True, False)
False
>>> np.logical_and([True, False], [False, False])
array([False, False])

>>> x = np.arange(5)
>>> np.logical_and(x>1, x<4)
array([False, False,  True,  True, False])
*)

val logical_not : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the truth value of NOT x element-wise.

Parameters
----------
x : array_like
    Logical NOT is applied to the elements of `x`.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : bool or ndarray of bool
    Boolean result with the same shape as `x` of the NOT operation
    on elements of `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
logical_and, logical_or, logical_xor

Examples
--------
>>> np.logical_not(3)
False
>>> np.logical_not([True, False, 0, 1])
array([False,  True,  True, False])

>>> x = np.arange(5)
>>> np.logical_not(x<3)
array([False, False, False,  True,  True])
*)

val logical_or : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the truth value of x1 OR x2 element-wise.

Parameters
----------
x1, x2 : array_like
    Logical OR is applied to the elements of `x1` and `x2`.
    If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or bool
    Boolean result of the logical OR operation applied to the elements
    of `x1` and `x2`; the shape is determined by broadcasting.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_and, logical_not, logical_xor
bitwise_or

Examples
--------
>>> np.logical_or(True, False)
True
>>> np.logical_or([True, False], [False, False])
array([ True, False])

>>> x = np.arange(5)
>>> np.logical_or(x < 1, x > 3)
array([ True, False, False, False,  True])
*)

val logical_xor : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the truth value of x1 XOR x2, element-wise.

Parameters
----------
x1, x2 : array_like
    Logical XOR is applied to the elements of `x1` and `x2`. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : bool or ndarray of bool
    Boolean result of the logical XOR operation applied to the elements
    of `x1` and `x2`; the shape is determined by broadcasting.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_and, logical_or, logical_not, bitwise_xor

Examples
--------
>>> np.logical_xor(True, False)
True
>>> np.logical_xor([True, True, False, False], [True, False, True, False])
array([False,  True,  True, False])

>>> x = np.arange(5)
>>> np.logical_xor(x < 1, x > 3)
array([ True, False, False, False,  True])

Simple example showing support of broadcasting

>>> np.logical_xor(0, np.eye(2))
array([[ True, False],
       [False,  True]])
*)

val make_mask : ?copy:bool -> ?shrink:bool -> ?dtype:Dtype.t -> m:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Create a boolean mask from an array.

Return `m` as a boolean mask, creating a copy if necessary or requested.
The function can accept any sequence that is convertible to integers,
or ``nomask``.  Does not require that contents must be 0s and 1s, values
of 0 are interpreted as False, everything else as True.

Parameters
----------
m : array_like
    Potential mask.
copy : bool, optional
    Whether to return a copy of `m` (True) or `m` itself (False).
shrink : bool, optional
    Whether to shrink `m` to ``nomask`` if all its values are False.
dtype : dtype, optional
    Data-type of the output mask. By default, the output mask has a
    dtype of MaskType (bool). If the dtype is flexible, each field has
    a boolean dtype. This is ignored when `m` is ``nomask``, in which
    case ``nomask`` is always returned.

Returns
-------
result : ndarray
    A boolean mask derived from `m`.

Examples
--------
>>> import numpy.ma as ma
>>> m = [True, False, True, True]
>>> ma.make_mask(m)
array([ True, False,  True,  True])
>>> m = [1, 0, 1, 1]
>>> ma.make_mask(m)
array([ True, False,  True,  True])
>>> m = [1, 0, 2, -3]
>>> ma.make_mask(m)
array([ True, False,  True,  True])

Effect of the `shrink` parameter.

>>> m = np.zeros(4)
>>> m
array([0., 0., 0., 0.])
>>> ma.make_mask(m)
False
>>> ma.make_mask(m, shrink=False)
array([False, False, False, False])

Using a flexible `dtype`.

>>> m = [1, 0, 1, 1]
>>> n = [0, 1, 0, 0]
>>> arr = []
>>> for man, mouse in zip(m, n):
...     arr.append((man, mouse))
>>> arr
[(1, 0), (0, 1), (1, 0), (1, 0)]
>>> dtype = np.dtype({'names':['man', 'mouse'],
...                   'formats':[np.int64, np.int64]})
>>> arr = np.array(arr, dtype=dtype)
>>> arr
array([(1, 0), (0, 1), (1, 0), (1, 0)],
      dtype=[('man', '<i8'), ('mouse', '<i8')])
>>> ma.make_mask(arr, dtype=dtype)
array([(True, False), (False, True), (True, False), (True, False)],
      dtype=[('man', '|b1'), ('mouse', '|b1')])
*)

val make_mask_descr : Dtype.t -> Dtype.t
(**
Construct a dtype description list from a given dtype.

Returns a new dtype object, with the type of all fields in `ndtype` to a
boolean type. Field names are not altered.

Parameters
----------
ndtype : dtype
    The dtype to convert.

Returns
-------
result : dtype
    A dtype that looks like `ndtype`, the type of all fields is boolean.

Examples
--------
>>> import numpy.ma as ma
>>> dtype = np.dtype({'names':['foo', 'bar'],
...                   'formats':[np.float32, np.int64]})
>>> dtype
dtype([('foo', '<f4'), ('bar', '<i8')])
>>> ma.make_mask_descr(dtype)
dtype([('foo', '|b1'), ('bar', '|b1')])
>>> ma.make_mask_descr(np.float32)
dtype('bool')
*)

val make_mask_none : ?dtype:Dtype.t -> newshape:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a boolean mask of the given shape, filled with False.

This function returns a boolean ndarray with all entries False, that can
be used in common mask manipulations. If a complex dtype is specified, the
type of each field is converted to a boolean type.

Parameters
----------
newshape : tuple
    A tuple indicating the shape of the mask.
dtype : {None, dtype}, optional
    If None, use a MaskType instance. Otherwise, use a new datatype with
    the same fields as `dtype`, converted to boolean types.

Returns
-------
result : ndarray
    An ndarray of appropriate shape and dtype, filled with False.

See Also
--------
make_mask : Create a boolean mask from an array.
make_mask_descr : Construct a dtype description list from a given dtype.

Examples
--------
>>> import numpy.ma as ma
>>> ma.make_mask_none((3,))
array([False, False, False])

Defining a more complex dtype.

>>> dtype = np.dtype({'names':['foo', 'bar'],
...                   'formats':[np.float32, np.int64]})
>>> dtype
dtype([('foo', '<f4'), ('bar', '<i8')])
>>> ma.make_mask_none((3,), dtype=dtype)
array([(False, False), (False, False), (False, False)],
      dtype=[('foo', '|b1'), ('bar', '|b1')])
*)

val mask_or : ?copy:bool -> ?shrink:bool -> m1:Py.Object.t -> m2:Py.Object.t -> unit -> Py.Object.t
(**
Combine two masks with the ``logical_or`` operator.

The result may be a view on `m1` or `m2` if the other is `nomask`
(i.e. False).

Parameters
----------
m1, m2 : array_like
    Input masks.
copy : bool, optional
    If copy is False and one of the inputs is `nomask`, return a view
    of the other input mask. Defaults to False.
shrink : bool, optional
    Whether to shrink the output to `nomask` if all its values are
    False. Defaults to True.

Returns
-------
mask : output mask
    The result masks values that are masked in either `m1` or `m2`.

Raises
------
ValueError
    If `m1` and `m2` have different flexible dtypes.

Examples
--------
>>> m1 = np.ma.make_mask([0, 1, 1, 0])
>>> m2 = np.ma.make_mask([1, 0, 0, 0])
>>> np.ma.mask_or(m1, m2)
array([ True,  True,  True, False])
*)

val mask_rowcols : ?axis:int -> [`MaskedArray of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
Mask rows and/or columns of a 2D array that contain masked values.

Mask whole rows and/or columns of a 2D array that contain
masked values.  The masking behavior is selected using the
`axis` parameter.

  - If `axis` is None, rows *and* columns are masked.
  - If `axis` is 0, only rows are masked.
  - If `axis` is 1 or -1, only columns are masked.

Parameters
----------
a : array_like, MaskedArray
    The array to mask.  If not a MaskedArray instance (or if no array
    elements are masked).  The result is a MaskedArray with `mask` set
    to `nomask` (False). Must be a 2D array.
axis : int, optional
    Axis along which to perform the operation. If None, applies to a
    flattened version of the array.

Returns
-------
a : MaskedArray
    A modified version of the input array, masked depending on the value
    of the `axis` parameter.

Raises
------
NotImplementedError
    If input array `a` is not 2D.

See Also
--------
mask_rows : Mask rows of a 2D array that contain masked values.
mask_cols : Mask cols of a 2D array that contain masked values.
masked_where : Mask where a condition is met.

Notes
-----
The input array's mask is modified by this function.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.zeros((3, 3), dtype=int)
>>> a[1, 1] = 1
>>> a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
>>> a = ma.masked_equal(a, 1)
>>> a
masked_array(
  data=[[0, 0, 0],
        [0, --, 0],
        [0, 0, 0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1)
>>> ma.mask_rowcols(a)
masked_array(
  data=[[0, --, 0],
        [--, --, --],
        [0, --, 0]],
  mask=[[False,  True, False],
        [ True,  True,  True],
        [False,  True, False]],
  fill_value=1)
*)

val masked_equal : ?copy:Py.Object.t -> value:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x == value).  For floating point arrays,
consider using ``masked_values(x, value)``.

See Also
--------
masked_where : Mask where a condition is met.
masked_values : Mask using floating point equality.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_equal(a, 2)
masked_array(data=[0, 1, --, 3],
             mask=[False, False,  True, False],
       fill_value=2)
*)

val masked_greater : ?copy:Py.Object.t -> value:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where greater than a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x > value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_greater(a, 2)
masked_array(data=[0, 1, 2, --],
             mask=[False, False, False,  True],
       fill_value=999999)
*)

val masked_greater_equal : ?copy:Py.Object.t -> value:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where greater than or equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x >= value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_greater_equal(a, 2)
masked_array(data=[0, 1, --, --],
             mask=[False, False,  True,  True],
       fill_value=999999)
*)

val masked_inside : ?copy:Py.Object.t -> v1:Py.Object.t -> v2:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array inside a given interval.

Shortcut to ``masked_where``, where `condition` is True for `x` inside
the interval [v1,v2] (v1 <= x <= v2).  The boundaries `v1` and `v2`
can be given in either order.

See Also
--------
masked_where : Mask where a condition is met.

Notes
-----
The array `x` is prefilled with its filling value.

Examples
--------
>>> import numpy.ma as ma
>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
>>> ma.masked_inside(x, -0.3, 0.3)
masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],
             mask=[False, False,  True,  True, False, False],
       fill_value=1e+20)

The order of `v1` and `v2` doesn't matter.

>>> ma.masked_inside(x, 0.3, -0.3)
masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],
             mask=[False, False,  True,  True, False, False],
       fill_value=1e+20)
*)

val masked_invalid : ?copy:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where invalid values occur (NaNs or infs).

This function is a shortcut to ``masked_where``, with
`condition` = ~(np.isfinite(a)). Any pre-existing mask is conserved.
Only applies to arrays with a dtype where NaNs or infs make sense
(i.e. floating point types), but accepts any array_like object.

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(5, dtype=float)
>>> a[2] = np.NaN
>>> a[3] = np.PINF
>>> a
array([ 0.,  1., nan, inf,  4.])
>>> ma.masked_invalid(a)
masked_array(data=[0.0, 1.0, --, --, 4.0],
             mask=[False, False,  True,  True, False],
       fill_value=1e+20)
*)

val masked_less : ?copy:Py.Object.t -> value:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where less than a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x < value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_less(a, 2)
masked_array(data=[--, --, 2, 3],
             mask=[ True,  True, False, False],
       fill_value=999999)
*)

val masked_less_equal : ?copy:Py.Object.t -> value:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where less than or equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x <= value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_less_equal(a, 2)
masked_array(data=[--, --, --, 3],
             mask=[ True,  True,  True, False],
       fill_value=999999)
*)

val masked_not_equal : ?copy:Py.Object.t -> value:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where `not` equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x != value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_not_equal(a, 2)
masked_array(data=[--, --, 2, --],
             mask=[ True,  True, False,  True],
       fill_value=999999)
*)

val masked_object : ?copy:bool -> ?shrink:bool -> value:Py.Object.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Mask the array `x` where the data are exactly equal to value.

This function is similar to `masked_values`, but only suitable
for object arrays: for floating point, use `masked_values` instead.

Parameters
----------
x : array_like
    Array to mask
value : object
    Comparison value
copy : {True, False}, optional
    Whether to return a copy of `x`.
shrink : {True, False}, optional
    Whether to collapse a mask full of False to nomask

Returns
-------
result : MaskedArray
    The result of masking `x` where equal to `value`.

See Also
--------
masked_where : Mask where a condition is met.
masked_equal : Mask where equal to a given value (integers).
masked_values : Mask using floating point equality.

Examples
--------
>>> import numpy.ma as ma
>>> food = np.array(['green_eggs', 'ham'], dtype=object)
>>> # don't eat spoiled food
>>> eat = ma.masked_object(food, 'green_eggs')
>>> eat
masked_array(data=[--, 'ham'],
             mask=[ True, False],
       fill_value='green_eggs',
            dtype=object)
>>> # plain ol` ham is boring
>>> fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)
>>> eat = ma.masked_object(fresh_food, 'green_eggs')
>>> eat
masked_array(data=['cheese', 'ham', 'pineapple'],
             mask=False,
       fill_value='green_eggs',
            dtype=object)

Note that `mask` is set to ``nomask`` if possible.

>>> eat
masked_array(data=['cheese', 'ham', 'pineapple'],
             mask=False,
       fill_value='green_eggs',
            dtype=object)
*)

val masked_outside : ?copy:Py.Object.t -> v1:Py.Object.t -> v2:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array outside a given interval.

Shortcut to ``masked_where``, where `condition` is True for `x` outside
the interval [v1,v2] (x < v1)|(x > v2).
The boundaries `v1` and `v2` can be given in either order.

See Also
--------
masked_where : Mask where a condition is met.

Notes
-----
The array `x` is prefilled with its filling value.

Examples
--------
>>> import numpy.ma as ma
>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
>>> ma.masked_outside(x, -0.3, 0.3)
masked_array(data=[--, --, 0.01, 0.2, --, --],
             mask=[ True,  True, False, False,  True,  True],
       fill_value=1e+20)

The order of `v1` and `v2` doesn't matter.

>>> ma.masked_outside(x, 0.3, -0.3)
masked_array(data=[--, --, 0.01, 0.2, --, --],
             mask=[ True,  True, False, False,  True,  True],
       fill_value=1e+20)
*)

val masked_values : ?rtol:Py.Object.t -> ?atol:Py.Object.t -> ?copy:bool -> ?shrink:bool -> value:float -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Mask using floating point equality.

Return a MaskedArray, masked where the data in array `x` are approximately
equal to `value`, determined using `isclose`. The default tolerances for
`masked_values` are the same as those for `isclose`.

For integer types, exact equality is used, in the same way as
`masked_equal`.

The fill_value is set to `value` and the mask is set to ``nomask`` if
possible.

Parameters
----------
x : array_like
    Array to mask.
value : float
    Masking value.
rtol, atol : float, optional
    Tolerance parameters passed on to `isclose`
copy : bool, optional
    Whether to return a copy of `x`.
shrink : bool, optional
    Whether to collapse a mask full of False to ``nomask``.

Returns
-------
result : MaskedArray
    The result of masking `x` where approximately equal to `value`.

See Also
--------
masked_where : Mask where a condition is met.
masked_equal : Mask where equal to a given value (integers).

Examples
--------
>>> import numpy.ma as ma
>>> x = np.array([1, 1.1, 2, 1.1, 3])
>>> ma.masked_values(x, 1.1)
masked_array(data=[1.0, --, 2.0, --, 3.0],
             mask=[False,  True, False,  True, False],
       fill_value=1.1)

Note that `mask` is set to ``nomask`` if possible.

>>> ma.masked_values(x, 1.5)
masked_array(data=[1. , 1.1, 2. , 1.1, 3. ],
             mask=False,
       fill_value=1.5)

For integers, the fill value will be different in general to the
result of ``masked_equal``.

>>> x = np.arange(5)
>>> x
array([0, 1, 2, 3, 4])
>>> ma.masked_values(x, 2)
masked_array(data=[0, 1, --, 3, 4],
             mask=[False, False,  True, False, False],
       fill_value=2)
>>> ma.masked_equal(x, 2)
masked_array(data=[0, 1, --, 3, 4],
             mask=[False, False,  True, False, False],
       fill_value=2)
*)

val masked_where : ?copy:bool -> condition:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Mask an array where a condition is met.

Return `a` as an array masked where `condition` is True.
Any masked values of `a` or `condition` are also masked in the output.

Parameters
----------
condition : array_like
    Masking condition.  When `condition` tests floating point values for
    equality, consider using ``masked_values`` instead.
a : array_like
    Array to mask.
copy : bool
    If True (default) make a copy of `a` in the result.  If False modify
    `a` in place and return a view.

Returns
-------
result : MaskedArray
    The result of masking `a` where `condition` is True.

See Also
--------
masked_values : Mask using floating point equality.
masked_equal : Mask where equal to a given value.
masked_not_equal : Mask where `not` equal to a given value.
masked_less_equal : Mask where less than or equal to a given value.
masked_greater_equal : Mask where greater than or equal to a given value.
masked_less : Mask where less than a given value.
masked_greater : Mask where greater than a given value.
masked_inside : Mask inside a given interval.
masked_outside : Mask outside a given interval.
masked_invalid : Mask invalid values (NaNs or infs).

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_where(a <= 2, a)
masked_array(data=[--, --, --, 3],
             mask=[ True,  True,  True, False],
       fill_value=999999)

Mask array `b` conditional on `a`.

>>> b = ['a', 'b', 'c', 'd']
>>> ma.masked_where(a == 2, b)
masked_array(data=['a', 'b', --, 'd'],
             mask=[False, False,  True, False],
       fill_value='N/A',
            dtype='<U1')

Effect of the `copy` argument.

>>> c = ma.masked_where(a <= 2, a)
>>> c
masked_array(data=[--, --, --, 3],
             mask=[ True,  True,  True, False],
       fill_value=999999)
>>> c[0] = 99
>>> c
masked_array(data=[99, --, --, 3],
             mask=[False,  True,  True, False],
       fill_value=999999)
>>> a
array([0, 1, 2, 3])
>>> c = ma.masked_where(a <= 2, a, copy=False)
>>> c[0] = 99
>>> c
masked_array(data=[99, --, --, 3],
             mask=[False,  True,  True, False],
       fill_value=999999)
>>> a
array([99,  1,  2,  3])

When `condition` or `a` contain masked values.

>>> a = np.arange(4)
>>> a = ma.masked_where(a == 2, a)
>>> a
masked_array(data=[0, 1, --, 3],
             mask=[False, False,  True, False],
       fill_value=999999)
>>> b = np.arange(4)
>>> b = ma.masked_where(b == 0, b)
>>> b
masked_array(data=[--, 1, 2, 3],
             mask=[ True, False, False, False],
       fill_value=999999)
>>> ma.masked_where(a == 3, b)
masked_array(data=[--, 1, --, --],
             mask=[ True, False,  True,  True],
       fill_value=999999)
*)

val max : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> obj:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the maximum along a given axis.

Parameters
----------
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
fill_value : {var}, optional
    Value used to fill in the masked values.
    If None, use the output of maximum_fill_value().
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
amax : array_like
    New array holding the result.
    If ``out`` was specified, ``out`` is returned.

See Also
--------
maximum_fill_value
    Returns the maximum filling value for a given datatype.
*)

val maximum : ?b:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Element-wise maximum of array elements.

Compare two arrays and returns a new array containing the element-wise
maxima. If one of the elements being compared is a NaN, then that
element is returned. If both elements are NaNs then the first is
returned. The latter distinction is important for complex NaNs, which
are defined as at least one of the real or imaginary parts being a NaN.
The net effect is that NaNs are propagated.

Parameters
----------
x1, x2 : array_like
    The arrays holding the elements to be compared. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The maximum of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
minimum :
    Element-wise minimum of two arrays, propagates NaNs.
fmax :
    Element-wise maximum of two arrays, ignores NaNs.
amax :
    The maximum value of an array along a given axis, propagates NaNs.
nanmax :
    The maximum value of an array along a given axis, ignores NaNs.

fmin, amin, nanmin

Notes
-----
The maximum is equivalent to ``np.where(x1 >= x2, x1, x2)`` when
neither x1 nor x2 are nans, but it is faster and does proper
broadcasting.

Examples
--------
>>> np.maximum([2, 3, 4], [1, 5, 2])
array([2, 5, 4])

>>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting
array([[ 1. ,  2. ],
       [ 0.5,  2. ]])

>>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])
array([nan, nan, nan])
>>> np.maximum(np.Inf, 1)
inf
*)

val maximum_fill_value : [`I of int | `Ndarray of [>`Ndarray] Obj.t | `F of float | `Bool of bool | `Dtype of Dtype.t | `S of string] -> Py.Object.t
(**
Return the minimum value that can be represented by the dtype of an object.

This function is useful for calculating a fill value suitable for
taking the maximum of an array with a given dtype.

Parameters
----------
obj : ndarray, dtype or scalar
    An object that can be queried for it's numeric type.

Returns
-------
val : scalar
    The minimum representable value.

Raises
------
TypeError
    If `obj` isn't a suitable numeric type.

See Also
--------
minimum_fill_value : The inverse function.
set_fill_value : Set the filling value of a masked array.
MaskedArray.fill_value : Return current fill value.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.int8()
>>> ma.maximum_fill_value(a)
-128
>>> a = np.int32()
>>> ma.maximum_fill_value(a)
-2147483648

An array of numeric data can also be passed.

>>> a = np.array([1, 2, 3], dtype=np.int8)
>>> ma.maximum_fill_value(a)
-128
>>> a = np.array([1, 2, 3], dtype=np.float32)
>>> ma.maximum_fill_value(a)
-inf
*)

val mean : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)

Returns the average of the array elements along given axis.

Masked entries are ignored, and result elements which are not
finite will be masked.

Refer to `numpy.mean` for full documentation.

See Also
--------
numpy.ndarray.mean : corresponding function for ndarrays
numpy.mean : Equivalent function
numpy.ma.average: Weighted average.

Examples
--------
>>> a = np.ma.array([1,2,3], mask=[False, False, True])
>>> a
masked_array(data=[1, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.mean()
1.5
*)

val min : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> obj:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the minimum along a given axis.

Parameters
----------
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must be of
    the same shape and buffer length as the expected output.
fill_value : {var}, optional
    Value used to fill in the masked values.
    If None, use the output of `minimum_fill_value`.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
amin : array_like
    New array holding the result.
    If ``out`` was specified, ``out`` is returned.

See Also
--------
minimum_fill_value
    Returns the minimum filling value for a given datatype.
*)

val minimum : ?b:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Element-wise minimum of array elements.

Compare two arrays and returns a new array containing the element-wise
minima. If one of the elements being compared is a NaN, then that
element is returned. If both elements are NaNs then the first is
returned. The latter distinction is important for complex NaNs, which
are defined as at least one of the real or imaginary parts being a NaN.
The net effect is that NaNs are propagated.

Parameters
----------
x1, x2 : array_like
    The arrays holding the elements to be compared. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The minimum of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
maximum :
    Element-wise maximum of two arrays, propagates NaNs.
fmin :
    Element-wise minimum of two arrays, ignores NaNs.
amin :
    The minimum value of an array along a given axis, propagates NaNs.
nanmin :
    The minimum value of an array along a given axis, ignores NaNs.

fmax, amax, nanmax

Notes
-----
The minimum is equivalent to ``np.where(x1 <= x2, x1, x2)`` when
neither x1 nor x2 are NaNs, but it is faster and does proper
broadcasting.

Examples
--------
>>> np.minimum([2, 3, 4], [1, 5, 2])
array([1, 3, 2])

>>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting
array([[ 0.5,  0. ],
       [ 0. ,  1. ]])

>>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])
array([nan, nan, nan])
>>> np.minimum(-np.Inf, 1)
-inf
*)

val minimum_fill_value : [`I of int | `Ndarray of [>`Ndarray] Obj.t | `F of float | `Bool of bool | `Dtype of Dtype.t | `S of string] -> Py.Object.t
(**
Return the maximum value that can be represented by the dtype of an object.

This function is useful for calculating a fill value suitable for
taking the minimum of an array with a given dtype.

Parameters
----------
obj : ndarray, dtype or scalar
    An object that can be queried for it's numeric type.

Returns
-------
val : scalar
    The maximum representable value.

Raises
------
TypeError
    If `obj` isn't a suitable numeric type.

See Also
--------
maximum_fill_value : The inverse function.
set_fill_value : Set the filling value of a masked array.
MaskedArray.fill_value : Return current fill value.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.int8()
>>> ma.minimum_fill_value(a)
127
>>> a = np.int32()
>>> ma.minimum_fill_value(a)
2147483647

An array of numeric data can also be passed.

>>> a = np.array([1, 2, 3], dtype=np.int8)
>>> ma.minimum_fill_value(a)
127
>>> a = np.array([1, 2, 3], dtype=np.float32)
>>> ma.minimum_fill_value(a)
inf
*)

val mod_ : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return element-wise remainder of division.

Computes the remainder complementary to the `floor_divide` function.  It is
equivalent to the Python modulus operator``x1 % x2`` and has the same sign
as the divisor `x2`. The MATLAB function equivalent to ``np.remainder``
is ``mod``.

.. warning::

    This should not be confused with:

    * Python 3.7's `math.remainder` and C's ``remainder``, which
      computes the IEEE remainder, which are the complement to
      ``round(x1 / x2)``.
    * The MATLAB ``rem`` function and or the C ``%`` operator which is the
      complement to ``int(x1 / x2)``.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
floor_divide : Equivalent of Python ``//`` operator.
divmod : Simultaneous floor division and remainder.
fmod : Equivalent of the MATLAB ``rem`` function.
divide, floor

Notes
-----
Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)
integers.
``mod`` is an alias of ``remainder``.

Examples
--------
>>> np.remainder([4, 7], [2, 3])
array([0, 1])
>>> np.remainder(np.arange(7), 5)
array([0, 1, 2, 3, 4, 0, 1])
*)

val multiply : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Multiply arguments element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays to be multiplied. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The product of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
Equivalent to `x1` * `x2` in terms of array broadcasting.

Examples
--------
>>> np.multiply(2.0, 4.0)
8.0

>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.multiply(x1, x2)
array([[  0.,   1.,   4.],
       [  0.,   4.,  10.],
       [  0.,   7.,  16.]])
*)

val narray : ?dtype:Dtype.t -> ?copy:bool -> ?order:[`K | `A | `C | `F] -> ?subok:bool -> ?ndmin:int -> object_:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)

Create an array.

Parameters
----------
object : array_like
    An array, any object exposing the array interface, an object whose
    __array__ method returns an array, or any (nested) sequence.
dtype : data-type, optional
    The desired data-type for the array.  If not given, then the type will
    be determined as the minimum type required to hold the objects in the
    sequence.
copy : bool, optional
    If true (default), then the object is copied.  Otherwise, a copy will
    only be made if __array__ returns a copy, if obj is a nested sequence,
    or if a copy is needed to satisfy any of the other requirements
    (`dtype`, `order`, etc.).
order : {'K', 'A', 'C', 'F'}, optional
    Specify the memory layout of the array. If object is not an array, the
    newly created array will be in C order (row major) unless 'F' is
    specified, in which case it will be in Fortran order (column major).
    If object is an array the following holds.

    ===== ========= ===================================================
    order  no copy                     copy=True
    ===== ========= ===================================================
    'K'   unchanged F & C order preserved, otherwise most similar order
    'A'   unchanged F order if input is F and not C, otherwise C order
    'C'   C order   C order
    'F'   F order   F order
    ===== ========= ===================================================

    When ``copy=False`` and a copy is made for other reasons, the result is
    the same as if ``copy=True``, with some exceptions for `A`, see the
    Notes section. The default order is 'K'.
subok : bool, optional
    If True, then sub-classes will be passed-through, otherwise
    the returned array will be forced to be a base-class array (default).
ndmin : int, optional
    Specifies the minimum number of dimensions that the resulting
    array should have.  Ones will be pre-pended to the shape as
    needed to meet this requirement.

Returns
-------
out : ndarray
    An array object satisfying the specified requirements.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Notes
-----
When order is 'A' and `object` is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.

Examples
--------
>>> np.array([1, 2, 3])
array([1, 2, 3])

Upcasting:

>>> np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])

More than one dimension:

>>> np.array([[1, 2], [3, 4]])
array([[1, 2],
       [3, 4]])

Minimum dimensions 2:

>>> np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])

Type provided:

>>> np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])

Data-type consisting of more than one element:

>>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])
>>> x['a']
array([1, 3])

Creating an array from sub-classes:

>>> np.array(np.mat('1 2; 3 4'))
array([[1, 2],
       [3, 4]])

>>> np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
        [3, 4]])
*)

val ndim : Py.Object.t -> int
(**
Return the number of dimensions of an array.

Parameters
----------
a : array_like
    Input array.  If it is not already an ndarray, a conversion is
    attempted.

Returns
-------
number_of_dimensions : int
    The number of dimensions in `a`.  Scalars are zero-dimensional.

See Also
--------
ndarray.ndim : equivalent method
shape : dimensions of array
ndarray.shape : dimensions of array

Examples
--------
>>> np.ndim([[1,2,3],[4,5,6]])
2
>>> np.ndim(np.array([[1,2,3],[4,5,6]]))
2
>>> np.ndim(1)
0
*)

val negative : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Numerical negative, element-wise.

Parameters
----------
x : array_like or scalar
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    Returned array or scalar: `y = -x`.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> np.negative([1.,-1.])
array([-1.,  1.])
*)

val nonzero : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
nonzero(self)

Return the indices of unmasked elements that are not zero.

Returns a tuple of arrays, one for each dimension, containing the
indices of the non-zero elements in that dimension. The corresponding
non-zero values can be obtained with::

    a[a.nonzero()]

To group the indices by element, rather than dimension, use
instead::

    np.transpose(a.nonzero())

The result of this is always a 2d array, with a row for each non-zero
element.

Parameters
----------
None

Returns
-------
tuple_of_arrays : tuple
    Indices of elements that are non-zero.

See Also
--------
numpy.nonzero :
    Function operating on ndarrays.
flatnonzero :
    Return indices that are non-zero in the flattened version of the input
    array.
numpy.ndarray.nonzero :
    Equivalent ndarray method.
count_nonzero :
    Counts the number of non-zero elements in the input array.

Examples
--------
>>> import numpy.ma as ma
>>> x = ma.array(np.eye(3))
>>> x
masked_array(
  data=[[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]],
  mask=False,
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 1, 2]), array([0, 1, 2]))

Masked elements are ignored.

>>> x[1, 1] = ma.masked
>>> x
masked_array(
  data=[[1.0, 0.0, 0.0],
        [0.0, --, 0.0],
        [0.0, 0.0, 1.0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 2]), array([0, 2]))

Indices can also be grouped by element.

>>> np.transpose(x.nonzero())
array([[0, 0],
       [2, 2]])

A common use for ``nonzero`` is to find the indices of an array, where
a condition is True.  Given an array `a`, the condition `a` > 3 is a
boolean array and since False is interpreted as 0, ma.nonzero(a > 3)
yields the indices of the `a` where the condition is true.

>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])
>>> a > 3
masked_array(
  data=[[False, False, False],
        [ True,  True,  True],
        [ True,  True,  True]],
  mask=False,
  fill_value=True)
>>> ma.nonzero(a > 3)
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))

The ``nonzero`` method of the condition array can also be called.

>>> (a > 3).nonzero()
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
*)

val normalize_axis_tuple : ?argname:string -> ?allow_duplicate:bool -> axis:[`I of int | `Iterable_of_int of Py.Object.t] -> ndim:int -> unit -> Py.Object.t
(**
Normalizes an axis argument into a tuple of non-negative integer axes.

This handles shorthands such as ``1`` and converts them to ``(1,)``,
as well as performing the handling of negative indices covered by
`normalize_axis_index`.

By default, this forbids axes from being specified multiple times.

Used internally by multi-axis-checking logic.

.. versionadded:: 1.13.0

Parameters
----------
axis : int, iterable of int
    The un-normalized index or indices of the axis.
ndim : int
    The number of dimensions of the array that `axis` should be normalized
    against.
argname : str, optional
    A prefix to put before the error message, typically the name of the
    argument.
allow_duplicate : bool, optional
    If False, the default, disallow an axis from being specified twice.

Returns
-------
normalized_axes : tuple of int
    The normalized axis index, such that `0 <= normalized_axis < ndim`

Raises
------
AxisError
    If any axis provided is out of range
ValueError
    If an axis is repeated

See also
--------
normalize_axis_index : normalizing a single scalar axis
*)

val not_equal : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return (x1 != x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays.  If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
equal, greater, greater_equal, less, less_equal

Examples
--------
>>> np.not_equal([1.,2.], [1., 3.])
array([False,  True])
>>> np.not_equal([1, 2], [[1, 3],[1, 4]])
array([[False,  True],
       [False,  True]])
*)

val ones : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
ones(shape, dtype=None, order='C')

Return a new array of given shape and type, filled with ones.

Parameters
----------
shape : int or sequence of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: C
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of ones with the given shape, dtype, and order.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
empty : Return a new uninitialized array.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Examples
--------
>>> np.ones(5)
array([1., 1., 1., 1., 1.])

>>> np.ones((5,), dtype=int)
array([1, 1, 1, 1, 1])

>>> np.ones((2, 1))
array([[1.],
       [1.]])

>>> s = (2,2)
>>> np.ones(s)
array([[1.,  1.],
       [1.,  1.]])
*)

val ones_like : ?dtype:Dtype.t -> ?order:[`F | `A | `PyObject of Py.Object.t] -> ?subok:bool -> ?shape:int list -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an array of ones with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of 'a', otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of ones with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
ones : Return a new array setting values to one.

Examples
--------
>>> x = np.arange(6)
>>> x = x.reshape((2, 3))
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.ones_like(x)
array([[1, 1, 1],
       [1, 1, 1]])

>>> y = np.arange(3, dtype=float)
>>> y
array([0., 1., 2.])
>>> np.ones_like(y)
array([1.,  1.,  1.])
*)

val outer : b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the outer product of two vectors.

Given two vectors, ``a = [a0, a1, ..., aM]`` and
``b = [b0, b1, ..., bN]``,
the outer product [1]_ is::

  [[a0*b0  a0*b1 ... a0*bN ]
   [a1*b0    .
   [ ...          .
   [aM*b0            aM*bN ]]

Parameters
----------
a : (M,) array_like
    First input vector.  Input is flattened if
    not already 1-dimensional.
b : (N,) array_like
    Second input vector.  Input is flattened if
    not already 1-dimensional.
out : (M, N) ndarray, optional
    A location where the result is stored

    .. versionadded:: 1.9.0

Returns
-------
out : (M, N) ndarray
    ``out[i, j] = a[i] * b[j]``

See also
--------
inner
einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.
ufunc.outer : A generalization to N dimensions and other operations.
              ``np.multiply.outer(a.ravel(), b.ravel())`` is the equivalent.

References
----------
.. [1] : G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd
         ed., Baltimore, MD, Johns Hopkins University Press, 1996,
         pg. 8.

Examples
--------
Make a ( *very* coarse) grid for computing a Mandelbrot set:

>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
>>> rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
>>> im
array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
>>> grid = rl + im
>>> grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])

An example using a 'vector' of letters:

>>> x = np.array(['a', 'b', 'c'], dtype=object)
>>> np.outer(x, [1, 2, 3])
array([['a', 'aa', 'aaa'],
       ['b', 'bb', 'bbb'],
       ['c', 'cc', 'ccc']], dtype=object)

Notes
-----
Masked values are replaced by 0.
*)

val outerproduct : b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the outer product of two vectors.

Given two vectors, ``a = [a0, a1, ..., aM]`` and
``b = [b0, b1, ..., bN]``,
the outer product [1]_ is::

  [[a0*b0  a0*b1 ... a0*bN ]
   [a1*b0    .
   [ ...          .
   [aM*b0            aM*bN ]]

Parameters
----------
a : (M,) array_like
    First input vector.  Input is flattened if
    not already 1-dimensional.
b : (N,) array_like
    Second input vector.  Input is flattened if
    not already 1-dimensional.
out : (M, N) ndarray, optional
    A location where the result is stored

    .. versionadded:: 1.9.0

Returns
-------
out : (M, N) ndarray
    ``out[i, j] = a[i] * b[j]``

See also
--------
inner
einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.
ufunc.outer : A generalization to N dimensions and other operations.
              ``np.multiply.outer(a.ravel(), b.ravel())`` is the equivalent.

References
----------
.. [1] : G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd
         ed., Baltimore, MD, Johns Hopkins University Press, 1996,
         pg. 8.

Examples
--------
Make a ( *very* coarse) grid for computing a Mandelbrot set:

>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
>>> rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
>>> im
array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
>>> grid = rl + im
>>> grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])

An example using a 'vector' of letters:

>>> x = np.array(['a', 'b', 'c'], dtype=object)
>>> np.outer(x, [1, 2, 3])
array([['a', 'aa', 'aaa'],
       ['b', 'bb', 'bbb'],
       ['c', 'cc', 'ccc']], dtype=object)

Notes
-----
Masked values are replaced by 0.
*)

val power : ?third:Py.Object.t -> b:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Returns element-wise base array raised to power from second array.

This is the masked array version of `numpy.power`. For details see
`numpy.power`.

See Also
--------
numpy.power

Notes
-----
The *out* argument to `numpy.power` is not supported, `third` has to be
None.
*)

val prod : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)

Return the product of the array elements over the given axis.

Masked elements are set to 1 internally for computation.

Refer to `numpy.prod` for full documentation.

Notes
-----
Arithmetic is modular when using integer types, and no error is raised
on overflow.

See Also
--------
numpy.ndarray.prod : corresponding function for ndarrays
numpy.prod : equivalent function
*)

val product : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)

Return the product of the array elements over the given axis.

Masked elements are set to 1 internally for computation.

Refer to `numpy.prod` for full documentation.

Notes
-----
Arithmetic is modular when using integer types, and no error is raised
on overflow.

See Also
--------
numpy.ndarray.prod : corresponding function for ndarrays
numpy.prod : equivalent function
*)

val ptp : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> obj:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return (maximum - minimum) along the given dimension
(i.e. peak-to-peak value).

Parameters
----------
axis : {None, int}, optional
    Axis along which to find the peaks.  If None (default) the
    flattened array is used.
out : {None, array_like}, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary.
fill_value : {var}, optional
    Value used to fill in the masked values.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
ptp : ndarray.
    A new array holding the result, unless ``out`` was
    specified, in which case a reference to ``out`` is returned.
*)

val put : ?mode:Py.Object.t -> indices:Py.Object.t -> values:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Set storage-indexed locations to corresponding values.

This function is equivalent to `MaskedArray.put`, see that method
for details.

See Also
--------
MaskedArray.put
*)

val putmask : mask:Py.Object.t -> values:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Changes elements of an array based on conditional and input values.

This is the masked array version of `numpy.putmask`, for details see
`numpy.putmask`.

See Also
--------
numpy.putmask

Notes
-----
Using a masked array as `values` will **not** transform a `ndarray` into
a `MaskedArray`.
*)

val ravel : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
ravel(self, order='C')

Returns a 1D version of self, as a view.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    The elements of `a` are read using this index order. 'C' means to
    index the elements in C-like order, with the last axis index
    changing fastest, back to the first axis index changing slowest.
    'F' means to index the elements in Fortran-like index order, with
    the first index changing fastest, and the last index changing
    slowest. Note that the 'C' and 'F' options take no account of the
    memory layout of the underlying array, and only refer to the order
    of axis indexing.  'A' means to read the elements in Fortran-like
    index order if `m` is Fortran *contiguous* in memory, C-like order
    otherwise.  'K' means to read the elements in the order they occur
    in memory, except for reversing the data when strides are negative.
    By default, 'C' index order is used.

Returns
-------
MaskedArray
    Output view is of shape ``(self.size,)`` (or
    ``(np.ma.product(self.shape),)``).

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.ravel()
masked_array(data=[1, --, 3, --, 5, --, 7, --, 9],
             mask=[False,  True, False,  True, False,  True, False,  True,
                   False],
       fill_value=999999)
*)

val reduce : ?initial:Py.Object.t -> function_:Py.Object.t -> sequence:Py.Object.t -> unit -> Py.Object.t
(**
reduce(function, sequence[, initial]) -> value

Apply a function of two arguments cumulatively to the items of a sequence,
from left to right, so as to reduce the sequence to a single value.
For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
of the sequence in the calculation, and serves as a default when the
sequence is empty.
*)

val remainder : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return element-wise remainder of division.

Computes the remainder complementary to the `floor_divide` function.  It is
equivalent to the Python modulus operator``x1 % x2`` and has the same sign
as the divisor `x2`. The MATLAB function equivalent to ``np.remainder``
is ``mod``.

.. warning::

    This should not be confused with:

    * Python 3.7's `math.remainder` and C's ``remainder``, which
      computes the IEEE remainder, which are the complement to
      ``round(x1 / x2)``.
    * The MATLAB ``rem`` function and or the C ``%`` operator which is the
      complement to ``int(x1 / x2)``.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
floor_divide : Equivalent of Python ``//`` operator.
divmod : Simultaneous floor division and remainder.
fmod : Equivalent of the MATLAB ``rem`` function.
divide, floor

Notes
-----
Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)
integers.
``mod`` is an alias of ``remainder``.

Examples
--------
>>> np.remainder([4, 7], [2, 3])
array([0, 1])
>>> np.remainder(np.arange(7), 5)
array([0, 1, 2, 3, 4, 0, 1])
*)

val repeat : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
repeat(self, *args, **params)
a.repeat(repeats, axis=None)

    Repeat elements of an array.

    Refer to `numpy.repeat` for full documentation.

    See Also
    --------
    numpy.repeat : equivalent function
*)

val reshape : ?order:Py.Object.t -> new_shape:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Returns an array containing the same data with a new shape.

Refer to `MaskedArray.reshape` for full documentation.

See Also
--------
MaskedArray.reshape : equivalent function
*)

val resize : new_shape:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Return a new masked array with the specified size and shape.

This is the masked equivalent of the `numpy.resize` function. The new
array is filled with repeated copies of `x` (in the order that the
data are stored in memory). If `x` is masked, the new array will be
masked, and the new mask will be a repetition of the old one.

See Also
--------
numpy.resize : Equivalent function in the top level NumPy module.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.array([[1, 2] ,[3, 4]])
>>> a[0, 1] = ma.masked
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=999999)
>>> np.resize(a, (3, 3))
masked_array(
  data=[[1, 2, 3],
        [4, 1, 2],
        [3, 4, 1]],
  mask=False,
  fill_value=999999)
>>> ma.resize(a, (3, 3))
masked_array(
  data=[[1, --, 3],
        [4, 1, --],
        [3, 4, 1]],
  mask=[[False,  True, False],
        [False, False,  True],
        [False, False, False]],
  fill_value=999999)

A MaskedArray is always returned, regardless of the input type.

>>> a = np.array([[1, 2] ,[3, 4]])
>>> ma.resize(a, (3, 3))
masked_array(
  data=[[1, 2, 3],
        [4, 1, 2],
        [3, 4, 1]],
  mask=False,
  fill_value=999999)
*)

val right_shift : n:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Shift the bits of an integer to the right.

This is the masked array version of `numpy.right_shift`, for details
see that function.

See Also
--------
numpy.right_shift
*)

val round : ?decimals:int -> ?out:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Return a copy of a, rounded to 'decimals' places.

When 'decimals' is negative, it specifies the number of positions
to the left of the decimal point.  The real and imaginary parts of
complex numbers are rounded separately. Nothing is done if the
array is not of float type and 'decimals' is greater than or equal
to 0.

Parameters
----------
decimals : int
    Number of decimals to round to. May be negative.
out : array_like
    Existing array to use for output.
    If not given, returns a default copy of a.

Notes
-----
If out is given and does not have a mask attribute, the mask of a
is lost!
*)

val set_fill_value : fill_value:Dtype.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Set the filling value of a, if a is a masked array.

This function changes the fill value of the masked array `a` in place.
If `a` is not a masked array, the function returns silently, without
doing anything.

Parameters
----------
a : array_like
    Input array.
fill_value : dtype
    Filling value. A consistency test is performed to make sure
    the value is compatible with the dtype of `a`.

Returns
-------
None
    Nothing returned by this function.

See Also
--------
maximum_fill_value : Return the default fill value for a dtype.
MaskedArray.fill_value : Return current fill value.
MaskedArray.set_fill_value : Equivalent method.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(5)
>>> a
array([0, 1, 2, 3, 4])
>>> a = ma.masked_where(a < 3, a)
>>> a
masked_array(data=[--, --, --, 3, 4],
             mask=[ True,  True,  True, False, False],
       fill_value=999999)
>>> ma.set_fill_value(a, -999)
>>> a
masked_array(data=[--, --, --, 3, 4],
             mask=[ True,  True,  True, False, False],
       fill_value=-999)

Nothing happens if `a` is not a masked array.

>>> a = list(range(5))
>>> a
[0, 1, 2, 3, 4]
>>> ma.set_fill_value(a, 100)
>>> a
[0, 1, 2, 3, 4]
>>> a = np.arange(5)
>>> a
array([0, 1, 2, 3, 4])
>>> ma.set_fill_value(a, 100)
>>> a
array([0, 1, 2, 3, 4])
*)

val shape : Py.Object.t -> int array
(**
Return the shape of an array.

Parameters
----------
a : array_like
    Input array.

Returns
-------
shape : tuple of ints
    The elements of the shape tuple give the lengths of the
    corresponding array dimensions.

See Also
--------
alen
ndarray.shape : Equivalent array method.

Examples
--------
>>> np.shape(np.eye(3))
(3, 3)
>>> np.shape([[1, 2]])
(1, 2)
>>> np.shape([0])
(1,)
>>> np.shape(0)
()

>>> a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
>>> np.shape(a)
(2,)
>>> a.shape
(2,)
*)

val shrink_mask : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
shrink_mask(self)

Reduce a mask to nomask when possible.

Parameters
----------
None

Returns
-------
None

Examples
--------
>>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)
>>> x.mask
array([[False, False],
       [False, False]])
>>> x.shrink_mask()
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> x.mask
False
*)

val sin : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Trigonometric sine, element-wise.

Parameters
----------
x : array_like
    Angle, in radians (:math:`2 \pi` rad equals 360 degrees).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : array_like
    The sine of each element of x.
    This is a scalar if `x` is a scalar.

See Also
--------
arcsin, sinh, cos

Notes
-----
The sine is one of the fundamental functions of trigonometry (the
mathematical study of triangles).  Consider a circle of radius 1
centered on the origin.  A ray comes in from the :math:`+x` axis, makes
an angle at the origin (measured counter-clockwise from that axis), and
departs from the origin.  The :math:`y` coordinate of the outgoing
ray's intersection with the unit circle is the sine of that angle.  It
ranges from -1 for :math:`x=3\pi / 2` to +1 for :math:`\pi / 2.`  The
function has zeroes where the angle is a multiple of :math:`\pi`.
Sines of angles between :math:`\pi` and :math:`2\pi` are negative.
The numerous properties of the sine and related functions are included
in any standard trigonometry text.

Examples
--------
Print sine of one angle:

>>> np.sin(np.pi/2.)
1.0

Print sines of an array of angles given in degrees:

>>> np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )
array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])

Plot the sine function:

>>> import matplotlib.pylab as plt
>>> x = np.linspace(-np.pi, np.pi, 201)
>>> plt.plot(x, np.sin(x))
>>> plt.xlabel('Angle [rad]')
>>> plt.ylabel('sin(x)')
>>> plt.axis('tight')
>>> plt.show()
*)

val sinh : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Hyperbolic sine, element-wise.

Equivalent to ``1/2 * (np.exp(x) - np.exp(-x))`` or
``-1j * np.sin(1j*x)``.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding hyperbolic sine values.
    This is a scalar if `x` is a scalar.

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972, pg. 83.

Examples
--------
>>> np.sinh(0)
0.0
>>> np.sinh(np.pi*1j/2)
1j
>>> np.sinh(np.pi*1j) # (exact value is 0)
1.2246063538223773e-016j
>>> # Discrepancy due to vagaries of floating point arithmetic.

>>> # Example of providing the optional output parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.sinh([0.1], out1)
>>> out2 is out1
True

>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.sinh(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
*)

val size : ?axis:int -> obj:Py.Object.t -> unit -> int
(**
Return the number of elements along a given axis.

Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which the elements are counted.  By default, give
    the total number of elements.

Returns
-------
element_count : int
    Number of elements along the specified axis.

See Also
--------
shape : dimensions of array
ndarray.shape : dimensions of array
ndarray.size : number of elements in array

Examples
--------
>>> a = np.array([[1,2,3],[4,5,6]])
>>> np.size(a)
6
>>> np.size(a,1)
3
>>> np.size(a,0)
2
*)

val soften_mask : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
soften_mask(self)

Force the mask to soft.

Whether the mask of a masked array is hard or soft is determined by
its `hardmask` property. `soften_mask` sets `hardmask` to False.

See Also
--------
hardmask
*)

val sometrue : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> target:Py.Object.t -> unit -> Py.Object.t
(**
Reduce `target` along the given `axis`.
*)

val sort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[>`Ndarray] Obj.t -> ?endwith:bool -> ?fill_value:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Sort the array, in-place

Parameters
----------
a : array_like
    Array to be sorted.
axis : int, optional
    Axis along which to sort. If None, the array is flattened before
    sorting. The default is -1, which sorts along the last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    The sorting algorithm used.
order : list, optional
    When `a` is a structured array, this argument specifies which fields
    to compare first, second, and so on.  This list does not need to
    include all of the fields.
endwith : {True, False}, optional
    Whether missing values (if any) should be treated as the largest values
    (True) or the smallest values (False)
    When the array contains unmasked values sorting at the same extremes of the
    datatype, the ordering of these values and the masked values is
    undefined.
fill_value : {var}, optional
    Value used internally for the masked values.
    If ``fill_value`` is not None, it supersedes ``endwith``.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
numpy.ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.

Notes
-----
See ``sort`` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Default
>>> a.sort()
>>> a
masked_array(data=[1, 3, 5, --, --],
             mask=[False, False, False,  True,  True],
       fill_value=999999)

>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Put missing values in the front
>>> a.sort(endwith=False)
>>> a
masked_array(data=[--, --, 1, 3, 5],
             mask=[ True,  True, False, False, False],
       fill_value=999999)

>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # fill_value takes over endwith
>>> a.sort(endwith=False, fill_value=3)
>>> a
masked_array(data=[1, --, --, 3, 5],
             mask=[False,  True,  True, False, False],
       fill_value=999999)
*)

val sqrt : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the non-negative square-root of an array, element-wise.

Parameters
----------
x : array_like
    The values whose square-roots are required.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    An array of the same shape as `x`, containing the positive
    square-root of each element in `x`.  If any element in `x` is
    complex, a complex array is returned (and the square-roots of
    negative reals are calculated).  If all of the elements in `x`
    are real, so is `y`, with negative elements returning ``nan``.
    If `out` was provided, `y` is a reference to it.
    This is a scalar if `x` is a scalar.

See Also
--------
lib.scimath.sqrt
    A version which returns complex numbers when given negative reals.

Notes
-----
*sqrt* has--consistent with common convention--as its branch cut the
real 'interval' [`-inf`, 0), and is continuous from above on it.
A branch cut is a curve in the complex plane across which a given
complex function fails to be continuous.

Examples
--------
>>> np.sqrt([1,4,9])
array([ 1.,  2.,  3.])

>>> np.sqrt([4, -1, -3+4J])
array([ 2.+0.j,  0.+1.j,  1.+2.j])

>>> np.sqrt([4, -1, np.inf])
array([ 2., nan, inf])
*)

val squeeze : ?axis:int list -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Remove single-dimensional entries from the shape of an array.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    .. versionadded:: 1.7.0

    Selects a subset of the single-dimensional entries in the
    shape. If an axis is selected with shape entry greater than
    one, an error is raised.

Returns
-------
squeezed : ndarray
    The input array, but with all or a subset of the
    dimensions of length 1 removed. This is always `a` itself
    or a view into `a`.

Raises
------
ValueError
    If `axis` is not None, and an axis being squeezed is not of length 1

See Also
--------
expand_dims : The inverse operation, adding singleton dimensions
reshape : Insert, remove, and combine dimensions, and resize existing ones

Examples
--------
>>> x = np.array([[[0], [1], [2]]])
>>> x.shape
(1, 3, 1)
>>> np.squeeze(x).shape
(3,)
>>> np.squeeze(x, axis=0).shape
(3, 1)
>>> np.squeeze(x, axis=1).shape
Traceback (most recent call last):
...
ValueError: cannot select an axis to squeeze out which has size not equal to one
>>> np.squeeze(x, axis=2).shape
(1, 3)
*)

val std : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)

Returns the standard deviation of the array elements along given axis.

Masked entries are ignored.

Refer to `numpy.std` for full documentation.

See Also
--------
numpy.ndarray.std : corresponding function for ndarrays
numpy.std : Equivalent function
*)

val subtract : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Subtract arguments, element-wise.

Parameters
----------
x1, x2 : array_like
    The arrays to be subtracted from each other. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The difference of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
Equivalent to ``x1 - x2`` in terms of array broadcasting.

Examples
--------
>>> np.subtract(1.0, 4.0)
-3.0

>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.subtract(x1, x2)
array([[ 0.,  0.,  0.],
       [ 3.,  3.,  3.],
       [ 6.,  6.,  6.]])
*)

val sum : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)

Return the sum of the array elements over the given axis.

Masked elements are set to 0 internally.

Refer to `numpy.sum` for full documentation.

See Also
--------
numpy.ndarray.sum : corresponding function for ndarrays
numpy.sum : equivalent function

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.sum()
25
>>> x.sum(axis=1)
masked_array(data=[4, 5, 16],
             mask=[False, False, False],
       fill_value=999999)
>>> x.sum(axis=0)
masked_array(data=[8, 5, 12],
             mask=[False, False, False],
       fill_value=999999)
>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))
<class 'numpy.int64'>
*)

val swapaxes : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
swapaxes(self, *args, **params)
a.swapaxes(axis1, axis2)

    Return a view of the array with `axis1` and `axis2` interchanged.

    Refer to `numpy.swapaxes` for full documentation.

    See Also
    --------
    numpy.swapaxes : equivalent function
*)

val take : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?mode:Py.Object.t -> indices:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
    
*)

val tan : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute tangent element-wise.

Equivalent to ``np.sin(x)/np.cos(x)`` element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding tangent values.
    This is a scalar if `x` is a scalar.

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.

Examples
--------
>>> from math import pi
>>> np.tan(np.array([-pi,pi/2,pi]))
array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])
>>>
>>> # Example of providing the optional output parameter illustrating
>>> # that what is returned is a reference to said parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.cos([0.1], out1)
>>> out2 is out1
True
>>>
>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
*)

val tanh : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute hyperbolic tangent element-wise.

Equivalent to ``np.sinh(x)/np.cosh(x)`` or ``-1j * np.tan(1j*x)``.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding hyperbolic tangent values.
    This is a scalar if `x` is a scalar.

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
.. [1] M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
       New York, NY: Dover, 1972, pg. 83.
       http://www.math.sfu.ca/~cbm/aands/

.. [2] Wikipedia, 'Hyperbolic function',
       https://en.wikipedia.org/wiki/Hyperbolic_function

Examples
--------
>>> np.tanh((0, np.pi*1j, np.pi*1j/2))
array([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])

>>> # Example of providing the optional output parameter illustrating
>>> # that what is returned is a reference to said parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.tanh([0.1], out1)
>>> out2 is out1
True

>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.tanh(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
*)

val trace : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)
a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)

    Return the sum along diagonals of the array.

    Refer to `numpy.trace` for full documentation.

    See Also
    --------
    numpy.trace : equivalent function
*)

val transpose : ?axes:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Permute the dimensions of an array.

This function is exactly equivalent to `numpy.transpose`.

See Also
--------
numpy.transpose : Equivalent function in top-level NumPy module.

Examples
--------
>>> import numpy.ma as ma
>>> x = ma.arange(4).reshape((2,2))
>>> x[1, 1] = ma.masked
>>> x
masked_array(
  data=[[0, 1],
        [2, --]],
  mask=[[False, False],
        [False,  True]],
  fill_value=999999)

>>> ma.transpose(x)
masked_array(
  data=[[0, 2],
        [1, --]],
  mask=[[False, False],
        [False,  True]],
  fill_value=999999)
*)

val true_divide : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Returns a true division of the inputs, element-wise.

Instead of the Python traditional 'floor division', this returns a true
division.  True division adjusts the output type to present the best
answer, regardless of input types.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
The floor division operator ``//`` was added in Python 2.2 making
``//`` and ``/`` equivalent operators.  The default floor division
operation of ``/`` can be replaced by true division with ``from
__future__ import division``.

In Python 3.0, ``//`` is the floor division operator and ``/`` the
true division operator.  The ``true_divide(x1, x2)`` function is
equivalent to true division in Python.

Examples
--------
>>> x = np.arange(5)
>>> np.true_divide(x, 4)
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])

>>> x//4
array([0, 0, 0, 0, 1])

>>> from __future__ import division
>>> x/4
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
>>> x//4
array([0, 0, 0, 0, 1])
*)

val var : ?params:(string * Py.Object.t) list -> [>`Ndarray] Obj.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)

Compute the variance along the specified axis.

Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.

Parameters
----------
a : array_like
    Array containing numbers whose variance is desired.  If `a` is not an
    array, a conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which the variance is computed.  The default is to
    compute the variance of the flattened array.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a variance is performed over multiple axes,
    instead of a single axis or all the axes as before.
dtype : data-type, optional
    Type to use in computing the variance.  For arrays of integer type
    the default is `float64`; for arrays of float types it is the same as
    the array type.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output, but the type is cast if
    necessary.
ddof : int, optional
    'Delta Degrees of Freedom': the divisor used in the calculation is
    ``N - ddof``, where ``N`` represents the number of elements. By
    default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `var` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
variance : ndarray, see dtype parameter above
    If ``out=None``, returns a new array containing the variance;
    otherwise, a reference to the output array is returned.

See Also
--------
std, mean, nanmean, nanstd, nanvar
ufuncs-output-type

Notes
-----
The variance is the average of the squared deviations from the mean,
i.e.,  ``var = mean(abs(x - x.mean())**2)``.

The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
If, however, `ddof` is specified, the divisor ``N - ddof`` is used
instead.  In standard statistical practice, ``ddof=1`` provides an
unbiased estimator of the variance of a hypothetical infinite population.
``ddof=0`` provides a maximum likelihood estimate of the variance for
normally distributed variables.

Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.

For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32` (see example
below).  Specifying a higher-accuracy accumulator using the ``dtype``
keyword can alleviate this issue.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> np.var(a)
1.25
>>> np.var(a, axis=0)
array([1.,  1.])
>>> np.var(a, axis=1)
array([0.25,  0.25])

In single precision, var() can be inaccurate:

>>> a = np.zeros((2, 512*512), dtype=np.float32)
>>> a[0, :] = 1.0
>>> a[1, :] = 0.1
>>> np.var(a)
0.20250003

Computing the variance in float64 is more accurate:

>>> np.var(a, dtype=np.float64)
0.20249999932944759 # may vary
>>> ((1-0.55)**2 + (0.1-0.55)**2)/2
0.2025
*)

val where : ?x:Py.Object.t -> ?y:Py.Object.t -> condition:[`Bool of bool | `Ndarray of [>`Ndarray] Obj.t] -> unit -> Py.Object.t
(**
Return a masked array with elements from `x` or `y`, depending on condition.

.. note::
    When only `condition` is provided, this function is identical to
    `nonzero`. The rest of this documentation covers only the case where
    all three arguments are provided.

Parameters
----------
condition : array_like, bool
    Where True, yield `x`, otherwise yield `y`.
x, y : array_like, optional
    Values from which to choose. `x`, `y` and `condition` need to be
    broadcastable to some shape.

Returns
-------
out : MaskedArray
    An masked array with `masked` elements where the condition is masked,
    elements from `x` where `condition` is True, and elements from `y`
    elsewhere.

See Also
--------
numpy.where : Equivalent function in the top-level NumPy module.
nonzero : The function that is called when x and y are omitted

Examples
--------
>>> x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],
...                                                    [1, 0, 1],
...                                                    [0, 1, 0]])
>>> x
masked_array(
  data=[[0.0, --, 2.0],
        [--, 4.0, --],
        [6.0, --, 8.0]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=1e+20)
>>> np.ma.where(x > 5, x, -3.1416)
masked_array(
  data=[[-3.1416, --, -3.1416],
        [--, -3.1416, --],
        [6.0, --, 8.0]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=1e+20)
*)

val zeros : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
zeros(shape, dtype=float, order='C')

Return a new array of given shape and type, filled with zeros.

Parameters
----------
shape : int or tuple of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: 'C'
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of zeros with the given shape, dtype, and order.

See Also
--------
zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.

Examples
--------
>>> np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])

>>> np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])

>>> np.zeros((2, 1))
array([[ 0.],
       [ 0.]])

>>> s = (2,2)
>>> np.zeros(s)
array([[ 0.,  0.],
       [ 0.,  0.]])

>>> np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
      dtype=[('x', '<i4'), ('y', '<i4')])
*)

val zeros_like : ?dtype:Dtype.t -> ?order:[`F | `A | `PyObject of Py.Object.t] -> ?subok:bool -> ?shape:int list -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an array of zeros with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of 'a', otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of zeros with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
full_like : Return a new array with shape of input filled with value.
zeros : Return a new array setting values to zero.

Examples
--------
>>> x = np.arange(6)
>>> x = x.reshape((2, 3))
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.zeros_like(x)
array([[0, 0, 0],
       [0, 0, 0]])

>>> y = np.arange(3, dtype=float)
>>> y
array([0., 1., 2.])
>>> np.zeros_like(y)
array([0.,  0.,  0.])
*)


end

val add : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Add arguments element-wise.

Parameters
----------
x1, x2 : array_like
    The arrays to be added. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
add : ndarray or scalar
    The sum of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
Equivalent to `x1` + `x2` in terms of array broadcasting.

Examples
--------
>>> np.add(1.0, 4.0)
5.0
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.add(x1, x2)
array([[  0.,   2.,   4.],
       [  3.,   5.,   7.],
       [  6.,   8.,  10.]])
*)

val apply_along_axis : ?kwargs:(string * Py.Object.t) list -> func1d:Py.Object.t -> axis:int -> arr:Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
Apply a function to 1-D slices along the given axis.

Execute `func1d(a, *args)` where `func1d` operates on 1-D arrays and `a`
is a 1-D slice of `arr` along `axis`.

This is equivalent to (but faster than) the following use of `ndindex` and
`s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices::

    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
    for ii in ndindex(Ni):
        for kk in ndindex(Nk):
            f = func1d(arr[ii + s_[:,] + kk])
            Nj = f.shape
            for jj in ndindex(Nj):
                out[ii + jj + kk] = f[jj]

Equivalently, eliminating the inner loop, this can be expressed as::

    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
    for ii in ndindex(Ni):
        for kk in ndindex(Nk):
            out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])

Parameters
----------
func1d : function (M,) -> (Nj...)
    This function should accept 1-D arrays. It is applied to 1-D
    slices of `arr` along the specified axis.
axis : integer
    Axis along which `arr` is sliced.
arr : ndarray (Ni..., M, Nk...)
    Input array.
args : any
    Additional arguments to `func1d`.
kwargs : any
    Additional named arguments to `func1d`.

    .. versionadded:: 1.9.0


Returns
-------
out : ndarray  (Ni..., Nj..., Nk...)
    The output array. The shape of `out` is identical to the shape of
    `arr`, except along the `axis` dimension. This axis is removed, and
    replaced with new dimensions equal to the shape of the return value
    of `func1d`. So if `func1d` returns a scalar `out` will have one
    fewer dimensions than `arr`.

See Also
--------
apply_over_axes : Apply a function repeatedly over multiple axes.

Examples
--------
>>> def my_func(a):
...     '''Average first and last element of a 1-D array'''
...     return (a[0] + a[-1]) * 0.5
>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
>>> np.apply_along_axis(my_func, 0, b)
array([4., 5., 6.])
>>> np.apply_along_axis(my_func, 1, b)
array([2.,  5.,  8.])

For a function that returns a 1D array, the number of dimensions in
`outarr` is the same as `arr`.

>>> b = np.array([[8,1,7], [4,3,9], [5,2,6]])
>>> np.apply_along_axis(sorted, 1, b)
array([[1, 7, 8],
       [3, 4, 9],
       [2, 5, 6]])

For a function that returns a higher dimensional array, those dimensions
are inserted in place of the `axis` dimension.

>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
>>> np.apply_along_axis(np.diag, -1, b)
array([[[1, 0, 0],
        [0, 2, 0],
        [0, 0, 3]],
       [[4, 0, 0],
        [0, 5, 0],
        [0, 0, 6]],
       [[7, 0, 0],
        [0, 8, 0],
        [0, 0, 9]]])
*)

val apply_over_axes : func:Py.Object.t -> axes:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Apply a function repeatedly over multiple axes.

`func` is called as `res = func(a, axis)`, where `axis` is the first
element of `axes`.  The result `res` of the function call must have
either the same dimensions as `a` or one less dimension.  If `res`
has one less dimension than `a`, a dimension is inserted before
`axis`.  The call to `func` is then repeated for each axis in `axes`,
with `res` as the first argument.

Parameters
----------
func : function
    This function must take two arguments, `func(a, axis)`.
a : array_like
    Input array.
axes : array_like
    Axes over which `func` is applied; the elements must be integers.

Returns
-------
apply_over_axis : ndarray
    The output array.  The number of dimensions is the same as `a`,
    but the shape can be different.  This depends on whether `func`
    changes the shape of its output with respect to its input.

See Also
--------
apply_along_axis :
    Apply a function to 1-D slices of an array along the given axis.

Examples
--------
>>> a = np.ma.arange(24).reshape(2,3,4)
>>> a[:,0,1] = np.ma.masked
>>> a[:,1,:] = np.ma.masked
>>> a
masked_array(
  data=[[[0, --, 2, 3],
         [--, --, --, --],
         [8, 9, 10, 11]],
        [[12, --, 14, 15],
         [--, --, --, --],
         [20, 21, 22, 23]]],
  mask=[[[False,  True, False, False],
         [ True,  True,  True,  True],
         [False, False, False, False]],
        [[False,  True, False, False],
         [ True,  True,  True,  True],
         [False, False, False, False]]],
  fill_value=999999)
>>> np.ma.apply_over_axes(np.ma.sum, a, [0,2])
masked_array(
  data=[[[46],
         [--],
         [124]]],
  mask=[[[False],
         [ True],
         [False]]],
  fill_value=999999)

Tuple axis arguments to ufuncs are equivalent:

>>> np.ma.sum(a, axis=(0,2)).reshape((1,-1,1))
masked_array(
  data=[[[46],
         [--],
         [124]]],
  mask=[[[False],
         [ True],
         [False]]],
  fill_value=999999)
*)

val array : ?dtype:Dtype.t -> ?copy:bool -> ?order:[`C | `F | `A] -> ?mask:Py.Object.t -> ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> ?keep_mask:bool -> ?hard_mask:bool -> ?shrink:bool -> ?subok:bool -> ?ndmin:int -> data:[>`Ndarray] Obj.t -> unit -> Py.Object.t
(**
An array class with possibly masked values.

Masked values of True exclude the corresponding element from any
computation.

Construction::

  x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
                  ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
                  shrink=True, order=None)

Parameters
----------
data : array_like
    Input data.
mask : sequence, optional
    Mask. Must be convertible to an array of booleans with the same
    shape as `data`. True indicates a masked (i.e. invalid) data.
dtype : dtype, optional
    Data type of the output.
    If `dtype` is None, the type of the data argument (``data.dtype``)
    is used. If `dtype` is not None and different from ``data.dtype``,
    a copy is performed.
copy : bool, optional
    Whether to copy the input data (True), or to use a reference instead.
    Default is False.
subok : bool, optional
    Whether to return a subclass of `MaskedArray` if possible (True) or a
    plain `MaskedArray`. Default is True.
ndmin : int, optional
    Minimum number of dimensions. Default is 0.
fill_value : scalar, optional
    Value used to fill in the masked values when necessary.
    If None, a default based on the data-type is used.
keep_mask : bool, optional
    Whether to combine `mask` with the mask of the input data, if any
    (True), or to use only `mask` for the output (False). Default is True.
hard_mask : bool, optional
    Whether to use a hard mask or not. With a hard mask, masked values
    cannot be unmasked. Default is False.
shrink : bool, optional
    Whether to force compression of an empty mask. Default is True.
order : {'C', 'F', 'A'}, optional
    Specify the order of the array.  If order is 'C', then the array
    will be in C-contiguous order (last-index varies the fastest).
    If order is 'F', then the returned array will be in
    Fortran-contiguous order (first-index varies the fastest).
    If order is 'A' (default), then the returned array may be
    in any order (either C-, Fortran-contiguous, or even discontiguous),
    unless a copy is required, in which case it will be C-contiguous.
*)

val asarray : ?dtype:Dtype.t -> ?order:[`C | `F] -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Convert the input to a masked array of the given data-type.

No copy is performed if the input is already an `ndarray`. If `a` is
a subclass of `MaskedArray`, a base class `MaskedArray` is returned.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to a masked array. This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists, ndarrays and masked arrays.
dtype : dtype, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major ('C') or column-major ('FORTRAN') memory
    representation.  Default is 'C'.

Returns
-------
out : MaskedArray
    Masked array interpretation of `a`.

See Also
--------
asanyarray : Similar to `asarray`, but conserves subclasses.

Examples
--------
>>> x = np.arange(10.).reshape(2, 5)
>>> x
array([[0., 1., 2., 3., 4.],
       [5., 6., 7., 8., 9.]])
>>> np.ma.asarray(x)
masked_array(
  data=[[0., 1., 2., 3., 4.],
        [5., 6., 7., 8., 9.]],
  mask=False,
  fill_value=1e+20)
>>> type(np.ma.asarray(x))
<class 'numpy.ma.core.MaskedArray'>
*)

val atleast_1d : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
atleast_1d( *args, **kwargs)

    Convert inputs to arrays with at least one dimension.

    Scalar inputs are converted to 1-dimensional arrays, whilst
    higher-dimensional inputs are preserved.

    Parameters
    ----------
    arys1, arys2, ... : array_like
        One or more input arrays.

    Returns
    -------
    ret : ndarray
        An array, or list of arrays, each with ``a.ndim >= 1``.
        Copies are made only if necessary.

    See Also
    --------
    atleast_2d, atleast_3d

    Examples
    --------
    >>> np.atleast_1d(1.0)
    array([1.])

    >>> x = np.arange(9.0).reshape(3,3)
    >>> np.atleast_1d(x)
    array([[0., 1., 2.],
           [3., 4., 5.],
           [6., 7., 8.]])
    >>> np.atleast_1d(x) is x
    True

    >>> np.atleast_1d(1, [3, 4])
    [array([1]), array([3, 4])]

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val atleast_2d : ?params:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
atleast_2d( *args, **kwargs)

    View inputs as arrays with at least two dimensions.

    Parameters
    ----------
    arys1, arys2, ... : array_like
        One or more array-like sequences.  Non-array inputs are converted
        to arrays.  Arrays that already have two or more dimensions are
        preserved.

    Returns
    -------
    res, res2, ... : ndarray
        An array, or list of arrays, each with ``a.ndim >= 2``.
        Copies are avoided where possible, and views with two or more
        dimensions are returned.

    See Also
    --------
    atleast_1d, atleast_3d

    Examples
    --------
    >>> np.atleast_2d(3.0)
    array([[3.]])

    >>> x = np.arange(3.0)
    >>> np.atleast_2d(x)
    array([[0., 1., 2.]])
    >>> np.atleast_2d(x).base is x
    True

    >>> np.atleast_2d(1, [1, 2], [[1, 2]])
    [array([[1]]), array([[1, 2]]), array([[1, 2]])]

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val atleast_3d : ?params:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
atleast_3d( *args, **kwargs)

    View inputs as arrays with at least three dimensions.

    Parameters
    ----------
    arys1, arys2, ... : array_like
        One or more array-like sequences.  Non-array inputs are converted to
        arrays.  Arrays that already have three or more dimensions are
        preserved.

    Returns
    -------
    res1, res2, ... : ndarray
        An array, or list of arrays, each with ``a.ndim >= 3``.  Copies are
        avoided where possible, and views with three or more dimensions are
        returned.  For example, a 1-D array of shape ``(N,)`` becomes a view
        of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a
        view of shape ``(M, N, 1)``.

    See Also
    --------
    atleast_1d, atleast_2d

    Examples
    --------
    >>> np.atleast_3d(3.0)
    array([[[3.]]])

    >>> x = np.arange(3.0)
    >>> np.atleast_3d(x).shape
    (1, 3, 1)

    >>> x = np.arange(12.0).reshape(4,3)
    >>> np.atleast_3d(x).shape
    (4, 3, 1)
    >>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself
    True

    >>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):
    ...     print(arr, arr.shape) # doctest: +SKIP
    ...
    [[[1]
      [2]]] (1, 2, 1)
    [[[1]
      [2]]] (1, 2, 1)
    [[[1 2]]] (1, 1, 2)

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val average : ?axis:int -> ?weights:[>`Ndarray] Obj.t -> ?returned:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the weighted average of array over the given axis.

Parameters
----------
a : array_like
    Data to be averaged.
    Masked entries are not taken into account in the computation.
axis : int, optional
    Axis along which to average `a`. If None, averaging is done over
    the flattened array.
weights : array_like, optional
    The importance that each element has in the computation of the average.
    The weights array can either be 1-D (in which case its length must be
    the size of `a` along the given axis) or of the same shape as `a`.
    If ``weights=None``, then all data in `a` are assumed to have a
    weight equal to one.  The 1-D calculation is::

        avg = sum(a * weights) / sum(weights)

    The only constraint on `weights` is that `sum(weights)` must not be 0.
returned : bool, optional
    Flag indicating whether a tuple ``(result, sum of weights)``
    should be returned as output (True), or just the result (False).
    Default is False.

Returns
-------
average, [sum_of_weights] : (tuple of) scalar or MaskedArray
    The average along the specified axis. When returned is `True`,
    return a tuple with the average as the first element and the sum
    of the weights as the second element. The return type is `np.float64`
    if `a` is of integer type and floats smaller than `float64`, or the
    input data-type, otherwise. If returned, `sum_of_weights` is always
    `float64`.

Examples
--------
>>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])
>>> np.ma.average(a, weights=[3, 1, 0, 0])
1.25

>>> x = np.ma.arange(6.).reshape(3, 2)
>>> x
masked_array(
  data=[[0., 1.],
        [2., 3.],
        [4., 5.]],
  mask=False,
  fill_value=1e+20)
>>> avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],
...                                 returned=True)
>>> avg
masked_array(data=[2.6666666666666665, 3.6666666666666665],
             mask=[False, False],
       fill_value=1e+20)
*)

val clump_masked : [>`Ndarray] Obj.t -> Py.Object.t
(**
Returns a list of slices corresponding to the masked clumps of a 1-D array.
(A 'clump' is defined as a contiguous region of the array).

Parameters
----------
a : ndarray
    A one-dimensional masked array.

Returns
-------
slices : list of slice
    The list of slices, one for each continuous region of masked elements
    in `a`.

Notes
-----
.. versionadded:: 1.4.0

See Also
--------
flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges
notmasked_contiguous, clump_unmasked

Examples
--------
>>> a = np.ma.masked_array(np.arange(10))
>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
>>> np.ma.clump_masked(a)
[slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]
*)

val clump_unmasked : [>`Ndarray] Obj.t -> Py.Object.t
(**
Return list of slices corresponding to the unmasked clumps of a 1-D array.
(A 'clump' is defined as a contiguous region of the array).

Parameters
----------
a : ndarray
    A one-dimensional masked array.

Returns
-------
slices : list of slice
    The list of slices, one for each continuous region of unmasked
    elements in `a`.

Notes
-----
.. versionadded:: 1.4.0

See Also
--------
flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges
notmasked_contiguous, clump_masked

Examples
--------
>>> a = np.ma.masked_array(np.arange(10))
>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
>>> np.ma.clump_unmasked(a)
[slice(3, 6, None), slice(7, 8, None)]
*)

val column_stack : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
column_stack( *args, **kwargs)

    Stack 1-D arrays as columns into a 2-D array.

    Take a sequence of 1-D arrays and stack them as columns
    to make a single 2-D array. 2-D arrays are stacked as-is,
    just like with `hstack`.  1-D arrays are turned into 2-D columns
    first.

    Parameters
    ----------
    tup : sequence of 1-D or 2-D arrays.
        Arrays to stack. All of them must have the same first dimension.

    Returns
    -------
    stacked : 2-D array
        The array formed by stacking the given arrays.

    See Also
    --------
    stack, hstack, vstack, concatenate

    Examples
    --------
    >>> a = np.array((1,2,3))
    >>> b = np.array((2,3,4))
    >>> np.column_stack((a,b))
    array([[1, 2],
           [2, 3],
           [3, 4]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val compress_cols : Py.Object.t -> Py.Object.t
(**
Suppress whole columns of a 2-D array that contain masked values.

This is equivalent to ``np.ma.compress_rowcols(a, 1)``, see
`extras.compress_rowcols` for details.

See Also
--------
extras.compress_rowcols
*)

val compress_nd : ?axis:int list -> [`MaskedArray of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Suppress slices from multiple dimensions which contain masked values.

Parameters
----------
x : array_like, MaskedArray
    The array to operate on. If not a MaskedArray instance (or if no array
    elements are masked, `x` is interpreted as a MaskedArray with `mask`
    set to `nomask`.
axis : tuple of ints or int, optional
    Which dimensions to suppress slices from can be configured with this
    parameter.
    - If axis is a tuple of ints, those are the axes to suppress slices from.
    - If axis is an int, then that is the only axis to suppress slices from.
    - If axis is None, all axis are selected.

Returns
-------
compress_array : ndarray
    The compressed array.
*)

val compress_rowcols : ?axis:int -> [`MaskedArray of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Suppress the rows and/or columns of a 2-D array that contain
masked values.

The suppression behavior is selected with the `axis` parameter.

- If axis is None, both rows and columns are suppressed.
- If axis is 0, only rows are suppressed.
- If axis is 1 or -1, only columns are suppressed.

Parameters
----------
x : array_like, MaskedArray
    The array to operate on.  If not a MaskedArray instance (or if no array
    elements are masked), `x` is interpreted as a MaskedArray with
    `mask` set to `nomask`. Must be a 2D array.
axis : int, optional
    Axis along which to perform the operation. Default is None.

Returns
-------
compressed_array : ndarray
    The compressed array.

Examples
--------
>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
...                                                   [1, 0, 0],
...                                                   [0, 0, 0]])
>>> x
masked_array(
  data=[[--, 1, 2],
        [--, 4, 5],
        [6, 7, 8]],
  mask=[[ True, False, False],
        [ True, False, False],
        [False, False, False]],
  fill_value=999999)

>>> np.ma.compress_rowcols(x)
array([[7, 8]])
>>> np.ma.compress_rowcols(x, 0)
array([[6, 7, 8]])
>>> np.ma.compress_rowcols(x, 1)
array([[1, 2],
       [4, 5],
       [7, 8]])
*)

val compress_rows : Py.Object.t -> Py.Object.t
(**
Suppress whole rows of a 2-D array that contain masked values.

This is equivalent to ``np.ma.compress_rowcols(a, 0)``, see
`extras.compress_rowcols` for details.

See Also
--------
extras.compress_rowcols
*)

val concatenate : ?axis:int -> arrays:Py.Object.t -> unit -> Py.Object.t
(**
Concatenate a sequence of arrays along the given axis.

Parameters
----------
arrays : sequence of array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int, optional
    The axis along which the arrays will be joined. Default is 0.

Returns
-------
result : MaskedArray
    The concatenated array with any masked entries preserved.

See Also
--------
numpy.concatenate : Equivalent function in the top-level NumPy module.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.arange(3)
>>> a[1] = ma.masked
>>> b = ma.arange(2, 5)
>>> a
masked_array(data=[0, --, 2],
             mask=[False,  True, False],
       fill_value=999999)
>>> b
masked_array(data=[2, 3, 4],
             mask=False,
       fill_value=999999)
>>> ma.concatenate([a, b])
masked_array(data=[0, --, 2, 2, 3, 4],
             mask=[False,  True, False, False, False, False],
       fill_value=999999)
*)

val corrcoef : ?y:[>`Ndarray] Obj.t -> ?rowvar:bool -> ?bias:Py.Object.t -> ?allow_masked:bool -> ?ddof:Py.Object.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Return Pearson product-moment correlation coefficients.

Except for the handling of missing data this function does the same as
`numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`.

Parameters
----------
x : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `x` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same
    shape as `x`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.10.0
allow_masked : bool, optional
    If True, masked values are propagated pair-wise: if a value is masked
    in `x`, the corresponding value is masked in `y`.
    If False, raises an exception.  Because `bias` is deprecated, this
    argument needs to be treated as keyword only to avoid a warning.
ddof : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.10.0

See Also
--------
numpy.corrcoef : Equivalent function in top-level NumPy module.
cov : Estimate the covariance matrix.

Notes
-----
This function accepts but discards arguments `bias` and `ddof`.  This is
for backwards compatibility with previous versions of this function.  These
arguments had no effect on the return values of the function and can be
safely ignored in this and previous versions of numpy.
*)

val count : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
count(self, axis=None, keepdims=<no value>)

Count the non-masked elements of the array along the given axis.

Parameters
----------
axis : None or int or tuple of ints, optional
    Axis or axes along which the count is performed.
    The default, None, performs the count over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.10.0

    If this is a tuple of ints, the count is performed on multiple
    axes, instead of a single axis or all the axes as before.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
result : ndarray or scalar
    An array with the same shape as the input array, with the specified
    axis removed. If the array is a 0-d array, or if `axis` is None, a
    scalar is returned.

See Also
--------
count_masked : Count masked elements in array or along a given axis.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.arange(6).reshape((2, 3))
>>> a[1, :] = ma.masked
>>> a
masked_array(
  data=[[0, 1, 2],
        [--, --, --]],
  mask=[[False, False, False],
        [ True,  True,  True]],
  fill_value=999999)
>>> a.count()
3

When the `axis` keyword is specified an array of appropriate size is
returned.

>>> a.count(axis=0)
array([1, 1, 1])
>>> a.count(axis=1)
array([3, 0])
*)

val count_masked : ?axis:int -> arr:[>`Ndarray] Obj.t -> unit -> Py.Object.t
(**
Count the number of masked elements along the given axis.

Parameters
----------
arr : array_like
    An array with (possibly) masked elements.
axis : int, optional
    Axis along which to count. If None (default), a flattened
    version of the array is used.

Returns
-------
count : int, ndarray
    The total number of masked elements (axis=None) or the number
    of masked elements along each slice of the given axis.

See Also
--------
MaskedArray.count : Count non-masked elements.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(9).reshape((3,3))
>>> a = ma.array(a)
>>> a[1, 0] = ma.masked
>>> a[1, 2] = ma.masked
>>> a[2, 1] = ma.masked
>>> a
masked_array(
  data=[[0, 1, 2],
        [--, 4, --],
        [6, --, 8]],
  mask=[[False, False, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> ma.count_masked(a)
3

When the `axis` keyword is used an array is returned.

>>> ma.count_masked(a, axis=0)
array([1, 1, 1])
>>> ma.count_masked(a, axis=1)
array([0, 2, 1])
*)

val cov : ?y:[>`Ndarray] Obj.t -> ?rowvar:bool -> ?bias:bool -> ?allow_masked:bool -> ?ddof:int -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Estimate the covariance matrix.

Except for the handling of missing data this function does the same as
`numpy.cov`. For more details and examples, see `numpy.cov`.

By default, masked values are recognized as such. If `x` and `y` have the
same shape, a common mask is allocated: if ``x[i,j]`` is masked, then
``y[i,j]`` will also be masked.
Setting `allow_masked` to False will raise an exception if values are
missing in either of the input arrays.

Parameters
----------
x : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `x` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same
    form as `x`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : bool, optional
    Default normalization (False) is by ``(N-1)``, where ``N`` is the
    number of observations given (unbiased estimate). If `bias` is True,
    then normalization is by ``N``. This keyword can be overridden by
    the keyword ``ddof`` in numpy versions >= 1.5.
allow_masked : bool, optional
    If True, masked values are propagated pair-wise: if a value is masked
    in `x`, the corresponding value is masked in `y`.
    If False, raises a `ValueError` exception when some values are missing.
ddof : {None, int}, optional
    If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is
    the number of observations; this overrides the value implied by
    ``bias``. The default value is ``None``.

    .. versionadded:: 1.5

Raises
------
ValueError
    Raised if some values are missing and `allow_masked` is False.

See Also
--------
numpy.cov
*)

val diagflat : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
diagflat( *args, **kwargs)

    Create a two-dimensional array with the flattened input as a diagonal.

    Parameters
    ----------
    v : array_like
        Input data, which is flattened and set as the `k`-th
        diagonal of the output.
    k : int, optional
        Diagonal to set; 0, the default, corresponds to the 'main' diagonal,
        a positive (negative) `k` giving the number of the diagonal above
        (below) the main.

    Returns
    -------
    out : ndarray
        The 2-D output array.

    See Also
    --------
    diag : MATLAB work-alike for 1-D and 2-D arrays.
    diagonal : Return specified diagonals.
    trace : Sum along diagonals.

    Examples
    --------
    >>> np.diagflat([[1,2], [3,4]])
    array([[1, 0, 0, 0],
           [0, 2, 0, 0],
           [0, 0, 3, 0],
           [0, 0, 0, 4]])

    >>> np.diagflat([1,2], 1)
    array([[0, 1, 0],
           [0, 0, 2],
           [0, 0, 0]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val dot : ?strict:bool -> ?out:Py.Object.t -> b:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Return the dot product of two arrays.

This function is the equivalent of `numpy.dot` that takes masked values
into account. Note that `strict` and `out` are in different position
than in the method version. In order to maintain compatibility with the
corresponding method, it is recommended that the optional arguments be
treated as keyword only.  At some point that may be mandatory.

.. note::
  Works only with 2-D arrays at the moment.


Parameters
----------
a, b : masked_array_like
    Inputs arrays.
strict : bool, optional
    Whether masked data are propagated (True) or set to 0 (False) for
    the computation. Default is False.  Propagating the mask means that
    if a masked value appears in a row or column, the whole row or
    column is considered masked.
out : masked_array, optional
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for `dot(a,b)`. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.

    .. versionadded:: 1.10.2

See Also
--------
numpy.dot : Equivalent function for ndarrays.

Examples
--------
>>> a = np.ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])
>>> b = np.ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])
>>> np.ma.dot(a, b)
masked_array(
  data=[[21, 26],
        [45, 64]],
  mask=[[False, False],
        [False, False]],
  fill_value=999999)
>>> np.ma.dot(a, b, strict=True)
masked_array(
  data=[[--, --],
        [--, 64]],
  mask=[[ True,  True],
        [ True, False]],
  fill_value=999999)
*)

val dstack : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
dstack( *args, **kwargs)

    Stack arrays in sequence depth wise (along third axis).

    This is equivalent to concatenation along the third axis after 2-D arrays
    of shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape
    `(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by
    `dsplit`.

    This function makes most sense for arrays with up to 3 dimensions. For
    instance, for pixel-data with a height (first axis), width (second axis),
    and r/g/b channels (third axis). The functions `concatenate`, `stack` and
    `block` provide more general stacking and concatenation operations.

    Parameters
    ----------
    tup : sequence of arrays
        The arrays must have the same shape along all but the third axis.
        1-D or 2-D arrays must have the same shape.

    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays, will be at least 3-D.

    See Also
    --------
    stack : Join a sequence of arrays along a new axis.
    vstack : Stack along first axis.
    hstack : Stack along second axis.
    concatenate : Join a sequence of arrays along an existing axis.
    dsplit : Split array along third axis.

    Examples
    --------
    >>> a = np.array((1,2,3))
    >>> b = np.array((2,3,4))
    >>> np.dstack((a,b))
    array([[[1, 2],
            [2, 3],
            [3, 4]]])

    >>> a = np.array([[1],[2],[3]])
    >>> b = np.array([[2],[3],[4]])
    >>> np.dstack((a,b))
    array([[[1, 2]],
           [[2, 3]],
           [[3, 4]]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val ediff1d : ?to_end:Py.Object.t -> ?to_begin:Py.Object.t -> arr:Py.Object.t -> unit -> Py.Object.t
(**
Compute the differences between consecutive elements of an array.

This function is the equivalent of `numpy.ediff1d` that takes masked
values into account, see `numpy.ediff1d` for details.

See Also
--------
numpy.ediff1d : Equivalent function for ndarrays.
*)

val filled : ?fill_value:[>`Ndarray] Obj.t -> [`MaskedArray of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return input as an array with masked data replaced by a fill value.

If `a` is not a `MaskedArray`, `a` itself is returned.
If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to
``a.fill_value``.

Parameters
----------
a : MaskedArray or array_like
    An input object.
fill_value : array_like, optional.
    Can be scalar or non-scalar. If non-scalar, the
    resulting filled array should be broadcastable
    over input array. Default is None.

Returns
-------
a : ndarray
    The filled array.

See Also
--------
compressed

Examples
--------
>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
...                                                   [1, 0, 0],
...                                                   [0, 0, 0]])
>>> x.filled()
array([[999999,      1,      2],
       [999999,      4,      5],
       [     6,      7,      8]])
>>> x.filled(fill_value=333)
array([[333,   1,   2],
       [333,   4,   5],
       [  6,   7,   8]])
>>> x.filled(fill_value=np.arange(3))
array([[0, 1, 2],
       [0, 4, 5],
       [6, 7, 8]])
*)

val flatnotmasked_contiguous : Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Find contiguous unmasked data in a masked array along the given axis.

Parameters
----------
a : narray
    The input array.

Returns
-------
slice_list : list
    A sorted sequence of `slice` objects (start index, end index).

    ..versionchanged:: 1.15.0
        Now returns an empty list instead of None for a fully masked array

See Also
--------
flatnotmasked_edges, notmasked_contiguous, notmasked_edges
clump_masked, clump_unmasked

Notes
-----
Only accepts 2-D arrays at most.

Examples
--------
>>> a = np.ma.arange(10)
>>> np.ma.flatnotmasked_contiguous(a)
[slice(0, 10, None)]

>>> mask = (a < 3) | (a > 8) | (a == 5)
>>> a[mask] = np.ma.masked
>>> np.array(a[~a.mask])
array([3, 4, 6, 7, 8])

>>> np.ma.flatnotmasked_contiguous(a)
[slice(3, 5, None), slice(6, 9, None)]
>>> a[:] = np.ma.masked
>>> np.ma.flatnotmasked_contiguous(a)
[]
*)

val flatnotmasked_edges : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t option
(**
Find the indices of the first and last unmasked values.

Expects a 1-D `MaskedArray`, returns None if all values are masked.

Parameters
----------
a : array_like
    Input 1-D `MaskedArray`

Returns
-------
edges : ndarray or None
    The indices of first and last non-masked value in the array.
    Returns None if all values are masked.

See Also
--------
flatnotmasked_contiguous, notmasked_contiguous, notmasked_edges
clump_masked, clump_unmasked

Notes
-----
Only accepts 1-D arrays.

Examples
--------
>>> a = np.ma.arange(10)
>>> np.ma.flatnotmasked_edges(a)
array([0, 9])

>>> mask = (a < 3) | (a > 8) | (a == 5)
>>> a[mask] = np.ma.masked
>>> np.array(a[~a.mask])
array([3, 4, 6, 7, 8])

>>> np.ma.flatnotmasked_edges(a)
array([3, 8])

>>> a[:] = np.ma.masked
>>> print(np.ma.flatnotmasked_edges(a))
None
*)

val flatten_inplace : Py.Object.t -> Py.Object.t
(**
Flatten a sequence in place.
*)

val get_masked_subclass : Py.Object.t list -> Py.Object.t
(**
Return the youngest subclass of MaskedArray from a list of (masked) arrays.

In case of siblings, the first listed takes over.
*)

val getdata : ?subok:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the data of a masked array as an ndarray.

Return the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,
else return `a` as a ndarray or subclass (depending on `subok`) if not.

Parameters
----------
a : array_like
    Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.
subok : bool
    Whether to force the output to be a `pure` ndarray (False) or to
    return a subclass of ndarray if appropriate (True, default).

See Also
--------
getmask : Return the mask of a masked array, or nomask.
getmaskarray : Return the mask of a masked array, or full array of False.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getdata(a)
array([[1, 2],
       [3, 4]])

Equivalently use the ``MaskedArray`` `data` attribute.

>>> a.data
array([[1, 2],
       [3, 4]])
*)

val getmask : [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the mask of a masked array, or nomask.

Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the
mask is not `nomask`, else return `nomask`. To guarantee a full array
of booleans of the same shape as a, use `getmaskarray`.

Parameters
----------
a : array_like
    Input `MaskedArray` for which the mask is required.

See Also
--------
getdata : Return the data of a masked array as an ndarray.
getmaskarray : Return the mask of a masked array, or full array of False.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getmask(a)
array([[False,  True],
       [False, False]])

Equivalently use the `MaskedArray` `mask` attribute.

>>> a.mask
array([[False,  True],
       [False, False]])

Result when mask == `nomask`

>>> b = ma.masked_array([[1,2],[3,4]])
>>> b
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> ma.nomask
False
>>> ma.getmask(b) == ma.nomask
True
>>> b.mask == ma.nomask
True
*)

val getmaskarray : [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the mask of a masked array, or full boolean array of False.

Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and
the mask is not `nomask`, else return a full boolean array of False of
the same shape as `arr`.

Parameters
----------
arr : array_like
    Input `MaskedArray` for which the mask is required.

See Also
--------
getmask : Return the mask of a masked array, or nomask.
getdata : Return the data of a masked array as an ndarray.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getmaskarray(a)
array([[False,  True],
       [False, False]])

Result when mask == ``nomask``

>>> b = ma.masked_array([[1,2],[3,4]])
>>> b
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> ma.getmaskarray(b)
array([[False, False],
       [False, False]])
*)

val hsplit : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
hsplit( *args, **kwargs)

    Split an array into multiple sub-arrays horizontally (column-wise).

    Please refer to the `split` documentation.  `hsplit` is equivalent
    to `split` with ``axis=1``, the array is always split along the second
    axis regardless of the array dimension.

    See Also
    --------
    split : Split an array into multiple sub-arrays of equal size.

    Examples
    --------
    >>> x = np.arange(16.0).reshape(4, 4)
    >>> x
    array([[ 0.,   1.,   2.,   3.],
           [ 4.,   5.,   6.,   7.],
           [ 8.,   9.,  10.,  11.],
           [12.,  13.,  14.,  15.]])
    >>> np.hsplit(x, 2)
    [array([[  0.,   1.],
           [  4.,   5.],
           [  8.,   9.],
           [12.,  13.]]),
     array([[  2.,   3.],
           [  6.,   7.],
           [10.,  11.],
           [14.,  15.]])]
    >>> np.hsplit(x, np.array([3, 6]))
    [array([[ 0.,   1.,   2.],
           [ 4.,   5.,   6.],
           [ 8.,   9.,  10.],
           [12.,  13.,  14.]]),
     array([[ 3.],
           [ 7.],
           [11.],
           [15.]]),
     array([], shape=(4, 0), dtype=float64)]

    With a higher dimensional array the split is still along the second axis.

    >>> x = np.arange(8.0).reshape(2, 2, 2)
    >>> x
    array([[[0.,  1.],
            [2.,  3.]],
           [[4.,  5.],
            [6.,  7.]]])
    >>> np.hsplit(x, 2)
    [array([[[0.,  1.]],
           [[4.,  5.]]]),
     array([[[2.,  3.]],
           [[6.,  7.]]])]

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val hstack : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
hstack( *args, **kwargs)

    Stack arrays in sequence horizontally (column wise).

    This is equivalent to concatenation along the second axis, except for 1-D
    arrays where it concatenates along the first axis. Rebuilds arrays divided
    by `hsplit`.

    This function makes most sense for arrays with up to 3 dimensions. For
    instance, for pixel-data with a height (first axis), width (second axis),
    and r/g/b channels (third axis). The functions `concatenate`, `stack` and
    `block` provide more general stacking and concatenation operations.

    Parameters
    ----------
    tup : sequence of ndarrays
        The arrays must have the same shape along all but the second axis,
        except 1-D arrays which can be any length.

    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays.

    See Also
    --------
    stack : Join a sequence of arrays along a new axis.
    vstack : Stack arrays in sequence vertically (row wise).
    dstack : Stack arrays in sequence depth wise (along third axis).
    concatenate : Join a sequence of arrays along an existing axis.
    hsplit : Split array along second axis.
    block : Assemble arrays from blocks.

    Examples
    --------
    >>> a = np.array((1,2,3))
    >>> b = np.array((2,3,4))
    >>> np.hstack((a,b))
    array([1, 2, 3, 2, 3, 4])
    >>> a = np.array([[1],[2],[3]])
    >>> b = np.array([[2],[3],[4]])
    >>> np.hstack((a,b))
    array([[1, 2],
           [2, 3],
           [3, 4]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val in1d : ?assume_unique:Py.Object.t -> ?invert:Py.Object.t -> ar1:Py.Object.t -> ar2:Py.Object.t -> unit -> Py.Object.t
(**
Test whether each element of an array is also present in a second
array.

The output is always a masked array. See `numpy.in1d` for more details.

We recommend using :func:`isin` instead of `in1d` for new code.

See Also
--------
isin       : Version of this function that preserves the shape of ar1.
numpy.in1d : Equivalent function for ndarrays.

Notes
-----
.. versionadded:: 1.4.0
*)

val intersect1d : ?assume_unique:Py.Object.t -> ar1:Py.Object.t -> ar2:Py.Object.t -> unit -> Py.Object.t
(**
Returns the unique elements common to both arrays.

Masked values are considered equal one to the other.
The output is always a masked array.

See `numpy.intersect1d` for more details.

See Also
--------
numpy.intersect1d : Equivalent function for ndarrays.

Examples
--------
>>> x = np.ma.array([1, 3, 3, 3], mask=[0, 0, 0, 1])
>>> y = np.ma.array([3, 1, 1, 1], mask=[0, 0, 0, 1])
>>> np.ma.intersect1d(x, y)
masked_array(data=[1, 3, --],
             mask=[False, False,  True],
       fill_value=999999)
*)

val isin : ?assume_unique:Py.Object.t -> ?invert:Py.Object.t -> element:Py.Object.t -> test_elements:Py.Object.t -> unit -> Py.Object.t
(**
Calculates `element in test_elements`, broadcasting over
`element` only.

The output is always a masked array of the same shape as `element`.
See `numpy.isin` for more details.

See Also
--------
in1d       : Flattened version of this function.
numpy.isin : Equivalent function for ndarrays.

Notes
-----
.. versionadded:: 1.13.0
*)

val issequence : Py.Object.t -> Py.Object.t
(**
Is seq a sequence (ndarray, list or tuple)?
*)

val make_mask_descr : Dtype.t -> Dtype.t
(**
Construct a dtype description list from a given dtype.

Returns a new dtype object, with the type of all fields in `ndtype` to a
boolean type. Field names are not altered.

Parameters
----------
ndtype : dtype
    The dtype to convert.

Returns
-------
result : dtype
    A dtype that looks like `ndtype`, the type of all fields is boolean.

Examples
--------
>>> import numpy.ma as ma
>>> dtype = np.dtype({'names':['foo', 'bar'],
...                   'formats':[np.float32, np.int64]})
>>> dtype
dtype([('foo', '<f4'), ('bar', '<i8')])
>>> ma.make_mask_descr(dtype)
dtype([('foo', '|b1'), ('bar', '|b1')])
>>> ma.make_mask_descr(np.float32)
dtype('bool')
*)

val mask_cols : ?axis:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask columns of a 2D array that contain masked values.

This function is a shortcut to ``mask_rowcols`` with `axis` equal to 1.

See Also
--------
mask_rowcols : Mask rows and/or columns of a 2D array.
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.zeros((3, 3), dtype=int)
>>> a[1, 1] = 1
>>> a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
>>> a = ma.masked_equal(a, 1)
>>> a
masked_array(
  data=[[0, 0, 0],
        [0, --, 0],
        [0, 0, 0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1)
>>> ma.mask_cols(a)
masked_array(
  data=[[0, --, 0],
        [0, --, 0],
        [0, --, 0]],
  mask=[[False,  True, False],
        [False,  True, False],
        [False,  True, False]],
  fill_value=1)
*)

val mask_or : ?copy:bool -> ?shrink:bool -> m1:Py.Object.t -> m2:Py.Object.t -> unit -> Py.Object.t
(**
Combine two masks with the ``logical_or`` operator.

The result may be a view on `m1` or `m2` if the other is `nomask`
(i.e. False).

Parameters
----------
m1, m2 : array_like
    Input masks.
copy : bool, optional
    If copy is False and one of the inputs is `nomask`, return a view
    of the other input mask. Defaults to False.
shrink : bool, optional
    Whether to shrink the output to `nomask` if all its values are
    False. Defaults to True.

Returns
-------
mask : output mask
    The result masks values that are masked in either `m1` or `m2`.

Raises
------
ValueError
    If `m1` and `m2` have different flexible dtypes.

Examples
--------
>>> m1 = np.ma.make_mask([0, 1, 1, 0])
>>> m2 = np.ma.make_mask([1, 0, 0, 0])
>>> np.ma.mask_or(m1, m2)
array([ True,  True,  True, False])
*)

val mask_rowcols : ?axis:int -> [`MaskedArray of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
Mask rows and/or columns of a 2D array that contain masked values.

Mask whole rows and/or columns of a 2D array that contain
masked values.  The masking behavior is selected using the
`axis` parameter.

  - If `axis` is None, rows *and* columns are masked.
  - If `axis` is 0, only rows are masked.
  - If `axis` is 1 or -1, only columns are masked.

Parameters
----------
a : array_like, MaskedArray
    The array to mask.  If not a MaskedArray instance (or if no array
    elements are masked).  The result is a MaskedArray with `mask` set
    to `nomask` (False). Must be a 2D array.
axis : int, optional
    Axis along which to perform the operation. If None, applies to a
    flattened version of the array.

Returns
-------
a : MaskedArray
    A modified version of the input array, masked depending on the value
    of the `axis` parameter.

Raises
------
NotImplementedError
    If input array `a` is not 2D.

See Also
--------
mask_rows : Mask rows of a 2D array that contain masked values.
mask_cols : Mask cols of a 2D array that contain masked values.
masked_where : Mask where a condition is met.

Notes
-----
The input array's mask is modified by this function.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.zeros((3, 3), dtype=int)
>>> a[1, 1] = 1
>>> a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
>>> a = ma.masked_equal(a, 1)
>>> a
masked_array(
  data=[[0, 0, 0],
        [0, --, 0],
        [0, 0, 0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1)
>>> ma.mask_rowcols(a)
masked_array(
  data=[[0, --, 0],
        [--, --, --],
        [0, --, 0]],
  mask=[[False,  True, False],
        [ True,  True,  True],
        [False,  True, False]],
  fill_value=1)
*)

val mask_rows : ?axis:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask rows of a 2D array that contain masked values.

This function is a shortcut to ``mask_rowcols`` with `axis` equal to 0.

See Also
--------
mask_rowcols : Mask rows and/or columns of a 2D array.
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.zeros((3, 3), dtype=int)
>>> a[1, 1] = 1
>>> a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
>>> a = ma.masked_equal(a, 1)
>>> a
masked_array(
  data=[[0, 0, 0],
        [0, --, 0],
        [0, 0, 0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1)

>>> ma.mask_rows(a)
masked_array(
  data=[[0, 0, 0],
        [--, --, --],
        [0, 0, 0]],
  mask=[[False, False, False],
        [ True,  True,  True],
        [False, False, False]],
  fill_value=1)
*)

val masked_all : ?dtype:Dtype.t -> int list -> Py.Object.t
(**
Empty masked array with all elements masked.

Return an empty masked array of the given shape and dtype, where all the
data are masked.

Parameters
----------
shape : tuple
    Shape of the required MaskedArray.
dtype : dtype, optional
    Data type of the output.

Returns
-------
a : MaskedArray
    A masked array with all data masked.

See Also
--------
masked_all_like : Empty masked array modelled on an existing array.

Examples
--------
>>> import numpy.ma as ma
>>> ma.masked_all((3, 3))
masked_array(
  data=[[--, --, --],
        [--, --, --],
        [--, --, --]],
  mask=[[ True,  True,  True],
        [ True,  True,  True],
        [ True,  True,  True]],
  fill_value=1e+20,
  dtype=float64)

The `dtype` parameter defines the underlying data type.

>>> a = ma.masked_all((3, 3))
>>> a.dtype
dtype('float64')
>>> a = ma.masked_all((3, 3), dtype=np.int32)
>>> a.dtype
dtype('int32')
*)

val masked_all_like : [>`Ndarray] Obj.t -> Py.Object.t
(**
Empty masked array with the properties of an existing array.

Return an empty masked array of the same shape and dtype as
the array `arr`, where all the data are masked.

Parameters
----------
arr : ndarray
    An array describing the shape and dtype of the required MaskedArray.

Returns
-------
a : MaskedArray
    A masked array with all data masked.

Raises
------
AttributeError
    If `arr` doesn't have a shape attribute (i.e. not an ndarray)

See Also
--------
masked_all : Empty masked array with all elements masked.

Examples
--------
>>> import numpy.ma as ma
>>> arr = np.zeros((2, 3), dtype=np.float32)
>>> arr
array([[0., 0., 0.],
       [0., 0., 0.]], dtype=float32)
>>> ma.masked_all_like(arr)
masked_array(
  data=[[--, --, --],
        [--, --, --]],
  mask=[[ True,  True,  True],
        [ True,  True,  True]],
  fill_value=1e+20,
  dtype=float32)

The dtype of the masked array matches the dtype of `arr`.

>>> arr.dtype
dtype('float32')
>>> ma.masked_all_like(arr).dtype
dtype('float32')
*)

val median : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?overwrite_input:bool -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the median along the specified axis.

Returns the median of the array elements.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : int, optional
    Axis along which the medians are computed. The default (None) is
    to compute the median along a flattened version of the array.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow use of memory of input array (a) for
    calculations. The input array will be modified by the call to
    median. This will save memory when you do not need to preserve
    the contents of the input array. Treat the input as undefined,
    but it will probably be fully or partially sorted. Default is
    False. Note that, if `overwrite_input` is True, and the input
    is not already an `ndarray`, an error will be raised.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    .. versionadded:: 1.10.0

Returns
-------
median : ndarray
    A new array holding the result is returned unless out is
    specified, in which case a reference to out is returned.
    Return data-type is `float64` for integers and floats smaller than
    `float64`, or the input data-type, otherwise.

See Also
--------
mean

Notes
-----
Given a vector ``V`` with ``N`` non masked values, the median of ``V``
is the middle value of a sorted copy of ``V`` (``Vs``) - i.e.
``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2``
when ``N`` is even.

Examples
--------
>>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)
>>> np.ma.median(x)
1.5

>>> x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)
>>> np.ma.median(x)
2.5
>>> np.ma.median(x, axis=-1, overwrite_input=True)
masked_array(data=[2.0, 5.0],
             mask=[False, False],
       fill_value=1e+20)
*)

val normalize_axis_index : ?msg_prefix:string -> axis:int -> ndim:int -> unit -> int
(**
normalize_axis_index(axis, ndim, msg_prefix=None)

Normalizes an axis index, `axis`, such that is a valid positive index into
the shape of array with `ndim` dimensions. Raises an AxisError with an
appropriate message if this is not possible.

Used internally by all axis-checking logic.

.. versionadded:: 1.13.0

Parameters
----------
axis : int
    The un-normalized index of the axis. Can be negative
ndim : int
    The number of dimensions of the array that `axis` should be normalized
    against
msg_prefix : str
    A prefix to put before the message, typically the name of the argument

Returns
-------
normalized_axis : int
    The normalized axis index, such that `0 <= normalized_axis < ndim`

Raises
------
AxisError
    If the axis index is invalid, when `-ndim <= axis < ndim` is false.

Examples
--------
>>> normalize_axis_index(0, ndim=3)
0
>>> normalize_axis_index(1, ndim=3)
1
>>> normalize_axis_index(-1, ndim=3)
2

>>> normalize_axis_index(3, ndim=3)
Traceback (most recent call last):
...
AxisError: axis 3 is out of bounds for array of dimension 3
>>> normalize_axis_index(-4, ndim=3, msg_prefix='axes_arg')
Traceback (most recent call last):
...
AxisError: axes_arg: axis -4 is out of bounds for array of dimension 3
*)

val normalize_axis_tuple : ?argname:string -> ?allow_duplicate:bool -> axis:[`I of int | `Iterable_of_int of Py.Object.t] -> ndim:int -> unit -> Py.Object.t
(**
Normalizes an axis argument into a tuple of non-negative integer axes.

This handles shorthands such as ``1`` and converts them to ``(1,)``,
as well as performing the handling of negative indices covered by
`normalize_axis_index`.

By default, this forbids axes from being specified multiple times.

Used internally by multi-axis-checking logic.

.. versionadded:: 1.13.0

Parameters
----------
axis : int, iterable of int
    The un-normalized index or indices of the axis.
ndim : int
    The number of dimensions of the array that `axis` should be normalized
    against.
argname : str, optional
    A prefix to put before the error message, typically the name of the
    argument.
allow_duplicate : bool, optional
    If False, the default, disallow an axis from being specified twice.

Returns
-------
normalized_axes : tuple of int
    The normalized axis index, such that `0 <= normalized_axis < ndim`

Raises
------
AxisError
    If any axis provided is out of range
ValueError
    If an axis is repeated

See also
--------
normalize_axis_index : normalizing a single scalar axis
*)

val notmasked_contiguous : ?axis:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Find contiguous unmasked data in a masked array along the given axis.

Parameters
----------
a : array_like
    The input array.
axis : int, optional
    Axis along which to perform the operation.
    If None (default), applies to a flattened version of the array, and this
    is the same as `flatnotmasked_contiguous`.

Returns
-------
endpoints : list
    A list of slices (start and end indexes) of unmasked indexes
    in the array.

    If the input is 2d and axis is specified, the result is a list of lists.

See Also
--------
flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges
clump_masked, clump_unmasked

Notes
-----
Only accepts 2-D arrays at most.

Examples
--------
>>> a = np.arange(12).reshape((3, 4))
>>> mask = np.zeros_like(a)
>>> mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0
>>> ma = np.ma.array(a, mask=mask)
>>> ma
masked_array(
  data=[[0, --, 2, 3],
        [--, --, --, 7],
        [8, --, --, 11]],
  mask=[[False,  True, False, False],
        [ True,  True,  True, False],
        [False,  True,  True, False]],
  fill_value=999999)
>>> np.array(ma[~ma.mask])
array([ 0,  2,  3,  7, 8, 11])

>>> np.ma.notmasked_contiguous(ma)
[slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]

>>> np.ma.notmasked_contiguous(ma, axis=0)
[[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]]

>>> np.ma.notmasked_contiguous(ma, axis=1)
[[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]]
*)

val notmasked_edges : ?axis:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Find the indices of the first and last unmasked values along an axis.

If all values are masked, return None.  Otherwise, return a list
of two tuples, corresponding to the indices of the first and last
unmasked values respectively.

Parameters
----------
a : array_like
    The input array.
axis : int, optional
    Axis along which to perform the operation.
    If None (default), applies to a flattened version of the array.

Returns
-------
edges : ndarray or list
    An array of start and end indexes if there are any masked data in
    the array. If there are no masked data in the array, `edges` is a
    list of the first and last index.

See Also
--------
flatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous
clump_masked, clump_unmasked

Examples
--------
>>> a = np.arange(9).reshape((3, 3))
>>> m = np.zeros_like(a)
>>> m[1:, 1:] = 1

>>> am = np.ma.array(a, mask=m)
>>> np.array(am[~am.mask])
array([0, 1, 2, 3, 6])

>>> np.ma.notmasked_edges(am)
array([0, 6])
*)

val nxarray : ?dtype:Dtype.t -> ?copy:bool -> ?order:[`K | `A | `C | `F] -> ?subok:bool -> ?ndmin:int -> object_:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)

Create an array.

Parameters
----------
object : array_like
    An array, any object exposing the array interface, an object whose
    __array__ method returns an array, or any (nested) sequence.
dtype : data-type, optional
    The desired data-type for the array.  If not given, then the type will
    be determined as the minimum type required to hold the objects in the
    sequence.
copy : bool, optional
    If true (default), then the object is copied.  Otherwise, a copy will
    only be made if __array__ returns a copy, if obj is a nested sequence,
    or if a copy is needed to satisfy any of the other requirements
    (`dtype`, `order`, etc.).
order : {'K', 'A', 'C', 'F'}, optional
    Specify the memory layout of the array. If object is not an array, the
    newly created array will be in C order (row major) unless 'F' is
    specified, in which case it will be in Fortran order (column major).
    If object is an array the following holds.

    ===== ========= ===================================================
    order  no copy                     copy=True
    ===== ========= ===================================================
    'K'   unchanged F & C order preserved, otherwise most similar order
    'A'   unchanged F order if input is F and not C, otherwise C order
    'C'   C order   C order
    'F'   F order   F order
    ===== ========= ===================================================

    When ``copy=False`` and a copy is made for other reasons, the result is
    the same as if ``copy=True``, with some exceptions for `A`, see the
    Notes section. The default order is 'K'.
subok : bool, optional
    If True, then sub-classes will be passed-through, otherwise
    the returned array will be forced to be a base-class array (default).
ndmin : int, optional
    Specifies the minimum number of dimensions that the resulting
    array should have.  Ones will be pre-pended to the shape as
    needed to meet this requirement.

Returns
-------
out : ndarray
    An array object satisfying the specified requirements.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Notes
-----
When order is 'A' and `object` is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.

Examples
--------
>>> np.array([1, 2, 3])
array([1, 2, 3])

Upcasting:

>>> np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])

More than one dimension:

>>> np.array([[1, 2], [3, 4]])
array([[1, 2],
       [3, 4]])

Minimum dimensions 2:

>>> np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])

Type provided:

>>> np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])

Data-type consisting of more than one element:

>>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])
>>> x['a']
array([1, 3])

Creating an array from sub-classes:

>>> np.array(np.mat('1 2; 3 4'))
array([[1, 2],
       [3, 4]])

>>> np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
        [3, 4]])
*)

val ones : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
ones(shape, dtype=None, order='C')

Return a new array of given shape and type, filled with ones.

Parameters
----------
shape : int or sequence of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: C
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of ones with the given shape, dtype, and order.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
empty : Return a new uninitialized array.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Examples
--------
>>> np.ones(5)
array([1., 1., 1., 1., 1.])

>>> np.ones((5,), dtype=int)
array([1, 1, 1, 1, 1])

>>> np.ones((2, 1))
array([[1.],
       [1.]])

>>> s = (2,2)
>>> np.ones(s)
array([[1.,  1.],
       [1.,  1.]])
*)

val polyfit : ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> ?cov:[`Bool of bool | `S of string] -> y:[>`Ndarray] Obj.t -> deg:int -> [>`Ndarray] Obj.t -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Least squares polynomial fit.

Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`
to points `(x, y)`. Returns a vector of coefficients `p` that minimises
the squared error in the order `deg`, `deg-1`, ... `0`.

The `Polynomial.fit <numpy.polynomial.polynomial.Polynomial.fit>` class
method is recommended for new code as it is more stable numerically. See
the documentation of the method for more information.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int
    Degree of the fitting polynomial
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (M,), optional
    Weights to apply to the y-coordinates of the sample points. For
    gaussian uncertainties, use 1/sigma (not 1/sigma**2).
cov : bool or str, optional
    If given and not `False`, return not just the estimate but also its
    covariance matrix. By default, the covariance are scaled by
    chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable
    except in a relative sense and everything is scaled such that the
    reduced chi2 is unity. This scaling is omitted if ``cov='unscaled'``,
    as is relevant for the case that the weights are 1/sigma**2, with
    sigma known to be a reliable estimate of the uncertainty.

Returns
-------
p : ndarray, shape (deg + 1,) or (deg + 1, K)
    Polynomial coefficients, highest power first.  If `y` was 2-D, the
    coefficients for `k`-th data set are in ``p[:,k]``.

residuals, rank, singular_values, rcond
    Present only if `full` = True.  Residuals is sum of squared residuals
    of the least-squares fit, the effective rank of the scaled Vandermonde
    coefficient matrix, its singular values, and the specified value of
    `rcond`. For more details, see `linalg.lstsq`.

V : ndarray, shape (M,M) or (M,M,K)
    Present only if `full` = False and `cov`=True.  The covariance
    matrix of the polynomial coefficient estimates.  The diagonal of
    this matrix are the variance estimates for each coefficient.  If y
    is a 2-D array, then the covariance matrix for the `k`-th data set
    are in ``V[:,:,k]``


Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.

    The warnings can be turned off by

    >>> import warnings
    >>> warnings.simplefilter('ignore', np.RankWarning)

See Also
--------
polyval : Compute polynomial values.
linalg.lstsq : Computes a least-squares fit.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----

Any masked values in x is propagated in y, and vice-versa.



The solution minimizes the squared error

.. math ::
    E = \sum_{j=0}^k |p(x_j) - y_j|^2

in the equations::

    x[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]
    x[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]
    ...
    x[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]

The coefficient matrix of the coefficients `p` is a Vandermonde matrix.

`polyfit` issues a `RankWarning` when the least-squares fit is badly
conditioned. This implies that the best fit is not well-defined due
to numerical error. The results may be improved by lowering the polynomial
degree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter
can also be set to a value smaller than its default, but the resulting
fit may be spurious: including contributions from the small singular
values can add numerical noise to the result.

Note that fitting polynomial coefficients is inherently badly conditioned
when the degree of the polynomial is large or the interval of sample points
is badly centered. The quality of the fit should always be checked in these
cases. When polynomial fits are not satisfactory, splines may be a good
alternative.

References
----------
.. [1] Wikipedia, 'Curve fitting',
       https://en.wikipedia.org/wiki/Curve_fitting
.. [2] Wikipedia, 'Polynomial interpolation',
       https://en.wikipedia.org/wiki/Polynomial_interpolation

Examples
--------
>>> import warnings
>>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])
>>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])
>>> z = np.polyfit(x, y, 3)
>>> z
array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary

It is convenient to use `poly1d` objects for dealing with polynomials:

>>> p = np.poly1d(z)
>>> p(0.5)
0.6143849206349179 # may vary
>>> p(3.5)
-0.34732142857143039 # may vary
>>> p(10)
22.579365079365115 # may vary

High-order polynomials may oscillate wildly:

>>> with warnings.catch_warnings():
...     warnings.simplefilter('ignore', np.RankWarning)
...     p30 = np.poly1d(np.polyfit(x, y, 30))
...
>>> p30(4)
-0.80000000000000204 # may vary
>>> p30(5)
-0.99999999999999445 # may vary
>>> p30(4.5)
-0.10547061179440398 # may vary

Illustration:

>>> import matplotlib.pyplot as plt
>>> xp = np.linspace(-2, 6, 100)
>>> _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')
>>> plt.ylim(-2,2)
(-2, 2)
>>> plt.show()
*)

val row_stack : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
vstack( *args, **kwargs)

    Stack arrays in sequence vertically (row wise).

    This is equivalent to concatenation along the first axis after 1-D arrays
    of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by
    `vsplit`.

    This function makes most sense for arrays with up to 3 dimensions. For
    instance, for pixel-data with a height (first axis), width (second axis),
    and r/g/b channels (third axis). The functions `concatenate`, `stack` and
    `block` provide more general stacking and concatenation operations.

    Parameters
    ----------
    tup : sequence of ndarrays
        The arrays must have the same shape along all but the first axis.
        1-D arrays must have the same length.

    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays, will be at least 2-D.

    See Also
    --------
    stack : Join a sequence of arrays along a new axis.
    hstack : Stack arrays in sequence horizontally (column wise).
    dstack : Stack arrays in sequence depth wise (along third dimension).
    concatenate : Join a sequence of arrays along an existing axis.
    vsplit : Split array into a list of multiple sub-arrays vertically.
    block : Assemble arrays from blocks.

    Examples
    --------
    >>> a = np.array([1, 2, 3])
    >>> b = np.array([2, 3, 4])
    >>> np.vstack((a,b))
    array([[1, 2, 3],
           [2, 3, 4]])

    >>> a = np.array([[1], [2], [3]])
    >>> b = np.array([[2], [3], [4]])
    >>> np.vstack((a,b))
    array([[1],
           [2],
           [3],
           [2],
           [3],
           [4]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val setdiff1d : ?assume_unique:Py.Object.t -> ar1:Py.Object.t -> ar2:Py.Object.t -> unit -> Py.Object.t
(**
Set difference of 1D arrays with unique elements.

The output is always a masked array. See `numpy.setdiff1d` for more
details.

See Also
--------
numpy.setdiff1d : Equivalent function for ndarrays.

Examples
--------
>>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])
>>> np.ma.setdiff1d(x, [1, 2])
masked_array(data=[3, --],
             mask=[False,  True],
       fill_value=999999)
*)

val setxor1d : ?assume_unique:Py.Object.t -> ar1:Py.Object.t -> ar2:Py.Object.t -> unit -> Py.Object.t
(**
Set exclusive-or of 1-D arrays with unique elements.

The output is always a masked array. See `numpy.setxor1d` for more details.

See Also
--------
numpy.setxor1d : Equivalent function for ndarrays.
*)

val sort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[>`Ndarray] Obj.t -> ?endwith:bool -> ?fill_value:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Sort the array, in-place

Parameters
----------
a : array_like
    Array to be sorted.
axis : int, optional
    Axis along which to sort. If None, the array is flattened before
    sorting. The default is -1, which sorts along the last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    The sorting algorithm used.
order : list, optional
    When `a` is a structured array, this argument specifies which fields
    to compare first, second, and so on.  This list does not need to
    include all of the fields.
endwith : {True, False}, optional
    Whether missing values (if any) should be treated as the largest values
    (True) or the smallest values (False)
    When the array contains unmasked values sorting at the same extremes of the
    datatype, the ordering of these values and the masked values is
    undefined.
fill_value : {var}, optional
    Value used internally for the masked values.
    If ``fill_value`` is not None, it supersedes ``endwith``.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
numpy.ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.

Notes
-----
See ``sort`` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Default
>>> a.sort()
>>> a
masked_array(data=[1, 3, 5, --, --],
             mask=[False, False, False,  True,  True],
       fill_value=999999)

>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Put missing values in the front
>>> a.sort(endwith=False)
>>> a
masked_array(data=[--, --, 1, 3, 5],
             mask=[ True,  True, False, False, False],
       fill_value=999999)

>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # fill_value takes over endwith
>>> a.sort(endwith=False, fill_value=3)
>>> a
masked_array(data=[1, --, --, 3, 5],
             mask=[False,  True,  True, False, False],
       fill_value=999999)
*)

val stack : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
stack( *args, **kwargs)

    Join a sequence of arrays along a new axis.

    The ``axis`` parameter specifies the index of the new axis in the
    dimensions of the result. For example, if ``axis=0`` it will be the first
    dimension and if ``axis=-1`` it will be the last dimension.

    .. versionadded:: 1.10.0

    Parameters
    ----------
    arrays : sequence of array_like
        Each array must have the same shape.

    axis : int, optional
        The axis in the result array along which the input arrays are stacked.

    out : ndarray, optional
        If provided, the destination to place the result. The shape must be
        correct, matching that of what stack would have returned if no
        out argument were specified.

    Returns
    -------
    stacked : ndarray
        The stacked array has one more dimension than the input arrays.

    See Also
    --------
    concatenate : Join a sequence of arrays along an existing axis.
    split : Split array into a list of multiple sub-arrays of equal size.
    block : Assemble arrays from blocks.

    Examples
    --------
    >>> arrays = [np.random.randn(3, 4) for _ in range(10)]
    >>> np.stack(arrays, axis=0).shape
    (10, 3, 4)

    >>> np.stack(arrays, axis=1).shape
    (3, 10, 4)

    >>> np.stack(arrays, axis=2).shape
    (3, 4, 10)

    >>> a = np.array([1, 2, 3])
    >>> b = np.array([2, 3, 4])
    >>> np.stack((a, b))
    array([[1, 2, 3],
           [2, 3, 4]])

    >>> np.stack((a, b), axis=-1)
    array([[1, 2],
           [2, 3],
           [3, 4]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val union1d : ar1:Py.Object.t -> ar2:Py.Object.t -> unit -> Py.Object.t
(**
Union of two arrays.

The output is always a masked array. See `numpy.union1d` for more details.

See also
--------
numpy.union1d : Equivalent function for ndarrays.
*)

val unique : ?return_index:Py.Object.t -> ?return_inverse:Py.Object.t -> ar1:Py.Object.t -> unit -> Py.Object.t
(**
Finds the unique elements of an array.

Masked values are considered the same element (masked). The output array
is always a masked array. See `numpy.unique` for more details.

See Also
--------
numpy.unique : Equivalent function for ndarrays.
*)

val vander : ?n:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Generate a Vandermonde matrix.

The columns of the output matrix are powers of the input vector. The
order of the powers is determined by the `increasing` boolean argument.
Specifically, when `increasing` is False, the `i`-th output column is
the input vector raised element-wise to the power of ``N - i - 1``. Such
a matrix with a geometric progression in each row is named for Alexandre-
Theophile Vandermonde.

Parameters
----------
x : array_like
    1-D input array.
N : int, optional
    Number of columns in the output.  If `N` is not specified, a square
    array is returned (``N = len(x)``).
increasing : bool, optional
    Order of the powers of the columns.  If True, the powers increase
    from left to right, if False (the default) they are reversed.

    .. versionadded:: 1.9.0

Returns
-------
out : ndarray
    Vandermonde matrix.  If `increasing` is False, the first column is
    ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is
    True, the columns are ``x^0, x^1, ..., x^(N-1)``.

See Also
--------
polynomial.polynomial.polyvander

Examples
--------
>>> x = np.array([1, 2, 3, 5])
>>> N = 3
>>> np.vander(x, N)
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

>>> np.column_stack([x**(N-1-i) for i in range(N)])
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

>>> x = np.array([1, 2, 3, 5])
>>> np.vander(x)
array([[  1,   1,   1,   1],
       [  8,   4,   2,   1],
       [ 27,   9,   3,   1],
       [125,  25,   5,   1]])
>>> np.vander(x, increasing=True)
array([[  1,   1,   1,   1],
       [  1,   2,   4,   8],
       [  1,   3,   9,  27],
       [  1,   5,  25, 125]])

The determinant of a square Vandermonde matrix is the product
of the differences between the values of the input vector:

>>> np.linalg.det(np.vander(x))
48.000000000000043 # may vary
>>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)
48

Notes
-----

Masked values in the input array result in rows of zeros.
*)

val vstack : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
vstack( *args, **kwargs)

    Stack arrays in sequence vertically (row wise).

    This is equivalent to concatenation along the first axis after 1-D arrays
    of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by
    `vsplit`.

    This function makes most sense for arrays with up to 3 dimensions. For
    instance, for pixel-data with a height (first axis), width (second axis),
    and r/g/b channels (third axis). The functions `concatenate`, `stack` and
    `block` provide more general stacking and concatenation operations.

    Parameters
    ----------
    tup : sequence of ndarrays
        The arrays must have the same shape along all but the first axis.
        1-D arrays must have the same length.

    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays, will be at least 2-D.

    See Also
    --------
    stack : Join a sequence of arrays along a new axis.
    hstack : Stack arrays in sequence horizontally (column wise).
    dstack : Stack arrays in sequence depth wise (along third dimension).
    concatenate : Join a sequence of arrays along an existing axis.
    vsplit : Split array into a list of multiple sub-arrays vertically.
    block : Assemble arrays from blocks.

    Examples
    --------
    >>> a = np.array([1, 2, 3])
    >>> b = np.array([2, 3, 4])
    >>> np.vstack((a,b))
    array([[1, 2, 3],
           [2, 3, 4]])

    >>> a = np.array([[1], [2], [3]])
    >>> b = np.array([[2], [3], [4]])
    >>> np.vstack((a,b))
    array([[1],
           [2],
           [3],
           [2],
           [3],
           [4]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val zeros : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
zeros(shape, dtype=float, order='C')

Return a new array of given shape and type, filled with zeros.

Parameters
----------
shape : int or tuple of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: 'C'
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of zeros with the given shape, dtype, and order.

See Also
--------
zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.

Examples
--------
>>> np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])

>>> np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])

>>> np.zeros((2, 1))
array([[ 0.],
       [ 0.]])

>>> s = (2,2)
>>> np.zeros(s)
array([[ 0.,  0.],
       [ 0.,  0.]])

>>> np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
      dtype=[('x', '<i4'), ('y', '<i4')])
*)


end

val abs : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Calculate the absolute value element-wise.

``np.abs`` is a shorthand for this function.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
absolute : ndarray
    An ndarray containing the absolute value of
    each element in `x`.  For complex input, ``a + ib``, the
    absolute value is :math:`\sqrt{ a^2 + b^2 }`.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> x = np.array([-1.2, 1.2])
>>> np.absolute(x)
array([ 1.2,  1.2])
>>> np.absolute(1.2 + 1j)
1.5620499351813308

Plot the function over ``[-10, 10]``:

>>> import matplotlib.pyplot as plt

>>> x = np.linspace(start=-10, stop=10, num=101)
>>> plt.plot(x, np.absolute(x))
>>> plt.show()

Plot the function over the complex plane:

>>> xx = x + 1j * x[:, np.newaxis]
>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
>>> plt.show()
*)

val absolute : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Calculate the absolute value element-wise.

``np.abs`` is a shorthand for this function.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
absolute : ndarray
    An ndarray containing the absolute value of
    each element in `x`.  For complex input, ``a + ib``, the
    absolute value is :math:`\sqrt{ a^2 + b^2 }`.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> x = np.array([-1.2, 1.2])
>>> np.absolute(x)
array([ 1.2,  1.2])
>>> np.absolute(1.2 + 1j)
1.5620499351813308

Plot the function over ``[-10, 10]``:

>>> import matplotlib.pyplot as plt

>>> x = np.linspace(start=-10, stop=10, num=101)
>>> plt.plot(x, np.absolute(x))
>>> plt.show()

Plot the function over the complex plane:

>>> xx = x + 1j * x[:, np.newaxis]
>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
>>> plt.show()
*)

val add : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Add arguments element-wise.

Parameters
----------
x1, x2 : array_like
    The arrays to be added. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
add : ndarray or scalar
    The sum of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
Equivalent to `x1` + `x2` in terms of array broadcasting.

Examples
--------
>>> np.add(1.0, 4.0)
5.0
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.add(x1, x2)
array([[  0.,   2.,   4.],
       [  3.,   5.,   7.],
       [  6.,   8.,  10.]])
*)

val all : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
all(self, axis=None, out=None, keepdims=<no value>)

Returns True if all elements evaluate to True.

The output array is masked where all the values along the given axis
are masked: if the output would have been a scalar and that all the
values are masked, then the output is `masked`.

Refer to `numpy.all` for full documentation.

See Also
--------
numpy.ndarray.all : corresponding function for ndarrays
numpy.all : equivalent function

Examples
--------
>>> np.ma.array([1,2,3]).all()
True
>>> a = np.ma.array([1,2,3], mask=True)
>>> (a.all() is np.ma.masked)
True
*)

val allclose : ?masked_equal:bool -> ?rtol:float -> ?atol:float -> b:Py.Object.t -> Py.Object.t -> bool
(**
Returns True if two arrays are element-wise equal within a tolerance.

This function is equivalent to `allclose` except that masked values
are treated as equal (default) or unequal, depending on the `masked_equal`
argument.

Parameters
----------
a, b : array_like
    Input arrays to compare.
masked_equal : bool, optional
    Whether masked values in `a` and `b` are considered equal (True) or not
    (False). They are considered equal by default.
rtol : float, optional
    Relative tolerance. The relative difference is equal to ``rtol * b``.
    Default is 1e-5.
atol : float, optional
    Absolute tolerance. The absolute difference is equal to `atol`.
    Default is 1e-8.

Returns
-------
y : bool
    Returns True if the two arrays are equal within the given
    tolerance, False otherwise. If either array contains NaN, then
    False is returned.

See Also
--------
all, any
numpy.allclose : the non-masked `allclose`.

Notes
-----
If the following equation is element-wise True, then `allclose` returns
True::

  absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))

Return True if all elements of `a` and `b` are equal subject to
given tolerances.

Examples
--------
>>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
>>> a
masked_array(data=[10000000000.0, 1e-07, --],
             mask=[False, False,  True],
       fill_value=1e+20)
>>> b = np.ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])
>>> np.ma.allclose(a, b)
False

>>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
>>> b = np.ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])
>>> np.ma.allclose(a, b)
True
>>> np.ma.allclose(a, b, masked_equal=False)
False

Masked values are not compared directly.

>>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
>>> b = np.ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])
>>> np.ma.allclose(a, b)
True
>>> np.ma.allclose(a, b, masked_equal=False)
False
*)

val allequal : ?fill_value:bool -> b:Py.Object.t -> Py.Object.t -> bool
(**
Return True if all entries of a and b are equal, using
fill_value as a truth value where either or both are masked.

Parameters
----------
a, b : array_like
    Input arrays to compare.
fill_value : bool, optional
    Whether masked values in a or b are considered equal (True) or not
    (False).

Returns
-------
y : bool
    Returns True if the two arrays are equal within the given
    tolerance, False otherwise. If either array contains NaN,
    then False is returned.

See Also
--------
all, any
numpy.ma.allclose

Examples
--------
>>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
>>> a
masked_array(data=[10000000000.0, 1e-07, --],
             mask=[False, False,  True],
       fill_value=1e+20)

>>> b = np.array([1e10, 1e-7, -42.0])
>>> b
array([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])
>>> np.ma.allequal(a, b, fill_value=False)
False
>>> np.ma.allequal(a, b)
True
*)

val alltrue : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> target:Py.Object.t -> unit -> Py.Object.t
(**
Reduce `target` along the given `axis`.
*)

val amax : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> ?initial:[`F of float | `I of int | `Bool of bool | `S of string] -> ?where:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the maximum of an array or maximum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, the maximum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `amax` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

initial : scalar, optional
    The minimum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to compare for the maximum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.17.0

Returns
-------
amax : ndarray or scalar
    Maximum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amin :
    The minimum value of an array along a given axis, propagating any NaNs.
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
argmax :
    Return the indices of the maximum values.

nanmin, minimum, fmin

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.

Don't use `amax` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
``amax(a, axis=0)``.

Examples
--------
>>> a = np.arange(4).reshape((2,2))
>>> a
array([[0, 1],
       [2, 3]])
>>> np.amax(a)           # Maximum of the flattened array
3
>>> np.amax(a, axis=0)   # Maxima along the first axis
array([2, 3])
>>> np.amax(a, axis=1)   # Maxima along the second axis
array([1, 3])
>>> np.amax(a, where=[False, True], initial=-1, axis=0)
array([-1,  3])
>>> b = np.arange(5, dtype=float)
>>> b[2] = np.NaN
>>> np.amax(b)
nan
>>> np.amax(b, where=~np.isnan(b), initial=-1)
4.0
>>> np.nanmax(b)
4.0

You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:

>>> np.max([[-50], [10]], axis=-1, initial=0)
array([ 0, 10])

Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.

>>> np.max([5], initial=6)
6
>>> max([5], default=6)
5
*)

val amin : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> ?initial:[`F of float | `I of int | `Bool of bool | `S of string] -> ?where:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the minimum of an array or minimum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, the minimum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `amin` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

initial : scalar, optional
    The maximum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to compare for the minimum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.17.0

Returns
-------
amin : ndarray or scalar
    Minimum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amax :
    The maximum value of an array along a given axis, propagating any NaNs.
nanmin :
    The minimum value of an array along a given axis, ignoring any NaNs.
minimum :
    Element-wise minimum of two arrays, propagating any NaNs.
fmin :
    Element-wise minimum of two arrays, ignoring any NaNs.
argmin :
    Return the indices of the minimum values.

nanmax, maximum, fmax

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.

Don't use `amin` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
``amin(a, axis=0)``.

Examples
--------
>>> a = np.arange(4).reshape((2,2))
>>> a
array([[0, 1],
       [2, 3]])
>>> np.amin(a)           # Minimum of the flattened array
0
>>> np.amin(a, axis=0)   # Minima along the first axis
array([0, 1])
>>> np.amin(a, axis=1)   # Minima along the second axis
array([0, 2])
>>> np.amin(a, where=[False, True], initial=10, axis=0)
array([10,  1])

>>> b = np.arange(5, dtype=float)
>>> b[2] = np.NaN
>>> np.amin(b)
nan
>>> np.amin(b, where=~np.isnan(b), initial=10)
0.0
>>> np.nanmin(b)
0.0

>>> np.min([[-50], [10]], axis=-1, initial=0)
array([-50,   0])

Notice that the initial value is used as one of the elements for which the
minimum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.

Notice that this isn't the same as Python's ``default`` argument.

>>> np.min([6], initial=5)
5
>>> min([6], default=5)
6
*)

val angle : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the angle of the complex argument.

Parameters
----------
z : array_like
    A complex number or sequence of complex numbers.
deg : bool, optional
    Return angle in degrees if True, radians if False (default).

Returns
-------
angle : ndarray or scalar
    The counterclockwise angle from the positive real axis on the complex
    plane in the range ``(-pi, pi]``, with dtype as numpy.float64.

    ..versionchanged:: 1.16.0
        This function works on subclasses of ndarray like `ma.array`.

See Also
--------
arctan2
absolute

Examples
--------
>>> np.angle([1.0, 1.0j, 1+1j])               # in radians
array([ 0.        ,  1.57079633,  0.78539816]) # may vary
>>> np.angle(1+1j, deg=True)                  # in degrees
45.0
*)

val anom : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
anom(self, axis=None, dtype=None)

Compute the anomalies (deviations from the arithmetic mean)
along the given axis.

Returns an array of anomalies, with the same shape as the input and
where the arithmetic mean is computed along the given axis.

Parameters
----------
axis : int, optional
    Axis over which the anomalies are taken.
    The default is to use the mean of the flattened array as reference.
dtype : dtype, optional
    Type to use in computing the variance. For arrays of integer type
     the default is float32; for arrays of float types it is the same as
     the array type.

See Also
--------
mean : Compute the mean of the array.

Examples
--------
>>> a = np.ma.array([1,2,3])
>>> a.anom()
masked_array(data=[-1.,  0.,  1.],
             mask=False,
       fill_value=1e+20)
*)

val anomalies : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
anom(self, axis=None, dtype=None)

Compute the anomalies (deviations from the arithmetic mean)
along the given axis.

Returns an array of anomalies, with the same shape as the input and
where the arithmetic mean is computed along the given axis.

Parameters
----------
axis : int, optional
    Axis over which the anomalies are taken.
    The default is to use the mean of the flattened array as reference.
dtype : dtype, optional
    Type to use in computing the variance. For arrays of integer type
     the default is float32; for arrays of float types it is the same as
     the array type.

See Also
--------
mean : Compute the mean of the array.

Examples
--------
>>> a = np.ma.array([1,2,3])
>>> a.anom()
masked_array(data=[-1.,  0.,  1.],
             mask=False,
       fill_value=1e+20)
*)

val any : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
any(self, axis=None, out=None, keepdims=<no value>)

Returns True if any of the elements of `a` evaluate to True.

Masked values are considered as False during computation.

Refer to `numpy.any` for full documentation.

See Also
--------
numpy.ndarray.any : corresponding function for ndarrays
numpy.any : equivalent function
*)

val append : ?axis:int -> b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Append values to the end of an array.

.. versionadded:: 1.9.0

Parameters
----------
a : array_like
    Values are appended to a copy of this array.
b : array_like
    These values are appended to a copy of `a`.  It must be of the
    correct shape (the same shape as `a`, excluding `axis`).  If `axis`
    is not specified, `b` can be any shape and will be flattened
    before use.
axis : int, optional
    The axis along which `v` are appended.  If `axis` is not given,
    both `a` and `b` are flattened before use.

Returns
-------
append : MaskedArray
    A copy of `a` with `b` appended to `axis`.  Note that `append`
    does not occur in-place: a new array is allocated and filled.  If
    `axis` is None, the result is a flattened array.

See Also
--------
numpy.append : Equivalent function in the top-level NumPy module.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.masked_values([1, 2, 3], 2)
>>> b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)
>>> ma.append(a, b)
masked_array(data=[1, --, 3, 4, 5, 6, --, 8, 9],
             mask=[False,  True, False, False, False, False,  True, False,
                   False],
       fill_value=999999)
*)

val apply_along_axis : ?kwargs:(string * Py.Object.t) list -> func1d:Py.Object.t -> axis:int -> arr:Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
Apply a function to 1-D slices along the given axis.

Execute `func1d(a, *args)` where `func1d` operates on 1-D arrays and `a`
is a 1-D slice of `arr` along `axis`.

This is equivalent to (but faster than) the following use of `ndindex` and
`s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices::

    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
    for ii in ndindex(Ni):
        for kk in ndindex(Nk):
            f = func1d(arr[ii + s_[:,] + kk])
            Nj = f.shape
            for jj in ndindex(Nj):
                out[ii + jj + kk] = f[jj]

Equivalently, eliminating the inner loop, this can be expressed as::

    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
    for ii in ndindex(Ni):
        for kk in ndindex(Nk):
            out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])

Parameters
----------
func1d : function (M,) -> (Nj...)
    This function should accept 1-D arrays. It is applied to 1-D
    slices of `arr` along the specified axis.
axis : integer
    Axis along which `arr` is sliced.
arr : ndarray (Ni..., M, Nk...)
    Input array.
args : any
    Additional arguments to `func1d`.
kwargs : any
    Additional named arguments to `func1d`.

    .. versionadded:: 1.9.0


Returns
-------
out : ndarray  (Ni..., Nj..., Nk...)
    The output array. The shape of `out` is identical to the shape of
    `arr`, except along the `axis` dimension. This axis is removed, and
    replaced with new dimensions equal to the shape of the return value
    of `func1d`. So if `func1d` returns a scalar `out` will have one
    fewer dimensions than `arr`.

See Also
--------
apply_over_axes : Apply a function repeatedly over multiple axes.

Examples
--------
>>> def my_func(a):
...     '''Average first and last element of a 1-D array'''
...     return (a[0] + a[-1]) * 0.5
>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
>>> np.apply_along_axis(my_func, 0, b)
array([4., 5., 6.])
>>> np.apply_along_axis(my_func, 1, b)
array([2.,  5.,  8.])

For a function that returns a 1D array, the number of dimensions in
`outarr` is the same as `arr`.

>>> b = np.array([[8,1,7], [4,3,9], [5,2,6]])
>>> np.apply_along_axis(sorted, 1, b)
array([[1, 7, 8],
       [3, 4, 9],
       [2, 5, 6]])

For a function that returns a higher dimensional array, those dimensions
are inserted in place of the `axis` dimension.

>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
>>> np.apply_along_axis(np.diag, -1, b)
array([[[1, 0, 0],
        [0, 2, 0],
        [0, 0, 3]],
       [[4, 0, 0],
        [0, 5, 0],
        [0, 0, 6]],
       [[7, 0, 0],
        [0, 8, 0],
        [0, 0, 9]]])
*)

val apply_over_axes : func:Py.Object.t -> axes:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Apply a function repeatedly over multiple axes.

`func` is called as `res = func(a, axis)`, where `axis` is the first
element of `axes`.  The result `res` of the function call must have
either the same dimensions as `a` or one less dimension.  If `res`
has one less dimension than `a`, a dimension is inserted before
`axis`.  The call to `func` is then repeated for each axis in `axes`,
with `res` as the first argument.

Parameters
----------
func : function
    This function must take two arguments, `func(a, axis)`.
a : array_like
    Input array.
axes : array_like
    Axes over which `func` is applied; the elements must be integers.

Returns
-------
apply_over_axis : ndarray
    The output array.  The number of dimensions is the same as `a`,
    but the shape can be different.  This depends on whether `func`
    changes the shape of its output with respect to its input.

See Also
--------
apply_along_axis :
    Apply a function to 1-D slices of an array along the given axis.

Examples
--------
>>> a = np.ma.arange(24).reshape(2,3,4)
>>> a[:,0,1] = np.ma.masked
>>> a[:,1,:] = np.ma.masked
>>> a
masked_array(
  data=[[[0, --, 2, 3],
         [--, --, --, --],
         [8, 9, 10, 11]],
        [[12, --, 14, 15],
         [--, --, --, --],
         [20, 21, 22, 23]]],
  mask=[[[False,  True, False, False],
         [ True,  True,  True,  True],
         [False, False, False, False]],
        [[False,  True, False, False],
         [ True,  True,  True,  True],
         [False, False, False, False]]],
  fill_value=999999)
>>> np.ma.apply_over_axes(np.ma.sum, a, [0,2])
masked_array(
  data=[[[46],
         [--],
         [124]]],
  mask=[[[False],
         [ True],
         [False]]],
  fill_value=999999)

Tuple axis arguments to ufuncs are equivalent:

>>> np.ma.sum(a, axis=(0,2)).reshape((1,-1,1))
masked_array(
  data=[[[46],
         [--],
         [124]]],
  mask=[[[False],
         [ True],
         [False]]],
  fill_value=999999)
*)

val arange : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arange([start,] stop[, step,], dtype=None)

Return evenly spaced values within a given interval.

Values are generated within the half-open interval ``[start, stop)``
(in other words, the interval including `start` but excluding `stop`).
For integer arguments the function is equivalent to the Python built-in
`range` function, but returns an ndarray rather than a list.

When using a non-integer step, such as 0.1, the results will often not
be consistent.  It is better to use `numpy.linspace` for these cases.

Parameters
----------
start : number, optional
    Start of interval.  The interval includes this value.  The default
    start value is 0.
stop : number
    End of interval.  The interval does not include this value, except
    in some cases where `step` is not an integer and floating point
    round-off affects the length of `out`.
step : number, optional
    Spacing between values.  For any output `out`, this is the distance
    between two adjacent values, ``out[i+1] - out[i]``.  The default
    step size is 1.  If `step` is specified as a position argument,
    `start` must also be given.
dtype : dtype
    The type of the output array.  If `dtype` is not given, infer the data
    type from the other input arguments.

Returns
-------
arange : ndarray
    Array of evenly spaced values.

    For floating point arguments, the length of the result is
    ``ceil((stop - start)/step)``.  Because of floating point overflow,
    this rule may result in the last element of `out` being greater
    than `stop`.

See Also
--------
numpy.linspace : Evenly spaced numbers with careful handling of endpoints.
numpy.ogrid: Arrays of evenly spaced numbers in N-dimensions.
numpy.mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.

Examples
--------
>>> np.arange(3)
array([0, 1, 2])
>>> np.arange(3.0)
array([ 0.,  1.,  2.])
>>> np.arange(3,7)
array([3, 4, 5, 6])
>>> np.arange(3,7,2)
array([3, 5])
*)

val arccos : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Trigonometric inverse cosine, element-wise.

The inverse of `cos` so that, if ``y = cos(x)``, then ``x = arccos(y)``.

Parameters
----------
x : array_like
    `x`-coordinate on the unit circle.
    For real arguments, the domain is [-1, 1].
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
angle : ndarray
    The angle of the ray intersecting the unit circle at the given
    `x`-coordinate in radians [0, pi].
    This is a scalar if `x` is a scalar.

See Also
--------
cos, arctan, arcsin, emath.arccos

Notes
-----
`arccos` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `cos(z) = x`. The convention is to return
the angle `z` whose real part lies in `[0, pi]`.

For real-valued input data types, `arccos` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arccos` is a complex analytic function that
has branch cuts `[-inf, -1]` and `[1, inf]` and is continuous from
above on the former and from below on the latter.

The inverse `cos` is also known as `acos` or cos^-1.

References
----------
M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/

Examples
--------
We expect the arccos of 1 to be 0, and of -1 to be pi:

>>> np.arccos([1, -1])
array([ 0.        ,  3.14159265])

Plot arccos:

>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-1, 1, num=100)
>>> plt.plot(x, np.arccos(x))
>>> plt.axis('tight')
>>> plt.show()
*)

val arccosh : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Inverse hyperbolic cosine, element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
arccosh : ndarray
    Array of the same shape as `x`.
    This is a scalar if `x` is a scalar.

See Also
--------

cosh, arcsinh, sinh, arctanh, tanh

Notes
-----
`arccosh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `cosh(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi, pi]` and the real part in
``[0, inf]``.

For real-valued input data types, `arccosh` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arccosh` is a complex analytical function that
has a branch cut `[-inf, 1]` and is continuous from above on it.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Inverse hyperbolic function',
       https://en.wikipedia.org/wiki/Arccosh

Examples
--------
>>> np.arccosh([np.e, 10.0])
array([ 1.65745445,  2.99322285])
>>> np.arccosh(1)
0.0
*)

val arcsin : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Inverse sine, element-wise.

Parameters
----------
x : array_like
    `y`-coordinate on the unit circle.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
angle : ndarray
    The inverse sine of each element in `x`, in radians and in the
    closed interval ``[-pi/2, pi/2]``.
    This is a scalar if `x` is a scalar.

See Also
--------
sin, cos, arccos, tan, arctan, arctan2, emath.arcsin

Notes
-----
`arcsin` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that :math:`sin(z) = x`.  The convention is to
return the angle `z` whose real part lies in [-pi/2, pi/2].

For real-valued input data types, *arcsin* always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arcsin` is a complex analytic function that
has, by convention, the branch cuts [-inf, -1] and [1, inf]  and is
continuous from above on the former and from below on the latter.

The inverse sine is also known as `asin` or sin^{-1}.

References
----------
Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,
10th printing, New York: Dover, 1964, pp. 79ff.
http://www.math.sfu.ca/~cbm/aands/

Examples
--------
>>> np.arcsin(1)     # pi/2
1.5707963267948966
>>> np.arcsin(-1)    # -pi/2
-1.5707963267948966
>>> np.arcsin(0)
0.0
*)

val arcsinh : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Inverse hyperbolic sine element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Array of the same shape as `x`.
    This is a scalar if `x` is a scalar.

Notes
-----
`arcsinh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `sinh(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi/2, pi/2]`.

For real-valued input data types, `arcsinh` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
returns ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arccos` is a complex analytical function that
has branch cuts `[1j, infj]` and `[-1j, -infj]` and is continuous from
the right on the former and from the left on the latter.

The inverse hyperbolic sine is also known as `asinh` or ``sinh^-1``.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Inverse hyperbolic function',
       https://en.wikipedia.org/wiki/Arcsinh

Examples
--------
>>> np.arcsinh(np.array([np.e, 10.0]))
array([ 1.72538256,  2.99822295])
*)

val arctan : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Trigonometric inverse tangent, element-wise.

The inverse of tan, so that if ``y = tan(x)`` then ``x = arctan(y)``.

Parameters
----------
x : array_like
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Out has the same shape as `x`.  Its real part is in
    ``[-pi/2, pi/2]`` (``arctan(+/-inf)`` returns ``+/-pi/2``).
    This is a scalar if `x` is a scalar.

See Also
--------
arctan2 : The 'four quadrant' arctan of the angle formed by (`x`, `y`)
    and the positive `x`-axis.
angle : Argument of complex values.

Notes
-----
`arctan` is a multi-valued function: for each `x` there are infinitely
many numbers `z` such that tan(`z`) = `x`.  The convention is to return
the angle `z` whose real part lies in [-pi/2, pi/2].

For real-valued input data types, `arctan` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arctan` is a complex analytic function that
has [`1j, infj`] and [`-1j, -infj`] as branch cuts, and is continuous
from the left on the former and from the right on the latter.

The inverse tangent is also known as `atan` or tan^{-1}.

References
----------
Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,
10th printing, New York: Dover, 1964, pp. 79.
http://www.math.sfu.ca/~cbm/aands/

Examples
--------
We expect the arctan of 0 to be 0, and of 1 to be pi/4:

>>> np.arctan([0, 1])
array([ 0.        ,  0.78539816])

>>> np.pi/4
0.78539816339744828

Plot arctan:

>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-10, 10)
>>> plt.plot(x, np.arctan(x))
>>> plt.axis('tight')
>>> plt.show()
*)

val arctan2 : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Element-wise arc tangent of ``x1/x2`` choosing the quadrant correctly.

The quadrant (i.e., branch) is chosen so that ``arctan2(x1, x2)`` is
the signed angle in radians between the ray ending at the origin and
passing through the point (1,0), and the ray ending at the origin and
passing through the point (`x2`, `x1`).  (Note the role reversal: the
'`y`-coordinate' is the first function parameter, the '`x`-coordinate'
is the second.)  By IEEE convention, this function is defined for
`x2` = +/-0 and for either or both of `x1` and `x2` = +/-inf (see
Notes for specific values).

This function is not defined for complex-valued arguments; for the
so-called argument of complex values, use `angle`.

Parameters
----------
x1 : array_like, real-valued
    `y`-coordinates.
x2 : array_like, real-valued
    `x`-coordinates. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
angle : ndarray
    Array of angles in radians, in the range ``[-pi, pi]``.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
arctan, tan, angle

Notes
-----
*arctan2* is identical to the `atan2` function of the underlying
C library.  The following special values are defined in the C
standard: [1]_

====== ====== ================
`x1`   `x2`   `arctan2(x1,x2)`
====== ====== ================
+/- 0  +0     +/- 0
+/- 0  -0     +/- pi
 > 0   +/-inf +0 / +pi
 < 0   +/-inf -0 / -pi
+/-inf +inf   +/- (pi/4)
+/-inf -inf   +/- (3*pi/4)
====== ====== ================

Note that +0 and -0 are distinct floating point numbers, as are +inf
and -inf.

References
----------
.. [1] ISO/IEC standard 9899:1999, 'Programming language C.'

Examples
--------
Consider four points in different quadrants:

>>> x = np.array([-1, +1, +1, -1])
>>> y = np.array([-1, -1, +1, +1])
>>> np.arctan2(y, x) * 180 / np.pi
array([-135.,  -45.,   45.,  135.])

Note the order of the parameters. `arctan2` is defined also when `x2` = 0
and at several other special points, obtaining values in
the range ``[-pi, pi]``:

>>> np.arctan2([1., -1.], [0., 0.])
array([ 1.57079633, -1.57079633])
>>> np.arctan2([0., 0., np.inf], [+0., -0., np.inf])
array([ 0.        ,  3.14159265,  0.78539816])
*)

val arctanh : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Inverse hyperbolic tangent element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Array of the same shape as `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
emath.arctanh

Notes
-----
`arctanh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `tanh(z) = x`. The convention is to return
the `z` whose imaginary part lies in `[-pi/2, pi/2]`.

For real-valued input data types, `arctanh` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arctanh` is a complex analytical function
that has branch cuts `[-1, -inf]` and `[1, inf]` and is continuous from
above on the former and from below on the latter.

The inverse hyperbolic tangent is also known as `atanh` or ``tanh^-1``.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Inverse hyperbolic function',
       https://en.wikipedia.org/wiki/Arctanh

Examples
--------
>>> np.arctanh([0, -0.5])
array([ 0.        , -0.54930614])
*)

val argmax : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
argmax(self, axis=None, fill_value=None, out=None)

Returns array of indices of the maximum values along the given axis.
Masked values are treated as if they had the value fill_value.

Parameters
----------
axis : {None, integer}
    If None, the index is into the flattened array, otherwise along
    the specified axis
fill_value : {var}, optional
    Value used to fill in the masked values.  If None, the output of
    maximum_fill_value(self._data) is used instead.
out : {None, array}, optional
    Array into which the result can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

Returns
-------
index_array : {integer_array}

Examples
--------
>>> a = np.arange(6).reshape(2,3)
>>> a.argmax()
5
>>> a.argmax(0)
array([1, 1, 1])
>>> a.argmax(1)
array([2, 2])
*)

val argmin : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
argmin(self, axis=None, fill_value=None, out=None)

Return array of indices to the minimum values along the given axis.

Parameters
----------
axis : {None, integer}
    If None, the index is into the flattened array, otherwise along
    the specified axis
fill_value : {var}, optional
    Value used to fill in the masked values.  If None, the output of
    minimum_fill_value(self._data) is used instead.
out : {None, array}, optional
    Array into which the result can be placed. Its type is preserved
    and it must be of the right shape to hold the output.

Returns
-------
ndarray or scalar
    If multi-dimension input, returns a new ndarray of indices to the
    minimum values along the given axis.  Otherwise, returns a scalar
    of index to the minimum values along the given axis.

Examples
--------
>>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])
>>> x.shape = (2,2)
>>> x
masked_array(
  data=[[--, --],
        [2, 3]],
  mask=[[ True,  True],
        [False, False]],
  fill_value=999999)
>>> x.argmin(axis=0, fill_value=-1)
array([0, 0])
>>> x.argmin(axis=0, fill_value=9)
array([1, 1])
*)

val argsort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[>`Ndarray] Obj.t -> ?endwith:bool -> ?fill_value:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an ndarray of indices that sort the array along the
specified axis.  Masked values are filled beforehand to
`fill_value`.

Parameters
----------
axis : int, optional
    Axis along which to sort. If None, the default, the flattened array
    is used.

    ..  versionchanged:: 1.13.0
        Previously, the default was documented to be -1, but that was
        in error. At some future date, the default will change to -1, as
        originally intended.
        Until then, the axis should be given explicitly when
        ``arr.ndim > 1``, to avoid a FutureWarning.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    The sorting algorithm used.
order : list, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  Not all fields need be
    specified.
endwith : {True, False}, optional
    Whether missing values (if any) should be treated as the largest values
    (True) or the smallest values (False)
    When the array contains unmasked values at the same extremes of the
    datatype, the ordering of these values and the masked values is
    undefined.
fill_value : {var}, optional
    Value used internally for the masked values.
    If ``fill_value`` is not None, it supersedes ``endwith``.

Returns
-------
index_array : ndarray, int
    Array of indices that sort `a` along the specified axis.
    In other words, ``a[index_array]`` yields a sorted `a`.

See Also
--------
MaskedArray.sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
numpy.ndarray.sort : Inplace sort.

Notes
-----
See `sort` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.ma.array([3,2,1], mask=[False, False, True])
>>> a
masked_array(data=[3, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.argsort()
array([1, 0, 2])
*)

val around : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
Round an array to the given number of decimals.

See Also
--------
around : equivalent function; see for details.
*)

val array : ?dtype:Dtype.t -> ?copy:bool -> ?order:[`C | `F | `A] -> ?mask:Py.Object.t -> ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> ?keep_mask:bool -> ?hard_mask:bool -> ?shrink:bool -> ?subok:bool -> ?ndmin:int -> data:[>`Ndarray] Obj.t -> unit -> Py.Object.t
(**
An array class with possibly masked values.

Masked values of True exclude the corresponding element from any
computation.

Construction::

  x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
                  ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
                  shrink=True, order=None)

Parameters
----------
data : array_like
    Input data.
mask : sequence, optional
    Mask. Must be convertible to an array of booleans with the same
    shape as `data`. True indicates a masked (i.e. invalid) data.
dtype : dtype, optional
    Data type of the output.
    If `dtype` is None, the type of the data argument (``data.dtype``)
    is used. If `dtype` is not None and different from ``data.dtype``,
    a copy is performed.
copy : bool, optional
    Whether to copy the input data (True), or to use a reference instead.
    Default is False.
subok : bool, optional
    Whether to return a subclass of `MaskedArray` if possible (True) or a
    plain `MaskedArray`. Default is True.
ndmin : int, optional
    Minimum number of dimensions. Default is 0.
fill_value : scalar, optional
    Value used to fill in the masked values when necessary.
    If None, a default based on the data-type is used.
keep_mask : bool, optional
    Whether to combine `mask` with the mask of the input data, if any
    (True), or to use only `mask` for the output (False). Default is True.
hard_mask : bool, optional
    Whether to use a hard mask or not. With a hard mask, masked values
    cannot be unmasked. Default is False.
shrink : bool, optional
    Whether to force compression of an empty mask. Default is True.
order : {'C', 'F', 'A'}, optional
    Specify the order of the array.  If order is 'C', then the array
    will be in C-contiguous order (last-index varies the fastest).
    If order is 'F', then the returned array will be in
    Fortran-contiguous order (first-index varies the fastest).
    If order is 'A' (default), then the returned array may be
    in any order (either C-, Fortran-contiguous, or even discontiguous),
    unless a copy is required, in which case it will be C-contiguous.
*)

val asanyarray : ?dtype:Dtype.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Convert the input to a masked array, conserving subclasses.

If `a` is a subclass of `MaskedArray`, its class is conserved.
No copy is performed if the input is already an `ndarray`.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.
dtype : dtype, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major ('C') or column-major ('FORTRAN') memory
    representation.  Default is 'C'.

Returns
-------
out : MaskedArray
    MaskedArray interpretation of `a`.

See Also
--------
asarray : Similar to `asanyarray`, but does not conserve subclass.

Examples
--------
>>> x = np.arange(10.).reshape(2, 5)
>>> x
array([[0., 1., 2., 3., 4.],
       [5., 6., 7., 8., 9.]])
>>> np.ma.asanyarray(x)
masked_array(
  data=[[0., 1., 2., 3., 4.],
        [5., 6., 7., 8., 9.]],
  mask=False,
  fill_value=1e+20)
>>> type(np.ma.asanyarray(x))
<class 'numpy.ma.core.MaskedArray'>
*)

val asarray : ?dtype:Dtype.t -> ?order:[`C | `F] -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Convert the input to a masked array of the given data-type.

No copy is performed if the input is already an `ndarray`. If `a` is
a subclass of `MaskedArray`, a base class `MaskedArray` is returned.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to a masked array. This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists, ndarrays and masked arrays.
dtype : dtype, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major ('C') or column-major ('FORTRAN') memory
    representation.  Default is 'C'.

Returns
-------
out : MaskedArray
    Masked array interpretation of `a`.

See Also
--------
asanyarray : Similar to `asarray`, but conserves subclasses.

Examples
--------
>>> x = np.arange(10.).reshape(2, 5)
>>> x
array([[0., 1., 2., 3., 4.],
       [5., 6., 7., 8., 9.]])
>>> np.ma.asarray(x)
masked_array(
  data=[[0., 1., 2., 3., 4.],
        [5., 6., 7., 8., 9.]],
  mask=False,
  fill_value=1e+20)
>>> type(np.ma.asarray(x))
<class 'numpy.ma.core.MaskedArray'>
*)

val atleast_1d : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
atleast_1d( *args, **kwargs)

    Convert inputs to arrays with at least one dimension.

    Scalar inputs are converted to 1-dimensional arrays, whilst
    higher-dimensional inputs are preserved.

    Parameters
    ----------
    arys1, arys2, ... : array_like
        One or more input arrays.

    Returns
    -------
    ret : ndarray
        An array, or list of arrays, each with ``a.ndim >= 1``.
        Copies are made only if necessary.

    See Also
    --------
    atleast_2d, atleast_3d

    Examples
    --------
    >>> np.atleast_1d(1.0)
    array([1.])

    >>> x = np.arange(9.0).reshape(3,3)
    >>> np.atleast_1d(x)
    array([[0., 1., 2.],
           [3., 4., 5.],
           [6., 7., 8.]])
    >>> np.atleast_1d(x) is x
    True

    >>> np.atleast_1d(1, [3, 4])
    [array([1]), array([3, 4])]

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val atleast_2d : ?params:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
atleast_2d( *args, **kwargs)

    View inputs as arrays with at least two dimensions.

    Parameters
    ----------
    arys1, arys2, ... : array_like
        One or more array-like sequences.  Non-array inputs are converted
        to arrays.  Arrays that already have two or more dimensions are
        preserved.

    Returns
    -------
    res, res2, ... : ndarray
        An array, or list of arrays, each with ``a.ndim >= 2``.
        Copies are avoided where possible, and views with two or more
        dimensions are returned.

    See Also
    --------
    atleast_1d, atleast_3d

    Examples
    --------
    >>> np.atleast_2d(3.0)
    array([[3.]])

    >>> x = np.arange(3.0)
    >>> np.atleast_2d(x)
    array([[0., 1., 2.]])
    >>> np.atleast_2d(x).base is x
    True

    >>> np.atleast_2d(1, [1, 2], [[1, 2]])
    [array([[1]]), array([[1, 2]]), array([[1, 2]])]

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val atleast_3d : ?params:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
atleast_3d( *args, **kwargs)

    View inputs as arrays with at least three dimensions.

    Parameters
    ----------
    arys1, arys2, ... : array_like
        One or more array-like sequences.  Non-array inputs are converted to
        arrays.  Arrays that already have three or more dimensions are
        preserved.

    Returns
    -------
    res1, res2, ... : ndarray
        An array, or list of arrays, each with ``a.ndim >= 3``.  Copies are
        avoided where possible, and views with three or more dimensions are
        returned.  For example, a 1-D array of shape ``(N,)`` becomes a view
        of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a
        view of shape ``(M, N, 1)``.

    See Also
    --------
    atleast_1d, atleast_2d

    Examples
    --------
    >>> np.atleast_3d(3.0)
    array([[[3.]]])

    >>> x = np.arange(3.0)
    >>> np.atleast_3d(x).shape
    (1, 3, 1)

    >>> x = np.arange(12.0).reshape(4,3)
    >>> np.atleast_3d(x).shape
    (4, 3, 1)
    >>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself
    True

    >>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):
    ...     print(arr, arr.shape) # doctest: +SKIP
    ...
    [[[1]
      [2]]] (1, 2, 1)
    [[[1]
      [2]]] (1, 2, 1)
    [[[1 2]]] (1, 1, 2)

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val average : ?axis:int -> ?weights:[>`Ndarray] Obj.t -> ?returned:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the weighted average of array over the given axis.

Parameters
----------
a : array_like
    Data to be averaged.
    Masked entries are not taken into account in the computation.
axis : int, optional
    Axis along which to average `a`. If None, averaging is done over
    the flattened array.
weights : array_like, optional
    The importance that each element has in the computation of the average.
    The weights array can either be 1-D (in which case its length must be
    the size of `a` along the given axis) or of the same shape as `a`.
    If ``weights=None``, then all data in `a` are assumed to have a
    weight equal to one.  The 1-D calculation is::

        avg = sum(a * weights) / sum(weights)

    The only constraint on `weights` is that `sum(weights)` must not be 0.
returned : bool, optional
    Flag indicating whether a tuple ``(result, sum of weights)``
    should be returned as output (True), or just the result (False).
    Default is False.

Returns
-------
average, [sum_of_weights] : (tuple of) scalar or MaskedArray
    The average along the specified axis. When returned is `True`,
    return a tuple with the average as the first element and the sum
    of the weights as the second element. The return type is `np.float64`
    if `a` is of integer type and floats smaller than `float64`, or the
    input data-type, otherwise. If returned, `sum_of_weights` is always
    `float64`.

Examples
--------
>>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])
>>> np.ma.average(a, weights=[3, 1, 0, 0])
1.25

>>> x = np.ma.arange(6.).reshape(3, 2)
>>> x
masked_array(
  data=[[0., 1.],
        [2., 3.],
        [4., 5.]],
  mask=False,
  fill_value=1e+20)
>>> avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],
...                                 returned=True)
>>> avg
masked_array(data=[2.6666666666666665, 3.6666666666666665],
             mask=[False, False],
       fill_value=1e+20)
*)

val bitwise_and : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the bit-wise AND of two arrays element-wise.

Computes the bit-wise AND of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``&``.

Parameters
----------
x1, x2 : array_like
    Only integer and boolean types are handled. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Result.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_and
bitwise_or
bitwise_xor
binary_repr :
    Return the binary representation of the input number as a string.

Examples
--------
The number 13 is represented by ``00001101``.  Likewise, 17 is
represented by ``00010001``.  The bit-wise AND of 13 and 17 is
therefore ``000000001``, or 1:

>>> np.bitwise_and(13, 17)
1

>>> np.bitwise_and(14, 13)
12
>>> np.binary_repr(12)
'1100'
>>> np.bitwise_and([14,3], 13)
array([12,  1])

>>> np.bitwise_and([11,7], [4,25])
array([0, 1])
>>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))
array([ 2,  4, 16])
>>> np.bitwise_and([True, True], [False, True])
array([False,  True])
*)

val bitwise_or : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the bit-wise OR of two arrays element-wise.

Computes the bit-wise OR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``|``.

Parameters
----------
x1, x2 : array_like
    Only integer and boolean types are handled. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Result.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_or
bitwise_and
bitwise_xor
binary_repr :
    Return the binary representation of the input number as a string.

Examples
--------
The number 13 has the binaray representation ``00001101``. Likewise,
16 is represented by ``00010000``.  The bit-wise OR of 13 and 16 is
then ``000111011``, or 29:

>>> np.bitwise_or(13, 16)
29
>>> np.binary_repr(29)
'11101'

>>> np.bitwise_or(32, 2)
34
>>> np.bitwise_or([33, 4], 1)
array([33,  5])
>>> np.bitwise_or([33, 4], [1, 2])
array([33,  6])

>>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))
array([  6,   5, 255])
>>> np.array([2, 5, 255]) | np.array([4, 4, 4])
array([  6,   5, 255])
>>> np.bitwise_or(np.array([2, 5, 255, 2147483647], dtype=np.int32),
...               np.array([4, 4, 4, 2147483647], dtype=np.int32))
array([         6,          5,        255, 2147483647])
>>> np.bitwise_or([True, True], [False, True])
array([ True,  True])
*)

val bitwise_xor : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the bit-wise XOR of two arrays element-wise.

Computes the bit-wise XOR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``^``.

Parameters
----------
x1, x2 : array_like
    Only integer and boolean types are handled. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Result.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_xor
bitwise_and
bitwise_or
binary_repr :
    Return the binary representation of the input number as a string.

Examples
--------
The number 13 is represented by ``00001101``. Likewise, 17 is
represented by ``00010001``.  The bit-wise XOR of 13 and 17 is
therefore ``00011100``, or 28:

>>> np.bitwise_xor(13, 17)
28
>>> np.binary_repr(28)
'11100'

>>> np.bitwise_xor(31, 5)
26
>>> np.bitwise_xor([31,3], 5)
array([26,  6])

>>> np.bitwise_xor([31,3], [5,6])
array([26,  5])
>>> np.bitwise_xor([True, True], [False, True])
array([ True, False])
*)

val ceil : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the ceiling of the input, element-wise.

The ceil of the scalar `x` is the smallest integer `i`, such that
`i >= x`.  It is often denoted as :math:`\lceil x \rceil`.

Parameters
----------
x : array_like
    Input data.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The ceiling of each element in `x`, with `float` dtype.
    This is a scalar if `x` is a scalar.

See Also
--------
floor, trunc, rint

Examples
--------
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.ceil(a)
array([-1., -1., -0.,  1.,  2.,  2.,  2.])
*)

val choose : ?out:[>`Ndarray] Obj.t -> ?mode:[`Raise | `Wrap | `Clip] -> indices:Py.Object.t -> choices:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Use an index array to construct a new array from a set of choices.

Given an array of integers and a set of n choice arrays, this method
will create a new array that merges each of the choice arrays.  Where a
value in `a` is i, the new array will have the value that choices[i]
contains in the same place.

Parameters
----------
a : ndarray of ints
    This array must contain integers in ``[0, n-1]``, where n is the
    number of choices.
choices : sequence of arrays
    Choice arrays. The index array and all of the choices should be
    broadcastable to the same shape.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and `dtype`.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.

    * 'raise' : raise an error
    * 'wrap' : wrap around
    * 'clip' : clip to the range

Returns
-------
merged_array : array

See Also
--------
choose : equivalent function

Examples
--------
>>> choice = np.array([[1,1,1], [2,2,2], [3,3,3]])
>>> a = np.array([2, 1, 0])
>>> np.ma.choose(a, choice)
masked_array(data=[3, 2, 1],
             mask=False,
       fill_value=999999)
*)

val clip : ?out:[>`Ndarray] Obj.t -> ?kwargs:(string * Py.Object.t) list -> a_min:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string | `None] -> a_max:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string | `None] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Clip (limit) the values in an array.

Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of ``[0, 1]``
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.

Equivalent to but faster than ``np.maximum(a_min, np.minimum(a, a_max))``.
No check is performed to ensure ``a_min < a_max``.

Parameters
----------
a : array_like
    Array containing elements to clip.
a_min : scalar or array_like or None
    Minimum value. If None, clipping is not performed on lower
    interval edge. Not more than one of `a_min` and `a_max` may be
    None.
a_max : scalar or array_like or None
    Maximum value. If None, clipping is not performed on upper
    interval edge. Not more than one of `a_min` and `a_max` may be
    None. If `a_min` or `a_max` are array_like, then the three
    arrays will be broadcasted to match their shapes.
out : ndarray, optional
    The results will be placed in this array. It may be the input
    array for in-place clipping.  `out` must be of the right shape
    to hold the output.  Its type is preserved.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

    .. versionadded:: 1.17.0

Returns
-------
clipped_array : ndarray
    An array with the elements of `a`, but where values
    < `a_min` are replaced with `a_min`, and those > `a_max`
    with `a_max`.

See Also
--------
ufuncs-output-type

Examples
--------
>>> a = np.arange(10)
>>> np.clip(a, 1, 8)
array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.clip(a, 3, 6, out=a)
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])
*)

val clump_masked : [>`Ndarray] Obj.t -> Py.Object.t
(**
Returns a list of slices corresponding to the masked clumps of a 1-D array.
(A 'clump' is defined as a contiguous region of the array).

Parameters
----------
a : ndarray
    A one-dimensional masked array.

Returns
-------
slices : list of slice
    The list of slices, one for each continuous region of masked elements
    in `a`.

Notes
-----
.. versionadded:: 1.4.0

See Also
--------
flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges
notmasked_contiguous, clump_unmasked

Examples
--------
>>> a = np.ma.masked_array(np.arange(10))
>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
>>> np.ma.clump_masked(a)
[slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]
*)

val clump_unmasked : [>`Ndarray] Obj.t -> Py.Object.t
(**
Return list of slices corresponding to the unmasked clumps of a 1-D array.
(A 'clump' is defined as a contiguous region of the array).

Parameters
----------
a : ndarray
    A one-dimensional masked array.

Returns
-------
slices : list of slice
    The list of slices, one for each continuous region of unmasked
    elements in `a`.

Notes
-----
.. versionadded:: 1.4.0

See Also
--------
flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges
notmasked_contiguous, clump_masked

Examples
--------
>>> a = np.ma.masked_array(np.arange(10))
>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
>>> np.ma.clump_unmasked(a)
[slice(3, 6, None), slice(7, 8, None)]
*)

val column_stack : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
column_stack( *args, **kwargs)

    Stack 1-D arrays as columns into a 2-D array.

    Take a sequence of 1-D arrays and stack them as columns
    to make a single 2-D array. 2-D arrays are stacked as-is,
    just like with `hstack`.  1-D arrays are turned into 2-D columns
    first.

    Parameters
    ----------
    tup : sequence of 1-D or 2-D arrays.
        Arrays to stack. All of them must have the same first dimension.

    Returns
    -------
    stacked : 2-D array
        The array formed by stacking the given arrays.

    See Also
    --------
    stack, hstack, vstack, concatenate

    Examples
    --------
    >>> a = np.array((1,2,3))
    >>> b = np.array((2,3,4))
    >>> np.column_stack((a,b))
    array([[1, 2],
           [2, 3],
           [3, 4]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val common_fill_value : b:Py.Object.t -> Py.Object.t -> Py.Object.t option
(**
Return the common filling value of two masked arrays, if any.

If ``a.fill_value == b.fill_value``, return the fill value,
otherwise return None.

Parameters
----------
a, b : MaskedArray
    The masked arrays for which to compare fill values.

Returns
-------
fill_value : scalar or None
    The common fill value, or None.

Examples
--------
>>> x = np.ma.array([0, 1.], fill_value=3)
>>> y = np.ma.array([0, 1.], fill_value=3)
>>> np.ma.common_fill_value(x, y)
3.0
*)

val compress : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
compress(self, condition, axis=None, out=None)

Return `a` where condition is ``True``.

If condition is a `MaskedArray`, missing values are considered
as ``False``.

Parameters
----------
condition : var
    Boolean 1-d array selecting which entries to return. If len(condition)
    is less than the size of a along the axis, then output is truncated
    to length of condition array.
axis : {None, int}, optional
    Axis along which the operation must be performed.
out : {None, ndarray}, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type will be cast if
    necessary.

Returns
-------
result : MaskedArray
    A :class:`MaskedArray` object.

Notes
-----
Please note the difference with :meth:`compressed` !
The output of :meth:`compress` has a mask, the output of
:meth:`compressed` does not.

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.compress([1, 0, 1])
masked_array(data=[1, 3],
             mask=[False, False],
       fill_value=999999)

>>> x.compress([1, 0, 1], axis=1)
masked_array(
  data=[[1, 3],
        [--, --],
        [7, 9]],
  mask=[[False, False],
        [ True,  True],
        [False, False]],
  fill_value=999999)
*)

val compress_cols : Py.Object.t -> Py.Object.t
(**
Suppress whole columns of a 2-D array that contain masked values.

This is equivalent to ``np.ma.compress_rowcols(a, 1)``, see
`extras.compress_rowcols` for details.

See Also
--------
extras.compress_rowcols
*)

val compress_nd : ?axis:int list -> [`MaskedArray of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Suppress slices from multiple dimensions which contain masked values.

Parameters
----------
x : array_like, MaskedArray
    The array to operate on. If not a MaskedArray instance (or if no array
    elements are masked, `x` is interpreted as a MaskedArray with `mask`
    set to `nomask`.
axis : tuple of ints or int, optional
    Which dimensions to suppress slices from can be configured with this
    parameter.
    - If axis is a tuple of ints, those are the axes to suppress slices from.
    - If axis is an int, then that is the only axis to suppress slices from.
    - If axis is None, all axis are selected.

Returns
-------
compress_array : ndarray
    The compressed array.
*)

val compress_rowcols : ?axis:int -> [`MaskedArray of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Suppress the rows and/or columns of a 2-D array that contain
masked values.

The suppression behavior is selected with the `axis` parameter.

- If axis is None, both rows and columns are suppressed.
- If axis is 0, only rows are suppressed.
- If axis is 1 or -1, only columns are suppressed.

Parameters
----------
x : array_like, MaskedArray
    The array to operate on.  If not a MaskedArray instance (or if no array
    elements are masked), `x` is interpreted as a MaskedArray with
    `mask` set to `nomask`. Must be a 2D array.
axis : int, optional
    Axis along which to perform the operation. Default is None.

Returns
-------
compressed_array : ndarray
    The compressed array.

Examples
--------
>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
...                                                   [1, 0, 0],
...                                                   [0, 0, 0]])
>>> x
masked_array(
  data=[[--, 1, 2],
        [--, 4, 5],
        [6, 7, 8]],
  mask=[[ True, False, False],
        [ True, False, False],
        [False, False, False]],
  fill_value=999999)

>>> np.ma.compress_rowcols(x)
array([[7, 8]])
>>> np.ma.compress_rowcols(x, 0)
array([[6, 7, 8]])
>>> np.ma.compress_rowcols(x, 1)
array([[1, 2],
       [4, 5],
       [7, 8]])
*)

val compress_rows : Py.Object.t -> Py.Object.t
(**
Suppress whole rows of a 2-D array that contain masked values.

This is equivalent to ``np.ma.compress_rowcols(a, 0)``, see
`extras.compress_rowcols` for details.

See Also
--------
extras.compress_rowcols
*)

val compressed : Py.Object.t -> Py.Object.t
(**
Return all the non-masked data as a 1-D array.

This function is equivalent to calling the 'compressed' method of a
`MaskedArray`, see `MaskedArray.compressed` for details.

See Also
--------
MaskedArray.compressed
    Equivalent method.
*)

val concatenate : ?axis:int -> arrays:Py.Object.t -> unit -> Py.Object.t
(**
Concatenate a sequence of arrays along the given axis.

Parameters
----------
arrays : sequence of array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int, optional
    The axis along which the arrays will be joined. Default is 0.

Returns
-------
result : MaskedArray
    The concatenated array with any masked entries preserved.

See Also
--------
numpy.concatenate : Equivalent function in the top-level NumPy module.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.arange(3)
>>> a[1] = ma.masked
>>> b = ma.arange(2, 5)
>>> a
masked_array(data=[0, --, 2],
             mask=[False,  True, False],
       fill_value=999999)
>>> b
masked_array(data=[2, 3, 4],
             mask=False,
       fill_value=999999)
>>> ma.concatenate([a, b])
masked_array(data=[0, --, 2, 2, 3, 4],
             mask=[False,  True, False, False, False, False],
       fill_value=999999)
*)

val conjugate : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the complex conjugate, element-wise.

The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.

Parameters
----------
x : array_like
    Input value.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The complex conjugate of `x`, with same dtype as `y`.
    This is a scalar if `x` is a scalar.

Notes
-----
`conj` is an alias for `conjugate`:

>>> np.conj is np.conjugate
True

Examples
--------
>>> np.conjugate(1+2j)
(1-2j)

>>> x = np.eye(2) + 1j * np.eye(2)
>>> np.conjugate(x)
array([[ 1.-1.j,  0.-0.j],
       [ 0.-0.j,  1.-1.j]])
*)

val convolve : ?mode:[`Valid | `Same | `Full] -> ?propagate_mask:bool -> v:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Returns the discrete, linear convolution of two one-dimensional sequences.

Parameters
----------
a, v : array_like
    Input sequences.
mode : {'valid', 'same', 'full'}, optional
    Refer to the `np.convolve` docstring.
propagate_mask : bool
    If True, then if any masked element is included in the sum for a result
    element, then the result is masked.
    If False, then the result element is only masked if no non-masked cells
    contribute towards it

Returns
-------
out : MaskedArray
    Discrete, linear convolution of `a` and `v`.

See Also
--------
numpy.convolve : Equivalent function in the top-level NumPy module.
*)

val copy : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
copy(self, *args, **params)
a.copy(order='C')

    Return a copy of the array.

    Parameters
    ----------
    order : {'C', 'F', 'A', 'K'}, optional
        Controls the memory layout of the copy. 'C' means C-order,
        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
        'C' otherwise. 'K' means match the layout of `a` as closely
        as possible. (Note that this function and :func:`numpy.copy` are very
        similar, but have different default values for their order=
        arguments.)

    See also
    --------
    numpy.copy
    numpy.copyto

    Examples
    --------
    >>> x = np.array([[1,2,3],[4,5,6]], order='F')

    >>> y = x.copy()

    >>> x.fill(0)

    >>> x
    array([[0, 0, 0],
           [0, 0, 0]])

    >>> y
    array([[1, 2, 3],
           [4, 5, 6]])

    >>> y.flags['C_CONTIGUOUS']
    True
*)

val corrcoef : ?y:[>`Ndarray] Obj.t -> ?rowvar:bool -> ?bias:Py.Object.t -> ?allow_masked:bool -> ?ddof:Py.Object.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Return Pearson product-moment correlation coefficients.

Except for the handling of missing data this function does the same as
`numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`.

Parameters
----------
x : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `x` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same
    shape as `x`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.10.0
allow_masked : bool, optional
    If True, masked values are propagated pair-wise: if a value is masked
    in `x`, the corresponding value is masked in `y`.
    If False, raises an exception.  Because `bias` is deprecated, this
    argument needs to be treated as keyword only to avoid a warning.
ddof : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.10.0

See Also
--------
numpy.corrcoef : Equivalent function in top-level NumPy module.
cov : Estimate the covariance matrix.

Notes
-----
This function accepts but discards arguments `bias` and `ddof`.  This is
for backwards compatibility with previous versions of this function.  These
arguments had no effect on the return values of the function and can be
safely ignored in this and previous versions of numpy.
*)

val correlate : ?mode:[`Valid | `Same | `Full] -> ?propagate_mask:bool -> v:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Cross-correlation of two 1-dimensional sequences.

Parameters
----------
a, v : array_like
    Input sequences.
mode : {'valid', 'same', 'full'}, optional
    Refer to the `np.convolve` docstring.  Note that the default
    is 'valid', unlike `convolve`, which uses 'full'.
propagate_mask : bool
    If True, then a result element is masked if any masked element contributes towards it.
    If False, then a result element is only masked if no non-masked element
    contribute towards it

Returns
-------
out : MaskedArray
    Discrete cross-correlation of `a` and `v`.

See Also
--------
numpy.correlate : Equivalent function in the top-level NumPy module.
*)

val cos : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Cosine element-wise.

Parameters
----------
x : array_like
    Input array in radians.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding cosine values.
    This is a scalar if `x` is a scalar.

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.

Examples
--------
>>> np.cos(np.array([0, np.pi/2, np.pi]))
array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])
>>>
>>> # Example of providing the optional output parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.cos([0.1], out1)
>>> out2 is out1
True
>>>
>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
*)

val cosh : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Hyperbolic cosine, element-wise.

Equivalent to ``1/2 * (np.exp(x) + np.exp(-x))`` and ``np.cos(1j*x)``.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array of same shape as `x`.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> np.cosh(0)
1.0

The hyperbolic cosine describes the shape of a hanging cable:

>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-4, 4, 1000)
>>> plt.plot(x, np.cosh(x))
>>> plt.show()
*)

val count : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
count(self, axis=None, keepdims=<no value>)

Count the non-masked elements of the array along the given axis.

Parameters
----------
axis : None or int or tuple of ints, optional
    Axis or axes along which the count is performed.
    The default, None, performs the count over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.10.0

    If this is a tuple of ints, the count is performed on multiple
    axes, instead of a single axis or all the axes as before.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
result : ndarray or scalar
    An array with the same shape as the input array, with the specified
    axis removed. If the array is a 0-d array, or if `axis` is None, a
    scalar is returned.

See Also
--------
count_masked : Count masked elements in array or along a given axis.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.arange(6).reshape((2, 3))
>>> a[1, :] = ma.masked
>>> a
masked_array(
  data=[[0, 1, 2],
        [--, --, --]],
  mask=[[False, False, False],
        [ True,  True,  True]],
  fill_value=999999)
>>> a.count()
3

When the `axis` keyword is specified an array of appropriate size is
returned.

>>> a.count(axis=0)
array([1, 1, 1])
>>> a.count(axis=1)
array([3, 0])
*)

val count_masked : ?axis:int -> arr:[>`Ndarray] Obj.t -> unit -> Py.Object.t
(**
Count the number of masked elements along the given axis.

Parameters
----------
arr : array_like
    An array with (possibly) masked elements.
axis : int, optional
    Axis along which to count. If None (default), a flattened
    version of the array is used.

Returns
-------
count : int, ndarray
    The total number of masked elements (axis=None) or the number
    of masked elements along each slice of the given axis.

See Also
--------
MaskedArray.count : Count non-masked elements.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(9).reshape((3,3))
>>> a = ma.array(a)
>>> a[1, 0] = ma.masked
>>> a[1, 2] = ma.masked
>>> a[2, 1] = ma.masked
>>> a
masked_array(
  data=[[0, 1, 2],
        [--, 4, --],
        [6, --, 8]],
  mask=[[False, False, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> ma.count_masked(a)
3

When the `axis` keyword is used an array is returned.

>>> ma.count_masked(a, axis=0)
array([1, 1, 1])
>>> ma.count_masked(a, axis=1)
array([0, 2, 1])
*)

val cov : ?y:[>`Ndarray] Obj.t -> ?rowvar:bool -> ?bias:bool -> ?allow_masked:bool -> ?ddof:int -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Estimate the covariance matrix.

Except for the handling of missing data this function does the same as
`numpy.cov`. For more details and examples, see `numpy.cov`.

By default, masked values are recognized as such. If `x` and `y` have the
same shape, a common mask is allocated: if ``x[i,j]`` is masked, then
``y[i,j]`` will also be masked.
Setting `allow_masked` to False will raise an exception if values are
missing in either of the input arrays.

Parameters
----------
x : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `x` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same
    form as `x`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : bool, optional
    Default normalization (False) is by ``(N-1)``, where ``N`` is the
    number of observations given (unbiased estimate). If `bias` is True,
    then normalization is by ``N``. This keyword can be overridden by
    the keyword ``ddof`` in numpy versions >= 1.5.
allow_masked : bool, optional
    If True, masked values are propagated pair-wise: if a value is masked
    in `x`, the corresponding value is masked in `y`.
    If False, raises a `ValueError` exception when some values are missing.
ddof : {None, int}, optional
    If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is
    the number of observations; this overrides the value implied by
    ``bias``. The default value is ``None``.

    .. versionadded:: 1.5

Raises
------
ValueError
    Raised if some values are missing and `allow_masked` is False.

See Also
--------
numpy.cov
*)

val cumprod : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
cumprod(self, axis=None, dtype=None, out=None)

Return the cumulative product of the array elements over the given axis.

Masked values are set to 1 internally during the computation.
However, their position is saved, and the result will be masked at
the same locations.

Refer to `numpy.cumprod` for full documentation.

Notes
-----
The mask is lost if `out` is not a valid MaskedArray !

Arithmetic is modular when using integer types, and no error is
raised on overflow.

See Also
--------
numpy.ndarray.cumprod : corresponding function for ndarrays
numpy.cumprod : equivalent function
*)

val cumsum : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
cumsum(self, axis=None, dtype=None, out=None)

Return the cumulative sum of the array elements over the given axis.

Masked values are set to 0 internally during the computation.
However, their position is saved, and the result will be masked at
the same locations.

Refer to `numpy.cumsum` for full documentation.

Notes
-----
The mask is lost if `out` is not a valid :class:`MaskedArray` !

Arithmetic is modular when using integer types, and no error is
raised on overflow.

See Also
--------
numpy.ndarray.cumsum : corresponding function for ndarrays
numpy.cumsum : equivalent function

Examples
--------
>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])
>>> marr.cumsum()
masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],
             mask=[False, False, False,  True,  True,  True, False, False,
                   False, False],
       fill_value=999999)
*)

val default_fill_value : [`I of int | `Ndarray of [>`Ndarray] Obj.t | `F of float | `Bool of bool | `Dtype of Dtype.t | `S of string] -> Py.Object.t
(**
Return the default fill value for the argument object.

The default filling value depends on the datatype of the input
array or the type of the input scalar:

   ========  ========
   datatype  default
   ========  ========
   bool      True
   int       999999
   float     1.e20
   complex   1.e20+0j
   object    '?'
   string    'N/A'
   ========  ========

For structured types, a structured scalar is returned, with each field the
default fill value for its type.

For subarray types, the fill value is an array of the same size containing
the default scalar fill value.

Parameters
----------
obj : ndarray, dtype or scalar
    The array data-type or scalar for which the default fill value
    is returned.

Returns
-------
fill_value : scalar
    The default fill value.

Examples
--------
>>> np.ma.default_fill_value(1)
999999
>>> np.ma.default_fill_value(np.array([1.1, 2., np.pi]))
1e+20
>>> np.ma.default_fill_value(np.dtype(complex))
(1e+20+0j)
*)

val diag : ?k:Py.Object.t -> v:Py.Object.t -> unit -> Py.Object.t
(**
Extract a diagonal or construct a diagonal array.

This function is the equivalent of `numpy.diag` that takes masked
values into account, see `numpy.diag` for details.

See Also
--------
numpy.diag : Equivalent function for ndarrays.
*)

val diagflat : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
diagflat( *args, **kwargs)

    Create a two-dimensional array with the flattened input as a diagonal.

    Parameters
    ----------
    v : array_like
        Input data, which is flattened and set as the `k`-th
        diagonal of the output.
    k : int, optional
        Diagonal to set; 0, the default, corresponds to the 'main' diagonal,
        a positive (negative) `k` giving the number of the diagonal above
        (below) the main.

    Returns
    -------
    out : ndarray
        The 2-D output array.

    See Also
    --------
    diag : MATLAB work-alike for 1-D and 2-D arrays.
    diagonal : Return specified diagonals.
    trace : Sum along diagonals.

    Examples
    --------
    >>> np.diagflat([[1,2], [3,4]])
    array([[1, 0, 0, 0],
           [0, 2, 0, 0],
           [0, 0, 3, 0],
           [0, 0, 0, 4]])

    >>> np.diagflat([1,2], 1)
    array([[0, 1, 0],
           [0, 0, 2],
           [0, 0, 0]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val diagonal : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
diagonal(self, *args, **params)
a.diagonal(offset=0, axis1=0, axis2=1)

    Return specified diagonals. In NumPy 1.9 the returned array is a
    read-only view instead of a copy as in previous NumPy versions.  In
    a future version the read-only restriction will be removed.

    Refer to :func:`numpy.diagonal` for full documentation.

    See Also
    --------
    numpy.diagonal : equivalent function
*)

val diff : ?n:int -> ?axis:int -> ?prepend:Py.Object.t -> ?append:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Calculate the n-th discrete difference along the given axis.

The first difference is given by ``out[i] = a[i+1] - a[i]`` along
the given axis, higher differences are calculated by using `diff`
recursively.

Parameters
----------
a : array_like
    Input array
n : int, optional
    The number of times values are differenced. If zero, the input
    is returned as-is.
axis : int, optional
    The axis along which the difference is taken, default is the
    last axis.
prepend, append : array_like, optional
    Values to prepend or append to `a` along axis prior to
    performing the difference.  Scalar values are expanded to
    arrays with length 1 in the direction of axis and the shape
    of the input array in along all other axes.  Otherwise the
    dimension and shape must match `a` except along axis.

    .. versionadded:: 1.16.0

Returns
-------
diff : ndarray
    The n-th differences. The shape of the output is the same as `a`
    except along `axis` where the dimension is smaller by `n`. The
    type of the output is the same as the type of the difference
    between any two elements of `a`. This is the same as the type of
    `a` in most cases. A notable exception is `datetime64`, which
    results in a `timedelta64` output array.

See Also
--------
gradient, ediff1d, cumsum

Notes
-----
Type is preserved for boolean arrays, so the result will contain
`False` when consecutive elements are the same and `True` when they
differ.

For unsigned integer arrays, the results will also be unsigned. This
should not be surprising, as the result is consistent with
calculating the difference directly:

>>> u8_arr = np.array([1, 0], dtype=np.uint8)
>>> np.diff(u8_arr)
array([255], dtype=uint8)
>>> u8_arr[1,...] - u8_arr[0,...]
255

If this is not desirable, then the array should be cast to a larger
integer type first:

>>> i16_arr = u8_arr.astype(np.int16)
>>> np.diff(i16_arr)
array([-1], dtype=int16)

Examples
--------
>>> x = np.array([1, 2, 4, 7, 0])
>>> np.diff(x)
array([ 1,  2,  3, -7])
>>> np.diff(x, n=2)
array([  1,   1, -10])

>>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
>>> np.diff(x)
array([[2, 3, 4],
       [5, 1, 2]])
>>> np.diff(x, axis=0)
array([[-1,  2,  0, -2]])

>>> x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)
>>> np.diff(x)
array([1, 1], dtype='timedelta64[D]')
*)

val divide : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Returns a true division of the inputs, element-wise.

Instead of the Python traditional 'floor division', this returns a true
division.  True division adjusts the output type to present the best
answer, regardless of input types.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
The floor division operator ``//`` was added in Python 2.2 making
``//`` and ``/`` equivalent operators.  The default floor division
operation of ``/`` can be replaced by true division with ``from
__future__ import division``.

In Python 3.0, ``//`` is the floor division operator and ``/`` the
true division operator.  The ``true_divide(x1, x2)`` function is
equivalent to true division in Python.

Examples
--------
>>> x = np.arange(5)
>>> np.true_divide(x, 4)
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])

>>> x//4
array([0, 0, 0, 0, 1])

>>> from __future__ import division
>>> x/4
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
>>> x//4
array([0, 0, 0, 0, 1])
*)

val dot : ?strict:bool -> ?out:Py.Object.t -> b:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Return the dot product of two arrays.

This function is the equivalent of `numpy.dot` that takes masked values
into account. Note that `strict` and `out` are in different position
than in the method version. In order to maintain compatibility with the
corresponding method, it is recommended that the optional arguments be
treated as keyword only.  At some point that may be mandatory.

.. note::
  Works only with 2-D arrays at the moment.


Parameters
----------
a, b : masked_array_like
    Inputs arrays.
strict : bool, optional
    Whether masked data are propagated (True) or set to 0 (False) for
    the computation. Default is False.  Propagating the mask means that
    if a masked value appears in a row or column, the whole row or
    column is considered masked.
out : masked_array, optional
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for `dot(a,b)`. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.

    .. versionadded:: 1.10.2

See Also
--------
numpy.dot : Equivalent function for ndarrays.

Examples
--------
>>> a = np.ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])
>>> b = np.ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])
>>> np.ma.dot(a, b)
masked_array(
  data=[[21, 26],
        [45, 64]],
  mask=[[False, False],
        [False, False]],
  fill_value=999999)
>>> np.ma.dot(a, b, strict=True)
masked_array(
  data=[[--, --],
        [--, 64]],
  mask=[[ True,  True],
        [ True, False]],
  fill_value=999999)
*)

val dstack : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
dstack( *args, **kwargs)

    Stack arrays in sequence depth wise (along third axis).

    This is equivalent to concatenation along the third axis after 2-D arrays
    of shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape
    `(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by
    `dsplit`.

    This function makes most sense for arrays with up to 3 dimensions. For
    instance, for pixel-data with a height (first axis), width (second axis),
    and r/g/b channels (third axis). The functions `concatenate`, `stack` and
    `block` provide more general stacking and concatenation operations.

    Parameters
    ----------
    tup : sequence of arrays
        The arrays must have the same shape along all but the third axis.
        1-D or 2-D arrays must have the same shape.

    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays, will be at least 3-D.

    See Also
    --------
    stack : Join a sequence of arrays along a new axis.
    vstack : Stack along first axis.
    hstack : Stack along second axis.
    concatenate : Join a sequence of arrays along an existing axis.
    dsplit : Split array along third axis.

    Examples
    --------
    >>> a = np.array((1,2,3))
    >>> b = np.array((2,3,4))
    >>> np.dstack((a,b))
    array([[[1, 2],
            [2, 3],
            [3, 4]]])

    >>> a = np.array([[1],[2],[3]])
    >>> b = np.array([[2],[3],[4]])
    >>> np.dstack((a,b))
    array([[[1, 2]],
           [[2, 3]],
           [[3, 4]]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val ediff1d : ?to_end:Py.Object.t -> ?to_begin:Py.Object.t -> arr:Py.Object.t -> unit -> Py.Object.t
(**
Compute the differences between consecutive elements of an array.

This function is the equivalent of `numpy.ediff1d` that takes masked
values into account, see `numpy.ediff1d` for details.

See Also
--------
numpy.ediff1d : Equivalent function for ndarrays.
*)

val empty : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
empty(shape, dtype=float, order='C')

Return a new array of given shape and type, without initializing entries.

Parameters
----------
shape : int or tuple of int
    Shape of the empty array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    Desired output data-type for the array, e.g, `numpy.int8`. Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: 'C'
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data of the given shape, dtype, and
    order.  Object arrays will be initialized to None.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Notes
-----
`empty`, unlike `zeros`, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.

Examples
--------
>>> np.empty([2, 2])
array([[ -9.74499359e+001,   6.69583040e-309],
       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized

>>> np.empty([2, 2], dtype=int)
array([[-1073741821, -1067949133],
       [  496041986,    19249760]])                     #uninitialized
*)

val empty_like : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
empty_like( *args, **kwargs)

empty_like(prototype, dtype=None, order='K', subok=True, shape=None)

Return a new array with the same shape and type as a given array.

Parameters
----------
prototype : array_like
    The shape and data-type of `prototype` define these same attributes
    of the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if ``prototype`` is Fortran
    contiguous, 'C' otherwise. 'K' means match the layout of ``prototype``
    as closely as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of 'a', otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data with the same
    shape and type as `prototype`.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.

Notes
-----
This function does *not* initialize the returned array; to do that use
`zeros_like` or `ones_like` instead.  It may be marginally faster than
the functions that do set the array values.

Examples
--------
>>> a = ([1,2,3], [4,5,6])                         # a is array-like
>>> np.empty_like(a)
array([[-1073741821, -1073741821,           3],    # uninitialized
       [          0,           0, -1073741821]])
>>> a = np.array([[1., 2., 3.],[4.,5.,6.]])
>>> np.empty_like(a)
array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized
       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])
*)

val equal : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return (x1 == x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
not_equal, greater_equal, less_equal, greater, less

Examples
--------
>>> np.equal([0, 1, 3], np.arange(3))
array([ True,  True, False])

What is compared are values, not types. So an int (1) and an array of
length one can evaluate as True:

>>> np.equal(1, np.ones(1))
array([ True])
*)

val exp : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Calculate the exponential of all elements in the input array.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise exponential of `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
expm1 : Calculate ``exp(x) - 1`` for all elements in the array.
exp2  : Calculate ``2**x`` for all elements in the array.

Notes
-----
The irrational number ``e`` is also known as Euler's number.  It is
approximately 2.718281, and is the base of the natural logarithm,
``ln`` (this means that, if :math:`x = \ln y = \log_e y`,
then :math:`e^x = y`. For real input, ``exp(x)`` is always positive.

For complex arguments, ``x = a + ib``, we can write
:math:`e^x = e^a e^{ib}`.  The first term, :math:`e^a`, is already
known (it is the real argument, described above).  The second term,
:math:`e^{ib}`, is :math:`\cos b + i \sin b`, a function with
magnitude 1 and a periodic phase.

References
----------
.. [1] Wikipedia, 'Exponential function',
       https://en.wikipedia.org/wiki/Exponential_function
.. [2] M. Abramovitz and I. A. Stegun, 'Handbook of Mathematical Functions
       with Formulas, Graphs, and Mathematical Tables,' Dover, 1964, p. 69,
       http://www.math.sfu.ca/~cbm/aands/page_69.htm

Examples
--------
Plot the magnitude and phase of ``exp(x)`` in the complex plane:

>>> import matplotlib.pyplot as plt

>>> x = np.linspace(-2*np.pi, 2*np.pi, 100)
>>> xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
>>> out = np.exp(xx)

>>> plt.subplot(121)
>>> plt.imshow(np.abs(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')
>>> plt.title('Magnitude of exp(x)')

>>> plt.subplot(122)
>>> plt.imshow(np.angle(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')
>>> plt.title('Phase (angle) of exp(x)')
>>> plt.show()
*)

val expand_dims : axis:int list -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Expand the shape of an array.

Insert a new axis that will appear at the `axis` position in the expanded
array shape.

Parameters
----------
a : array_like
    Input array.
axis : int or tuple of ints
    Position in the expanded axes where the new axis (or axes) is placed.

    .. deprecated:: 1.13.0
        Passing an axis where ``axis > a.ndim`` will be treated as
        ``axis == a.ndim``, and passing ``axis < -a.ndim - 1`` will
        be treated as ``axis == 0``. This behavior is deprecated.

    .. versionchanged:: 1.18.0
        A tuple of axes is now supported.  Out of range axes as
        described above are now forbidden and raise an `AxisError`.

Returns
-------
result : ndarray
    View of `a` with the number of dimensions increased.

See Also
--------
squeeze : The inverse operation, removing singleton dimensions
reshape : Insert, remove, and combine dimensions, and resize existing ones
doc.indexing, atleast_1d, atleast_2d, atleast_3d

Examples
--------
>>> x = np.array([1, 2])
>>> x.shape
(2,)

The following is equivalent to ``x[np.newaxis, :]`` or ``x[np.newaxis]``:

>>> y = np.expand_dims(x, axis=0)
>>> y
array([[1, 2]])
>>> y.shape
(1, 2)

The following is equivalent to ``x[:, np.newaxis]``:

>>> y = np.expand_dims(x, axis=1)
>>> y
array([[1],
       [2]])
>>> y.shape
(2, 1)

``axis`` may also be a tuple:

>>> y = np.expand_dims(x, axis=(0, 1))
>>> y
array([[[1, 2]]])

>>> y = np.expand_dims(x, axis=(2, 0))
>>> y
array([[[1],
        [2]]])

Note that some examples may use ``None`` instead of ``np.newaxis``.  These
are the same objects:

>>> np.newaxis is None
True
*)

val fabs : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the absolute values element-wise.

This function returns the absolute values (positive magnitude) of the
data in `x`. Complex values are not handled, use `absolute` to find the
absolute values of complex data.

Parameters
----------
x : array_like
    The array of numbers for which the absolute values are required. If
    `x` is a scalar, the result `y` will also be a scalar.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The absolute values of `x`, the returned values are always floats.
    This is a scalar if `x` is a scalar.

See Also
--------
absolute : Absolute values including `complex` types.

Examples
--------
>>> np.fabs(-1)
1.0
>>> np.fabs([-1.2, 1.2])
array([ 1.2,  1.2])
*)

val filled : ?fill_value:[>`Ndarray] Obj.t -> [`MaskedArray of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return input as an array with masked data replaced by a fill value.

If `a` is not a `MaskedArray`, `a` itself is returned.
If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to
``a.fill_value``.

Parameters
----------
a : MaskedArray or array_like
    An input object.
fill_value : array_like, optional.
    Can be scalar or non-scalar. If non-scalar, the
    resulting filled array should be broadcastable
    over input array. Default is None.

Returns
-------
a : ndarray
    The filled array.

See Also
--------
compressed

Examples
--------
>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
...                                                   [1, 0, 0],
...                                                   [0, 0, 0]])
>>> x.filled()
array([[999999,      1,      2],
       [999999,      4,      5],
       [     6,      7,      8]])
>>> x.filled(fill_value=333)
array([[333,   1,   2],
       [333,   4,   5],
       [  6,   7,   8]])
>>> x.filled(fill_value=np.arange(3))
array([[0, 1, 2],
       [0, 4, 5],
       [6, 7, 8]])
*)

val fix_invalid : ?mask:Py.Object.t -> ?copy:bool -> ?fill_value:[`S of string | `Bool of bool | `F of float | `I of int] -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Return input with invalid data masked and replaced by a fill value.

Invalid data means values of `nan`, `inf`, etc.

Parameters
----------
a : array_like
    Input array, a (subclass of) ndarray.
mask : sequence, optional
    Mask. Must be convertible to an array of booleans with the same
    shape as `data`. True indicates a masked (i.e. invalid) data.
copy : bool, optional
    Whether to use a copy of `a` (True) or to fix `a` in place (False).
    Default is True.
fill_value : scalar, optional
    Value used for fixing invalid data. Default is None, in which case
    the ``a.fill_value`` is used.

Returns
-------
b : MaskedArray
    The input array with invalid entries fixed.

Notes
-----
A copy is performed by default.

Examples
--------
>>> x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)
>>> x
masked_array(data=[--, -1.0, nan, inf],
             mask=[ True, False, False, False],
       fill_value=1e+20)
>>> np.ma.fix_invalid(x)
masked_array(data=[--, -1.0, --, --],
             mask=[ True, False,  True,  True],
       fill_value=1e+20)

>>> fixed = np.ma.fix_invalid(x)
>>> fixed.data
array([ 1.e+00, -1.e+00,  1.e+20,  1.e+20])
>>> x.data
array([ 1., -1., nan, inf])
*)

val flatnotmasked_contiguous : Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Find contiguous unmasked data in a masked array along the given axis.

Parameters
----------
a : narray
    The input array.

Returns
-------
slice_list : list
    A sorted sequence of `slice` objects (start index, end index).

    ..versionchanged:: 1.15.0
        Now returns an empty list instead of None for a fully masked array

See Also
--------
flatnotmasked_edges, notmasked_contiguous, notmasked_edges
clump_masked, clump_unmasked

Notes
-----
Only accepts 2-D arrays at most.

Examples
--------
>>> a = np.ma.arange(10)
>>> np.ma.flatnotmasked_contiguous(a)
[slice(0, 10, None)]

>>> mask = (a < 3) | (a > 8) | (a == 5)
>>> a[mask] = np.ma.masked
>>> np.array(a[~a.mask])
array([3, 4, 6, 7, 8])

>>> np.ma.flatnotmasked_contiguous(a)
[slice(3, 5, None), slice(6, 9, None)]
>>> a[:] = np.ma.masked
>>> np.ma.flatnotmasked_contiguous(a)
[]
*)

val flatnotmasked_edges : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t option
(**
Find the indices of the first and last unmasked values.

Expects a 1-D `MaskedArray`, returns None if all values are masked.

Parameters
----------
a : array_like
    Input 1-D `MaskedArray`

Returns
-------
edges : ndarray or None
    The indices of first and last non-masked value in the array.
    Returns None if all values are masked.

See Also
--------
flatnotmasked_contiguous, notmasked_contiguous, notmasked_edges
clump_masked, clump_unmasked

Notes
-----
Only accepts 1-D arrays.

Examples
--------
>>> a = np.ma.arange(10)
>>> np.ma.flatnotmasked_edges(a)
array([0, 9])

>>> mask = (a < 3) | (a > 8) | (a == 5)
>>> a[mask] = np.ma.masked
>>> np.array(a[~a.mask])
array([3, 4, 6, 7, 8])

>>> np.ma.flatnotmasked_edges(a)
array([3, 8])

>>> a[:] = np.ma.masked
>>> print(np.ma.flatnotmasked_edges(a))
None
*)

val flatten_mask : [>`Ndarray] Obj.t -> Py.Object.t
(**
Returns a completely flattened version of the mask, where nested fields
are collapsed.

Parameters
----------
mask : array_like
    Input array, which will be interpreted as booleans.

Returns
-------
flattened_mask : ndarray of bools
    The flattened input.

Examples
--------
>>> mask = np.array([0, 0, 1])
>>> np.ma.flatten_mask(mask)
array([False, False,  True])

>>> mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])
>>> np.ma.flatten_mask(mask)
array([False, False, False,  True])

>>> mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]
>>> mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)
>>> np.ma.flatten_mask(mask)
array([False, False, False, False, False,  True])
*)

val flatten_structured_array : Py.Object.t -> Py.Object.t
(**
Flatten a structured array.

The data type of the output is chosen such that it can represent all of the
(nested) fields.

Parameters
----------
a : structured array

Returns
-------
output : masked array or ndarray
    A flattened masked array if the input is a masked array, otherwise a
    standard ndarray.

Examples
--------
>>> ndtype = [('a', int), ('b', float)]
>>> a = np.array([(1, 1), (2, 2)], dtype=ndtype)
>>> np.ma.flatten_structured_array(a)
array([[1., 1.],
       [2., 2.]])
*)

val floor : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the floor of the input, element-wise.

The floor of the scalar `x` is the largest integer `i`, such that
`i <= x`.  It is often denoted as :math:`\lfloor x \rfloor`.

Parameters
----------
x : array_like
    Input data.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The floor of each element in `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
ceil, trunc, rint

Notes
-----
Some spreadsheet programs calculate the 'floor-towards-zero', in other
words ``floor(-2.5) == -2``.  NumPy instead uses the definition of
`floor` where `floor(-2.5) == -3`.

Examples
--------
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.floor(a)
array([-2., -2., -1.,  0.,  1.,  1.,  2.])
*)

val floor_divide : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the largest integer smaller or equal to the division of the inputs.
It is equivalent to the Python ``//`` operator and pairs with the
Python ``%`` (`remainder`), function so that ``a = a % b + b * (a // b)``
up to roundoff.

Parameters
----------
x1 : array_like
    Numerator.
x2 : array_like
    Denominator. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    y = floor(`x1`/`x2`)
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
remainder : Remainder complementary to floor_divide.
divmod : Simultaneous floor division and remainder.
divide : Standard division.
floor : Round a number to the nearest integer toward minus infinity.
ceil : Round a number to the nearest integer toward infinity.

Examples
--------
>>> np.floor_divide(7,3)
2
>>> np.floor_divide([1., 2., 3., 4.], 2.5)
array([ 0.,  0.,  1.,  1.])
*)

val fmod : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the element-wise remainder of division.

This is the NumPy implementation of the C library function fmod, the
remainder has the same sign as the dividend `x1`. It is equivalent to
the Matlab(TM) ``rem`` function and should not be confused with the
Python modulus operator ``x1 % x2``.

Parameters
----------
x1 : array_like
    Dividend.
x2 : array_like
    Divisor. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : array_like
    The remainder of the division of `x1` by `x2`.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
remainder : Equivalent to the Python ``%`` operator.
divide

Notes
-----
The result of the modulo operation for negative dividend and divisors
is bound by conventions. For `fmod`, the sign of result is the sign of
the dividend, while for `remainder` the sign of the result is the sign
of the divisor. The `fmod` function is equivalent to the Matlab(TM)
``rem`` function.

Examples
--------
>>> np.fmod([-3, -2, -1, 1, 2, 3], 2)
array([-1,  0, -1,  1,  0,  1])
>>> np.remainder([-3, -2, -1, 1, 2, 3], 2)
array([1, 0, 1, 1, 0, 1])

>>> np.fmod([5, 3], [2, 2.])
array([ 1.,  1.])
>>> a = np.arange(-3, 3).reshape(3, 2)
>>> a
array([[-3, -2],
       [-1,  0],
       [ 1,  2]])
>>> np.fmod(a, [2,2])
array([[-1,  0],
       [-1,  0],
       [ 1,  0]])
*)

val frombuffer : ?params:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
frombuffer(buffer, dtype=float, count=-1, offset=0)

Interpret a buffer as a 1-dimensional array.

Parameters
----------
buffer : buffer_like
    An object that exposes the buffer interface.
dtype : data-type, optional
    Data-type of the returned array; default: float.
count : int, optional
    Number of items to read. ``-1`` means all data in the buffer.
offset : int, optional
    Start reading the buffer from this offset (in bytes); default: 0.

Notes
-----
If the buffer has data that is not in machine byte-order, this should
be specified as part of the data-type, e.g.::

  >>> dt = np.dtype(int)
  >>> dt = dt.newbyteorder('>')
  >>> np.frombuffer(buf, dtype=dt) # doctest: +SKIP

The data of the resulting array will not be byteswapped, but will be
interpreted correctly.

Examples
--------
>>> s = b'hello world'
>>> np.frombuffer(s, dtype='S1', count=5, offset=6)
array([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')

>>> np.frombuffer(b'\x01\x02', dtype=np.uint8)
array([1, 2], dtype=uint8)
>>> np.frombuffer(b'\x01\x02\x03\x04\x05', dtype=np.uint8, count=3)
array([1, 2, 3], dtype=uint8)
*)

val fromflex : [>`Ndarray] Obj.t -> Py.Object.t
(**
Build a masked array from a suitable flexible-type array.

The input array has to have a data-type with ``_data`` and ``_mask``
fields. This type of array is output by `MaskedArray.toflex`.

Parameters
----------
fxarray : ndarray
    The structured input array, containing ``_data`` and ``_mask``
    fields. If present, other fields are discarded.

Returns
-------
result : MaskedArray
    The constructed masked array.

See Also
--------
MaskedArray.toflex : Build a flexible-type array from a masked array.

Examples
--------
>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[0] + [1, 0] * 4)
>>> rec = x.toflex()
>>> rec
array([[(0, False), (1,  True), (2, False)],
       [(3,  True), (4, False), (5,  True)],
       [(6, False), (7,  True), (8, False)]],
      dtype=[('_data', '<i8'), ('_mask', '?')])
>>> x2 = np.ma.fromflex(rec)
>>> x2
masked_array(
  data=[[0, --, 2],
        [--, 4, --],
        [6, --, 8]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)

Extra fields can be present in the structured array but are discarded:

>>> dt = [('_data', '<i4'), ('_mask', '|b1'), ('field3', '<f4')]
>>> rec2 = np.zeros((2, 2), dtype=dt)
>>> rec2
array([[(0, False, 0.), (0, False, 0.)],
       [(0, False, 0.), (0, False, 0.)]],
      dtype=[('_data', '<i4'), ('_mask', '?'), ('field3', '<f4')])
>>> y = np.ma.fromflex(rec2)
>>> y
masked_array(
  data=[[0, 0],
        [0, 0]],
  mask=[[False, False],
        [False, False]],
  fill_value=999999,
  dtype=int32)
*)

val fromfunction : ?params:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
fromfunction(function, shape, **kwargs)

Construct an array by executing a function over each coordinate.

The resulting array therefore has a value ``fn(x, y, z)`` at
coordinate ``(x, y, z)``.

Parameters
----------
function : callable
    The function is called with N parameters, where N is the rank of
    `shape`.  Each parameter represents the coordinates of the array
    varying along a specific axis.  For example, if `shape`
    were ``(2, 2)``, then the parameters would be
    ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``
shape : (N,) tuple of ints
    Shape of the output array, which also determines the shape of
    the coordinate arrays passed to `function`.
dtype : data-type, optional
    Data-type of the coordinate arrays passed to `function`.
    By default, `dtype` is float.

Returns
-------
fromfunction : any
    The result of the call to `function` is passed back directly.
    Therefore the shape of `fromfunction` is completely determined by
    `function`.  If `function` returns a scalar value, the shape of
    `fromfunction` would not match the `shape` parameter.

See Also
--------
indices, meshgrid

Notes
-----
Keywords other than `dtype` are passed to `function`.

Examples
--------
>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
array([[ True, False, False],
       [False,  True, False],
       [False, False,  True]])

>>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)
array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])
*)

val getdata : ?subok:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the data of a masked array as an ndarray.

Return the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,
else return `a` as a ndarray or subclass (depending on `subok`) if not.

Parameters
----------
a : array_like
    Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.
subok : bool
    Whether to force the output to be a `pure` ndarray (False) or to
    return a subclass of ndarray if appropriate (True, default).

See Also
--------
getmask : Return the mask of a masked array, or nomask.
getmaskarray : Return the mask of a masked array, or full array of False.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getdata(a)
array([[1, 2],
       [3, 4]])

Equivalently use the ``MaskedArray`` `data` attribute.

>>> a.data
array([[1, 2],
       [3, 4]])
*)

val getmask : [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the mask of a masked array, or nomask.

Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the
mask is not `nomask`, else return `nomask`. To guarantee a full array
of booleans of the same shape as a, use `getmaskarray`.

Parameters
----------
a : array_like
    Input `MaskedArray` for which the mask is required.

See Also
--------
getdata : Return the data of a masked array as an ndarray.
getmaskarray : Return the mask of a masked array, or full array of False.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getmask(a)
array([[False,  True],
       [False, False]])

Equivalently use the `MaskedArray` `mask` attribute.

>>> a.mask
array([[False,  True],
       [False, False]])

Result when mask == `nomask`

>>> b = ma.masked_array([[1,2],[3,4]])
>>> b
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> ma.nomask
False
>>> ma.getmask(b) == ma.nomask
True
>>> b.mask == ma.nomask
True
*)

val getmaskarray : [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the mask of a masked array, or full boolean array of False.

Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and
the mask is not `nomask`, else return a full boolean array of False of
the same shape as `arr`.

Parameters
----------
arr : array_like
    Input `MaskedArray` for which the mask is required.

See Also
--------
getmask : Return the mask of a masked array, or nomask.
getdata : Return the data of a masked array as an ndarray.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getmaskarray(a)
array([[False,  True],
       [False, False]])

Result when mask == ``nomask``

>>> b = ma.masked_array([[1,2],[3,4]])
>>> b
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> ma.getmaskarray(b)
array([[False, False],
       [False, False]])
*)

val greater : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the truth value of (x1 > x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.


See Also
--------
greater_equal, less, less_equal, equal, not_equal

Examples
--------
>>> np.greater([4,2],[2,2])
array([ True, False])

If the inputs are ndarrays, then np.greater is equivalent to '>'.

>>> a = np.array([4,2])
>>> b = np.array([2,2])
>>> a > b
array([ True, False])
*)

val greater_equal : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the truth value of (x1 >= x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : bool or ndarray of bool
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
greater, less, less_equal, equal, not_equal

Examples
--------
>>> np.greater_equal([4, 2, 1], [2, 2, 2])
array([ True, True, False])
*)

val harden_mask : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
harden_mask(self)

Force the mask to hard.

Whether the mask of a masked array is hard or soft is determined by
its `hardmask` property. `harden_mask` sets `hardmask` to True.

See Also
--------
hardmask
*)

val hsplit : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
hsplit( *args, **kwargs)

    Split an array into multiple sub-arrays horizontally (column-wise).

    Please refer to the `split` documentation.  `hsplit` is equivalent
    to `split` with ``axis=1``, the array is always split along the second
    axis regardless of the array dimension.

    See Also
    --------
    split : Split an array into multiple sub-arrays of equal size.

    Examples
    --------
    >>> x = np.arange(16.0).reshape(4, 4)
    >>> x
    array([[ 0.,   1.,   2.,   3.],
           [ 4.,   5.,   6.,   7.],
           [ 8.,   9.,  10.,  11.],
           [12.,  13.,  14.,  15.]])
    >>> np.hsplit(x, 2)
    [array([[  0.,   1.],
           [  4.,   5.],
           [  8.,   9.],
           [12.,  13.]]),
     array([[  2.,   3.],
           [  6.,   7.],
           [10.,  11.],
           [14.,  15.]])]
    >>> np.hsplit(x, np.array([3, 6]))
    [array([[ 0.,   1.,   2.],
           [ 4.,   5.,   6.],
           [ 8.,   9.,  10.],
           [12.,  13.,  14.]]),
     array([[ 3.],
           [ 7.],
           [11.],
           [15.]]),
     array([], shape=(4, 0), dtype=float64)]

    With a higher dimensional array the split is still along the second axis.

    >>> x = np.arange(8.0).reshape(2, 2, 2)
    >>> x
    array([[[0.,  1.],
            [2.,  3.]],
           [[4.,  5.],
            [6.,  7.]]])
    >>> np.hsplit(x, 2)
    [array([[[0.,  1.]],
           [[4.,  5.]]]),
     array([[[2.,  3.]],
           [[6.,  7.]]])]

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val hstack : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
hstack( *args, **kwargs)

    Stack arrays in sequence horizontally (column wise).

    This is equivalent to concatenation along the second axis, except for 1-D
    arrays where it concatenates along the first axis. Rebuilds arrays divided
    by `hsplit`.

    This function makes most sense for arrays with up to 3 dimensions. For
    instance, for pixel-data with a height (first axis), width (second axis),
    and r/g/b channels (third axis). The functions `concatenate`, `stack` and
    `block` provide more general stacking and concatenation operations.

    Parameters
    ----------
    tup : sequence of ndarrays
        The arrays must have the same shape along all but the second axis,
        except 1-D arrays which can be any length.

    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays.

    See Also
    --------
    stack : Join a sequence of arrays along a new axis.
    vstack : Stack arrays in sequence vertically (row wise).
    dstack : Stack arrays in sequence depth wise (along third axis).
    concatenate : Join a sequence of arrays along an existing axis.
    hsplit : Split array along second axis.
    block : Assemble arrays from blocks.

    Examples
    --------
    >>> a = np.array((1,2,3))
    >>> b = np.array((2,3,4))
    >>> np.hstack((a,b))
    array([1, 2, 3, 2, 3, 4])
    >>> a = np.array([[1],[2],[3]])
    >>> b = np.array([[2],[3],[4]])
    >>> np.hstack((a,b))
    array([[1, 2],
           [2, 3],
           [3, 4]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val hypot : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Given the 'legs' of a right triangle, return its hypotenuse.

Equivalent to ``sqrt(x1**2 + x2**2)``, element-wise.  If `x1` or
`x2` is scalar_like (i.e., unambiguously cast-able to a scalar type),
it is broadcast for use with each element of the other argument.
(See Examples)

Parameters
----------
x1, x2 : array_like
    Leg of the triangle(s). If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
z : ndarray
    The hypotenuse of the triangle(s).
    This is a scalar if both `x1` and `x2` are scalars.

Examples
--------
>>> np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])

Example showing broadcast of scalar_like argument:

>>> np.hypot(3*np.ones((3, 3)), [4])
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])
*)

val identity : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
identity(n, dtype=None)

Return the identity array.

The identity array is a square array with ones on
the main diagonal.

Parameters
----------
n : int
    Number of rows (and columns) in `n` x `n` output.
dtype : data-type, optional
    Data-type of the output.  Defaults to ``float``.

Returns
-------
out : ndarray
    `n` x `n` array with its main diagonal set to one,
    and all other elements 0.

Examples
--------
>>> np.identity(3)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
*)

val ids : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
ids(self)

Return the addresses of the data and mask areas.

Parameters
----------
None

Examples
--------
>>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])
>>> x.ids()
(166670640, 166659832) # may vary

If the array has no mask, the address of `nomask` is returned. This address
is typically not close to the data in memory:

>>> x = np.ma.array([1, 2, 3])
>>> x.ids()
(166691080, 3083169284L) # may vary
*)

val in1d : ?assume_unique:Py.Object.t -> ?invert:Py.Object.t -> ar1:Py.Object.t -> ar2:Py.Object.t -> unit -> Py.Object.t
(**
Test whether each element of an array is also present in a second
array.

The output is always a masked array. See `numpy.in1d` for more details.

We recommend using :func:`isin` instead of `in1d` for new code.

See Also
--------
isin       : Version of this function that preserves the shape of ar1.
numpy.in1d : Equivalent function for ndarrays.

Notes
-----
.. versionadded:: 1.4.0
*)

val indices : ?dtype:Dtype.t -> ?sparse:bool -> dimensions:int list -> unit -> Py.Object.t
(**
Return an array representing the indices of a grid.

Compute an array where the subarrays contain index values 0, 1, ...
varying only along the corresponding axis.

Parameters
----------
dimensions : sequence of ints
    The shape of the grid.
dtype : dtype, optional
    Data type of the result.
sparse : boolean, optional
    Return a sparse representation of the grid instead of a dense
    representation. Default is False.

    .. versionadded:: 1.17

Returns
-------
grid : one ndarray or tuple of ndarrays
    If sparse is False:
        Returns one array of grid indices,
        ``grid.shape = (len(dimensions),) + tuple(dimensions)``.
    If sparse is True:
        Returns a tuple of arrays, with
        ``grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)`` with
        dimensions[i] in the ith place

See Also
--------
mgrid, ogrid, meshgrid

Notes
-----
The output shape in the dense case is obtained by prepending the number
of dimensions in front of the tuple of dimensions, i.e. if `dimensions`
is a tuple ``(r0, ..., rN-1)`` of length ``N``, the output shape is
``(N, r0, ..., rN-1)``.

The subarrays ``grid[k]`` contains the N-D array of indices along the
``k-th`` axis. Explicitly::

    grid[k, i0, i1, ..., iN-1] = ik

Examples
--------
>>> grid = np.indices((2, 3))
>>> grid.shape
(2, 2, 3)
>>> grid[0]        # row indices
array([[0, 0, 0],
       [1, 1, 1]])
>>> grid[1]        # column indices
array([[0, 1, 2],
       [0, 1, 2]])

The indices can be used as an index into an array.

>>> x = np.arange(20).reshape(5, 4)
>>> row, col = np.indices((2, 3))
>>> x[row, col]
array([[0, 1, 2],
       [4, 5, 6]])

Note that it would be more straightforward in the above example to
extract the required elements directly with ``x[:2, :3]``.

If sparse is set to true, the grid will be returned in a sparse
representation.

>>> i, j = np.indices((2, 3), sparse=True)
>>> i.shape
(2, 1)
>>> j.shape
(1, 3)
>>> i        # row indices
array([[0],
       [1]])
>>> j        # column indices
array([[0, 1, 2]])
*)

val inner : b:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
inner(a, b)

Inner product of two arrays.

Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.

Parameters
----------
a, b : array_like
    If `a` and `b` are nonscalar, their last dimensions must match.

Returns
-------
out : ndarray
    `out.shape = a.shape[:-1] + b.shape[:-1]`

Raises
------
ValueError
    If the last dimension of `a` and `b` has different size.

See Also
--------
tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of `b`.
einsum : Einstein summation convention.

Notes
-----
Masked values are replaced by 0.

For vectors (1-D arrays) it computes the ordinary inner-product::

    np.inner(a, b) = sum(a[:]*b[:])

More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::

    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))

or explicitly::

    np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
         = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])

In addition `a` or `b` may be scalars, in which case::

   np.inner(a,b) = a*b

Examples
--------
Ordinary inner product for vectors:

>>> a = np.array([1,2,3])
>>> b = np.array([0,1,0])
>>> np.inner(a, b)
2

A multidimensional example:

>>> a = np.arange(24).reshape((2,3,4))
>>> b = np.arange(4)
>>> np.inner(a, b)
array([[ 14,  38,  62],
       [ 86, 110, 134]])

An example where `b` is a scalar:

>>> np.inner(np.eye(2), 7)
array([[7., 0.],
       [0., 7.]])
*)

val innerproduct : b:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
inner(a, b)

Inner product of two arrays.

Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.

Parameters
----------
a, b : array_like
    If `a` and `b` are nonscalar, their last dimensions must match.

Returns
-------
out : ndarray
    `out.shape = a.shape[:-1] + b.shape[:-1]`

Raises
------
ValueError
    If the last dimension of `a` and `b` has different size.

See Also
--------
tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of `b`.
einsum : Einstein summation convention.

Notes
-----
Masked values are replaced by 0.

For vectors (1-D arrays) it computes the ordinary inner-product::

    np.inner(a, b) = sum(a[:]*b[:])

More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::

    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))

or explicitly::

    np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
         = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])

In addition `a` or `b` may be scalars, in which case::

   np.inner(a,b) = a*b

Examples
--------
Ordinary inner product for vectors:

>>> a = np.array([1,2,3])
>>> b = np.array([0,1,0])
>>> np.inner(a, b)
2

A multidimensional example:

>>> a = np.arange(24).reshape((2,3,4))
>>> b = np.arange(4)
>>> np.inner(a, b)
array([[ 14,  38,  62],
       [ 86, 110, 134]])

An example where `b` is a scalar:

>>> np.inner(np.eye(2), 7)
array([[7., 0.],
       [0., 7.]])
*)

val intersect1d : ?assume_unique:Py.Object.t -> ar1:Py.Object.t -> ar2:Py.Object.t -> unit -> Py.Object.t
(**
Returns the unique elements common to both arrays.

Masked values are considered equal one to the other.
The output is always a masked array.

See `numpy.intersect1d` for more details.

See Also
--------
numpy.intersect1d : Equivalent function for ndarrays.

Examples
--------
>>> x = np.ma.array([1, 3, 3, 3], mask=[0, 0, 0, 1])
>>> y = np.ma.array([3, 1, 1, 1], mask=[0, 0, 0, 1])
>>> np.ma.intersect1d(x, y)
masked_array(data=[1, 3, --],
             mask=[False, False,  True],
       fill_value=999999)
*)

val isMA : Py.Object.t -> bool
(**
Test whether input is an instance of MaskedArray.

This function returns True if `x` is an instance of MaskedArray
and returns False otherwise.  Any object is accepted as input.

Parameters
----------
x : object
    Object to test.

Returns
-------
result : bool
    True if `x` is a MaskedArray.

See Also
--------
isMA : Alias to isMaskedArray.
isarray : Alias to isMaskedArray.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.eye(3, 3)
>>> a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
>>> m = ma.masked_values(a, 0)
>>> m
masked_array(
  data=[[1.0, --, --],
        [--, 1.0, --],
        [--, --, 1.0]],
  mask=[[False,  True,  True],
        [ True, False,  True],
        [ True,  True, False]],
  fill_value=0.0)
>>> ma.isMaskedArray(a)
False
>>> ma.isMaskedArray(m)
True
>>> ma.isMaskedArray([0, 1, 2])
False
*)

val isMaskedArray : Py.Object.t -> bool
(**
Test whether input is an instance of MaskedArray.

This function returns True if `x` is an instance of MaskedArray
and returns False otherwise.  Any object is accepted as input.

Parameters
----------
x : object
    Object to test.

Returns
-------
result : bool
    True if `x` is a MaskedArray.

See Also
--------
isMA : Alias to isMaskedArray.
isarray : Alias to isMaskedArray.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.eye(3, 3)
>>> a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
>>> m = ma.masked_values(a, 0)
>>> m
masked_array(
  data=[[1.0, --, --],
        [--, 1.0, --],
        [--, --, 1.0]],
  mask=[[False,  True,  True],
        [ True, False,  True],
        [ True,  True, False]],
  fill_value=0.0)
>>> ma.isMaskedArray(a)
False
>>> ma.isMaskedArray(m)
True
>>> ma.isMaskedArray([0, 1, 2])
False
*)

val is_mask : [>`Ndarray] Obj.t -> bool
(**
Return True if m is a valid, standard mask.

This function does not check the contents of the input, only that the
type is MaskType. In particular, this function returns False if the
mask has a flexible dtype.

Parameters
----------
m : array_like
    Array to test.

Returns
-------
result : bool
    True if `m.dtype.type` is MaskType, False otherwise.

See Also
--------
isMaskedArray : Test whether input is an instance of MaskedArray.

Examples
--------
>>> import numpy.ma as ma
>>> m = ma.masked_equal([0, 1, 0, 2, 3], 0)
>>> m
masked_array(data=[--, 1, --, 2, 3],
             mask=[ True, False,  True, False, False],
       fill_value=0)
>>> ma.is_mask(m)
False
>>> ma.is_mask(m.mask)
True

Input must be an ndarray (or have similar attributes)
for it to be considered a valid mask.

>>> m = [False, True, False]
>>> ma.is_mask(m)
False
>>> m = np.array([False, True, False])
>>> m
array([False,  True, False])
>>> ma.is_mask(m)
True

Arrays with complex dtypes don't return True.

>>> dtype = np.dtype({'names':['monty', 'pithon'],
...                   'formats':[bool, bool]})
>>> dtype
dtype([('monty', '|b1'), ('pithon', '|b1')])
>>> m = np.array([(True, False), (False, True), (True, False)],
...              dtype=dtype)
>>> m
array([( True, False), (False,  True), ( True, False)],
      dtype=[('monty', '?'), ('pithon', '?')])
>>> ma.is_mask(m)
False
*)

val is_masked : [>`Ndarray] Obj.t -> bool
(**
Determine whether input has masked values.

Accepts any object as input, but always returns False unless the
input is a MaskedArray containing masked values.

Parameters
----------
x : array_like
    Array to check for masked values.

Returns
-------
result : bool
    True if `x` is a MaskedArray with masked values, False otherwise.

Examples
--------
>>> import numpy.ma as ma
>>> x = ma.masked_equal([0, 1, 0, 2, 3], 0)
>>> x
masked_array(data=[--, 1, --, 2, 3],
             mask=[ True, False,  True, False, False],
       fill_value=0)
>>> ma.is_masked(x)
True
>>> x = ma.masked_equal([0, 1, 0, 2, 3], 42)
>>> x
masked_array(data=[0, 1, 0, 2, 3],
             mask=False,
       fill_value=42)
>>> ma.is_masked(x)
False

Always returns False if `x` isn't a MaskedArray.

>>> x = [False, True, False]
>>> ma.is_masked(x)
False
>>> x = 'a string'
>>> ma.is_masked(x)
False
*)

val isarray : Py.Object.t -> bool
(**
Test whether input is an instance of MaskedArray.

This function returns True if `x` is an instance of MaskedArray
and returns False otherwise.  Any object is accepted as input.

Parameters
----------
x : object
    Object to test.

Returns
-------
result : bool
    True if `x` is a MaskedArray.

See Also
--------
isMA : Alias to isMaskedArray.
isarray : Alias to isMaskedArray.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.eye(3, 3)
>>> a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
>>> m = ma.masked_values(a, 0)
>>> m
masked_array(
  data=[[1.0, --, --],
        [--, 1.0, --],
        [--, --, 1.0]],
  mask=[[False,  True,  True],
        [ True, False,  True],
        [ True,  True, False]],
  fill_value=0.0)
>>> ma.isMaskedArray(a)
False
>>> ma.isMaskedArray(m)
True
>>> ma.isMaskedArray([0, 1, 2])
False
*)

val isin : ?assume_unique:Py.Object.t -> ?invert:Py.Object.t -> element:Py.Object.t -> test_elements:Py.Object.t -> unit -> Py.Object.t
(**
Calculates `element in test_elements`, broadcasting over
`element` only.

The output is always a masked array of the same shape as `element`.
See `numpy.isin` for more details.

See Also
--------
in1d       : Flattened version of this function.
numpy.isin : Equivalent function for ndarrays.

Notes
-----
.. versionadded:: 1.13.0
*)

val left_shift : n:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Shift the bits of an integer to the left.

This is the masked array version of `numpy.left_shift`, for details
see that function.

See Also
--------
numpy.left_shift
*)

val less : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the truth value of (x1 < x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
greater, less_equal, greater_equal, equal, not_equal

Examples
--------
>>> np.less([1, 2], [2, 2])
array([ True, False])
*)

val less_equal : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the truth value of (x1 =< x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
greater, less, greater_equal, equal, not_equal

Examples
--------
>>> np.less_equal([4, 2, 1], [2, 2, 2])
array([False,  True,  True])
*)

val log : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Natural logarithm, element-wise.

The natural logarithm `log` is the inverse of the exponential function,
so that `log(exp(x)) = x`. The natural logarithm is logarithm in base
`e`.

Parameters
----------
x : array_like
    Input value.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The natural logarithm of `x`, element-wise.
    This is a scalar if `x` is a scalar.

See Also
--------
log10, log2, log1p, emath.log

Notes
-----
Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `exp(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log` always returns real output. For
each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it. `log`
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Logarithm'. https://en.wikipedia.org/wiki/Logarithm

Examples
--------
>>> np.log([1, np.e, np.e**2, 0])
array([  0.,   1.,   2., -Inf])
*)

val log10 : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the base 10 logarithm of the input array, element-wise.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The logarithm to the base 10 of `x`, element-wise. NaNs are
    returned where x is negative.
    This is a scalar if `x` is a scalar.

See Also
--------
emath.log10

Notes
-----
Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `10**z = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log10` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log10` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it.
`log10` handles the floating-point negative zero as an infinitesimal
negative number, conforming to the C99 standard.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Logarithm'. https://en.wikipedia.org/wiki/Logarithm

Examples
--------
>>> np.log10([1e-15, -3.])
array([-15.,  nan])
*)

val log2 : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Base-2 logarithm of `x`.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    Base-2 logarithm of `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
log, log10, log1p, emath.log2

Notes
-----
.. versionadded:: 1.3.0

Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `2**z = x`. The convention is to return the `z`
whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log2` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log2` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it. `log2`
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.

Examples
--------
>>> x = np.array([0, 1, 2, 2**4])
>>> np.log2(x)
array([-Inf,   0.,   1.,   4.])

>>> xi = np.array([0+1.j, 1, 2+0.j, 4.j])
>>> np.log2(xi)
array([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])
*)

val logical_and : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the truth value of x1 AND x2 element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or bool
    Boolean result of the logical AND operation applied to the elements
    of `x1` and `x2`; the shape is determined by broadcasting.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_or, logical_not, logical_xor
bitwise_and

Examples
--------
>>> np.logical_and(True, False)
False
>>> np.logical_and([True, False], [False, False])
array([False, False])

>>> x = np.arange(5)
>>> np.logical_and(x>1, x<4)
array([False, False,  True,  True, False])
*)

val logical_not : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the truth value of NOT x element-wise.

Parameters
----------
x : array_like
    Logical NOT is applied to the elements of `x`.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : bool or ndarray of bool
    Boolean result with the same shape as `x` of the NOT operation
    on elements of `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
logical_and, logical_or, logical_xor

Examples
--------
>>> np.logical_not(3)
False
>>> np.logical_not([True, False, 0, 1])
array([False,  True,  True, False])

>>> x = np.arange(5)
>>> np.logical_not(x<3)
array([False, False, False,  True,  True])
*)

val logical_or : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the truth value of x1 OR x2 element-wise.

Parameters
----------
x1, x2 : array_like
    Logical OR is applied to the elements of `x1` and `x2`.
    If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or bool
    Boolean result of the logical OR operation applied to the elements
    of `x1` and `x2`; the shape is determined by broadcasting.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_and, logical_not, logical_xor
bitwise_or

Examples
--------
>>> np.logical_or(True, False)
True
>>> np.logical_or([True, False], [False, False])
array([ True, False])

>>> x = np.arange(5)
>>> np.logical_or(x < 1, x > 3)
array([ True, False, False, False,  True])
*)

val logical_xor : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the truth value of x1 XOR x2, element-wise.

Parameters
----------
x1, x2 : array_like
    Logical XOR is applied to the elements of `x1` and `x2`. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : bool or ndarray of bool
    Boolean result of the logical XOR operation applied to the elements
    of `x1` and `x2`; the shape is determined by broadcasting.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_and, logical_or, logical_not, bitwise_xor

Examples
--------
>>> np.logical_xor(True, False)
True
>>> np.logical_xor([True, True, False, False], [True, False, True, False])
array([False,  True,  True, False])

>>> x = np.arange(5)
>>> np.logical_xor(x < 1, x > 3)
array([ True, False, False, False,  True])

Simple example showing support of broadcasting

>>> np.logical_xor(0, np.eye(2))
array([[ True, False],
       [False,  True]])
*)

val make_mask : ?copy:bool -> ?shrink:bool -> ?dtype:Dtype.t -> m:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Create a boolean mask from an array.

Return `m` as a boolean mask, creating a copy if necessary or requested.
The function can accept any sequence that is convertible to integers,
or ``nomask``.  Does not require that contents must be 0s and 1s, values
of 0 are interpreted as False, everything else as True.

Parameters
----------
m : array_like
    Potential mask.
copy : bool, optional
    Whether to return a copy of `m` (True) or `m` itself (False).
shrink : bool, optional
    Whether to shrink `m` to ``nomask`` if all its values are False.
dtype : dtype, optional
    Data-type of the output mask. By default, the output mask has a
    dtype of MaskType (bool). If the dtype is flexible, each field has
    a boolean dtype. This is ignored when `m` is ``nomask``, in which
    case ``nomask`` is always returned.

Returns
-------
result : ndarray
    A boolean mask derived from `m`.

Examples
--------
>>> import numpy.ma as ma
>>> m = [True, False, True, True]
>>> ma.make_mask(m)
array([ True, False,  True,  True])
>>> m = [1, 0, 1, 1]
>>> ma.make_mask(m)
array([ True, False,  True,  True])
>>> m = [1, 0, 2, -3]
>>> ma.make_mask(m)
array([ True, False,  True,  True])

Effect of the `shrink` parameter.

>>> m = np.zeros(4)
>>> m
array([0., 0., 0., 0.])
>>> ma.make_mask(m)
False
>>> ma.make_mask(m, shrink=False)
array([False, False, False, False])

Using a flexible `dtype`.

>>> m = [1, 0, 1, 1]
>>> n = [0, 1, 0, 0]
>>> arr = []
>>> for man, mouse in zip(m, n):
...     arr.append((man, mouse))
>>> arr
[(1, 0), (0, 1), (1, 0), (1, 0)]
>>> dtype = np.dtype({'names':['man', 'mouse'],
...                   'formats':[np.int64, np.int64]})
>>> arr = np.array(arr, dtype=dtype)
>>> arr
array([(1, 0), (0, 1), (1, 0), (1, 0)],
      dtype=[('man', '<i8'), ('mouse', '<i8')])
>>> ma.make_mask(arr, dtype=dtype)
array([(True, False), (False, True), (True, False), (True, False)],
      dtype=[('man', '|b1'), ('mouse', '|b1')])
*)

val make_mask_descr : Dtype.t -> Dtype.t
(**
Construct a dtype description list from a given dtype.

Returns a new dtype object, with the type of all fields in `ndtype` to a
boolean type. Field names are not altered.

Parameters
----------
ndtype : dtype
    The dtype to convert.

Returns
-------
result : dtype
    A dtype that looks like `ndtype`, the type of all fields is boolean.

Examples
--------
>>> import numpy.ma as ma
>>> dtype = np.dtype({'names':['foo', 'bar'],
...                   'formats':[np.float32, np.int64]})
>>> dtype
dtype([('foo', '<f4'), ('bar', '<i8')])
>>> ma.make_mask_descr(dtype)
dtype([('foo', '|b1'), ('bar', '|b1')])
>>> ma.make_mask_descr(np.float32)
dtype('bool')
*)

val make_mask_none : ?dtype:Dtype.t -> newshape:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a boolean mask of the given shape, filled with False.

This function returns a boolean ndarray with all entries False, that can
be used in common mask manipulations. If a complex dtype is specified, the
type of each field is converted to a boolean type.

Parameters
----------
newshape : tuple
    A tuple indicating the shape of the mask.
dtype : {None, dtype}, optional
    If None, use a MaskType instance. Otherwise, use a new datatype with
    the same fields as `dtype`, converted to boolean types.

Returns
-------
result : ndarray
    An ndarray of appropriate shape and dtype, filled with False.

See Also
--------
make_mask : Create a boolean mask from an array.
make_mask_descr : Construct a dtype description list from a given dtype.

Examples
--------
>>> import numpy.ma as ma
>>> ma.make_mask_none((3,))
array([False, False, False])

Defining a more complex dtype.

>>> dtype = np.dtype({'names':['foo', 'bar'],
...                   'formats':[np.float32, np.int64]})
>>> dtype
dtype([('foo', '<f4'), ('bar', '<i8')])
>>> ma.make_mask_none((3,), dtype=dtype)
array([(False, False), (False, False), (False, False)],
      dtype=[('foo', '|b1'), ('bar', '|b1')])
*)

val mask_cols : ?axis:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask columns of a 2D array that contain masked values.

This function is a shortcut to ``mask_rowcols`` with `axis` equal to 1.

See Also
--------
mask_rowcols : Mask rows and/or columns of a 2D array.
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.zeros((3, 3), dtype=int)
>>> a[1, 1] = 1
>>> a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
>>> a = ma.masked_equal(a, 1)
>>> a
masked_array(
  data=[[0, 0, 0],
        [0, --, 0],
        [0, 0, 0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1)
>>> ma.mask_cols(a)
masked_array(
  data=[[0, --, 0],
        [0, --, 0],
        [0, --, 0]],
  mask=[[False,  True, False],
        [False,  True, False],
        [False,  True, False]],
  fill_value=1)
*)

val mask_or : ?copy:bool -> ?shrink:bool -> m1:Py.Object.t -> m2:Py.Object.t -> unit -> Py.Object.t
(**
Combine two masks with the ``logical_or`` operator.

The result may be a view on `m1` or `m2` if the other is `nomask`
(i.e. False).

Parameters
----------
m1, m2 : array_like
    Input masks.
copy : bool, optional
    If copy is False and one of the inputs is `nomask`, return a view
    of the other input mask. Defaults to False.
shrink : bool, optional
    Whether to shrink the output to `nomask` if all its values are
    False. Defaults to True.

Returns
-------
mask : output mask
    The result masks values that are masked in either `m1` or `m2`.

Raises
------
ValueError
    If `m1` and `m2` have different flexible dtypes.

Examples
--------
>>> m1 = np.ma.make_mask([0, 1, 1, 0])
>>> m2 = np.ma.make_mask([1, 0, 0, 0])
>>> np.ma.mask_or(m1, m2)
array([ True,  True,  True, False])
*)

val mask_rowcols : ?axis:int -> [`MaskedArray of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
Mask rows and/or columns of a 2D array that contain masked values.

Mask whole rows and/or columns of a 2D array that contain
masked values.  The masking behavior is selected using the
`axis` parameter.

  - If `axis` is None, rows *and* columns are masked.
  - If `axis` is 0, only rows are masked.
  - If `axis` is 1 or -1, only columns are masked.

Parameters
----------
a : array_like, MaskedArray
    The array to mask.  If not a MaskedArray instance (or if no array
    elements are masked).  The result is a MaskedArray with `mask` set
    to `nomask` (False). Must be a 2D array.
axis : int, optional
    Axis along which to perform the operation. If None, applies to a
    flattened version of the array.

Returns
-------
a : MaskedArray
    A modified version of the input array, masked depending on the value
    of the `axis` parameter.

Raises
------
NotImplementedError
    If input array `a` is not 2D.

See Also
--------
mask_rows : Mask rows of a 2D array that contain masked values.
mask_cols : Mask cols of a 2D array that contain masked values.
masked_where : Mask where a condition is met.

Notes
-----
The input array's mask is modified by this function.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.zeros((3, 3), dtype=int)
>>> a[1, 1] = 1
>>> a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
>>> a = ma.masked_equal(a, 1)
>>> a
masked_array(
  data=[[0, 0, 0],
        [0, --, 0],
        [0, 0, 0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1)
>>> ma.mask_rowcols(a)
masked_array(
  data=[[0, --, 0],
        [--, --, --],
        [0, --, 0]],
  mask=[[False,  True, False],
        [ True,  True,  True],
        [False,  True, False]],
  fill_value=1)
*)

val mask_rows : ?axis:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask rows of a 2D array that contain masked values.

This function is a shortcut to ``mask_rowcols`` with `axis` equal to 0.

See Also
--------
mask_rowcols : Mask rows and/or columns of a 2D array.
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.zeros((3, 3), dtype=int)
>>> a[1, 1] = 1
>>> a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
>>> a = ma.masked_equal(a, 1)
>>> a
masked_array(
  data=[[0, 0, 0],
        [0, --, 0],
        [0, 0, 0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1)

>>> ma.mask_rows(a)
masked_array(
  data=[[0, 0, 0],
        [--, --, --],
        [0, 0, 0]],
  mask=[[False, False, False],
        [ True,  True,  True],
        [False, False, False]],
  fill_value=1)
*)

val masked_all : ?dtype:Dtype.t -> int list -> Py.Object.t
(**
Empty masked array with all elements masked.

Return an empty masked array of the given shape and dtype, where all the
data are masked.

Parameters
----------
shape : tuple
    Shape of the required MaskedArray.
dtype : dtype, optional
    Data type of the output.

Returns
-------
a : MaskedArray
    A masked array with all data masked.

See Also
--------
masked_all_like : Empty masked array modelled on an existing array.

Examples
--------
>>> import numpy.ma as ma
>>> ma.masked_all((3, 3))
masked_array(
  data=[[--, --, --],
        [--, --, --],
        [--, --, --]],
  mask=[[ True,  True,  True],
        [ True,  True,  True],
        [ True,  True,  True]],
  fill_value=1e+20,
  dtype=float64)

The `dtype` parameter defines the underlying data type.

>>> a = ma.masked_all((3, 3))
>>> a.dtype
dtype('float64')
>>> a = ma.masked_all((3, 3), dtype=np.int32)
>>> a.dtype
dtype('int32')
*)

val masked_all_like : [>`Ndarray] Obj.t -> Py.Object.t
(**
Empty masked array with the properties of an existing array.

Return an empty masked array of the same shape and dtype as
the array `arr`, where all the data are masked.

Parameters
----------
arr : ndarray
    An array describing the shape and dtype of the required MaskedArray.

Returns
-------
a : MaskedArray
    A masked array with all data masked.

Raises
------
AttributeError
    If `arr` doesn't have a shape attribute (i.e. not an ndarray)

See Also
--------
masked_all : Empty masked array with all elements masked.

Examples
--------
>>> import numpy.ma as ma
>>> arr = np.zeros((2, 3), dtype=np.float32)
>>> arr
array([[0., 0., 0.],
       [0., 0., 0.]], dtype=float32)
>>> ma.masked_all_like(arr)
masked_array(
  data=[[--, --, --],
        [--, --, --]],
  mask=[[ True,  True,  True],
        [ True,  True,  True]],
  fill_value=1e+20,
  dtype=float32)

The dtype of the masked array matches the dtype of `arr`.

>>> arr.dtype
dtype('float32')
>>> ma.masked_all_like(arr).dtype
dtype('float32')
*)

val masked_equal : ?copy:Py.Object.t -> value:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x == value).  For floating point arrays,
consider using ``masked_values(x, value)``.

See Also
--------
masked_where : Mask where a condition is met.
masked_values : Mask using floating point equality.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_equal(a, 2)
masked_array(data=[0, 1, --, 3],
             mask=[False, False,  True, False],
       fill_value=2)
*)

val masked_greater : ?copy:Py.Object.t -> value:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where greater than a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x > value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_greater(a, 2)
masked_array(data=[0, 1, 2, --],
             mask=[False, False, False,  True],
       fill_value=999999)
*)

val masked_greater_equal : ?copy:Py.Object.t -> value:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where greater than or equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x >= value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_greater_equal(a, 2)
masked_array(data=[0, 1, --, --],
             mask=[False, False,  True,  True],
       fill_value=999999)
*)

val masked_inside : ?copy:Py.Object.t -> v1:Py.Object.t -> v2:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array inside a given interval.

Shortcut to ``masked_where``, where `condition` is True for `x` inside
the interval [v1,v2] (v1 <= x <= v2).  The boundaries `v1` and `v2`
can be given in either order.

See Also
--------
masked_where : Mask where a condition is met.

Notes
-----
The array `x` is prefilled with its filling value.

Examples
--------
>>> import numpy.ma as ma
>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
>>> ma.masked_inside(x, -0.3, 0.3)
masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],
             mask=[False, False,  True,  True, False, False],
       fill_value=1e+20)

The order of `v1` and `v2` doesn't matter.

>>> ma.masked_inside(x, 0.3, -0.3)
masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],
             mask=[False, False,  True,  True, False, False],
       fill_value=1e+20)
*)

val masked_invalid : ?copy:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where invalid values occur (NaNs or infs).

This function is a shortcut to ``masked_where``, with
`condition` = ~(np.isfinite(a)). Any pre-existing mask is conserved.
Only applies to arrays with a dtype where NaNs or infs make sense
(i.e. floating point types), but accepts any array_like object.

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(5, dtype=float)
>>> a[2] = np.NaN
>>> a[3] = np.PINF
>>> a
array([ 0.,  1., nan, inf,  4.])
>>> ma.masked_invalid(a)
masked_array(data=[0.0, 1.0, --, --, 4.0],
             mask=[False, False,  True,  True, False],
       fill_value=1e+20)
*)

val masked_less : ?copy:Py.Object.t -> value:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where less than a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x < value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_less(a, 2)
masked_array(data=[--, --, 2, 3],
             mask=[ True,  True, False, False],
       fill_value=999999)
*)

val masked_less_equal : ?copy:Py.Object.t -> value:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where less than or equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x <= value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_less_equal(a, 2)
masked_array(data=[--, --, --, 3],
             mask=[ True,  True,  True, False],
       fill_value=999999)
*)

val masked_not_equal : ?copy:Py.Object.t -> value:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array where `not` equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x != value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_not_equal(a, 2)
masked_array(data=[--, --, 2, --],
             mask=[ True,  True, False,  True],
       fill_value=999999)
*)

val masked_object : ?copy:bool -> ?shrink:bool -> value:Py.Object.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Mask the array `x` where the data are exactly equal to value.

This function is similar to `masked_values`, but only suitable
for object arrays: for floating point, use `masked_values` instead.

Parameters
----------
x : array_like
    Array to mask
value : object
    Comparison value
copy : {True, False}, optional
    Whether to return a copy of `x`.
shrink : {True, False}, optional
    Whether to collapse a mask full of False to nomask

Returns
-------
result : MaskedArray
    The result of masking `x` where equal to `value`.

See Also
--------
masked_where : Mask where a condition is met.
masked_equal : Mask where equal to a given value (integers).
masked_values : Mask using floating point equality.

Examples
--------
>>> import numpy.ma as ma
>>> food = np.array(['green_eggs', 'ham'], dtype=object)
>>> # don't eat spoiled food
>>> eat = ma.masked_object(food, 'green_eggs')
>>> eat
masked_array(data=[--, 'ham'],
             mask=[ True, False],
       fill_value='green_eggs',
            dtype=object)
>>> # plain ol` ham is boring
>>> fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)
>>> eat = ma.masked_object(fresh_food, 'green_eggs')
>>> eat
masked_array(data=['cheese', 'ham', 'pineapple'],
             mask=False,
       fill_value='green_eggs',
            dtype=object)

Note that `mask` is set to ``nomask`` if possible.

>>> eat
masked_array(data=['cheese', 'ham', 'pineapple'],
             mask=False,
       fill_value='green_eggs',
            dtype=object)
*)

val masked_outside : ?copy:Py.Object.t -> v1:Py.Object.t -> v2:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Mask an array outside a given interval.

Shortcut to ``masked_where``, where `condition` is True for `x` outside
the interval [v1,v2] (x < v1)|(x > v2).
The boundaries `v1` and `v2` can be given in either order.

See Also
--------
masked_where : Mask where a condition is met.

Notes
-----
The array `x` is prefilled with its filling value.

Examples
--------
>>> import numpy.ma as ma
>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
>>> ma.masked_outside(x, -0.3, 0.3)
masked_array(data=[--, --, 0.01, 0.2, --, --],
             mask=[ True,  True, False, False,  True,  True],
       fill_value=1e+20)

The order of `v1` and `v2` doesn't matter.

>>> ma.masked_outside(x, 0.3, -0.3)
masked_array(data=[--, --, 0.01, 0.2, --, --],
             mask=[ True,  True, False, False,  True,  True],
       fill_value=1e+20)
*)

val masked_values : ?rtol:Py.Object.t -> ?atol:Py.Object.t -> ?copy:bool -> ?shrink:bool -> value:float -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Mask using floating point equality.

Return a MaskedArray, masked where the data in array `x` are approximately
equal to `value`, determined using `isclose`. The default tolerances for
`masked_values` are the same as those for `isclose`.

For integer types, exact equality is used, in the same way as
`masked_equal`.

The fill_value is set to `value` and the mask is set to ``nomask`` if
possible.

Parameters
----------
x : array_like
    Array to mask.
value : float
    Masking value.
rtol, atol : float, optional
    Tolerance parameters passed on to `isclose`
copy : bool, optional
    Whether to return a copy of `x`.
shrink : bool, optional
    Whether to collapse a mask full of False to ``nomask``.

Returns
-------
result : MaskedArray
    The result of masking `x` where approximately equal to `value`.

See Also
--------
masked_where : Mask where a condition is met.
masked_equal : Mask where equal to a given value (integers).

Examples
--------
>>> import numpy.ma as ma
>>> x = np.array([1, 1.1, 2, 1.1, 3])
>>> ma.masked_values(x, 1.1)
masked_array(data=[1.0, --, 2.0, --, 3.0],
             mask=[False,  True, False,  True, False],
       fill_value=1.1)

Note that `mask` is set to ``nomask`` if possible.

>>> ma.masked_values(x, 1.5)
masked_array(data=[1. , 1.1, 2. , 1.1, 3. ],
             mask=False,
       fill_value=1.5)

For integers, the fill value will be different in general to the
result of ``masked_equal``.

>>> x = np.arange(5)
>>> x
array([0, 1, 2, 3, 4])
>>> ma.masked_values(x, 2)
masked_array(data=[0, 1, --, 3, 4],
             mask=[False, False,  True, False, False],
       fill_value=2)
>>> ma.masked_equal(x, 2)
masked_array(data=[0, 1, --, 3, 4],
             mask=[False, False,  True, False, False],
       fill_value=2)
*)

val masked_where : ?copy:bool -> condition:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Mask an array where a condition is met.

Return `a` as an array masked where `condition` is True.
Any masked values of `a` or `condition` are also masked in the output.

Parameters
----------
condition : array_like
    Masking condition.  When `condition` tests floating point values for
    equality, consider using ``masked_values`` instead.
a : array_like
    Array to mask.
copy : bool
    If True (default) make a copy of `a` in the result.  If False modify
    `a` in place and return a view.

Returns
-------
result : MaskedArray
    The result of masking `a` where `condition` is True.

See Also
--------
masked_values : Mask using floating point equality.
masked_equal : Mask where equal to a given value.
masked_not_equal : Mask where `not` equal to a given value.
masked_less_equal : Mask where less than or equal to a given value.
masked_greater_equal : Mask where greater than or equal to a given value.
masked_less : Mask where less than a given value.
masked_greater : Mask where greater than a given value.
masked_inside : Mask inside a given interval.
masked_outside : Mask outside a given interval.
masked_invalid : Mask invalid values (NaNs or infs).

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_where(a <= 2, a)
masked_array(data=[--, --, --, 3],
             mask=[ True,  True,  True, False],
       fill_value=999999)

Mask array `b` conditional on `a`.

>>> b = ['a', 'b', 'c', 'd']
>>> ma.masked_where(a == 2, b)
masked_array(data=['a', 'b', --, 'd'],
             mask=[False, False,  True, False],
       fill_value='N/A',
            dtype='<U1')

Effect of the `copy` argument.

>>> c = ma.masked_where(a <= 2, a)
>>> c
masked_array(data=[--, --, --, 3],
             mask=[ True,  True,  True, False],
       fill_value=999999)
>>> c[0] = 99
>>> c
masked_array(data=[99, --, --, 3],
             mask=[False,  True,  True, False],
       fill_value=999999)
>>> a
array([0, 1, 2, 3])
>>> c = ma.masked_where(a <= 2, a, copy=False)
>>> c[0] = 99
>>> c
masked_array(data=[99, --, --, 3],
             mask=[False,  True,  True, False],
       fill_value=999999)
>>> a
array([99,  1,  2,  3])

When `condition` or `a` contain masked values.

>>> a = np.arange(4)
>>> a = ma.masked_where(a == 2, a)
>>> a
masked_array(data=[0, 1, --, 3],
             mask=[False, False,  True, False],
       fill_value=999999)
>>> b = np.arange(4)
>>> b = ma.masked_where(b == 0, b)
>>> b
masked_array(data=[--, 1, 2, 3],
             mask=[ True, False, False, False],
       fill_value=999999)
>>> ma.masked_where(a == 3, b)
masked_array(data=[--, 1, --, --],
             mask=[ True, False,  True,  True],
       fill_value=999999)
*)

val max : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> obj:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the maximum along a given axis.

Parameters
----------
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
fill_value : {var}, optional
    Value used to fill in the masked values.
    If None, use the output of maximum_fill_value().
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
amax : array_like
    New array holding the result.
    If ``out`` was specified, ``out`` is returned.

See Also
--------
maximum_fill_value
    Returns the maximum filling value for a given datatype.
*)

val maximum : ?b:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Element-wise maximum of array elements.

Compare two arrays and returns a new array containing the element-wise
maxima. If one of the elements being compared is a NaN, then that
element is returned. If both elements are NaNs then the first is
returned. The latter distinction is important for complex NaNs, which
are defined as at least one of the real or imaginary parts being a NaN.
The net effect is that NaNs are propagated.

Parameters
----------
x1, x2 : array_like
    The arrays holding the elements to be compared. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The maximum of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
minimum :
    Element-wise minimum of two arrays, propagates NaNs.
fmax :
    Element-wise maximum of two arrays, ignores NaNs.
amax :
    The maximum value of an array along a given axis, propagates NaNs.
nanmax :
    The maximum value of an array along a given axis, ignores NaNs.

fmin, amin, nanmin

Notes
-----
The maximum is equivalent to ``np.where(x1 >= x2, x1, x2)`` when
neither x1 nor x2 are nans, but it is faster and does proper
broadcasting.

Examples
--------
>>> np.maximum([2, 3, 4], [1, 5, 2])
array([2, 5, 4])

>>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting
array([[ 1. ,  2. ],
       [ 0.5,  2. ]])

>>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])
array([nan, nan, nan])
>>> np.maximum(np.Inf, 1)
inf
*)

val maximum_fill_value : [`I of int | `Ndarray of [>`Ndarray] Obj.t | `F of float | `Bool of bool | `Dtype of Dtype.t | `S of string] -> Py.Object.t
(**
Return the minimum value that can be represented by the dtype of an object.

This function is useful for calculating a fill value suitable for
taking the maximum of an array with a given dtype.

Parameters
----------
obj : ndarray, dtype or scalar
    An object that can be queried for it's numeric type.

Returns
-------
val : scalar
    The minimum representable value.

Raises
------
TypeError
    If `obj` isn't a suitable numeric type.

See Also
--------
minimum_fill_value : The inverse function.
set_fill_value : Set the filling value of a masked array.
MaskedArray.fill_value : Return current fill value.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.int8()
>>> ma.maximum_fill_value(a)
-128
>>> a = np.int32()
>>> ma.maximum_fill_value(a)
-2147483648

An array of numeric data can also be passed.

>>> a = np.array([1, 2, 3], dtype=np.int8)
>>> ma.maximum_fill_value(a)
-128
>>> a = np.array([1, 2, 3], dtype=np.float32)
>>> ma.maximum_fill_value(a)
-inf
*)

val mean : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)

Returns the average of the array elements along given axis.

Masked entries are ignored, and result elements which are not
finite will be masked.

Refer to `numpy.mean` for full documentation.

See Also
--------
numpy.ndarray.mean : corresponding function for ndarrays
numpy.mean : Equivalent function
numpy.ma.average: Weighted average.

Examples
--------
>>> a = np.ma.array([1,2,3], mask=[False, False, True])
>>> a
masked_array(data=[1, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.mean()
1.5
*)

val median : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?overwrite_input:bool -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the median along the specified axis.

Returns the median of the array elements.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : int, optional
    Axis along which the medians are computed. The default (None) is
    to compute the median along a flattened version of the array.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow use of memory of input array (a) for
    calculations. The input array will be modified by the call to
    median. This will save memory when you do not need to preserve
    the contents of the input array. Treat the input as undefined,
    but it will probably be fully or partially sorted. Default is
    False. Note that, if `overwrite_input` is True, and the input
    is not already an `ndarray`, an error will be raised.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    .. versionadded:: 1.10.0

Returns
-------
median : ndarray
    A new array holding the result is returned unless out is
    specified, in which case a reference to out is returned.
    Return data-type is `float64` for integers and floats smaller than
    `float64`, or the input data-type, otherwise.

See Also
--------
mean

Notes
-----
Given a vector ``V`` with ``N`` non masked values, the median of ``V``
is the middle value of a sorted copy of ``V`` (``Vs``) - i.e.
``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2``
when ``N`` is even.

Examples
--------
>>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)
>>> np.ma.median(x)
1.5

>>> x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)
>>> np.ma.median(x)
2.5
>>> np.ma.median(x, axis=-1, overwrite_input=True)
masked_array(data=[2.0, 5.0],
             mask=[False, False],
       fill_value=1e+20)
*)

val min : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> obj:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the minimum along a given axis.

Parameters
----------
axis : {None, int}, optional
    Axis along which to operate.  By default, ``axis`` is None and the
    flattened input is used.
out : array_like, optional
    Alternative output array in which to place the result.  Must be of
    the same shape and buffer length as the expected output.
fill_value : {var}, optional
    Value used to fill in the masked values.
    If None, use the output of `minimum_fill_value`.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
amin : array_like
    New array holding the result.
    If ``out`` was specified, ``out`` is returned.

See Also
--------
minimum_fill_value
    Returns the minimum filling value for a given datatype.
*)

val minimum : ?b:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Element-wise minimum of array elements.

Compare two arrays and returns a new array containing the element-wise
minima. If one of the elements being compared is a NaN, then that
element is returned. If both elements are NaNs then the first is
returned. The latter distinction is important for complex NaNs, which
are defined as at least one of the real or imaginary parts being a NaN.
The net effect is that NaNs are propagated.

Parameters
----------
x1, x2 : array_like
    The arrays holding the elements to be compared. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The minimum of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
maximum :
    Element-wise maximum of two arrays, propagates NaNs.
fmin :
    Element-wise minimum of two arrays, ignores NaNs.
amin :
    The minimum value of an array along a given axis, propagates NaNs.
nanmin :
    The minimum value of an array along a given axis, ignores NaNs.

fmax, amax, nanmax

Notes
-----
The minimum is equivalent to ``np.where(x1 <= x2, x1, x2)`` when
neither x1 nor x2 are NaNs, but it is faster and does proper
broadcasting.

Examples
--------
>>> np.minimum([2, 3, 4], [1, 5, 2])
array([1, 3, 2])

>>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting
array([[ 0.5,  0. ],
       [ 0. ,  1. ]])

>>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])
array([nan, nan, nan])
>>> np.minimum(-np.Inf, 1)
-inf
*)

val minimum_fill_value : [`I of int | `Ndarray of [>`Ndarray] Obj.t | `F of float | `Bool of bool | `Dtype of Dtype.t | `S of string] -> Py.Object.t
(**
Return the maximum value that can be represented by the dtype of an object.

This function is useful for calculating a fill value suitable for
taking the minimum of an array with a given dtype.

Parameters
----------
obj : ndarray, dtype or scalar
    An object that can be queried for it's numeric type.

Returns
-------
val : scalar
    The maximum representable value.

Raises
------
TypeError
    If `obj` isn't a suitable numeric type.

See Also
--------
maximum_fill_value : The inverse function.
set_fill_value : Set the filling value of a masked array.
MaskedArray.fill_value : Return current fill value.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.int8()
>>> ma.minimum_fill_value(a)
127
>>> a = np.int32()
>>> ma.minimum_fill_value(a)
2147483647

An array of numeric data can also be passed.

>>> a = np.array([1, 2, 3], dtype=np.int8)
>>> ma.minimum_fill_value(a)
127
>>> a = np.array([1, 2, 3], dtype=np.float32)
>>> ma.minimum_fill_value(a)
inf
*)

val mod_ : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return element-wise remainder of division.

Computes the remainder complementary to the `floor_divide` function.  It is
equivalent to the Python modulus operator``x1 % x2`` and has the same sign
as the divisor `x2`. The MATLAB function equivalent to ``np.remainder``
is ``mod``.

.. warning::

    This should not be confused with:

    * Python 3.7's `math.remainder` and C's ``remainder``, which
      computes the IEEE remainder, which are the complement to
      ``round(x1 / x2)``.
    * The MATLAB ``rem`` function and or the C ``%`` operator which is the
      complement to ``int(x1 / x2)``.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
floor_divide : Equivalent of Python ``//`` operator.
divmod : Simultaneous floor division and remainder.
fmod : Equivalent of the MATLAB ``rem`` function.
divide, floor

Notes
-----
Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)
integers.
``mod`` is an alias of ``remainder``.

Examples
--------
>>> np.remainder([4, 7], [2, 3])
array([0, 1])
>>> np.remainder(np.arange(7), 5)
array([0, 1, 2, 3, 4, 0, 1])
*)

val multiply : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Multiply arguments element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays to be multiplied. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The product of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
Equivalent to `x1` * `x2` in terms of array broadcasting.

Examples
--------
>>> np.multiply(2.0, 4.0)
8.0

>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.multiply(x1, x2)
array([[  0.,   1.,   4.],
       [  0.,   4.,  10.],
       [  0.,   7.,  16.]])
*)

val ndim : Py.Object.t -> int
(**
Return the number of dimensions of an array.

Parameters
----------
a : array_like
    Input array.  If it is not already an ndarray, a conversion is
    attempted.

Returns
-------
number_of_dimensions : int
    The number of dimensions in `a`.  Scalars are zero-dimensional.

See Also
--------
ndarray.ndim : equivalent method
shape : dimensions of array
ndarray.shape : dimensions of array

Examples
--------
>>> np.ndim([[1,2,3],[4,5,6]])
2
>>> np.ndim(np.array([[1,2,3],[4,5,6]]))
2
>>> np.ndim(1)
0
*)

val negative : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Numerical negative, element-wise.

Parameters
----------
x : array_like or scalar
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    Returned array or scalar: `y = -x`.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> np.negative([1.,-1.])
array([-1.,  1.])
*)

val nonzero : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
nonzero(self)

Return the indices of unmasked elements that are not zero.

Returns a tuple of arrays, one for each dimension, containing the
indices of the non-zero elements in that dimension. The corresponding
non-zero values can be obtained with::

    a[a.nonzero()]

To group the indices by element, rather than dimension, use
instead::

    np.transpose(a.nonzero())

The result of this is always a 2d array, with a row for each non-zero
element.

Parameters
----------
None

Returns
-------
tuple_of_arrays : tuple
    Indices of elements that are non-zero.

See Also
--------
numpy.nonzero :
    Function operating on ndarrays.
flatnonzero :
    Return indices that are non-zero in the flattened version of the input
    array.
numpy.ndarray.nonzero :
    Equivalent ndarray method.
count_nonzero :
    Counts the number of non-zero elements in the input array.

Examples
--------
>>> import numpy.ma as ma
>>> x = ma.array(np.eye(3))
>>> x
masked_array(
  data=[[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]],
  mask=False,
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 1, 2]), array([0, 1, 2]))

Masked elements are ignored.

>>> x[1, 1] = ma.masked
>>> x
masked_array(
  data=[[1.0, 0.0, 0.0],
        [0.0, --, 0.0],
        [0.0, 0.0, 1.0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 2]), array([0, 2]))

Indices can also be grouped by element.

>>> np.transpose(x.nonzero())
array([[0, 0],
       [2, 2]])

A common use for ``nonzero`` is to find the indices of an array, where
a condition is True.  Given an array `a`, the condition `a` > 3 is a
boolean array and since False is interpreted as 0, ma.nonzero(a > 3)
yields the indices of the `a` where the condition is true.

>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])
>>> a > 3
masked_array(
  data=[[False, False, False],
        [ True,  True,  True],
        [ True,  True,  True]],
  mask=False,
  fill_value=True)
>>> ma.nonzero(a > 3)
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))

The ``nonzero`` method of the condition array can also be called.

>>> (a > 3).nonzero()
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
*)

val not_equal : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return (x1 != x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays.  If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
equal, greater, greater_equal, less, less_equal

Examples
--------
>>> np.not_equal([1.,2.], [1., 3.])
array([False,  True])
>>> np.not_equal([1, 2], [[1, 3],[1, 4]])
array([[False,  True],
       [False,  True]])
*)

val notmasked_contiguous : ?axis:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Find contiguous unmasked data in a masked array along the given axis.

Parameters
----------
a : array_like
    The input array.
axis : int, optional
    Axis along which to perform the operation.
    If None (default), applies to a flattened version of the array, and this
    is the same as `flatnotmasked_contiguous`.

Returns
-------
endpoints : list
    A list of slices (start and end indexes) of unmasked indexes
    in the array.

    If the input is 2d and axis is specified, the result is a list of lists.

See Also
--------
flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges
clump_masked, clump_unmasked

Notes
-----
Only accepts 2-D arrays at most.

Examples
--------
>>> a = np.arange(12).reshape((3, 4))
>>> mask = np.zeros_like(a)
>>> mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0
>>> ma = np.ma.array(a, mask=mask)
>>> ma
masked_array(
  data=[[0, --, 2, 3],
        [--, --, --, 7],
        [8, --, --, 11]],
  mask=[[False,  True, False, False],
        [ True,  True,  True, False],
        [False,  True,  True, False]],
  fill_value=999999)
>>> np.array(ma[~ma.mask])
array([ 0,  2,  3,  7, 8, 11])

>>> np.ma.notmasked_contiguous(ma)
[slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]

>>> np.ma.notmasked_contiguous(ma, axis=0)
[[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]]

>>> np.ma.notmasked_contiguous(ma, axis=1)
[[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]]
*)

val notmasked_edges : ?axis:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Find the indices of the first and last unmasked values along an axis.

If all values are masked, return None.  Otherwise, return a list
of two tuples, corresponding to the indices of the first and last
unmasked values respectively.

Parameters
----------
a : array_like
    The input array.
axis : int, optional
    Axis along which to perform the operation.
    If None (default), applies to a flattened version of the array.

Returns
-------
edges : ndarray or list
    An array of start and end indexes if there are any masked data in
    the array. If there are no masked data in the array, `edges` is a
    list of the first and last index.

See Also
--------
flatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous
clump_masked, clump_unmasked

Examples
--------
>>> a = np.arange(9).reshape((3, 3))
>>> m = np.zeros_like(a)
>>> m[1:, 1:] = 1

>>> am = np.ma.array(a, mask=m)
>>> np.array(am[~am.mask])
array([0, 1, 2, 3, 6])

>>> np.ma.notmasked_edges(am)
array([0, 6])
*)

val ones : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
ones(shape, dtype=None, order='C')

Return a new array of given shape and type, filled with ones.

Parameters
----------
shape : int or sequence of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: C
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of ones with the given shape, dtype, and order.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
empty : Return a new uninitialized array.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Examples
--------
>>> np.ones(5)
array([1., 1., 1., 1., 1.])

>>> np.ones((5,), dtype=int)
array([1, 1, 1, 1, 1])

>>> np.ones((2, 1))
array([[1.],
       [1.]])

>>> s = (2,2)
>>> np.ones(s)
array([[1.,  1.],
       [1.,  1.]])
*)

val outer : b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the outer product of two vectors.

Given two vectors, ``a = [a0, a1, ..., aM]`` and
``b = [b0, b1, ..., bN]``,
the outer product [1]_ is::

  [[a0*b0  a0*b1 ... a0*bN ]
   [a1*b0    .
   [ ...          .
   [aM*b0            aM*bN ]]

Parameters
----------
a : (M,) array_like
    First input vector.  Input is flattened if
    not already 1-dimensional.
b : (N,) array_like
    Second input vector.  Input is flattened if
    not already 1-dimensional.
out : (M, N) ndarray, optional
    A location where the result is stored

    .. versionadded:: 1.9.0

Returns
-------
out : (M, N) ndarray
    ``out[i, j] = a[i] * b[j]``

See also
--------
inner
einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.
ufunc.outer : A generalization to N dimensions and other operations.
              ``np.multiply.outer(a.ravel(), b.ravel())`` is the equivalent.

References
----------
.. [1] : G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd
         ed., Baltimore, MD, Johns Hopkins University Press, 1996,
         pg. 8.

Examples
--------
Make a ( *very* coarse) grid for computing a Mandelbrot set:

>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
>>> rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
>>> im
array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
>>> grid = rl + im
>>> grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])

An example using a 'vector' of letters:

>>> x = np.array(['a', 'b', 'c'], dtype=object)
>>> np.outer(x, [1, 2, 3])
array([['a', 'aa', 'aaa'],
       ['b', 'bb', 'bbb'],
       ['c', 'cc', 'ccc']], dtype=object)

Notes
-----
Masked values are replaced by 0.
*)

val outerproduct : b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the outer product of two vectors.

Given two vectors, ``a = [a0, a1, ..., aM]`` and
``b = [b0, b1, ..., bN]``,
the outer product [1]_ is::

  [[a0*b0  a0*b1 ... a0*bN ]
   [a1*b0    .
   [ ...          .
   [aM*b0            aM*bN ]]

Parameters
----------
a : (M,) array_like
    First input vector.  Input is flattened if
    not already 1-dimensional.
b : (N,) array_like
    Second input vector.  Input is flattened if
    not already 1-dimensional.
out : (M, N) ndarray, optional
    A location where the result is stored

    .. versionadded:: 1.9.0

Returns
-------
out : (M, N) ndarray
    ``out[i, j] = a[i] * b[j]``

See also
--------
inner
einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.
ufunc.outer : A generalization to N dimensions and other operations.
              ``np.multiply.outer(a.ravel(), b.ravel())`` is the equivalent.

References
----------
.. [1] : G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd
         ed., Baltimore, MD, Johns Hopkins University Press, 1996,
         pg. 8.

Examples
--------
Make a ( *very* coarse) grid for computing a Mandelbrot set:

>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
>>> rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
>>> im
array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
>>> grid = rl + im
>>> grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])

An example using a 'vector' of letters:

>>> x = np.array(['a', 'b', 'c'], dtype=object)
>>> np.outer(x, [1, 2, 3])
array([['a', 'aa', 'aaa'],
       ['b', 'bb', 'bbb'],
       ['c', 'cc', 'ccc']], dtype=object)

Notes
-----
Masked values are replaced by 0.
*)

val polyfit : ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> ?cov:[`Bool of bool | `S of string] -> y:[>`Ndarray] Obj.t -> deg:int -> [>`Ndarray] Obj.t -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Least squares polynomial fit.

Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`
to points `(x, y)`. Returns a vector of coefficients `p` that minimises
the squared error in the order `deg`, `deg-1`, ... `0`.

The `Polynomial.fit <numpy.polynomial.polynomial.Polynomial.fit>` class
method is recommended for new code as it is more stable numerically. See
the documentation of the method for more information.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int
    Degree of the fitting polynomial
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (M,), optional
    Weights to apply to the y-coordinates of the sample points. For
    gaussian uncertainties, use 1/sigma (not 1/sigma**2).
cov : bool or str, optional
    If given and not `False`, return not just the estimate but also its
    covariance matrix. By default, the covariance are scaled by
    chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable
    except in a relative sense and everything is scaled such that the
    reduced chi2 is unity. This scaling is omitted if ``cov='unscaled'``,
    as is relevant for the case that the weights are 1/sigma**2, with
    sigma known to be a reliable estimate of the uncertainty.

Returns
-------
p : ndarray, shape (deg + 1,) or (deg + 1, K)
    Polynomial coefficients, highest power first.  If `y` was 2-D, the
    coefficients for `k`-th data set are in ``p[:,k]``.

residuals, rank, singular_values, rcond
    Present only if `full` = True.  Residuals is sum of squared residuals
    of the least-squares fit, the effective rank of the scaled Vandermonde
    coefficient matrix, its singular values, and the specified value of
    `rcond`. For more details, see `linalg.lstsq`.

V : ndarray, shape (M,M) or (M,M,K)
    Present only if `full` = False and `cov`=True.  The covariance
    matrix of the polynomial coefficient estimates.  The diagonal of
    this matrix are the variance estimates for each coefficient.  If y
    is a 2-D array, then the covariance matrix for the `k`-th data set
    are in ``V[:,:,k]``


Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.

    The warnings can be turned off by

    >>> import warnings
    >>> warnings.simplefilter('ignore', np.RankWarning)

See Also
--------
polyval : Compute polynomial values.
linalg.lstsq : Computes a least-squares fit.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----

Any masked values in x is propagated in y, and vice-versa.



The solution minimizes the squared error

.. math ::
    E = \sum_{j=0}^k |p(x_j) - y_j|^2

in the equations::

    x[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]
    x[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]
    ...
    x[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]

The coefficient matrix of the coefficients `p` is a Vandermonde matrix.

`polyfit` issues a `RankWarning` when the least-squares fit is badly
conditioned. This implies that the best fit is not well-defined due
to numerical error. The results may be improved by lowering the polynomial
degree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter
can also be set to a value smaller than its default, but the resulting
fit may be spurious: including contributions from the small singular
values can add numerical noise to the result.

Note that fitting polynomial coefficients is inherently badly conditioned
when the degree of the polynomial is large or the interval of sample points
is badly centered. The quality of the fit should always be checked in these
cases. When polynomial fits are not satisfactory, splines may be a good
alternative.

References
----------
.. [1] Wikipedia, 'Curve fitting',
       https://en.wikipedia.org/wiki/Curve_fitting
.. [2] Wikipedia, 'Polynomial interpolation',
       https://en.wikipedia.org/wiki/Polynomial_interpolation

Examples
--------
>>> import warnings
>>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])
>>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])
>>> z = np.polyfit(x, y, 3)
>>> z
array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary

It is convenient to use `poly1d` objects for dealing with polynomials:

>>> p = np.poly1d(z)
>>> p(0.5)
0.6143849206349179 # may vary
>>> p(3.5)
-0.34732142857143039 # may vary
>>> p(10)
22.579365079365115 # may vary

High-order polynomials may oscillate wildly:

>>> with warnings.catch_warnings():
...     warnings.simplefilter('ignore', np.RankWarning)
...     p30 = np.poly1d(np.polyfit(x, y, 30))
...
>>> p30(4)
-0.80000000000000204 # may vary
>>> p30(5)
-0.99999999999999445 # may vary
>>> p30(4.5)
-0.10547061179440398 # may vary

Illustration:

>>> import matplotlib.pyplot as plt
>>> xp = np.linspace(-2, 6, 100)
>>> _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')
>>> plt.ylim(-2,2)
(-2, 2)
>>> plt.show()
*)

val power : ?third:Py.Object.t -> b:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Returns element-wise base array raised to power from second array.

This is the masked array version of `numpy.power`. For details see
`numpy.power`.

See Also
--------
numpy.power

Notes
-----
The *out* argument to `numpy.power` is not supported, `third` has to be
None.
*)

val prod : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)

Return the product of the array elements over the given axis.

Masked elements are set to 1 internally for computation.

Refer to `numpy.prod` for full documentation.

Notes
-----
Arithmetic is modular when using integer types, and no error is raised
on overflow.

See Also
--------
numpy.ndarray.prod : corresponding function for ndarrays
numpy.prod : equivalent function
*)

val product : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)

Return the product of the array elements over the given axis.

Masked elements are set to 1 internally for computation.

Refer to `numpy.prod` for full documentation.

Notes
-----
Arithmetic is modular when using integer types, and no error is raised
on overflow.

See Also
--------
numpy.ndarray.prod : corresponding function for ndarrays
numpy.prod : equivalent function
*)

val ptp : ?axis:int -> ?out:[>`Ndarray] Obj.t -> ?fill_value:Py.Object.t -> ?keepdims:bool -> obj:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return (maximum - minimum) along the given dimension
(i.e. peak-to-peak value).

Parameters
----------
axis : {None, int}, optional
    Axis along which to find the peaks.  If None (default) the
    flattened array is used.
out : {None, array_like}, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary.
fill_value : {var}, optional
    Value used to fill in the masked values.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the array.

Returns
-------
ptp : ndarray.
    A new array holding the result, unless ``out`` was
    specified, in which case a reference to ``out`` is returned.
*)

val put : ?mode:Py.Object.t -> indices:Py.Object.t -> values:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Set storage-indexed locations to corresponding values.

This function is equivalent to `MaskedArray.put`, see that method
for details.

See Also
--------
MaskedArray.put
*)

val putmask : mask:Py.Object.t -> values:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Changes elements of an array based on conditional and input values.

This is the masked array version of `numpy.putmask`, for details see
`numpy.putmask`.

See Also
--------
numpy.putmask

Notes
-----
Using a masked array as `values` will **not** transform a `ndarray` into
a `MaskedArray`.
*)

val ravel : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
ravel(self, order='C')

Returns a 1D version of self, as a view.

Parameters
----------
order : {'C', 'F', 'A', 'K'}, optional
    The elements of `a` are read using this index order. 'C' means to
    index the elements in C-like order, with the last axis index
    changing fastest, back to the first axis index changing slowest.
    'F' means to index the elements in Fortran-like index order, with
    the first index changing fastest, and the last index changing
    slowest. Note that the 'C' and 'F' options take no account of the
    memory layout of the underlying array, and only refer to the order
    of axis indexing.  'A' means to read the elements in Fortran-like
    index order if `m` is Fortran *contiguous* in memory, C-like order
    otherwise.  'K' means to read the elements in the order they occur
    in memory, except for reversing the data when strides are negative.
    By default, 'C' index order is used.

Returns
-------
MaskedArray
    Output view is of shape ``(self.size,)`` (or
    ``(np.ma.product(self.shape),)``).

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.ravel()
masked_array(data=[1, --, 3, --, 5, --, 7, --, 9],
             mask=[False,  True, False,  True, False,  True, False,  True,
                   False],
       fill_value=999999)
*)

val remainder : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return element-wise remainder of division.

Computes the remainder complementary to the `floor_divide` function.  It is
equivalent to the Python modulus operator``x1 % x2`` and has the same sign
as the divisor `x2`. The MATLAB function equivalent to ``np.remainder``
is ``mod``.

.. warning::

    This should not be confused with:

    * Python 3.7's `math.remainder` and C's ``remainder``, which
      computes the IEEE remainder, which are the complement to
      ``round(x1 / x2)``.
    * The MATLAB ``rem`` function and or the C ``%`` operator which is the
      complement to ``int(x1 / x2)``.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
floor_divide : Equivalent of Python ``//`` operator.
divmod : Simultaneous floor division and remainder.
fmod : Equivalent of the MATLAB ``rem`` function.
divide, floor

Notes
-----
Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)
integers.
``mod`` is an alias of ``remainder``.

Examples
--------
>>> np.remainder([4, 7], [2, 3])
array([0, 1])
>>> np.remainder(np.arange(7), 5)
array([0, 1, 2, 3, 4, 0, 1])
*)

val repeat : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
repeat(self, *args, **params)
a.repeat(repeats, axis=None)

    Repeat elements of an array.

    Refer to `numpy.repeat` for full documentation.

    See Also
    --------
    numpy.repeat : equivalent function
*)

val reshape : ?order:Py.Object.t -> new_shape:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Returns an array containing the same data with a new shape.

Refer to `MaskedArray.reshape` for full documentation.

See Also
--------
MaskedArray.reshape : equivalent function
*)

val resize : new_shape:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Return a new masked array with the specified size and shape.

This is the masked equivalent of the `numpy.resize` function. The new
array is filled with repeated copies of `x` (in the order that the
data are stored in memory). If `x` is masked, the new array will be
masked, and the new mask will be a repetition of the old one.

See Also
--------
numpy.resize : Equivalent function in the top level NumPy module.

Examples
--------
>>> import numpy.ma as ma
>>> a = ma.array([[1, 2] ,[3, 4]])
>>> a[0, 1] = ma.masked
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=999999)
>>> np.resize(a, (3, 3))
masked_array(
  data=[[1, 2, 3],
        [4, 1, 2],
        [3, 4, 1]],
  mask=False,
  fill_value=999999)
>>> ma.resize(a, (3, 3))
masked_array(
  data=[[1, --, 3],
        [4, 1, --],
        [3, 4, 1]],
  mask=[[False,  True, False],
        [False, False,  True],
        [False, False, False]],
  fill_value=999999)

A MaskedArray is always returned, regardless of the input type.

>>> a = np.array([[1, 2] ,[3, 4]])
>>> ma.resize(a, (3, 3))
masked_array(
  data=[[1, 2, 3],
        [4, 1, 2],
        [3, 4, 1]],
  mask=False,
  fill_value=999999)
*)

val right_shift : n:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Shift the bits of an integer to the right.

This is the masked array version of `numpy.right_shift`, for details
see that function.

See Also
--------
numpy.right_shift
*)

val round : ?decimals:int -> ?out:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Return a copy of a, rounded to 'decimals' places.

When 'decimals' is negative, it specifies the number of positions
to the left of the decimal point.  The real and imaginary parts of
complex numbers are rounded separately. Nothing is done if the
array is not of float type and 'decimals' is greater than or equal
to 0.

Parameters
----------
decimals : int
    Number of decimals to round to. May be negative.
out : array_like
    Existing array to use for output.
    If not given, returns a default copy of a.

Notes
-----
If out is given and does not have a mask attribute, the mask of a
is lost!
*)

val row_stack : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
vstack( *args, **kwargs)

    Stack arrays in sequence vertically (row wise).

    This is equivalent to concatenation along the first axis after 1-D arrays
    of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by
    `vsplit`.

    This function makes most sense for arrays with up to 3 dimensions. For
    instance, for pixel-data with a height (first axis), width (second axis),
    and r/g/b channels (third axis). The functions `concatenate`, `stack` and
    `block` provide more general stacking and concatenation operations.

    Parameters
    ----------
    tup : sequence of ndarrays
        The arrays must have the same shape along all but the first axis.
        1-D arrays must have the same length.

    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays, will be at least 2-D.

    See Also
    --------
    stack : Join a sequence of arrays along a new axis.
    hstack : Stack arrays in sequence horizontally (column wise).
    dstack : Stack arrays in sequence depth wise (along third dimension).
    concatenate : Join a sequence of arrays along an existing axis.
    vsplit : Split array into a list of multiple sub-arrays vertically.
    block : Assemble arrays from blocks.

    Examples
    --------
    >>> a = np.array([1, 2, 3])
    >>> b = np.array([2, 3, 4])
    >>> np.vstack((a,b))
    array([[1, 2, 3],
           [2, 3, 4]])

    >>> a = np.array([[1], [2], [3]])
    >>> b = np.array([[2], [3], [4]])
    >>> np.vstack((a,b))
    array([[1],
           [2],
           [3],
           [2],
           [3],
           [4]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val set_fill_value : fill_value:Dtype.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Set the filling value of a, if a is a masked array.

This function changes the fill value of the masked array `a` in place.
If `a` is not a masked array, the function returns silently, without
doing anything.

Parameters
----------
a : array_like
    Input array.
fill_value : dtype
    Filling value. A consistency test is performed to make sure
    the value is compatible with the dtype of `a`.

Returns
-------
None
    Nothing returned by this function.

See Also
--------
maximum_fill_value : Return the default fill value for a dtype.
MaskedArray.fill_value : Return current fill value.
MaskedArray.set_fill_value : Equivalent method.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(5)
>>> a
array([0, 1, 2, 3, 4])
>>> a = ma.masked_where(a < 3, a)
>>> a
masked_array(data=[--, --, --, 3, 4],
             mask=[ True,  True,  True, False, False],
       fill_value=999999)
>>> ma.set_fill_value(a, -999)
>>> a
masked_array(data=[--, --, --, 3, 4],
             mask=[ True,  True,  True, False, False],
       fill_value=-999)

Nothing happens if `a` is not a masked array.

>>> a = list(range(5))
>>> a
[0, 1, 2, 3, 4]
>>> ma.set_fill_value(a, 100)
>>> a
[0, 1, 2, 3, 4]
>>> a = np.arange(5)
>>> a
array([0, 1, 2, 3, 4])
>>> ma.set_fill_value(a, 100)
>>> a
array([0, 1, 2, 3, 4])
*)

val setdiff1d : ?assume_unique:Py.Object.t -> ar1:Py.Object.t -> ar2:Py.Object.t -> unit -> Py.Object.t
(**
Set difference of 1D arrays with unique elements.

The output is always a masked array. See `numpy.setdiff1d` for more
details.

See Also
--------
numpy.setdiff1d : Equivalent function for ndarrays.

Examples
--------
>>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])
>>> np.ma.setdiff1d(x, [1, 2])
masked_array(data=[3, --],
             mask=[False,  True],
       fill_value=999999)
*)

val setxor1d : ?assume_unique:Py.Object.t -> ar1:Py.Object.t -> ar2:Py.Object.t -> unit -> Py.Object.t
(**
Set exclusive-or of 1-D arrays with unique elements.

The output is always a masked array. See `numpy.setxor1d` for more details.

See Also
--------
numpy.setxor1d : Equivalent function for ndarrays.
*)

val shape : Py.Object.t -> int array
(**
Return the shape of an array.

Parameters
----------
a : array_like
    Input array.

Returns
-------
shape : tuple of ints
    The elements of the shape tuple give the lengths of the
    corresponding array dimensions.

See Also
--------
alen
ndarray.shape : Equivalent array method.

Examples
--------
>>> np.shape(np.eye(3))
(3, 3)
>>> np.shape([[1, 2]])
(1, 2)
>>> np.shape([0])
(1,)
>>> np.shape(0)
()

>>> a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
>>> np.shape(a)
(2,)
>>> a.shape
(2,)
*)

val sin : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Trigonometric sine, element-wise.

Parameters
----------
x : array_like
    Angle, in radians (:math:`2 \pi` rad equals 360 degrees).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : array_like
    The sine of each element of x.
    This is a scalar if `x` is a scalar.

See Also
--------
arcsin, sinh, cos

Notes
-----
The sine is one of the fundamental functions of trigonometry (the
mathematical study of triangles).  Consider a circle of radius 1
centered on the origin.  A ray comes in from the :math:`+x` axis, makes
an angle at the origin (measured counter-clockwise from that axis), and
departs from the origin.  The :math:`y` coordinate of the outgoing
ray's intersection with the unit circle is the sine of that angle.  It
ranges from -1 for :math:`x=3\pi / 2` to +1 for :math:`\pi / 2.`  The
function has zeroes where the angle is a multiple of :math:`\pi`.
Sines of angles between :math:`\pi` and :math:`2\pi` are negative.
The numerous properties of the sine and related functions are included
in any standard trigonometry text.

Examples
--------
Print sine of one angle:

>>> np.sin(np.pi/2.)
1.0

Print sines of an array of angles given in degrees:

>>> np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )
array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])

Plot the sine function:

>>> import matplotlib.pylab as plt
>>> x = np.linspace(-np.pi, np.pi, 201)
>>> plt.plot(x, np.sin(x))
>>> plt.xlabel('Angle [rad]')
>>> plt.ylabel('sin(x)')
>>> plt.axis('tight')
>>> plt.show()
*)

val sinh : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Hyperbolic sine, element-wise.

Equivalent to ``1/2 * (np.exp(x) - np.exp(-x))`` or
``-1j * np.sin(1j*x)``.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding hyperbolic sine values.
    This is a scalar if `x` is a scalar.

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972, pg. 83.

Examples
--------
>>> np.sinh(0)
0.0
>>> np.sinh(np.pi*1j/2)
1j
>>> np.sinh(np.pi*1j) # (exact value is 0)
1.2246063538223773e-016j
>>> # Discrepancy due to vagaries of floating point arithmetic.

>>> # Example of providing the optional output parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.sinh([0.1], out1)
>>> out2 is out1
True

>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.sinh(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
*)

val size : ?axis:int -> obj:Py.Object.t -> unit -> int
(**
Return the number of elements along a given axis.

Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which the elements are counted.  By default, give
    the total number of elements.

Returns
-------
element_count : int
    Number of elements along the specified axis.

See Also
--------
shape : dimensions of array
ndarray.shape : dimensions of array
ndarray.size : number of elements in array

Examples
--------
>>> a = np.array([[1,2,3],[4,5,6]])
>>> np.size(a)
6
>>> np.size(a,1)
3
>>> np.size(a,0)
2
*)

val soften_mask : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
soften_mask(self)

Force the mask to soft.

Whether the mask of a masked array is hard or soft is determined by
its `hardmask` property. `soften_mask` sets `hardmask` to False.

See Also
--------
hardmask
*)

val sometrue : ?axis:Py.Object.t -> ?dtype:Py.Object.t -> target:Py.Object.t -> unit -> Py.Object.t
(**
Reduce `target` along the given `axis`.
*)

val sort : ?axis:int -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[>`Ndarray] Obj.t -> ?endwith:bool -> ?fill_value:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Sort the array, in-place

Parameters
----------
a : array_like
    Array to be sorted.
axis : int, optional
    Axis along which to sort. If None, the array is flattened before
    sorting. The default is -1, which sorts along the last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    The sorting algorithm used.
order : list, optional
    When `a` is a structured array, this argument specifies which fields
    to compare first, second, and so on.  This list does not need to
    include all of the fields.
endwith : {True, False}, optional
    Whether missing values (if any) should be treated as the largest values
    (True) or the smallest values (False)
    When the array contains unmasked values sorting at the same extremes of the
    datatype, the ordering of these values and the masked values is
    undefined.
fill_value : {var}, optional
    Value used internally for the masked values.
    If ``fill_value`` is not None, it supersedes ``endwith``.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
numpy.ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.

Notes
-----
See ``sort`` for notes on the different sorting algorithms.

Examples
--------
>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Default
>>> a.sort()
>>> a
masked_array(data=[1, 3, 5, --, --],
             mask=[False, False, False,  True,  True],
       fill_value=999999)

>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Put missing values in the front
>>> a.sort(endwith=False)
>>> a
masked_array(data=[--, --, 1, 3, 5],
             mask=[ True,  True, False, False, False],
       fill_value=999999)

>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # fill_value takes over endwith
>>> a.sort(endwith=False, fill_value=3)
>>> a
masked_array(data=[1, --, --, 3, 5],
             mask=[False,  True,  True, False, False],
       fill_value=999999)
*)

val sqrt : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the non-negative square-root of an array, element-wise.

Parameters
----------
x : array_like
    The values whose square-roots are required.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    An array of the same shape as `x`, containing the positive
    square-root of each element in `x`.  If any element in `x` is
    complex, a complex array is returned (and the square-roots of
    negative reals are calculated).  If all of the elements in `x`
    are real, so is `y`, with negative elements returning ``nan``.
    If `out` was provided, `y` is a reference to it.
    This is a scalar if `x` is a scalar.

See Also
--------
lib.scimath.sqrt
    A version which returns complex numbers when given negative reals.

Notes
-----
*sqrt* has--consistent with common convention--as its branch cut the
real 'interval' [`-inf`, 0), and is continuous from above on it.
A branch cut is a curve in the complex plane across which a given
complex function fails to be continuous.

Examples
--------
>>> np.sqrt([1,4,9])
array([ 1.,  2.,  3.])

>>> np.sqrt([4, -1, -3+4J])
array([ 2.+0.j,  0.+1.j,  1.+2.j])

>>> np.sqrt([4, -1, np.inf])
array([ 2., nan, inf])
*)

val squeeze : ?axis:int list -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Remove single-dimensional entries from the shape of an array.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    .. versionadded:: 1.7.0

    Selects a subset of the single-dimensional entries in the
    shape. If an axis is selected with shape entry greater than
    one, an error is raised.

Returns
-------
squeezed : ndarray
    The input array, but with all or a subset of the
    dimensions of length 1 removed. This is always `a` itself
    or a view into `a`.

Raises
------
ValueError
    If `axis` is not None, and an axis being squeezed is not of length 1

See Also
--------
expand_dims : The inverse operation, adding singleton dimensions
reshape : Insert, remove, and combine dimensions, and resize existing ones

Examples
--------
>>> x = np.array([[[0], [1], [2]]])
>>> x.shape
(1, 3, 1)
>>> np.squeeze(x).shape
(3,)
>>> np.squeeze(x, axis=0).shape
(3, 1)
>>> np.squeeze(x, axis=1).shape
Traceback (most recent call last):
...
ValueError: cannot select an axis to squeeze out which has size not equal to one
>>> np.squeeze(x, axis=2).shape
(1, 3)
*)

val stack : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
stack( *args, **kwargs)

    Join a sequence of arrays along a new axis.

    The ``axis`` parameter specifies the index of the new axis in the
    dimensions of the result. For example, if ``axis=0`` it will be the first
    dimension and if ``axis=-1`` it will be the last dimension.

    .. versionadded:: 1.10.0

    Parameters
    ----------
    arrays : sequence of array_like
        Each array must have the same shape.

    axis : int, optional
        The axis in the result array along which the input arrays are stacked.

    out : ndarray, optional
        If provided, the destination to place the result. The shape must be
        correct, matching that of what stack would have returned if no
        out argument were specified.

    Returns
    -------
    stacked : ndarray
        The stacked array has one more dimension than the input arrays.

    See Also
    --------
    concatenate : Join a sequence of arrays along an existing axis.
    split : Split array into a list of multiple sub-arrays of equal size.
    block : Assemble arrays from blocks.

    Examples
    --------
    >>> arrays = [np.random.randn(3, 4) for _ in range(10)]
    >>> np.stack(arrays, axis=0).shape
    (10, 3, 4)

    >>> np.stack(arrays, axis=1).shape
    (3, 10, 4)

    >>> np.stack(arrays, axis=2).shape
    (3, 4, 10)

    >>> a = np.array([1, 2, 3])
    >>> b = np.array([2, 3, 4])
    >>> np.stack((a, b))
    array([[1, 2, 3],
           [2, 3, 4]])

    >>> np.stack((a, b), axis=-1)
    array([[1, 2],
           [2, 3],
           [3, 4]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val std : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)

Returns the standard deviation of the array elements along given axis.

Masked entries are ignored.

Refer to `numpy.std` for full documentation.

See Also
--------
numpy.ndarray.std : corresponding function for ndarrays
numpy.std : Equivalent function
*)

val subtract : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Subtract arguments, element-wise.

Parameters
----------
x1, x2 : array_like
    The arrays to be subtracted from each other. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The difference of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
Equivalent to ``x1 - x2`` in terms of array broadcasting.

Examples
--------
>>> np.subtract(1.0, 4.0)
-3.0

>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.subtract(x1, x2)
array([[ 0.,  0.,  0.],
       [ 3.,  3.,  3.],
       [ 6.,  6.,  6.]])
*)

val sum : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)

Return the sum of the array elements over the given axis.

Masked elements are set to 0 internally.

Refer to `numpy.sum` for full documentation.

See Also
--------
numpy.ndarray.sum : corresponding function for ndarrays
numpy.sum : equivalent function

Examples
--------
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.sum()
25
>>> x.sum(axis=1)
masked_array(data=[4, 5, 16],
             mask=[False, False, False],
       fill_value=999999)
>>> x.sum(axis=0)
masked_array(data=[8, 5, 12],
             mask=[False, False, False],
       fill_value=999999)
>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))
<class 'numpy.int64'>
*)

val swapaxes : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
swapaxes(self, *args, **params)
a.swapaxes(axis1, axis2)

    Return a view of the array with `axis1` and `axis2` interchanged.

    Refer to `numpy.swapaxes` for full documentation.

    See Also
    --------
    numpy.swapaxes : equivalent function
*)

val take : ?axis:Py.Object.t -> ?out:Py.Object.t -> ?mode:Py.Object.t -> indices:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
    
*)

val tan : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute tangent element-wise.

Equivalent to ``np.sin(x)/np.cos(x)`` element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding tangent values.
    This is a scalar if `x` is a scalar.

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.

Examples
--------
>>> from math import pi
>>> np.tan(np.array([-pi,pi/2,pi]))
array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])
>>>
>>> # Example of providing the optional output parameter illustrating
>>> # that what is returned is a reference to said parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.cos([0.1], out1)
>>> out2 is out1
True
>>>
>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
*)

val tanh : ?kwargs:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute hyperbolic tangent element-wise.

Equivalent to ``np.sinh(x)/np.cosh(x)`` or ``-1j * np.tan(1j*x)``.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding hyperbolic tangent values.
    This is a scalar if `x` is a scalar.

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
.. [1] M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
       New York, NY: Dover, 1972, pg. 83.
       http://www.math.sfu.ca/~cbm/aands/

.. [2] Wikipedia, 'Hyperbolic function',
       https://en.wikipedia.org/wiki/Hyperbolic_function

Examples
--------
>>> np.tanh((0, np.pi*1j, np.pi*1j/2))
array([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])

>>> # Example of providing the optional output parameter illustrating
>>> # that what is returned is a reference to said parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.tanh([0.1], out1)
>>> out2 is out1
True

>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.tanh(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
*)

val trace : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)
a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)

    Return the sum along diagonals of the array.

    Refer to `numpy.trace` for full documentation.

    See Also
    --------
    numpy.trace : equivalent function
*)

val transpose : ?axes:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Permute the dimensions of an array.

This function is exactly equivalent to `numpy.transpose`.

See Also
--------
numpy.transpose : Equivalent function in top-level NumPy module.

Examples
--------
>>> import numpy.ma as ma
>>> x = ma.arange(4).reshape((2,2))
>>> x[1, 1] = ma.masked
>>> x
masked_array(
  data=[[0, 1],
        [2, --]],
  mask=[[False, False],
        [False,  True]],
  fill_value=999999)

>>> ma.transpose(x)
masked_array(
  data=[[0, 2],
        [1, --]],
  mask=[[False, False],
        [False,  True]],
  fill_value=999999)
*)

val true_divide : ?kwargs:(string * Py.Object.t) list -> b:Py.Object.t -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Returns a true division of the inputs, element-wise.

Instead of the Python traditional 'floor division', this returns a true
division.  True division adjusts the output type to present the best
answer, regardless of input types.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
The floor division operator ``//`` was added in Python 2.2 making
``//`` and ``/`` equivalent operators.  The default floor division
operation of ``/`` can be replaced by true division with ``from
__future__ import division``.

In Python 3.0, ``//`` is the floor division operator and ``/`` the
true division operator.  The ``true_divide(x1, x2)`` function is
equivalent to true division in Python.

Examples
--------
>>> x = np.arange(5)
>>> np.true_divide(x, 4)
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])

>>> x//4
array([0, 0, 0, 0, 1])

>>> from __future__ import division
>>> x/4
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
>>> x//4
array([0, 0, 0, 0, 1])
*)

val union1d : ar1:Py.Object.t -> ar2:Py.Object.t -> unit -> Py.Object.t
(**
Union of two arrays.

The output is always a masked array. See `numpy.union1d` for more details.

See also
--------
numpy.union1d : Equivalent function for ndarrays.
*)

val unique : ?return_index:Py.Object.t -> ?return_inverse:Py.Object.t -> ar1:Py.Object.t -> unit -> Py.Object.t
(**
Finds the unique elements of an array.

Masked values are considered the same element (masked). The output array
is always a masked array. See `numpy.unique` for more details.

See Also
--------
numpy.unique : Equivalent function for ndarrays.
*)

val vander : ?n:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Generate a Vandermonde matrix.

The columns of the output matrix are powers of the input vector. The
order of the powers is determined by the `increasing` boolean argument.
Specifically, when `increasing` is False, the `i`-th output column is
the input vector raised element-wise to the power of ``N - i - 1``. Such
a matrix with a geometric progression in each row is named for Alexandre-
Theophile Vandermonde.

Parameters
----------
x : array_like
    1-D input array.
N : int, optional
    Number of columns in the output.  If `N` is not specified, a square
    array is returned (``N = len(x)``).
increasing : bool, optional
    Order of the powers of the columns.  If True, the powers increase
    from left to right, if False (the default) they are reversed.

    .. versionadded:: 1.9.0

Returns
-------
out : ndarray
    Vandermonde matrix.  If `increasing` is False, the first column is
    ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is
    True, the columns are ``x^0, x^1, ..., x^(N-1)``.

See Also
--------
polynomial.polynomial.polyvander

Examples
--------
>>> x = np.array([1, 2, 3, 5])
>>> N = 3
>>> np.vander(x, N)
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

>>> np.column_stack([x**(N-1-i) for i in range(N)])
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

>>> x = np.array([1, 2, 3, 5])
>>> np.vander(x)
array([[  1,   1,   1,   1],
       [  8,   4,   2,   1],
       [ 27,   9,   3,   1],
       [125,  25,   5,   1]])
>>> np.vander(x, increasing=True)
array([[  1,   1,   1,   1],
       [  1,   2,   4,   8],
       [  1,   3,   9,  27],
       [  1,   5,  25, 125]])

The determinant of a square Vandermonde matrix is the product
of the differences between the values of the input vector:

>>> np.linalg.det(np.vander(x))
48.000000000000043 # may vary
>>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)
48

Notes
-----

Masked values in the input array result in rows of zeros.
*)

val var : ?params:(string * Py.Object.t) list -> [>`Ndarray] Obj.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>)

Compute the variance along the specified axis.

Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.

Parameters
----------
a : array_like
    Array containing numbers whose variance is desired.  If `a` is not an
    array, a conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which the variance is computed.  The default is to
    compute the variance of the flattened array.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a variance is performed over multiple axes,
    instead of a single axis or all the axes as before.
dtype : data-type, optional
    Type to use in computing the variance.  For arrays of integer type
    the default is `float64`; for arrays of float types it is the same as
    the array type.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output, but the type is cast if
    necessary.
ddof : int, optional
    'Delta Degrees of Freedom': the divisor used in the calculation is
    ``N - ddof``, where ``N`` represents the number of elements. By
    default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `var` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
variance : ndarray, see dtype parameter above
    If ``out=None``, returns a new array containing the variance;
    otherwise, a reference to the output array is returned.

See Also
--------
std, mean, nanmean, nanstd, nanvar
ufuncs-output-type

Notes
-----
The variance is the average of the squared deviations from the mean,
i.e.,  ``var = mean(abs(x - x.mean())**2)``.

The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
If, however, `ddof` is specified, the divisor ``N - ddof`` is used
instead.  In standard statistical practice, ``ddof=1`` provides an
unbiased estimator of the variance of a hypothetical infinite population.
``ddof=0`` provides a maximum likelihood estimate of the variance for
normally distributed variables.

Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.

For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32` (see example
below).  Specifying a higher-accuracy accumulator using the ``dtype``
keyword can alleviate this issue.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> np.var(a)
1.25
>>> np.var(a, axis=0)
array([1.,  1.])
>>> np.var(a, axis=1)
array([0.25,  0.25])

In single precision, var() can be inaccurate:

>>> a = np.zeros((2, 512*512), dtype=np.float32)
>>> a[0, :] = 1.0
>>> a[1, :] = 0.1
>>> np.var(a)
0.20250003

Computing the variance in float64 is more accurate:

>>> np.var(a, dtype=np.float64)
0.20249999932944759 # may vary
>>> ((1-0.55)**2 + (0.1-0.55)**2)/2
0.2025
*)

val vstack : ?params:(string * Py.Object.t) list -> Py.Object.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
vstack( *args, **kwargs)

    Stack arrays in sequence vertically (row wise).

    This is equivalent to concatenation along the first axis after 1-D arrays
    of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by
    `vsplit`.

    This function makes most sense for arrays with up to 3 dimensions. For
    instance, for pixel-data with a height (first axis), width (second axis),
    and r/g/b channels (third axis). The functions `concatenate`, `stack` and
    `block` provide more general stacking and concatenation operations.

    Parameters
    ----------
    tup : sequence of ndarrays
        The arrays must have the same shape along all but the first axis.
        1-D arrays must have the same length.

    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays, will be at least 2-D.

    See Also
    --------
    stack : Join a sequence of arrays along a new axis.
    hstack : Stack arrays in sequence horizontally (column wise).
    dstack : Stack arrays in sequence depth wise (along third dimension).
    concatenate : Join a sequence of arrays along an existing axis.
    vsplit : Split array into a list of multiple sub-arrays vertically.
    block : Assemble arrays from blocks.

    Examples
    --------
    >>> a = np.array([1, 2, 3])
    >>> b = np.array([2, 3, 4])
    >>> np.vstack((a,b))
    array([[1, 2, 3],
           [2, 3, 4]])

    >>> a = np.array([[1], [2], [3]])
    >>> b = np.array([[2], [3], [4]])
    >>> np.vstack((a,b))
    array([[1],
           [2],
           [3],
           [2],
           [3],
           [4]])

    
Notes
-----
The function is applied to both the _data and the _mask, if any.
*)

val where : ?x:Py.Object.t -> ?y:Py.Object.t -> condition:[`Bool of bool | `Ndarray of [>`Ndarray] Obj.t] -> unit -> Py.Object.t
(**
Return a masked array with elements from `x` or `y`, depending on condition.

.. note::
    When only `condition` is provided, this function is identical to
    `nonzero`. The rest of this documentation covers only the case where
    all three arguments are provided.

Parameters
----------
condition : array_like, bool
    Where True, yield `x`, otherwise yield `y`.
x, y : array_like, optional
    Values from which to choose. `x`, `y` and `condition` need to be
    broadcastable to some shape.

Returns
-------
out : MaskedArray
    An masked array with `masked` elements where the condition is masked,
    elements from `x` where `condition` is True, and elements from `y`
    elsewhere.

See Also
--------
numpy.where : Equivalent function in the top-level NumPy module.
nonzero : The function that is called when x and y are omitted

Examples
--------
>>> x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],
...                                                    [1, 0, 1],
...                                                    [0, 1, 0]])
>>> x
masked_array(
  data=[[0.0, --, 2.0],
        [--, 4.0, --],
        [6.0, --, 8.0]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=1e+20)
>>> np.ma.where(x > 5, x, -3.1416)
masked_array(
  data=[[-3.1416, --, -3.1416],
        [--, -3.1416, --],
        [6.0, --, 8.0]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=1e+20)
*)

val zeros : ?params:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
zeros(shape, dtype=float, order='C')

Return a new array of given shape and type, filled with zeros.

Parameters
----------
shape : int or tuple of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: 'C'
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of zeros with the given shape, dtype, and order.

See Also
--------
zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.

Examples
--------
>>> np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])

>>> np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])

>>> np.zeros((2, 1))
array([[ 0.],
       [ 0.]])

>>> s = (2,2)
>>> np.zeros(s)
array([[ 0.,  0.],
       [ 0.,  0.]])

>>> np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
      dtype=[('x', '<i4'), ('y', '<i4')])
*)


end

module Polynomial : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

module Chebyshev : sig
type tag = [`Chebyshev]
type t = [`ABCPolyBase | `Chebyshev | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_abc_poly : t -> [`ABCPolyBase] Obj.t
val create : ?domain:Py.Object.t -> ?window:Py.Object.t -> coef:[>`Ndarray] Obj.t -> unit -> t
(**
A Chebyshev series class.

The Chebyshev class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
methods listed below.

Parameters
----------
coef : array_like
    Chebyshev coefficients in order of increasing degree, i.e.,
    ``(1, 2, 3)`` gives ``1*T_0(x) + 2*T_1(x) + 3*T_2(x)``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [-1, 1].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [-1, 1].

    .. versionadded:: 1.6.0
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
None
*)

val basis : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> deg:int -> [> tag] Obj.t -> Py.Object.t
(**
Series basis polynomial of degree `deg`.

Returns the series representing the basis polynomial of degree `deg`.

.. versionadded:: 1.7.0

Parameters
----------
deg : int
    Degree of the basis polynomial for the series. Must be >= 0.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series with the coefficient of the `deg` term set to one and
    all others zero.
*)

val cast : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> series:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to series of this class.

The `series` is expected to be an instance of some polynomial
series of one of the types supported by by the numpy.polynomial
module, but could be some other class that supports the convert
method.

.. versionadded:: 1.7.0

Parameters
----------
series : series
    The series instance to be converted.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series of the same kind as the calling class and equal to
    `series` when evaluated.

See Also
--------
convert : similar instance method
*)

val convert : ?domain:[>`Ndarray] Obj.t -> ?kind:Py.Object.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to a different kind and/or domain and/or window.

Parameters
----------
domain : array_like, optional
    The domain of the converted series. If the value is None,
    the default domain of `kind` is used.
kind : class, optional
    The polynomial series type class to which the current instance
    should be converted. If kind is None, then the class of the
    current instance is used.
window : array_like, optional
    The window of the converted series. If the value is None,
    the default window of `kind` is used.

Returns
-------
new_series : series
    The returned class can be of different type than the current
    instance and/or have a different domain and/or different
    window.

Notes
-----
Conversion between domains and class types can result in
numerically ill defined series.

Examples
--------
*)

val copy : [> tag] Obj.t -> Py.Object.t
(**
Return a copy.

Returns
-------
new_series : series
    Copy of self.
*)

val cutdeg : deg:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to the given degree.

Reduce the degree of the series to `deg` by discarding the
high order terms. If `deg` is greater than the current degree a
copy of the current series is returned. This can be useful in least
squares where the coefficients of the high degree terms may be very
small.

.. versionadded:: 1.5.0

Parameters
----------
deg : non-negative int
    The series is reduced to degree `deg` by discarding the high
    order terms. The value of `deg` must be a non-negative integer.

Returns
-------
new_series : series
    New instance of series with reduced degree.
*)

val degree : [> tag] Obj.t -> int
(**
The degree of the series.

.. versionadded:: 1.5.0

Returns
-------
degree : int
    Degree of the series, one less than the number of coefficients.
*)

val deriv : ?m:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Differentiate.

Return a series instance of that is the derivative of the current
series.

Parameters
----------
m : non-negative int
    Find the derivative of order `m`.

Returns
-------
new_series : series
    A new series representing the derivative. The domain is the same
    as the domain of the differentiated series.
*)

val fit : ?domain:Py.Object.t -> ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> ?window:Py.Object.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Least squares fit to data.

Return a series instance that is the least squares fit to the data
`y` sampled at `x`. The domain of the returned instance can be
specified and this will often result in a superior fit with less
chance of ill conditioning.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
domain : {None, [beg, end], []}, optional
    Domain to use for the returned series. If ``None``,
    then a minimal domain that covers the points `x` is chosen.  If
    ``[]`` the class domain is used. The default value was the
    class domain in NumPy 1.4 and ``None`` in later versions.
    The ``[]`` option was added in numpy 1.5.0.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller
    than this relative to the largest singular value will be
    ignored. The default value is len(x)*eps, where eps is the
    relative precision of the float type, about 2e-16 in most
    cases.
full : bool, optional
    Switch determining nature of return value. When it is False
    (the default) just the coefficients are returned, when True
    diagnostic information from the singular value decomposition is
    also returned.
w : array_like, shape (M,), optional
    Weights. If not None the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products
    ``w[i]*y[i]`` all have the same variance.  The default value is
    None.

    .. versionadded:: 1.5.0
window : {[beg, end]}, optional
    Window to use for the returned series. The default
    value is the default class domain

    .. versionadded:: 1.6.0

Returns
-------
new_series : series
    A series that represents the least squares fit to the data and
    has the domain and window specified in the call. If the
    coefficients for the unscaled and unshifted basis polynomials are
    of interest, do ``new_series.convert().coef``.

[resid, rank, sv, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.
*)

val fromroots : ?domain:[`Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `None] -> ?window:[>`Ndarray] Obj.t -> roots:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return series instance that has the specified roots.

Returns a series representing the product
``(x - r[0])*(x - r[1])*...*(x - r[n-1])``, where ``r`` is a
list of roots.

Parameters
----------
roots : array_like
    List of roots.
domain : {[], None, array_like}, optional
    Domain for the resulting series. If None the domain is the
    interval from the smallest root to the largest. If [] the
    domain is the class domain. The default is [].
window : {None, array_like}, optional
    Window for the returned series. If None the class window is
    used. The default is None.

Returns
-------
new_series : series
    Series with the specified roots.
*)

val has_samecoef : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if coefficients match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``coef`` attribute.

Returns
-------
bool : boolean
    True if the coefficients are the same, False otherwise.
*)

val has_samedomain : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if domains match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``domain`` attribute.

Returns
-------
bool : boolean
    True if the domains are the same, False otherwise.
*)

val has_sametype : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if types match.

.. versionadded:: 1.7.0

Parameters
----------
other : object
    Class instance.

Returns
-------
bool : boolean
    True if other is same class as self
*)

val has_samewindow : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if windows match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``window`` attribute.

Returns
-------
bool : boolean
    True if the windows are the same, False otherwise.
*)

val identity : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Identity function.

If ``p`` is the returned series, then ``p(x) == x`` for all
values of x.

Parameters
----------
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
     Series of representing the identity.
*)

val integ : ?m:Py.Object.t -> ?k:[>`Ndarray] Obj.t -> ?lbnd:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Integrate.

Return a series instance that is the definite integral of the
current series.

Parameters
----------
m : non-negative int
    The number of integrations to perform.
k : array_like
    Integration constants. The first constant is applied to the
    first integration, the second to the second, and so on. The
    list of values must less than or equal to `m` in length and any
    missing values are set to zero.
lbnd : Scalar
    The lower bound of the definite integral.

Returns
-------
new_series : series
    A new series representing the integral. The domain is the same
    as the domain of the integrated series.
*)

val interpolate : ?domain:Py.Object.t -> ?args:Py.Object.t -> func:Py.Object.t -> deg:int -> [> tag] Obj.t -> Py.Object.t
(**
Interpolate a function at the Chebyshev points of the first kind.

Returns the series that interpolates `func` at the Chebyshev points of
the first kind scaled and shifted to the `domain`. The resulting series
tends to a minmax approximation of `func` when the function is
continuous in the domain.

.. versionadded:: 1.14.0

Parameters
----------
func : function
    The function to be interpolated. It must be a function of a single
    variable of the form ``f(x, a, b, c...)``, where ``a, b, c...`` are
    extra arguments passed in the `args` parameter.
deg : int
    Degree of the interpolating polynomial.
domain : {None, [beg, end]}, optional
    Domain over which `func` is interpolated. The default is None, in
    which case the domain is [-1, 1].
args : tuple, optional
    Extra arguments to be used in the function call. Default is no
    extra arguments.

Returns
-------
polynomial : Chebyshev instance
    Interpolating Chebyshev instance.

Notes
-----
See `numpy.polynomial.chebfromfunction` for more details.
*)

val linspace : ?n:int -> ?domain:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return x, y values at equally spaced points in domain.

Returns the x, y values at `n` linearly spaced points across the
domain.  Here y is the value of the polynomial at the points x. By
default the domain is the same as that of the series instance.
This method is intended mostly as a plotting aid.

.. versionadded:: 1.5.0

Parameters
----------
n : int, optional
    Number of point pairs to return. The default value is 100.
domain : {None, array_like}, optional
    If not None, the specified domain is used instead of that of
    the calling instance. It should be of the form ``[beg,end]``.
    The default is None which case the class domain is used.

Returns
-------
x, y : ndarray
    x is equal to linspace(self.domain[0], self.domain[1], n) and
    y is the series evaluated at element of x.
*)

val mapparms : [> tag] Obj.t -> Py.Object.t
(**
Return the mapping parameters.

The returned values define a linear map ``off + scl*x`` that is
applied to the input arguments before the series is evaluated. The
map depends on the ``domain`` and ``window``; if the current
``domain`` is equal to the ``window`` the resulting map is the
identity.  If the coefficients of the series instance are to be
used by themselves outside this class, then the linear function
must be substituted for the ``x`` in the standard representation of
the base polynomials.

Returns
-------
off, scl : float or complex
    The mapping function is defined by ``off + scl*x``.

Notes
-----
If the current domain is the interval ``[l1, r1]`` and the window
is ``[l2, r2]``, then the linear mapping function ``L`` is
defined by the equations::

    L(l1) = l2
    L(r1) = r2
*)

val roots : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the roots of the series polynomial.

Compute the roots for the series. Note that the accuracy of the
roots decrease the further outside the domain they lie.

Returns
-------
roots : ndarray
    Array containing the roots of the series.
*)

val trim : ?tol:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Remove trailing coefficients

Remove trailing coefficients until a coefficient is reached whose
absolute value greater than `tol` or the beginning of the series is
reached. If all the coefficients would be removed the series is set
to ``[0]``. A new series instance is returned with the new
coefficients.  The current instance remains unchanged.

Parameters
----------
tol : non-negative number.
    All trailing coefficients less than `tol` will be removed.

Returns
-------
new_series : series
    Contains the new set of coefficients.
*)

val truncate : size:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to length `size`.

Reduce the series to length `size` by discarding the high
degree terms. The value of `size` must be a positive integer. This
can be useful in least squares where the coefficients of the
high degree terms may be very small.

Parameters
----------
size : positive int
    The series is reduced to length `size` by discarding the high
    degree terms. The value of `size` must be a positive integer.

Returns
-------
new_series : series
    New instance of series with truncated coefficients.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Hermite : sig
type tag = [`Hermite]
type t = [`ABCPolyBase | `Hermite | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_abc_poly : t -> [`ABCPolyBase] Obj.t
val create : ?domain:Py.Object.t -> ?window:Py.Object.t -> coef:[>`Ndarray] Obj.t -> unit -> t
(**
An Hermite series class.

The Hermite class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
attributes and methods listed in the `ABCPolyBase` documentation.

Parameters
----------
coef : array_like
    Hermite coefficients in order of increasing degree, i.e,
    ``(1, 2, 3)`` gives ``1*H_0(x) + 2*H_1(X) + 3*H_2(x)``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [-1, 1].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [-1, 1].

    .. versionadded:: 1.6.0
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
None
*)

val basis : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> deg:int -> [> tag] Obj.t -> Py.Object.t
(**
Series basis polynomial of degree `deg`.

Returns the series representing the basis polynomial of degree `deg`.

.. versionadded:: 1.7.0

Parameters
----------
deg : int
    Degree of the basis polynomial for the series. Must be >= 0.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series with the coefficient of the `deg` term set to one and
    all others zero.
*)

val cast : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> series:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to series of this class.

The `series` is expected to be an instance of some polynomial
series of one of the types supported by by the numpy.polynomial
module, but could be some other class that supports the convert
method.

.. versionadded:: 1.7.0

Parameters
----------
series : series
    The series instance to be converted.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series of the same kind as the calling class and equal to
    `series` when evaluated.

See Also
--------
convert : similar instance method
*)

val convert : ?domain:[>`Ndarray] Obj.t -> ?kind:Py.Object.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to a different kind and/or domain and/or window.

Parameters
----------
domain : array_like, optional
    The domain of the converted series. If the value is None,
    the default domain of `kind` is used.
kind : class, optional
    The polynomial series type class to which the current instance
    should be converted. If kind is None, then the class of the
    current instance is used.
window : array_like, optional
    The window of the converted series. If the value is None,
    the default window of `kind` is used.

Returns
-------
new_series : series
    The returned class can be of different type than the current
    instance and/or have a different domain and/or different
    window.

Notes
-----
Conversion between domains and class types can result in
numerically ill defined series.

Examples
--------
*)

val copy : [> tag] Obj.t -> Py.Object.t
(**
Return a copy.

Returns
-------
new_series : series
    Copy of self.
*)

val cutdeg : deg:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to the given degree.

Reduce the degree of the series to `deg` by discarding the
high order terms. If `deg` is greater than the current degree a
copy of the current series is returned. This can be useful in least
squares where the coefficients of the high degree terms may be very
small.

.. versionadded:: 1.5.0

Parameters
----------
deg : non-negative int
    The series is reduced to degree `deg` by discarding the high
    order terms. The value of `deg` must be a non-negative integer.

Returns
-------
new_series : series
    New instance of series with reduced degree.
*)

val degree : [> tag] Obj.t -> int
(**
The degree of the series.

.. versionadded:: 1.5.0

Returns
-------
degree : int
    Degree of the series, one less than the number of coefficients.
*)

val deriv : ?m:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Differentiate.

Return a series instance of that is the derivative of the current
series.

Parameters
----------
m : non-negative int
    Find the derivative of order `m`.

Returns
-------
new_series : series
    A new series representing the derivative. The domain is the same
    as the domain of the differentiated series.
*)

val fit : ?domain:Py.Object.t -> ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> ?window:Py.Object.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Least squares fit to data.

Return a series instance that is the least squares fit to the data
`y` sampled at `x`. The domain of the returned instance can be
specified and this will often result in a superior fit with less
chance of ill conditioning.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
domain : {None, [beg, end], []}, optional
    Domain to use for the returned series. If ``None``,
    then a minimal domain that covers the points `x` is chosen.  If
    ``[]`` the class domain is used. The default value was the
    class domain in NumPy 1.4 and ``None`` in later versions.
    The ``[]`` option was added in numpy 1.5.0.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller
    than this relative to the largest singular value will be
    ignored. The default value is len(x)*eps, where eps is the
    relative precision of the float type, about 2e-16 in most
    cases.
full : bool, optional
    Switch determining nature of return value. When it is False
    (the default) just the coefficients are returned, when True
    diagnostic information from the singular value decomposition is
    also returned.
w : array_like, shape (M,), optional
    Weights. If not None the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products
    ``w[i]*y[i]`` all have the same variance.  The default value is
    None.

    .. versionadded:: 1.5.0
window : {[beg, end]}, optional
    Window to use for the returned series. The default
    value is the default class domain

    .. versionadded:: 1.6.0

Returns
-------
new_series : series
    A series that represents the least squares fit to the data and
    has the domain and window specified in the call. If the
    coefficients for the unscaled and unshifted basis polynomials are
    of interest, do ``new_series.convert().coef``.

[resid, rank, sv, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.
*)

val fromroots : ?domain:[`Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `None] -> ?window:[>`Ndarray] Obj.t -> roots:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return series instance that has the specified roots.

Returns a series representing the product
``(x - r[0])*(x - r[1])*...*(x - r[n-1])``, where ``r`` is a
list of roots.

Parameters
----------
roots : array_like
    List of roots.
domain : {[], None, array_like}, optional
    Domain for the resulting series. If None the domain is the
    interval from the smallest root to the largest. If [] the
    domain is the class domain. The default is [].
window : {None, array_like}, optional
    Window for the returned series. If None the class window is
    used. The default is None.

Returns
-------
new_series : series
    Series with the specified roots.
*)

val has_samecoef : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if coefficients match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``coef`` attribute.

Returns
-------
bool : boolean
    True if the coefficients are the same, False otherwise.
*)

val has_samedomain : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if domains match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``domain`` attribute.

Returns
-------
bool : boolean
    True if the domains are the same, False otherwise.
*)

val has_sametype : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if types match.

.. versionadded:: 1.7.0

Parameters
----------
other : object
    Class instance.

Returns
-------
bool : boolean
    True if other is same class as self
*)

val has_samewindow : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if windows match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``window`` attribute.

Returns
-------
bool : boolean
    True if the windows are the same, False otherwise.
*)

val identity : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Identity function.

If ``p`` is the returned series, then ``p(x) == x`` for all
values of x.

Parameters
----------
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
     Series of representing the identity.
*)

val integ : ?m:Py.Object.t -> ?k:[>`Ndarray] Obj.t -> ?lbnd:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Integrate.

Return a series instance that is the definite integral of the
current series.

Parameters
----------
m : non-negative int
    The number of integrations to perform.
k : array_like
    Integration constants. The first constant is applied to the
    first integration, the second to the second, and so on. The
    list of values must less than or equal to `m` in length and any
    missing values are set to zero.
lbnd : Scalar
    The lower bound of the definite integral.

Returns
-------
new_series : series
    A new series representing the integral. The domain is the same
    as the domain of the integrated series.
*)

val linspace : ?n:int -> ?domain:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return x, y values at equally spaced points in domain.

Returns the x, y values at `n` linearly spaced points across the
domain.  Here y is the value of the polynomial at the points x. By
default the domain is the same as that of the series instance.
This method is intended mostly as a plotting aid.

.. versionadded:: 1.5.0

Parameters
----------
n : int, optional
    Number of point pairs to return. The default value is 100.
domain : {None, array_like}, optional
    If not None, the specified domain is used instead of that of
    the calling instance. It should be of the form ``[beg,end]``.
    The default is None which case the class domain is used.

Returns
-------
x, y : ndarray
    x is equal to linspace(self.domain[0], self.domain[1], n) and
    y is the series evaluated at element of x.
*)

val mapparms : [> tag] Obj.t -> Py.Object.t
(**
Return the mapping parameters.

The returned values define a linear map ``off + scl*x`` that is
applied to the input arguments before the series is evaluated. The
map depends on the ``domain`` and ``window``; if the current
``domain`` is equal to the ``window`` the resulting map is the
identity.  If the coefficients of the series instance are to be
used by themselves outside this class, then the linear function
must be substituted for the ``x`` in the standard representation of
the base polynomials.

Returns
-------
off, scl : float or complex
    The mapping function is defined by ``off + scl*x``.

Notes
-----
If the current domain is the interval ``[l1, r1]`` and the window
is ``[l2, r2]``, then the linear mapping function ``L`` is
defined by the equations::

    L(l1) = l2
    L(r1) = r2
*)

val roots : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the roots of the series polynomial.

Compute the roots for the series. Note that the accuracy of the
roots decrease the further outside the domain they lie.

Returns
-------
roots : ndarray
    Array containing the roots of the series.
*)

val trim : ?tol:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Remove trailing coefficients

Remove trailing coefficients until a coefficient is reached whose
absolute value greater than `tol` or the beginning of the series is
reached. If all the coefficients would be removed the series is set
to ``[0]``. A new series instance is returned with the new
coefficients.  The current instance remains unchanged.

Parameters
----------
tol : non-negative number.
    All trailing coefficients less than `tol` will be removed.

Returns
-------
new_series : series
    Contains the new set of coefficients.
*)

val truncate : size:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to length `size`.

Reduce the series to length `size` by discarding the high
degree terms. The value of `size` must be a positive integer. This
can be useful in least squares where the coefficients of the
high degree terms may be very small.

Parameters
----------
size : positive int
    The series is reduced to length `size` by discarding the high
    degree terms. The value of `size` must be a positive integer.

Returns
-------
new_series : series
    New instance of series with truncated coefficients.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module HermiteE : sig
type tag = [`HermiteE]
type t = [`ABCPolyBase | `HermiteE | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_abc_poly : t -> [`ABCPolyBase] Obj.t
val create : ?domain:Py.Object.t -> ?window:Py.Object.t -> coef:[>`Ndarray] Obj.t -> unit -> t
(**
An HermiteE series class.

The HermiteE class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
attributes and methods listed in the `ABCPolyBase` documentation.

Parameters
----------
coef : array_like
    HermiteE coefficients in order of increasing degree, i.e,
    ``(1, 2, 3)`` gives ``1*He_0(x) + 2*He_1(X) + 3*He_2(x)``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [-1, 1].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [-1, 1].

    .. versionadded:: 1.6.0
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
None
*)

val basis : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> deg:int -> [> tag] Obj.t -> Py.Object.t
(**
Series basis polynomial of degree `deg`.

Returns the series representing the basis polynomial of degree `deg`.

.. versionadded:: 1.7.0

Parameters
----------
deg : int
    Degree of the basis polynomial for the series. Must be >= 0.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series with the coefficient of the `deg` term set to one and
    all others zero.
*)

val cast : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> series:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to series of this class.

The `series` is expected to be an instance of some polynomial
series of one of the types supported by by the numpy.polynomial
module, but could be some other class that supports the convert
method.

.. versionadded:: 1.7.0

Parameters
----------
series : series
    The series instance to be converted.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series of the same kind as the calling class and equal to
    `series` when evaluated.

See Also
--------
convert : similar instance method
*)

val convert : ?domain:[>`Ndarray] Obj.t -> ?kind:Py.Object.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to a different kind and/or domain and/or window.

Parameters
----------
domain : array_like, optional
    The domain of the converted series. If the value is None,
    the default domain of `kind` is used.
kind : class, optional
    The polynomial series type class to which the current instance
    should be converted. If kind is None, then the class of the
    current instance is used.
window : array_like, optional
    The window of the converted series. If the value is None,
    the default window of `kind` is used.

Returns
-------
new_series : series
    The returned class can be of different type than the current
    instance and/or have a different domain and/or different
    window.

Notes
-----
Conversion between domains and class types can result in
numerically ill defined series.

Examples
--------
*)

val copy : [> tag] Obj.t -> Py.Object.t
(**
Return a copy.

Returns
-------
new_series : series
    Copy of self.
*)

val cutdeg : deg:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to the given degree.

Reduce the degree of the series to `deg` by discarding the
high order terms. If `deg` is greater than the current degree a
copy of the current series is returned. This can be useful in least
squares where the coefficients of the high degree terms may be very
small.

.. versionadded:: 1.5.0

Parameters
----------
deg : non-negative int
    The series is reduced to degree `deg` by discarding the high
    order terms. The value of `deg` must be a non-negative integer.

Returns
-------
new_series : series
    New instance of series with reduced degree.
*)

val degree : [> tag] Obj.t -> int
(**
The degree of the series.

.. versionadded:: 1.5.0

Returns
-------
degree : int
    Degree of the series, one less than the number of coefficients.
*)

val deriv : ?m:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Differentiate.

Return a series instance of that is the derivative of the current
series.

Parameters
----------
m : non-negative int
    Find the derivative of order `m`.

Returns
-------
new_series : series
    A new series representing the derivative. The domain is the same
    as the domain of the differentiated series.
*)

val fit : ?domain:Py.Object.t -> ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> ?window:Py.Object.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Least squares fit to data.

Return a series instance that is the least squares fit to the data
`y` sampled at `x`. The domain of the returned instance can be
specified and this will often result in a superior fit with less
chance of ill conditioning.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
domain : {None, [beg, end], []}, optional
    Domain to use for the returned series. If ``None``,
    then a minimal domain that covers the points `x` is chosen.  If
    ``[]`` the class domain is used. The default value was the
    class domain in NumPy 1.4 and ``None`` in later versions.
    The ``[]`` option was added in numpy 1.5.0.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller
    than this relative to the largest singular value will be
    ignored. The default value is len(x)*eps, where eps is the
    relative precision of the float type, about 2e-16 in most
    cases.
full : bool, optional
    Switch determining nature of return value. When it is False
    (the default) just the coefficients are returned, when True
    diagnostic information from the singular value decomposition is
    also returned.
w : array_like, shape (M,), optional
    Weights. If not None the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products
    ``w[i]*y[i]`` all have the same variance.  The default value is
    None.

    .. versionadded:: 1.5.0
window : {[beg, end]}, optional
    Window to use for the returned series. The default
    value is the default class domain

    .. versionadded:: 1.6.0

Returns
-------
new_series : series
    A series that represents the least squares fit to the data and
    has the domain and window specified in the call. If the
    coefficients for the unscaled and unshifted basis polynomials are
    of interest, do ``new_series.convert().coef``.

[resid, rank, sv, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.
*)

val fromroots : ?domain:[`Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `None] -> ?window:[>`Ndarray] Obj.t -> roots:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return series instance that has the specified roots.

Returns a series representing the product
``(x - r[0])*(x - r[1])*...*(x - r[n-1])``, where ``r`` is a
list of roots.

Parameters
----------
roots : array_like
    List of roots.
domain : {[], None, array_like}, optional
    Domain for the resulting series. If None the domain is the
    interval from the smallest root to the largest. If [] the
    domain is the class domain. The default is [].
window : {None, array_like}, optional
    Window for the returned series. If None the class window is
    used. The default is None.

Returns
-------
new_series : series
    Series with the specified roots.
*)

val has_samecoef : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if coefficients match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``coef`` attribute.

Returns
-------
bool : boolean
    True if the coefficients are the same, False otherwise.
*)

val has_samedomain : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if domains match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``domain`` attribute.

Returns
-------
bool : boolean
    True if the domains are the same, False otherwise.
*)

val has_sametype : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if types match.

.. versionadded:: 1.7.0

Parameters
----------
other : object
    Class instance.

Returns
-------
bool : boolean
    True if other is same class as self
*)

val has_samewindow : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if windows match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``window`` attribute.

Returns
-------
bool : boolean
    True if the windows are the same, False otherwise.
*)

val identity : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Identity function.

If ``p`` is the returned series, then ``p(x) == x`` for all
values of x.

Parameters
----------
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
     Series of representing the identity.
*)

val integ : ?m:Py.Object.t -> ?k:[>`Ndarray] Obj.t -> ?lbnd:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Integrate.

Return a series instance that is the definite integral of the
current series.

Parameters
----------
m : non-negative int
    The number of integrations to perform.
k : array_like
    Integration constants. The first constant is applied to the
    first integration, the second to the second, and so on. The
    list of values must less than or equal to `m` in length and any
    missing values are set to zero.
lbnd : Scalar
    The lower bound of the definite integral.

Returns
-------
new_series : series
    A new series representing the integral. The domain is the same
    as the domain of the integrated series.
*)

val linspace : ?n:int -> ?domain:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return x, y values at equally spaced points in domain.

Returns the x, y values at `n` linearly spaced points across the
domain.  Here y is the value of the polynomial at the points x. By
default the domain is the same as that of the series instance.
This method is intended mostly as a plotting aid.

.. versionadded:: 1.5.0

Parameters
----------
n : int, optional
    Number of point pairs to return. The default value is 100.
domain : {None, array_like}, optional
    If not None, the specified domain is used instead of that of
    the calling instance. It should be of the form ``[beg,end]``.
    The default is None which case the class domain is used.

Returns
-------
x, y : ndarray
    x is equal to linspace(self.domain[0], self.domain[1], n) and
    y is the series evaluated at element of x.
*)

val mapparms : [> tag] Obj.t -> Py.Object.t
(**
Return the mapping parameters.

The returned values define a linear map ``off + scl*x`` that is
applied to the input arguments before the series is evaluated. The
map depends on the ``domain`` and ``window``; if the current
``domain`` is equal to the ``window`` the resulting map is the
identity.  If the coefficients of the series instance are to be
used by themselves outside this class, then the linear function
must be substituted for the ``x`` in the standard representation of
the base polynomials.

Returns
-------
off, scl : float or complex
    The mapping function is defined by ``off + scl*x``.

Notes
-----
If the current domain is the interval ``[l1, r1]`` and the window
is ``[l2, r2]``, then the linear mapping function ``L`` is
defined by the equations::

    L(l1) = l2
    L(r1) = r2
*)

val roots : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the roots of the series polynomial.

Compute the roots for the series. Note that the accuracy of the
roots decrease the further outside the domain they lie.

Returns
-------
roots : ndarray
    Array containing the roots of the series.
*)

val trim : ?tol:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Remove trailing coefficients

Remove trailing coefficients until a coefficient is reached whose
absolute value greater than `tol` or the beginning of the series is
reached. If all the coefficients would be removed the series is set
to ``[0]``. A new series instance is returned with the new
coefficients.  The current instance remains unchanged.

Parameters
----------
tol : non-negative number.
    All trailing coefficients less than `tol` will be removed.

Returns
-------
new_series : series
    Contains the new set of coefficients.
*)

val truncate : size:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to length `size`.

Reduce the series to length `size` by discarding the high
degree terms. The value of `size` must be a positive integer. This
can be useful in least squares where the coefficients of the
high degree terms may be very small.

Parameters
----------
size : positive int
    The series is reduced to length `size` by discarding the high
    degree terms. The value of `size` must be a positive integer.

Returns
-------
new_series : series
    New instance of series with truncated coefficients.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Laguerre : sig
type tag = [`Laguerre]
type t = [`ABCPolyBase | `Laguerre | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_abc_poly : t -> [`ABCPolyBase] Obj.t
val create : ?domain:Py.Object.t -> ?window:Py.Object.t -> coef:[>`Ndarray] Obj.t -> unit -> t
(**
A Laguerre series class.

The Laguerre class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
attributes and methods listed in the `ABCPolyBase` documentation.

Parameters
----------
coef : array_like
    Laguerre coefficients in order of increasing degree, i.e,
    ``(1, 2, 3)`` gives ``1*L_0(x) + 2*L_1(X) + 3*L_2(x)``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [0, 1].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [0, 1].

    .. versionadded:: 1.6.0
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
None
*)

val basis : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> deg:int -> [> tag] Obj.t -> Py.Object.t
(**
Series basis polynomial of degree `deg`.

Returns the series representing the basis polynomial of degree `deg`.

.. versionadded:: 1.7.0

Parameters
----------
deg : int
    Degree of the basis polynomial for the series. Must be >= 0.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series with the coefficient of the `deg` term set to one and
    all others zero.
*)

val cast : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> series:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to series of this class.

The `series` is expected to be an instance of some polynomial
series of one of the types supported by by the numpy.polynomial
module, but could be some other class that supports the convert
method.

.. versionadded:: 1.7.0

Parameters
----------
series : series
    The series instance to be converted.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series of the same kind as the calling class and equal to
    `series` when evaluated.

See Also
--------
convert : similar instance method
*)

val convert : ?domain:[>`Ndarray] Obj.t -> ?kind:Py.Object.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to a different kind and/or domain and/or window.

Parameters
----------
domain : array_like, optional
    The domain of the converted series. If the value is None,
    the default domain of `kind` is used.
kind : class, optional
    The polynomial series type class to which the current instance
    should be converted. If kind is None, then the class of the
    current instance is used.
window : array_like, optional
    The window of the converted series. If the value is None,
    the default window of `kind` is used.

Returns
-------
new_series : series
    The returned class can be of different type than the current
    instance and/or have a different domain and/or different
    window.

Notes
-----
Conversion between domains and class types can result in
numerically ill defined series.

Examples
--------
*)

val copy : [> tag] Obj.t -> Py.Object.t
(**
Return a copy.

Returns
-------
new_series : series
    Copy of self.
*)

val cutdeg : deg:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to the given degree.

Reduce the degree of the series to `deg` by discarding the
high order terms. If `deg` is greater than the current degree a
copy of the current series is returned. This can be useful in least
squares where the coefficients of the high degree terms may be very
small.

.. versionadded:: 1.5.0

Parameters
----------
deg : non-negative int
    The series is reduced to degree `deg` by discarding the high
    order terms. The value of `deg` must be a non-negative integer.

Returns
-------
new_series : series
    New instance of series with reduced degree.
*)

val degree : [> tag] Obj.t -> int
(**
The degree of the series.

.. versionadded:: 1.5.0

Returns
-------
degree : int
    Degree of the series, one less than the number of coefficients.
*)

val deriv : ?m:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Differentiate.

Return a series instance of that is the derivative of the current
series.

Parameters
----------
m : non-negative int
    Find the derivative of order `m`.

Returns
-------
new_series : series
    A new series representing the derivative. The domain is the same
    as the domain of the differentiated series.
*)

val fit : ?domain:Py.Object.t -> ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> ?window:Py.Object.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Least squares fit to data.

Return a series instance that is the least squares fit to the data
`y` sampled at `x`. The domain of the returned instance can be
specified and this will often result in a superior fit with less
chance of ill conditioning.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
domain : {None, [beg, end], []}, optional
    Domain to use for the returned series. If ``None``,
    then a minimal domain that covers the points `x` is chosen.  If
    ``[]`` the class domain is used. The default value was the
    class domain in NumPy 1.4 and ``None`` in later versions.
    The ``[]`` option was added in numpy 1.5.0.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller
    than this relative to the largest singular value will be
    ignored. The default value is len(x)*eps, where eps is the
    relative precision of the float type, about 2e-16 in most
    cases.
full : bool, optional
    Switch determining nature of return value. When it is False
    (the default) just the coefficients are returned, when True
    diagnostic information from the singular value decomposition is
    also returned.
w : array_like, shape (M,), optional
    Weights. If not None the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products
    ``w[i]*y[i]`` all have the same variance.  The default value is
    None.

    .. versionadded:: 1.5.0
window : {[beg, end]}, optional
    Window to use for the returned series. The default
    value is the default class domain

    .. versionadded:: 1.6.0

Returns
-------
new_series : series
    A series that represents the least squares fit to the data and
    has the domain and window specified in the call. If the
    coefficients for the unscaled and unshifted basis polynomials are
    of interest, do ``new_series.convert().coef``.

[resid, rank, sv, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.
*)

val fromroots : ?domain:[`Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `None] -> ?window:[>`Ndarray] Obj.t -> roots:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return series instance that has the specified roots.

Returns a series representing the product
``(x - r[0])*(x - r[1])*...*(x - r[n-1])``, where ``r`` is a
list of roots.

Parameters
----------
roots : array_like
    List of roots.
domain : {[], None, array_like}, optional
    Domain for the resulting series. If None the domain is the
    interval from the smallest root to the largest. If [] the
    domain is the class domain. The default is [].
window : {None, array_like}, optional
    Window for the returned series. If None the class window is
    used. The default is None.

Returns
-------
new_series : series
    Series with the specified roots.
*)

val has_samecoef : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if coefficients match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``coef`` attribute.

Returns
-------
bool : boolean
    True if the coefficients are the same, False otherwise.
*)

val has_samedomain : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if domains match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``domain`` attribute.

Returns
-------
bool : boolean
    True if the domains are the same, False otherwise.
*)

val has_sametype : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if types match.

.. versionadded:: 1.7.0

Parameters
----------
other : object
    Class instance.

Returns
-------
bool : boolean
    True if other is same class as self
*)

val has_samewindow : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if windows match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``window`` attribute.

Returns
-------
bool : boolean
    True if the windows are the same, False otherwise.
*)

val identity : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Identity function.

If ``p`` is the returned series, then ``p(x) == x`` for all
values of x.

Parameters
----------
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
     Series of representing the identity.
*)

val integ : ?m:Py.Object.t -> ?k:[>`Ndarray] Obj.t -> ?lbnd:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Integrate.

Return a series instance that is the definite integral of the
current series.

Parameters
----------
m : non-negative int
    The number of integrations to perform.
k : array_like
    Integration constants. The first constant is applied to the
    first integration, the second to the second, and so on. The
    list of values must less than or equal to `m` in length and any
    missing values are set to zero.
lbnd : Scalar
    The lower bound of the definite integral.

Returns
-------
new_series : series
    A new series representing the integral. The domain is the same
    as the domain of the integrated series.
*)

val linspace : ?n:int -> ?domain:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return x, y values at equally spaced points in domain.

Returns the x, y values at `n` linearly spaced points across the
domain.  Here y is the value of the polynomial at the points x. By
default the domain is the same as that of the series instance.
This method is intended mostly as a plotting aid.

.. versionadded:: 1.5.0

Parameters
----------
n : int, optional
    Number of point pairs to return. The default value is 100.
domain : {None, array_like}, optional
    If not None, the specified domain is used instead of that of
    the calling instance. It should be of the form ``[beg,end]``.
    The default is None which case the class domain is used.

Returns
-------
x, y : ndarray
    x is equal to linspace(self.domain[0], self.domain[1], n) and
    y is the series evaluated at element of x.
*)

val mapparms : [> tag] Obj.t -> Py.Object.t
(**
Return the mapping parameters.

The returned values define a linear map ``off + scl*x`` that is
applied to the input arguments before the series is evaluated. The
map depends on the ``domain`` and ``window``; if the current
``domain`` is equal to the ``window`` the resulting map is the
identity.  If the coefficients of the series instance are to be
used by themselves outside this class, then the linear function
must be substituted for the ``x`` in the standard representation of
the base polynomials.

Returns
-------
off, scl : float or complex
    The mapping function is defined by ``off + scl*x``.

Notes
-----
If the current domain is the interval ``[l1, r1]`` and the window
is ``[l2, r2]``, then the linear mapping function ``L`` is
defined by the equations::

    L(l1) = l2
    L(r1) = r2
*)

val roots : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the roots of the series polynomial.

Compute the roots for the series. Note that the accuracy of the
roots decrease the further outside the domain they lie.

Returns
-------
roots : ndarray
    Array containing the roots of the series.
*)

val trim : ?tol:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Remove trailing coefficients

Remove trailing coefficients until a coefficient is reached whose
absolute value greater than `tol` or the beginning of the series is
reached. If all the coefficients would be removed the series is set
to ``[0]``. A new series instance is returned with the new
coefficients.  The current instance remains unchanged.

Parameters
----------
tol : non-negative number.
    All trailing coefficients less than `tol` will be removed.

Returns
-------
new_series : series
    Contains the new set of coefficients.
*)

val truncate : size:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to length `size`.

Reduce the series to length `size` by discarding the high
degree terms. The value of `size` must be a positive integer. This
can be useful in least squares where the coefficients of the
high degree terms may be very small.

Parameters
----------
size : positive int
    The series is reduced to length `size` by discarding the high
    degree terms. The value of `size` must be a positive integer.

Returns
-------
new_series : series
    New instance of series with truncated coefficients.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Legendre : sig
type tag = [`Legendre]
type t = [`ABCPolyBase | `Legendre | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_abc_poly : t -> [`ABCPolyBase] Obj.t
val create : ?domain:Py.Object.t -> ?window:Py.Object.t -> coef:[>`Ndarray] Obj.t -> unit -> t
(**
A Legendre series class.

The Legendre class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
attributes and methods listed in the `ABCPolyBase` documentation.

Parameters
----------
coef : array_like
    Legendre coefficients in order of increasing degree, i.e.,
    ``(1, 2, 3)`` gives ``1*P_0(x) + 2*P_1(x) + 3*P_2(x)``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [-1, 1].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [-1, 1].

    .. versionadded:: 1.6.0
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
None
*)

val basis : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> deg:int -> [> tag] Obj.t -> Py.Object.t
(**
Series basis polynomial of degree `deg`.

Returns the series representing the basis polynomial of degree `deg`.

.. versionadded:: 1.7.0

Parameters
----------
deg : int
    Degree of the basis polynomial for the series. Must be >= 0.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series with the coefficient of the `deg` term set to one and
    all others zero.
*)

val cast : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> series:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to series of this class.

The `series` is expected to be an instance of some polynomial
series of one of the types supported by by the numpy.polynomial
module, but could be some other class that supports the convert
method.

.. versionadded:: 1.7.0

Parameters
----------
series : series
    The series instance to be converted.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series of the same kind as the calling class and equal to
    `series` when evaluated.

See Also
--------
convert : similar instance method
*)

val convert : ?domain:[>`Ndarray] Obj.t -> ?kind:Py.Object.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to a different kind and/or domain and/or window.

Parameters
----------
domain : array_like, optional
    The domain of the converted series. If the value is None,
    the default domain of `kind` is used.
kind : class, optional
    The polynomial series type class to which the current instance
    should be converted. If kind is None, then the class of the
    current instance is used.
window : array_like, optional
    The window of the converted series. If the value is None,
    the default window of `kind` is used.

Returns
-------
new_series : series
    The returned class can be of different type than the current
    instance and/or have a different domain and/or different
    window.

Notes
-----
Conversion between domains and class types can result in
numerically ill defined series.

Examples
--------
*)

val copy : [> tag] Obj.t -> Py.Object.t
(**
Return a copy.

Returns
-------
new_series : series
    Copy of self.
*)

val cutdeg : deg:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to the given degree.

Reduce the degree of the series to `deg` by discarding the
high order terms. If `deg` is greater than the current degree a
copy of the current series is returned. This can be useful in least
squares where the coefficients of the high degree terms may be very
small.

.. versionadded:: 1.5.0

Parameters
----------
deg : non-negative int
    The series is reduced to degree `deg` by discarding the high
    order terms. The value of `deg` must be a non-negative integer.

Returns
-------
new_series : series
    New instance of series with reduced degree.
*)

val degree : [> tag] Obj.t -> int
(**
The degree of the series.

.. versionadded:: 1.5.0

Returns
-------
degree : int
    Degree of the series, one less than the number of coefficients.
*)

val deriv : ?m:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Differentiate.

Return a series instance of that is the derivative of the current
series.

Parameters
----------
m : non-negative int
    Find the derivative of order `m`.

Returns
-------
new_series : series
    A new series representing the derivative. The domain is the same
    as the domain of the differentiated series.
*)

val fit : ?domain:Py.Object.t -> ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> ?window:Py.Object.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Least squares fit to data.

Return a series instance that is the least squares fit to the data
`y` sampled at `x`. The domain of the returned instance can be
specified and this will often result in a superior fit with less
chance of ill conditioning.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
domain : {None, [beg, end], []}, optional
    Domain to use for the returned series. If ``None``,
    then a minimal domain that covers the points `x` is chosen.  If
    ``[]`` the class domain is used. The default value was the
    class domain in NumPy 1.4 and ``None`` in later versions.
    The ``[]`` option was added in numpy 1.5.0.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller
    than this relative to the largest singular value will be
    ignored. The default value is len(x)*eps, where eps is the
    relative precision of the float type, about 2e-16 in most
    cases.
full : bool, optional
    Switch determining nature of return value. When it is False
    (the default) just the coefficients are returned, when True
    diagnostic information from the singular value decomposition is
    also returned.
w : array_like, shape (M,), optional
    Weights. If not None the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products
    ``w[i]*y[i]`` all have the same variance.  The default value is
    None.

    .. versionadded:: 1.5.0
window : {[beg, end]}, optional
    Window to use for the returned series. The default
    value is the default class domain

    .. versionadded:: 1.6.0

Returns
-------
new_series : series
    A series that represents the least squares fit to the data and
    has the domain and window specified in the call. If the
    coefficients for the unscaled and unshifted basis polynomials are
    of interest, do ``new_series.convert().coef``.

[resid, rank, sv, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.
*)

val fromroots : ?domain:[`Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `None] -> ?window:[>`Ndarray] Obj.t -> roots:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return series instance that has the specified roots.

Returns a series representing the product
``(x - r[0])*(x - r[1])*...*(x - r[n-1])``, where ``r`` is a
list of roots.

Parameters
----------
roots : array_like
    List of roots.
domain : {[], None, array_like}, optional
    Domain for the resulting series. If None the domain is the
    interval from the smallest root to the largest. If [] the
    domain is the class domain. The default is [].
window : {None, array_like}, optional
    Window for the returned series. If None the class window is
    used. The default is None.

Returns
-------
new_series : series
    Series with the specified roots.
*)

val has_samecoef : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if coefficients match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``coef`` attribute.

Returns
-------
bool : boolean
    True if the coefficients are the same, False otherwise.
*)

val has_samedomain : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if domains match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``domain`` attribute.

Returns
-------
bool : boolean
    True if the domains are the same, False otherwise.
*)

val has_sametype : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if types match.

.. versionadded:: 1.7.0

Parameters
----------
other : object
    Class instance.

Returns
-------
bool : boolean
    True if other is same class as self
*)

val has_samewindow : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if windows match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``window`` attribute.

Returns
-------
bool : boolean
    True if the windows are the same, False otherwise.
*)

val identity : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Identity function.

If ``p`` is the returned series, then ``p(x) == x`` for all
values of x.

Parameters
----------
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
     Series of representing the identity.
*)

val integ : ?m:Py.Object.t -> ?k:[>`Ndarray] Obj.t -> ?lbnd:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Integrate.

Return a series instance that is the definite integral of the
current series.

Parameters
----------
m : non-negative int
    The number of integrations to perform.
k : array_like
    Integration constants. The first constant is applied to the
    first integration, the second to the second, and so on. The
    list of values must less than or equal to `m` in length and any
    missing values are set to zero.
lbnd : Scalar
    The lower bound of the definite integral.

Returns
-------
new_series : series
    A new series representing the integral. The domain is the same
    as the domain of the integrated series.
*)

val linspace : ?n:int -> ?domain:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return x, y values at equally spaced points in domain.

Returns the x, y values at `n` linearly spaced points across the
domain.  Here y is the value of the polynomial at the points x. By
default the domain is the same as that of the series instance.
This method is intended mostly as a plotting aid.

.. versionadded:: 1.5.0

Parameters
----------
n : int, optional
    Number of point pairs to return. The default value is 100.
domain : {None, array_like}, optional
    If not None, the specified domain is used instead of that of
    the calling instance. It should be of the form ``[beg,end]``.
    The default is None which case the class domain is used.

Returns
-------
x, y : ndarray
    x is equal to linspace(self.domain[0], self.domain[1], n) and
    y is the series evaluated at element of x.
*)

val mapparms : [> tag] Obj.t -> Py.Object.t
(**
Return the mapping parameters.

The returned values define a linear map ``off + scl*x`` that is
applied to the input arguments before the series is evaluated. The
map depends on the ``domain`` and ``window``; if the current
``domain`` is equal to the ``window`` the resulting map is the
identity.  If the coefficients of the series instance are to be
used by themselves outside this class, then the linear function
must be substituted for the ``x`` in the standard representation of
the base polynomials.

Returns
-------
off, scl : float or complex
    The mapping function is defined by ``off + scl*x``.

Notes
-----
If the current domain is the interval ``[l1, r1]`` and the window
is ``[l2, r2]``, then the linear mapping function ``L`` is
defined by the equations::

    L(l1) = l2
    L(r1) = r2
*)

val roots : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the roots of the series polynomial.

Compute the roots for the series. Note that the accuracy of the
roots decrease the further outside the domain they lie.

Returns
-------
roots : ndarray
    Array containing the roots of the series.
*)

val trim : ?tol:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Remove trailing coefficients

Remove trailing coefficients until a coefficient is reached whose
absolute value greater than `tol` or the beginning of the series is
reached. If all the coefficients would be removed the series is set
to ``[0]``. A new series instance is returned with the new
coefficients.  The current instance remains unchanged.

Parameters
----------
tol : non-negative number.
    All trailing coefficients less than `tol` will be removed.

Returns
-------
new_series : series
    Contains the new set of coefficients.
*)

val truncate : size:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to length `size`.

Reduce the series to length `size` by discarding the high
degree terms. The value of `size` must be a positive integer. This
can be useful in least squares where the coefficients of the
high degree terms may be very small.

Parameters
----------
size : positive int
    The series is reduced to length `size` by discarding the high
    degree terms. The value of `size` must be a positive integer.

Returns
-------
new_series : series
    New instance of series with truncated coefficients.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Polynomial : sig
type tag = [`Polynomial]
type t = [`ABCPolyBase | `Object | `Polynomial] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_abc_poly : t -> [`ABCPolyBase] Obj.t
val create : ?domain:Py.Object.t -> ?window:Py.Object.t -> coef:[>`Ndarray] Obj.t -> unit -> t
(**
A power series class.

The Polynomial class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
attributes and methods listed in the `ABCPolyBase` documentation.

Parameters
----------
coef : array_like
    Polynomial coefficients in order of increasing degree, i.e.,
    ``(1, 2, 3)`` give ``1 + 2*x + 3*x**2``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [-1, 1].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [-1, 1].

    .. versionadded:: 1.6.0
*)

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
None
*)

val basis : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> deg:int -> [> tag] Obj.t -> Py.Object.t
(**
Series basis polynomial of degree `deg`.

Returns the series representing the basis polynomial of degree `deg`.

.. versionadded:: 1.7.0

Parameters
----------
deg : int
    Degree of the basis polynomial for the series. Must be >= 0.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series with the coefficient of the `deg` term set to one and
    all others zero.
*)

val cast : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> series:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to series of this class.

The `series` is expected to be an instance of some polynomial
series of one of the types supported by by the numpy.polynomial
module, but could be some other class that supports the convert
method.

.. versionadded:: 1.7.0

Parameters
----------
series : series
    The series instance to be converted.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series of the same kind as the calling class and equal to
    `series` when evaluated.

See Also
--------
convert : similar instance method
*)

val convert : ?domain:[>`Ndarray] Obj.t -> ?kind:Py.Object.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to a different kind and/or domain and/or window.

Parameters
----------
domain : array_like, optional
    The domain of the converted series. If the value is None,
    the default domain of `kind` is used.
kind : class, optional
    The polynomial series type class to which the current instance
    should be converted. If kind is None, then the class of the
    current instance is used.
window : array_like, optional
    The window of the converted series. If the value is None,
    the default window of `kind` is used.

Returns
-------
new_series : series
    The returned class can be of different type than the current
    instance and/or have a different domain and/or different
    window.

Notes
-----
Conversion between domains and class types can result in
numerically ill defined series.

Examples
--------
*)

val copy : [> tag] Obj.t -> Py.Object.t
(**
Return a copy.

Returns
-------
new_series : series
    Copy of self.
*)

val cutdeg : deg:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to the given degree.

Reduce the degree of the series to `deg` by discarding the
high order terms. If `deg` is greater than the current degree a
copy of the current series is returned. This can be useful in least
squares where the coefficients of the high degree terms may be very
small.

.. versionadded:: 1.5.0

Parameters
----------
deg : non-negative int
    The series is reduced to degree `deg` by discarding the high
    order terms. The value of `deg` must be a non-negative integer.

Returns
-------
new_series : series
    New instance of series with reduced degree.
*)

val degree : [> tag] Obj.t -> int
(**
The degree of the series.

.. versionadded:: 1.5.0

Returns
-------
degree : int
    Degree of the series, one less than the number of coefficients.
*)

val deriv : ?m:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Differentiate.

Return a series instance of that is the derivative of the current
series.

Parameters
----------
m : non-negative int
    Find the derivative of order `m`.

Returns
-------
new_series : series
    A new series representing the derivative. The domain is the same
    as the domain of the differentiated series.
*)

val fit : ?domain:Py.Object.t -> ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> ?window:Py.Object.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Least squares fit to data.

Return a series instance that is the least squares fit to the data
`y` sampled at `x`. The domain of the returned instance can be
specified and this will often result in a superior fit with less
chance of ill conditioning.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
domain : {None, [beg, end], []}, optional
    Domain to use for the returned series. If ``None``,
    then a minimal domain that covers the points `x` is chosen.  If
    ``[]`` the class domain is used. The default value was the
    class domain in NumPy 1.4 and ``None`` in later versions.
    The ``[]`` option was added in numpy 1.5.0.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller
    than this relative to the largest singular value will be
    ignored. The default value is len(x)*eps, where eps is the
    relative precision of the float type, about 2e-16 in most
    cases.
full : bool, optional
    Switch determining nature of return value. When it is False
    (the default) just the coefficients are returned, when True
    diagnostic information from the singular value decomposition is
    also returned.
w : array_like, shape (M,), optional
    Weights. If not None the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products
    ``w[i]*y[i]`` all have the same variance.  The default value is
    None.

    .. versionadded:: 1.5.0
window : {[beg, end]}, optional
    Window to use for the returned series. The default
    value is the default class domain

    .. versionadded:: 1.6.0

Returns
-------
new_series : series
    A series that represents the least squares fit to the data and
    has the domain and window specified in the call. If the
    coefficients for the unscaled and unshifted basis polynomials are
    of interest, do ``new_series.convert().coef``.

[resid, rank, sv, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.
*)

val fromroots : ?domain:[`Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `None] -> ?window:[>`Ndarray] Obj.t -> roots:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return series instance that has the specified roots.

Returns a series representing the product
``(x - r[0])*(x - r[1])*...*(x - r[n-1])``, where ``r`` is a
list of roots.

Parameters
----------
roots : array_like
    List of roots.
domain : {[], None, array_like}, optional
    Domain for the resulting series. If None the domain is the
    interval from the smallest root to the largest. If [] the
    domain is the class domain. The default is [].
window : {None, array_like}, optional
    Window for the returned series. If None the class window is
    used. The default is None.

Returns
-------
new_series : series
    Series with the specified roots.
*)

val has_samecoef : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if coefficients match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``coef`` attribute.

Returns
-------
bool : boolean
    True if the coefficients are the same, False otherwise.
*)

val has_samedomain : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if domains match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``domain`` attribute.

Returns
-------
bool : boolean
    True if the domains are the same, False otherwise.
*)

val has_sametype : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if types match.

.. versionadded:: 1.7.0

Parameters
----------
other : object
    Class instance.

Returns
-------
bool : boolean
    True if other is same class as self
*)

val has_samewindow : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if windows match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``window`` attribute.

Returns
-------
bool : boolean
    True if the windows are the same, False otherwise.
*)

val identity : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Identity function.

If ``p`` is the returned series, then ``p(x) == x`` for all
values of x.

Parameters
----------
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
     Series of representing the identity.
*)

val integ : ?m:Py.Object.t -> ?k:[>`Ndarray] Obj.t -> ?lbnd:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Integrate.

Return a series instance that is the definite integral of the
current series.

Parameters
----------
m : non-negative int
    The number of integrations to perform.
k : array_like
    Integration constants. The first constant is applied to the
    first integration, the second to the second, and so on. The
    list of values must less than or equal to `m` in length and any
    missing values are set to zero.
lbnd : Scalar
    The lower bound of the definite integral.

Returns
-------
new_series : series
    A new series representing the integral. The domain is the same
    as the domain of the integrated series.
*)

val linspace : ?n:int -> ?domain:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return x, y values at equally spaced points in domain.

Returns the x, y values at `n` linearly spaced points across the
domain.  Here y is the value of the polynomial at the points x. By
default the domain is the same as that of the series instance.
This method is intended mostly as a plotting aid.

.. versionadded:: 1.5.0

Parameters
----------
n : int, optional
    Number of point pairs to return. The default value is 100.
domain : {None, array_like}, optional
    If not None, the specified domain is used instead of that of
    the calling instance. It should be of the form ``[beg,end]``.
    The default is None which case the class domain is used.

Returns
-------
x, y : ndarray
    x is equal to linspace(self.domain[0], self.domain[1], n) and
    y is the series evaluated at element of x.
*)

val mapparms : [> tag] Obj.t -> Py.Object.t
(**
Return the mapping parameters.

The returned values define a linear map ``off + scl*x`` that is
applied to the input arguments before the series is evaluated. The
map depends on the ``domain`` and ``window``; if the current
``domain`` is equal to the ``window`` the resulting map is the
identity.  If the coefficients of the series instance are to be
used by themselves outside this class, then the linear function
must be substituted for the ``x`` in the standard representation of
the base polynomials.

Returns
-------
off, scl : float or complex
    The mapping function is defined by ``off + scl*x``.

Notes
-----
If the current domain is the interval ``[l1, r1]`` and the window
is ``[l2, r2]``, then the linear mapping function ``L`` is
defined by the equations::

    L(l1) = l2
    L(r1) = r2
*)

val roots : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the roots of the series polynomial.

Compute the roots for the series. Note that the accuracy of the
roots decrease the further outside the domain they lie.

Returns
-------
roots : ndarray
    Array containing the roots of the series.
*)

val trim : ?tol:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Remove trailing coefficients

Remove trailing coefficients until a coefficient is reached whose
absolute value greater than `tol` or the beginning of the series is
reached. If all the coefficients would be removed the series is set
to ``[0]``. A new series instance is returned with the new
coefficients.  The current instance remains unchanged.

Parameters
----------
tol : non-negative number.
    All trailing coefficients less than `tol` will be removed.

Returns
-------
new_series : series
    Contains the new set of coefficients.
*)

val truncate : size:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to length `size`.

Reduce the series to length `size` by discarding the high
degree terms. The value of `size` must be a positive integer. This
can be useful in least squares where the coefficients of the
high degree terms may be very small.

Parameters
----------
size : positive int
    The series is reduced to length `size` by discarding the high
    degree terms. The value of `size` must be a positive integer.

Returns
-------
new_series : series
    New instance of series with truncated coefficients.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Chebyshev' : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

module ABCPolyBase : sig
type tag = [`ABCPolyBase]
type t = [`ABCPolyBase | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
None
*)

val basis : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> deg:int -> [> tag] Obj.t -> Py.Object.t
(**
Series basis polynomial of degree `deg`.

Returns the series representing the basis polynomial of degree `deg`.

.. versionadded:: 1.7.0

Parameters
----------
deg : int
    Degree of the basis polynomial for the series. Must be >= 0.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series with the coefficient of the `deg` term set to one and
    all others zero.
*)

val cast : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> series:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to series of this class.

The `series` is expected to be an instance of some polynomial
series of one of the types supported by by the numpy.polynomial
module, but could be some other class that supports the convert
method.

.. versionadded:: 1.7.0

Parameters
----------
series : series
    The series instance to be converted.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series of the same kind as the calling class and equal to
    `series` when evaluated.

See Also
--------
convert : similar instance method
*)

val convert : ?domain:[>`Ndarray] Obj.t -> ?kind:Py.Object.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to a different kind and/or domain and/or window.

Parameters
----------
domain : array_like, optional
    The domain of the converted series. If the value is None,
    the default domain of `kind` is used.
kind : class, optional
    The polynomial series type class to which the current instance
    should be converted. If kind is None, then the class of the
    current instance is used.
window : array_like, optional
    The window of the converted series. If the value is None,
    the default window of `kind` is used.

Returns
-------
new_series : series
    The returned class can be of different type than the current
    instance and/or have a different domain and/or different
    window.

Notes
-----
Conversion between domains and class types can result in
numerically ill defined series.

Examples
--------
*)

val copy : [> tag] Obj.t -> Py.Object.t
(**
Return a copy.

Returns
-------
new_series : series
    Copy of self.
*)

val cutdeg : deg:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to the given degree.

Reduce the degree of the series to `deg` by discarding the
high order terms. If `deg` is greater than the current degree a
copy of the current series is returned. This can be useful in least
squares where the coefficients of the high degree terms may be very
small.

.. versionadded:: 1.5.0

Parameters
----------
deg : non-negative int
    The series is reduced to degree `deg` by discarding the high
    order terms. The value of `deg` must be a non-negative integer.

Returns
-------
new_series : series
    New instance of series with reduced degree.
*)

val degree : [> tag] Obj.t -> int
(**
The degree of the series.

.. versionadded:: 1.5.0

Returns
-------
degree : int
    Degree of the series, one less than the number of coefficients.
*)

val deriv : ?m:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Differentiate.

Return a series instance of that is the derivative of the current
series.

Parameters
----------
m : non-negative int
    Find the derivative of order `m`.

Returns
-------
new_series : series
    A new series representing the derivative. The domain is the same
    as the domain of the differentiated series.
*)

val fit : ?domain:Py.Object.t -> ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> ?window:Py.Object.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Least squares fit to data.

Return a series instance that is the least squares fit to the data
`y` sampled at `x`. The domain of the returned instance can be
specified and this will often result in a superior fit with less
chance of ill conditioning.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
domain : {None, [beg, end], []}, optional
    Domain to use for the returned series. If ``None``,
    then a minimal domain that covers the points `x` is chosen.  If
    ``[]`` the class domain is used. The default value was the
    class domain in NumPy 1.4 and ``None`` in later versions.
    The ``[]`` option was added in numpy 1.5.0.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller
    than this relative to the largest singular value will be
    ignored. The default value is len(x)*eps, where eps is the
    relative precision of the float type, about 2e-16 in most
    cases.
full : bool, optional
    Switch determining nature of return value. When it is False
    (the default) just the coefficients are returned, when True
    diagnostic information from the singular value decomposition is
    also returned.
w : array_like, shape (M,), optional
    Weights. If not None the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products
    ``w[i]*y[i]`` all have the same variance.  The default value is
    None.

    .. versionadded:: 1.5.0
window : {[beg, end]}, optional
    Window to use for the returned series. The default
    value is the default class domain

    .. versionadded:: 1.6.0

Returns
-------
new_series : series
    A series that represents the least squares fit to the data and
    has the domain and window specified in the call. If the
    coefficients for the unscaled and unshifted basis polynomials are
    of interest, do ``new_series.convert().coef``.

[resid, rank, sv, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.
*)

val fromroots : ?domain:[`Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `None] -> ?window:[>`Ndarray] Obj.t -> roots:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return series instance that has the specified roots.

Returns a series representing the product
``(x - r[0])*(x - r[1])*...*(x - r[n-1])``, where ``r`` is a
list of roots.

Parameters
----------
roots : array_like
    List of roots.
domain : {[], None, array_like}, optional
    Domain for the resulting series. If None the domain is the
    interval from the smallest root to the largest. If [] the
    domain is the class domain. The default is [].
window : {None, array_like}, optional
    Window for the returned series. If None the class window is
    used. The default is None.

Returns
-------
new_series : series
    Series with the specified roots.
*)

val has_samecoef : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if coefficients match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``coef`` attribute.

Returns
-------
bool : boolean
    True if the coefficients are the same, False otherwise.
*)

val has_samedomain : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if domains match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``domain`` attribute.

Returns
-------
bool : boolean
    True if the domains are the same, False otherwise.
*)

val has_sametype : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if types match.

.. versionadded:: 1.7.0

Parameters
----------
other : object
    Class instance.

Returns
-------
bool : boolean
    True if other is same class as self
*)

val has_samewindow : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if windows match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``window`` attribute.

Returns
-------
bool : boolean
    True if the windows are the same, False otherwise.
*)

val identity : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Identity function.

If ``p`` is the returned series, then ``p(x) == x`` for all
values of x.

Parameters
----------
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
     Series of representing the identity.
*)

val integ : ?m:Py.Object.t -> ?k:[>`Ndarray] Obj.t -> ?lbnd:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Integrate.

Return a series instance that is the definite integral of the
current series.

Parameters
----------
m : non-negative int
    The number of integrations to perform.
k : array_like
    Integration constants. The first constant is applied to the
    first integration, the second to the second, and so on. The
    list of values must less than or equal to `m` in length and any
    missing values are set to zero.
lbnd : Scalar
    The lower bound of the definite integral.

Returns
-------
new_series : series
    A new series representing the integral. The domain is the same
    as the domain of the integrated series.
*)

val linspace : ?n:int -> ?domain:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return x, y values at equally spaced points in domain.

Returns the x, y values at `n` linearly spaced points across the
domain.  Here y is the value of the polynomial at the points x. By
default the domain is the same as that of the series instance.
This method is intended mostly as a plotting aid.

.. versionadded:: 1.5.0

Parameters
----------
n : int, optional
    Number of point pairs to return. The default value is 100.
domain : {None, array_like}, optional
    If not None, the specified domain is used instead of that of
    the calling instance. It should be of the form ``[beg,end]``.
    The default is None which case the class domain is used.

Returns
-------
x, y : ndarray
    x is equal to linspace(self.domain[0], self.domain[1], n) and
    y is the series evaluated at element of x.
*)

val mapparms : [> tag] Obj.t -> Py.Object.t
(**
Return the mapping parameters.

The returned values define a linear map ``off + scl*x`` that is
applied to the input arguments before the series is evaluated. The
map depends on the ``domain`` and ``window``; if the current
``domain`` is equal to the ``window`` the resulting map is the
identity.  If the coefficients of the series instance are to be
used by themselves outside this class, then the linear function
must be substituted for the ``x`` in the standard representation of
the base polynomials.

Returns
-------
off, scl : float or complex
    The mapping function is defined by ``off + scl*x``.

Notes
-----
If the current domain is the interval ``[l1, r1]`` and the window
is ``[l2, r2]``, then the linear mapping function ``L`` is
defined by the equations::

    L(l1) = l2
    L(r1) = r2
*)

val roots : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the roots of the series polynomial.

Compute the roots for the series. Note that the accuracy of the
roots decrease the further outside the domain they lie.

Returns
-------
roots : ndarray
    Array containing the roots of the series.
*)

val trim : ?tol:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Remove trailing coefficients

Remove trailing coefficients until a coefficient is reached whose
absolute value greater than `tol` or the beginning of the series is
reached. If all the coefficients would be removed the series is set
to ``[0]``. A new series instance is returned with the new
coefficients.  The current instance remains unchanged.

Parameters
----------
tol : non-negative number.
    All trailing coefficients less than `tol` will be removed.

Returns
-------
new_series : series
    Contains the new set of coefficients.
*)

val truncate : size:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to length `size`.

Reduce the series to length `size` by discarding the high
degree terms. The value of `size` must be a positive integer. This
can be useful in least squares where the coefficients of the
high degree terms may be very small.

Parameters
----------
size : positive int
    The series is reduced to length `size` by discarding the high
    degree terms. The value of `size` must be a positive integer.

Returns
-------
new_series : series
    New instance of series with truncated coefficients.
*)


(** Attribute coef: get value or raise Not_found if None.*)
val coef : t -> [`ArrayLike|`Ndarray|`Object] Obj.t

(** Attribute coef: get value as an option. *)
val coef_opt : t -> ([`ArrayLike|`Ndarray|`Object] Obj.t) option


(** Attribute domain: get value or raise Not_found if None.*)
val domain : t -> Py.Object.t

(** Attribute domain: get value as an option. *)
val domain_opt : t -> (Py.Object.t) option


(** Attribute window: get value or raise Not_found if None.*)
val window : t -> Py.Object.t

(** Attribute window: get value as an option. *)
val window_opt : t -> (Py.Object.t) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

val cheb2poly : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Convert a Chebyshev series to a polynomial.

Convert an array representing the coefficients of a Chebyshev series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the 'standard' basis) ordered
from lowest to highest degree.

Parameters
----------
c : array_like
    1-D array containing the Chebyshev series coefficients, ordered
    from lowest order term to highest.

Returns
-------
pol : ndarray
    1-D array containing the coefficients of the equivalent polynomial
    (relative to the 'standard' basis) ordered from lowest order term
    to highest.

See Also
--------
poly2cheb

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy import polynomial as P
>>> c = P.Chebyshev(range(4))
>>> c
Chebyshev([0., 1., 2., 3.], domain=[-1,  1], window=[-1,  1])
>>> p = c.convert(kind=P.Polynomial)
>>> p
Polynomial([-2., -8.,  4., 12.], domain=[-1.,  1.], window=[-1.,  1.])
>>> P.chebyshev.cheb2poly(range(4))
array([-2.,  -8.,   4.,  12.])
*)

val chebadd : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Add one Chebyshev series to another.

Returns the sum of two Chebyshev series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Chebyshev series of their sum.

See Also
--------
chebsub, chebmulx, chebmul, chebdiv, chebpow

Notes
-----
Unlike multiplication, division, etc., the sum of two Chebyshev series
is a Chebyshev series (without having to 'reproject' the result onto
the basis set) so addition, just like that of 'standard' polynomials,
is simply 'component-wise.'

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> C.chebadd(c1,c2)
array([4., 4., 4.])
*)

val chebcompanion : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the scaled companion matrix of c.

The basis polynomials are scaled so that the companion matrix is
symmetric when `c` is a Chebyshev basis polynomial. This provides
better eigenvalue estimates than the unscaled case and for basis
polynomials the eigenvalues are guaranteed to be real if
`numpy.linalg.eigvalsh` is used to obtain them.

Parameters
----------
c : array_like
    1-D array of Chebyshev series coefficients ordered from low to high
    degree.

Returns
-------
mat : ndarray
    Scaled companion matrix of dimensions (deg, deg).

Notes
-----

.. versionadded:: 1.7.0
*)

val chebder : ?m:int -> ?scl:[`F of float | `I of int | `Bool of bool | `S of string] -> ?axis:int -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Differentiate a Chebyshev series.

Returns the Chebyshev series coefficients `c` differentiated `m` times
along `axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable). The argument
`c` is an array of coefficients from low to high degree along each
axis, e.g., [1,2,3] represents the series ``1*T_0 + 2*T_1 + 3*T_2``
while [[1,2],[1,2]] represents ``1*T_0(x)*T_0(y) + 1*T_1(x)*T_0(y) +
2*T_0(x)*T_1(y) + 2*T_1(x)*T_1(y)`` if axis=0 is ``x`` and axis=1 is
``y``.

Parameters
----------
c : array_like
    Array of Chebyshev series coefficients. If c is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change of
    variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Chebyshev series of the derivative.

See Also
--------
chebint

Notes
-----
In general, the result of differentiating a C-series needs to be
'reprojected' onto the C-series basis set. Thus, typically, the
result of this function is 'unintuitive,' albeit correct; see Examples
section below.

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> c = (1,2,3,4)
>>> C.chebder(c)
array([14., 12., 24.])
>>> C.chebder(c,3)
array([96.])
>>> C.chebder(c,scl=-1)
array([-14., -12., -24.])
>>> C.chebder(c,2,-1)
array([12.,  96.])
*)

val chebdiv : c1:Py.Object.t -> c2:Py.Object.t -> unit -> Py.Object.t
(**
Divide one Chebyshev series by another.

Returns the quotient-with-remainder of two Chebyshev series
`c1` / `c2`.  The arguments are sequences of coefficients from lowest
order 'term' to highest, e.g., [1,2,3] represents the series
``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
[quo, rem] : ndarrays
    Of Chebyshev series coefficients representing the quotient and
    remainder.

See Also
--------
chebadd, chebsub, chemulx, chebmul, chebpow

Notes
-----
In general, the (polynomial) division of one C-series by another
results in quotient and remainder terms that are not in the Chebyshev
polynomial basis set.  Thus, to express these results as C-series, it
is typically necessary to 'reproject' the results onto said basis
set, which typically produces 'unintuitive' (but correct) results;
see Examples section below.

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> C.chebdiv(c1,c2) # quotient 'intuitive,' remainder not
(array([3.]), array([-8., -4.]))
>>> c2 = (0,1,2,3)
>>> C.chebdiv(c2,c1) # neither 'intuitive'
(array([0., 2.]), array([-2., -4.]))
*)

val chebfit : ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Least squares fit of Chebyshev series to data.

Return the coefficients of a Chebyshev series of degree `deg` that is the
least squares fit to the data values `y` given at points `x`. If `y` is
1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * T_1(x) + ... + c_n * T_n(x),

where `n` is `deg`.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer,
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.

    .. versionadded:: 1.5.0

Returns
-------
coef : ndarray, shape (M,) or (M, K)
    Chebyshev coefficients ordered from low to high. If `y` was 2-D,
    the coefficients for the data in column k  of `y` are in column
    `k`.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.  The
    warnings can be turned off by

    >>> import warnings
    >>> warnings.simplefilter('ignore', np.RankWarning)

See Also
--------
polyfit, legfit, lagfit, hermfit, hermefit
chebval : Evaluates a Chebyshev series.
chebvander : Vandermonde matrix of Chebyshev series.
chebweight : Chebyshev weight function.
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the Chebyshev series `p` that
minimizes the sum of the weighted squared errors

.. math:: E = \sum_j w_j^2 * |y_j - p(x_j)|^2,

where :math:`w_j` are the weights. This problem is solved by setting up
as the (typically) overdetermined matrix equation

.. math:: V(x) * c = w * y,

where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
coefficients to be solved for, `w` are the weights, and `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected, then a `RankWarning` will be issued. This means that the
coefficient values may be poorly determined. Using a lower order fit
will usually get rid of the warning.  The `rcond` parameter can also be
set to a value smaller than its default, but the resulting fit may be
spurious and have large contributions from roundoff error.

Fits using Chebyshev series are usually better conditioned than fits
using power series, but much can depend on the distribution of the
sample points and the smoothness of the data. If the quality of the fit
is inadequate splines may be a good alternative.

References
----------
.. [1] Wikipedia, 'Curve fitting',
       https://en.wikipedia.org/wiki/Curve_fitting

Examples
--------
*)

val chebfromroots : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Generate a Chebyshev series with given roots.

The function returns the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

in Chebyshev form, where the `r_n` are the roots specified in `roots`.
If a zero has multiplicity n, then it must appear in `roots` n times.
For instance, if 2 is a root of multiplicity three and 3 is a root of
multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
roots can appear in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * T_1(x) + ... +  c_n * T_n(x)

The coefficient of the last term is not generally 1 for monic
polynomials in Chebyshev form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of coefficients.  If all roots are real then `out` is a
    real array, if some of the roots are complex, then `out` is complex
    even if all the coefficients in the result are real (see Examples
    below).

See Also
--------
polyfromroots, legfromroots, lagfromroots, hermfromroots, hermefromroots

Examples
--------
>>> import numpy.polynomial.chebyshev as C
>>> C.chebfromroots((-1,0,1)) # x^3 - x relative to the standard basis
array([ 0.  , -0.25,  0.  ,  0.25])
>>> j = complex(0,1)
>>> C.chebfromroots((-j,j)) # x^2 + 1 relative to the standard basis
array([1.5+0.j, 0. +0.j, 0.5+0.j])
*)

val chebgauss : int -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Gauss-Chebyshev quadrature.

Computes the sample points and weights for Gauss-Chebyshev quadrature.
These sample points and weights will correctly integrate polynomials of
degree :math:`2*deg - 1` or less over the interval :math:`[-1, 1]` with
the weight function :math:`f(x) = 1/\sqrt{1 - x^2}`.

Parameters
----------
deg : int
    Number of sample points and weights. It must be >= 1.

Returns
-------
x : ndarray
    1-D ndarray containing the sample points.
y : ndarray
    1-D ndarray containing the weights.

Notes
-----

.. versionadded:: 1.7.0

The results have only been tested up to degree 100, higher degrees may
be problematic. For Gauss-Chebyshev there are closed form solutions for
the sample points and weights. If n = `deg`, then

.. math:: x_i = \cos(\pi (2 i - 1) / (2 n))

.. math:: w_i = \pi / n
*)

val chebgrid2d : y:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \sum_{i,j} c_{i,j} * T_i(a) * T_j(b),

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape + y.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j is contained in `c[i,j]`. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional Chebyshev series at points in the
    Cartesian product of `x` and `y`.

See Also
--------
chebval, chebval2d, chebval3d, chebgrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val chebgrid3d : y:Py.Object.t -> z:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.

This function returns the values:

.. math:: p(a,b,c) = \sum_{i,j,k} c_{i,j,k} * T_i(a) * T_j(b) * T_k(c)

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
chebval, chebval2d, chebgrid2d, chebval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val chebint : ?m:int -> ?k:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `Bool of bool | `F of float | `S of string] -> ?lbnd:[`F of float | `I of int | `Bool of bool | `S of string] -> ?scl:[`F of float | `I of int | `Bool of bool | `S of string] -> ?axis:int -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Integrate a Chebyshev series.

Returns the Chebyshev series coefficients `c` integrated `m` times from
`lbnd` along `axis`. At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ('Buyer
beware': note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.)  The argument `c` is an array of
coefficients from low to high degree along each axis, e.g., [1,2,3]
represents the series ``T_0 + 2*T_1 + 3*T_2`` while [[1,2],[1,2]]
represents ``1*T_0(x)*T_0(y) + 1*T_1(x)*T_0(y) + 2*T_0(x)*T_1(y) +
2*T_1(x)*T_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.

Parameters
----------
c : array_like
    Array of Chebyshev series coefficients. If c is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at zero
    is the first value in the list, the value of the second integral
    at zero is the second value, etc.  If ``k == []`` (the default),
    all constants are set to zero.  If ``m == 1``, a single scalar can
    be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    C-series coefficients of the integral.

Raises
------
ValueError
    If ``m < 1``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or
    ``np.ndim(scl) != 0``.

See Also
--------
chebder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.
Why is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`.  Then
:math:`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a`- perhaps not what one would have first thought.

Also note that, in general, the result of integrating a C-series needs
to be 'reprojected' onto the C-series basis set.  Thus, typically,
the result of this function is 'unintuitive,' albeit correct; see
Examples section below.

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> c = (1,2,3)
>>> C.chebint(c)
array([ 0.5, -0.5,  0.5,  0.5])
>>> C.chebint(c,3)
array([ 0.03125   , -0.1875    ,  0.04166667, -0.05208333,  0.01041667, # may vary
    0.00625   ])
>>> C.chebint(c, k=3)
array([ 3.5, -0.5,  0.5,  0.5])
>>> C.chebint(c,lbnd=-2)
array([ 8.5, -0.5,  0.5,  0.5])
>>> C.chebint(c,scl=-2)
array([-1.,  1., -1., -1.])
*)

val chebinterpolate : ?args:Py.Object.t -> func:Py.Object.t -> deg:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Interpolate a function at the Chebyshev points of the first kind.

Returns the Chebyshev series that interpolates `func` at the Chebyshev
points of the first kind in the interval [-1, 1]. The interpolating
series tends to a minmax approximation to `func` with increasing `deg`
if the function is continuous in the interval.

.. versionadded:: 1.14.0

Parameters
----------
func : function
    The function to be approximated. It must be a function of a single
    variable of the form ``f(x, a, b, c...)``, where ``a, b, c...`` are
    extra arguments passed in the `args` parameter.
deg : int
    Degree of the interpolating polynomial
args : tuple, optional
    Extra arguments to be used in the function call. Default is no extra
    arguments.

Returns
-------
coef : ndarray, shape (deg + 1,)
    Chebyshev coefficients of the interpolating series ordered from low to
    high.

Examples
--------
>>> import numpy.polynomial.chebyshev as C
>>> C.chebfromfunction(lambda x: np.tanh(x) + 0.5, 8)
array([  5.00000000e-01,   8.11675684e-01,  -9.86864911e-17,
        -5.42457905e-02,  -2.71387850e-16,   4.51658839e-03,
         2.46716228e-17,  -3.79694221e-04,  -3.26899002e-16])

Notes
-----

The Chebyshev polynomials used in the interpolation are orthogonal when
sampled at the Chebyshev points of the first kind. If it is desired to
constrain some of the coefficients they can simply be set to the desired
value after the interpolation, no new interpolation or fit is needed. This
is especially useful if it is known apriori that some of coefficients are
zero. For instance, if the function is even then the coefficients of the
terms of odd degree in the result can be set to zero.
*)

val chebline : off:Py.Object.t -> scl:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Chebyshev series whose graph is a straight line.



Parameters
----------
off, scl : scalars
    The specified line is given by ``off + scl*x``.

Returns
-------
y : ndarray
    This module's representation of the Chebyshev series for
    ``off + scl*x``.

See Also
--------
polyline

Examples
--------
>>> import numpy.polynomial.chebyshev as C
>>> C.chebline(3,2)
array([3, 2])
>>> C.chebval(-3, C.chebline(3,2)) # should be -3
-3.0
*)

val chebmul : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Multiply one Chebyshev series by another.

Returns the product of two Chebyshev series `c1` * `c2`.  The arguments
are sequences of coefficients, from lowest order 'term' to highest,
e.g., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Chebyshev series coefficients representing their product.

See Also
--------
chebadd, chebsub, chebmulx, chebdiv, chebpow

Notes
-----
In general, the (polynomial) product of two C-series results in terms
that are not in the Chebyshev polynomial basis set.  Thus, to express
the product as a C-series, it is typically necessary to 'reproject'
the product onto said basis set, which typically produces
'unintuitive live' (but correct) results; see Examples section below.

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> C.chebmul(c1,c2) # multiplication requires 'reprojection'
array([  6.5,  12. ,  12. ,   4. ,   1.5])
*)

val chebmulx : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Multiply a Chebyshev series by x.

Multiply the polynomial `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

Notes
-----

.. versionadded:: 1.5.0

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> C.chebmulx([1,2,3])
array([1. , 2.5, 1. , 1.5])
*)

val chebpow : ?maxpower:int -> c:[>`Ndarray] Obj.t -> pow:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Raise a Chebyshev series to a power.

Returns the Chebyshev series `c` raised to the power `pow`. The
argument `c` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``T_0 + 2*T_1 + 3*T_2.``

Parameters
----------
c : array_like
    1-D array of Chebyshev series coefficients ordered from low to
    high.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Chebyshev series of power.

See Also
--------
chebadd, chebsub, chebmulx, chebmul, chebdiv

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> C.chebpow([1, 2, 3, 4], 2)
array([15.5, 22. , 16. , ..., 12.5, 12. ,  8. ])
*)

val chebpts1 : int -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Chebyshev points of the first kind.

The Chebyshev points of the first kind are the points ``cos(x)``,
where ``x = [pi*(k + .5)/npts for k in range(npts)]``.

Parameters
----------
npts : int
    Number of sample points desired.

Returns
-------
pts : ndarray
    The Chebyshev points of the first kind.

See Also
--------
chebpts2

Notes
-----

.. versionadded:: 1.5.0
*)

val chebpts2 : int -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Chebyshev points of the second kind.

The Chebyshev points of the second kind are the points ``cos(x)``,
where ``x = [pi*k/(npts - 1) for k in range(npts)]``.

Parameters
----------
npts : int
    Number of sample points desired.

Returns
-------
pts : ndarray
    The Chebyshev points of the second kind.

Notes
-----

.. versionadded:: 1.5.0
*)

val chebroots : Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the roots of a Chebyshev series.

Return the roots (a.k.a. 'zeros') of the polynomial

.. math:: p(x) = \sum_i c[i] * T_i(x).

Parameters
----------
c : 1-D array_like
    1-D array of coefficients.

Returns
-------
out : ndarray
    Array of the roots of the series. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
polyroots, legroots, lagroots, hermroots, hermeroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the series for such
values. Roots with multiplicity greater than 1 will also show larger
errors as the value of the series near such points is relatively
insensitive to errors in the roots. Isolated roots near the origin can
be improved by a few iterations of Newton's method.

The Chebyshev series basis polynomials aren't powers of `x` so the
results of this function may seem unintuitive.

Examples
--------
>>> import numpy.polynomial.chebyshev as cheb
>>> cheb.chebroots((-1, 1,-1, 1)) # T3 - T2 + T1 - T0 has real roots
array([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00]) # may vary
*)

val chebsub : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Subtract one Chebyshev series from another.

Returns the difference of two Chebyshev series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Chebyshev series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Chebyshev series coefficients representing their difference.

See Also
--------
chebadd, chebmulx, chebmul, chebdiv, chebpow

Notes
-----
Unlike multiplication, division, etc., the difference of two Chebyshev
series is a Chebyshev series (without having to 'reproject' the result
onto the basis set) so subtraction, just like that of 'standard'
polynomials, is simply 'component-wise.'

Examples
--------
>>> from numpy.polynomial import chebyshev as C
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> C.chebsub(c1,c2)
array([-2.,  0.,  2.])
>>> C.chebsub(c2,c1) # -C.chebsub(c1,c2)
array([ 2.,  0., -2.])
*)

val chebtrim : ?tol:[`F of float | `I of int] -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Remove 'small' 'trailing' coefficients from a polynomial.

'Small' means 'small in absolute value' and is controlled by the
parameter `tol`; 'trailing' means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be 'trimmed.'

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` < 0

See Also
--------
trimseq

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> pu.trimcoef((0,0,3,0,5,0,0))
array([0.,  0.,  3.,  0.,  5.])
>>> pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([0.])
>>> i = complex(0,1) # works for complex
>>> pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([0.0003+0.j   , 0.001 -0.001j])
*)

val chebval : ?tensor:bool -> c:[>`Ndarray] Obj.t -> [`Compatible_object of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
Evaluate a Chebyshev series at points x.

If `c` is of length `n + 1`, this function returns the value:

.. math:: p(x) = c_0 * T_0(x) + c_1 * T_1(x) + ... + c_n * T_n(x)

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, algebra_like
    The shape of the return value is described above.

See Also
--------
chebval2d, chebgrid2d, chebval3d, chebgrid3d

Notes
-----
The evaluation uses Clenshaw recursion, aka synthetic division.

Examples
--------
*)

val chebval2d : y:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 2-D Chebyshev series at points (x, y).

This function returns the values:

.. math:: p(x,y) = \sum_{i,j} c_{i,j} * T_i(x) * T_j(y)

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` is a 1-D array a one is implicitly appended to its shape to make
it 2-D. The shape of the result will be c.shape[2:] + x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and if it isn't an ndarray it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in ``c[i,j]``. If `c` has
    dimension greater than 2 the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional Chebyshev series at points formed
    from pairs of corresponding values from `x` and `y`.

See Also
--------
chebval, chebgrid2d, chebval3d, chebgrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val chebval3d : y:Py.Object.t -> z:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 3-D Chebyshev series at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \sum_{i,j,k} c_{i,j,k} * T_i(x) * T_j(y) * T_k(z)

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimensional polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
chebval, chebval2d, chebgrid2d, chebgrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val chebvander : deg:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degree.

Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
`x`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., i] = T_i(x),

where `0 <= i <= deg`. The leading indices of `V` index the elements of
`x` and the last index is the degree of the Chebyshev polynomial.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
matrix ``V = chebvander(x, n)``, then ``np.dot(V, c)`` and
``chebval(x, c)`` are the same up to roundoff.  This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of Chebyshev series of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray
    The pseudo Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where The last index is the degree of the
    corresponding Chebyshev polynomial.  The dtype will be the same as
    the converted `x`.
*)

val chebvander2d : y:Py.Object.t -> deg:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (deg[1] + 1)*i + j] = T_i(x) * T_j(y),

where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the degrees of
the Chebyshev polynomials.

If ``V = chebvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``chebval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D Chebyshev
series of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to
    1-D arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
chebvander, chebvander3d, chebval2d, chebval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val chebvander3d : y:Py.Object.t -> z:Py.Object.t -> deg:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = T_i(x)*T_j(y)*T_k(z),

where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the degrees of the Chebyshev polynomials.

If ``V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and ``np.dot(V, c.flat)`` and ``chebval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D Chebyshev
series of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
chebvander, chebvander3d, chebval2d, chebval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val chebweight : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
The weight function of the Chebyshev polynomials.

The weight function is :math:`1/\sqrt{1 - x^2}` and the interval of
integration is :math:`[-1, 1]`. The Chebyshev polynomials are
orthogonal, but not normalized, with respect to this weight function.

Parameters
----------
x : array_like
   Values at which the weight function will be computed.

Returns
-------
w : ndarray
   The weight function at `x`.

Notes
-----

.. versionadded:: 1.7.0
*)

val normalize_axis_index : ?msg_prefix:string -> axis:int -> ndim:int -> unit -> int
(**
normalize_axis_index(axis, ndim, msg_prefix=None)

Normalizes an axis index, `axis`, such that is a valid positive index into
the shape of array with `ndim` dimensions. Raises an AxisError with an
appropriate message if this is not possible.

Used internally by all axis-checking logic.

.. versionadded:: 1.13.0

Parameters
----------
axis : int
    The un-normalized index of the axis. Can be negative
ndim : int
    The number of dimensions of the array that `axis` should be normalized
    against
msg_prefix : str
    A prefix to put before the message, typically the name of the argument

Returns
-------
normalized_axis : int
    The normalized axis index, such that `0 <= normalized_axis < ndim`

Raises
------
AxisError
    If the axis index is invalid, when `-ndim <= axis < ndim` is false.

Examples
--------
>>> normalize_axis_index(0, ndim=3)
0
>>> normalize_axis_index(1, ndim=3)
1
>>> normalize_axis_index(-1, ndim=3)
2

>>> normalize_axis_index(3, ndim=3)
Traceback (most recent call last):
...
AxisError: axis 3 is out of bounds for array of dimension 3
>>> normalize_axis_index(-4, ndim=3, msg_prefix='axes_arg')
Traceback (most recent call last):
...
AxisError: axes_arg: axis -4 is out of bounds for array of dimension 3
*)

val poly2cheb : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Convert a polynomial to a Chebyshev series.

Convert an array representing the coefficients of a polynomial (relative
to the 'standard' basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Chebyshev series, ordered
from lowest to highest degree.

Parameters
----------
pol : array_like
    1-D array containing the polynomial coefficients

Returns
-------
c : ndarray
    1-D array containing the coefficients of the equivalent Chebyshev
    series.

See Also
--------
cheb2poly

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy import polynomial as P
>>> p = P.Polynomial(range(4))
>>> p
Polynomial([0., 1., 2., 3.], domain=[-1,  1], window=[-1,  1])
>>> c = p.convert(kind=P.Chebyshev)
>>> c
Chebyshev([1.  , 3.25, 1.  , 0.75], domain=[-1.,  1.], window=[-1.,  1.])
>>> P.chebyshev.poly2cheb(range(4))
array([1.  , 3.25, 1.  , 0.75])
*)


end

module Hermite' : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

module ABCPolyBase : sig
type tag = [`ABCPolyBase]
type t = [`ABCPolyBase | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val __iter__ : [> tag] Obj.t -> Py.Object.t
(**
None
*)

val basis : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> deg:int -> [> tag] Obj.t -> Py.Object.t
(**
Series basis polynomial of degree `deg`.

Returns the series representing the basis polynomial of degree `deg`.

.. versionadded:: 1.7.0

Parameters
----------
deg : int
    Degree of the basis polynomial for the series. Must be >= 0.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series with the coefficient of the `deg` term set to one and
    all others zero.
*)

val cast : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> series:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to series of this class.

The `series` is expected to be an instance of some polynomial
series of one of the types supported by by the numpy.polynomial
module, but could be some other class that supports the convert
method.

.. versionadded:: 1.7.0

Parameters
----------
series : series
    The series instance to be converted.
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
    A series of the same kind as the calling class and equal to
    `series` when evaluated.

See Also
--------
convert : similar instance method
*)

val convert : ?domain:[>`Ndarray] Obj.t -> ?kind:Py.Object.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Convert series to a different kind and/or domain and/or window.

Parameters
----------
domain : array_like, optional
    The domain of the converted series. If the value is None,
    the default domain of `kind` is used.
kind : class, optional
    The polynomial series type class to which the current instance
    should be converted. If kind is None, then the class of the
    current instance is used.
window : array_like, optional
    The window of the converted series. If the value is None,
    the default window of `kind` is used.

Returns
-------
new_series : series
    The returned class can be of different type than the current
    instance and/or have a different domain and/or different
    window.

Notes
-----
Conversion between domains and class types can result in
numerically ill defined series.

Examples
--------
*)

val copy : [> tag] Obj.t -> Py.Object.t
(**
Return a copy.

Returns
-------
new_series : series
    Copy of self.
*)

val cutdeg : deg:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to the given degree.

Reduce the degree of the series to `deg` by discarding the
high order terms. If `deg` is greater than the current degree a
copy of the current series is returned. This can be useful in least
squares where the coefficients of the high degree terms may be very
small.

.. versionadded:: 1.5.0

Parameters
----------
deg : non-negative int
    The series is reduced to degree `deg` by discarding the high
    order terms. The value of `deg` must be a non-negative integer.

Returns
-------
new_series : series
    New instance of series with reduced degree.
*)

val degree : [> tag] Obj.t -> int
(**
The degree of the series.

.. versionadded:: 1.5.0

Returns
-------
degree : int
    Degree of the series, one less than the number of coefficients.
*)

val deriv : ?m:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Differentiate.

Return a series instance of that is the derivative of the current
series.

Parameters
----------
m : non-negative int
    Find the derivative of order `m`.

Returns
-------
new_series : series
    A new series representing the derivative. The domain is the same
    as the domain of the differentiated series.
*)

val fit : ?domain:Py.Object.t -> ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> ?window:Py.Object.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Least squares fit to data.

Return a series instance that is the least squares fit to the data
`y` sampled at `x`. The domain of the returned instance can be
specified and this will often result in a superior fit with less
chance of ill conditioning.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
domain : {None, [beg, end], []}, optional
    Domain to use for the returned series. If ``None``,
    then a minimal domain that covers the points `x` is chosen.  If
    ``[]`` the class domain is used. The default value was the
    class domain in NumPy 1.4 and ``None`` in later versions.
    The ``[]`` option was added in numpy 1.5.0.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller
    than this relative to the largest singular value will be
    ignored. The default value is len(x)*eps, where eps is the
    relative precision of the float type, about 2e-16 in most
    cases.
full : bool, optional
    Switch determining nature of return value. When it is False
    (the default) just the coefficients are returned, when True
    diagnostic information from the singular value decomposition is
    also returned.
w : array_like, shape (M,), optional
    Weights. If not None the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products
    ``w[i]*y[i]`` all have the same variance.  The default value is
    None.

    .. versionadded:: 1.5.0
window : {[beg, end]}, optional
    Window to use for the returned series. The default
    value is the default class domain

    .. versionadded:: 1.6.0

Returns
-------
new_series : series
    A series that represents the least squares fit to the data and
    has the domain and window specified in the call. If the
    coefficients for the unscaled and unshifted basis polynomials are
    of interest, do ``new_series.convert().coef``.

[resid, rank, sv, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.
*)

val fromroots : ?domain:[`Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `None] -> ?window:[>`Ndarray] Obj.t -> roots:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return series instance that has the specified roots.

Returns a series representing the product
``(x - r[0])*(x - r[1])*...*(x - r[n-1])``, where ``r`` is a
list of roots.

Parameters
----------
roots : array_like
    List of roots.
domain : {[], None, array_like}, optional
    Domain for the resulting series. If None the domain is the
    interval from the smallest root to the largest. If [] the
    domain is the class domain. The default is [].
window : {None, array_like}, optional
    Window for the returned series. If None the class window is
    used. The default is None.

Returns
-------
new_series : series
    Series with the specified roots.
*)

val has_samecoef : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if coefficients match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``coef`` attribute.

Returns
-------
bool : boolean
    True if the coefficients are the same, False otherwise.
*)

val has_samedomain : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if domains match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``domain`` attribute.

Returns
-------
bool : boolean
    True if the domains are the same, False otherwise.
*)

val has_sametype : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if types match.

.. versionadded:: 1.7.0

Parameters
----------
other : object
    Class instance.

Returns
-------
bool : boolean
    True if other is same class as self
*)

val has_samewindow : other:Py.Object.t -> [> tag] Obj.t -> bool
(**
Check if windows match.

.. versionadded:: 1.6.0

Parameters
----------
other : class instance
    The other class must have the ``window`` attribute.

Returns
-------
bool : boolean
    True if the windows are the same, False otherwise.
*)

val identity : ?domain:[>`Ndarray] Obj.t -> ?window:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Identity function.

If ``p`` is the returned series, then ``p(x) == x`` for all
values of x.

Parameters
----------
domain : {None, array_like}, optional
    If given, the array must be of the form ``[beg, end]``, where
    ``beg`` and ``end`` are the endpoints of the domain. If None is
    given then the class domain is used. The default is None.
window : {None, array_like}, optional
    If given, the resulting array must be if the form
    ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of
    the window. If None is given then the class window is used. The
    default is None.

Returns
-------
new_series : series
     Series of representing the identity.
*)

val integ : ?m:Py.Object.t -> ?k:[>`Ndarray] Obj.t -> ?lbnd:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Integrate.

Return a series instance that is the definite integral of the
current series.

Parameters
----------
m : non-negative int
    The number of integrations to perform.
k : array_like
    Integration constants. The first constant is applied to the
    first integration, the second to the second, and so on. The
    list of values must less than or equal to `m` in length and any
    missing values are set to zero.
lbnd : Scalar
    The lower bound of the definite integral.

Returns
-------
new_series : series
    A new series representing the integral. The domain is the same
    as the domain of the integrated series.
*)

val linspace : ?n:int -> ?domain:[>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
Return x, y values at equally spaced points in domain.

Returns the x, y values at `n` linearly spaced points across the
domain.  Here y is the value of the polynomial at the points x. By
default the domain is the same as that of the series instance.
This method is intended mostly as a plotting aid.

.. versionadded:: 1.5.0

Parameters
----------
n : int, optional
    Number of point pairs to return. The default value is 100.
domain : {None, array_like}, optional
    If not None, the specified domain is used instead of that of
    the calling instance. It should be of the form ``[beg,end]``.
    The default is None which case the class domain is used.

Returns
-------
x, y : ndarray
    x is equal to linspace(self.domain[0], self.domain[1], n) and
    y is the series evaluated at element of x.
*)

val mapparms : [> tag] Obj.t -> Py.Object.t
(**
Return the mapping parameters.

The returned values define a linear map ``off + scl*x`` that is
applied to the input arguments before the series is evaluated. The
map depends on the ``domain`` and ``window``; if the current
``domain`` is equal to the ``window`` the resulting map is the
identity.  If the coefficients of the series instance are to be
used by themselves outside this class, then the linear function
must be substituted for the ``x`` in the standard representation of
the base polynomials.

Returns
-------
off, scl : float or complex
    The mapping function is defined by ``off + scl*x``.

Notes
-----
If the current domain is the interval ``[l1, r1]`` and the window
is ``[l2, r2]``, then the linear mapping function ``L`` is
defined by the equations::

    L(l1) = l2
    L(r1) = r2
*)

val roots : [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the roots of the series polynomial.

Compute the roots for the series. Note that the accuracy of the
roots decrease the further outside the domain they lie.

Returns
-------
roots : ndarray
    Array containing the roots of the series.
*)

val trim : ?tol:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Remove trailing coefficients

Remove trailing coefficients until a coefficient is reached whose
absolute value greater than `tol` or the beginning of the series is
reached. If all the coefficients would be removed the series is set
to ``[0]``. A new series instance is returned with the new
coefficients.  The current instance remains unchanged.

Parameters
----------
tol : non-negative number.
    All trailing coefficients less than `tol` will be removed.

Returns
-------
new_series : series
    Contains the new set of coefficients.
*)

val truncate : size:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Truncate series to length `size`.

Reduce the series to length `size` by discarding the high
degree terms. The value of `size` must be a positive integer. This
can be useful in least squares where the coefficients of the
high degree terms may be very small.

Parameters
----------
size : positive int
    The series is reduced to length `size` by discarding the high
    degree terms. The value of `size` must be a positive integer.

Returns
-------
new_series : series
    New instance of series with truncated coefficients.
*)


(** Attribute coef: get value or raise Not_found if None.*)
val coef : t -> [`ArrayLike|`Ndarray|`Object] Obj.t

(** Attribute coef: get value as an option. *)
val coef_opt : t -> ([`ArrayLike|`Ndarray|`Object] Obj.t) option


(** Attribute domain: get value or raise Not_found if None.*)
val domain : t -> Py.Object.t

(** Attribute domain: get value as an option. *)
val domain_opt : t -> (Py.Object.t) option


(** Attribute window: get value or raise Not_found if None.*)
val window : t -> Py.Object.t

(** Attribute window: get value as an option. *)
val window_opt : t -> (Py.Object.t) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

val herm2poly : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Convert a Hermite series to a polynomial.

Convert an array representing the coefficients of a Hermite series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the 'standard' basis) ordered
from lowest to highest degree.

Parameters
----------
c : array_like
    1-D array containing the Hermite series coefficients, ordered
    from lowest order term to highest.

Returns
-------
pol : ndarray
    1-D array containing the coefficients of the equivalent polynomial
    (relative to the 'standard' basis) ordered from lowest order term
    to highest.

See Also
--------
poly2herm

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy.polynomial.hermite import herm2poly
>>> herm2poly([ 1.   ,  2.75 ,  0.5  ,  0.375])
array([0., 1., 2., 3.])
*)

val hermadd : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Add one Hermite series to another.

Returns the sum of two Hermite series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Hermite series of their sum.

See Also
--------
hermsub, hermmulx, hermmul, hermdiv, hermpow

Notes
-----
Unlike multiplication, division, etc., the sum of two Hermite series
is a Hermite series (without having to 'reproject' the result onto
the basis set) so addition, just like that of 'standard' polynomials,
is simply 'component-wise.'

Examples
--------
>>> from numpy.polynomial.hermite import hermadd
>>> hermadd([1, 2, 3], [1, 2, 3, 4])
array([2., 4., 6., 4.])
*)

val hermcompanion : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the scaled companion matrix of c.

The basis polynomials are scaled so that the companion matrix is
symmetric when `c` is an Hermite basis polynomial. This provides
better eigenvalue estimates than the unscaled case and for basis
polynomials the eigenvalues are guaranteed to be real if
`numpy.linalg.eigvalsh` is used to obtain them.

Parameters
----------
c : array_like
    1-D array of Hermite series coefficients ordered from low to high
    degree.

Returns
-------
mat : ndarray
    Scaled companion matrix of dimensions (deg, deg).

Notes
-----

.. versionadded:: 1.7.0
*)

val hermder : ?m:int -> ?scl:[`F of float | `I of int | `Bool of bool | `S of string] -> ?axis:int -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Differentiate a Hermite series.

Returns the Hermite series coefficients `c` differentiated `m` times
along `axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable). The argument
`c` is an array of coefficients from low to high degree along each
axis, e.g., [1,2,3] represents the series ``1*H_0 + 2*H_1 + 3*H_2``
while [[1,2],[1,2]] represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) +
2*H_0(x)*H_1(y) + 2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is
``y``.

Parameters
----------
c : array_like
    Array of Hermite series coefficients. If `c` is multidimensional the
    different axis correspond to different variables with the degree in
    each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change of
    variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Hermite series of the derivative.

See Also
--------
hermint

Notes
-----
In general, the result of differentiating a Hermite series does not
resemble the same operation on a power series. Thus the result of this
function may be 'unintuitive,' albeit correct; see Examples section
below.

Examples
--------
>>> from numpy.polynomial.hermite import hermder
>>> hermder([ 1. ,  0.5,  0.5,  0.5])
array([1., 2., 3.])
>>> hermder([-0.5,  1./2.,  1./8.,  1./12.,  1./16.], m=2)
array([1., 2., 3.])
*)

val hermdiv : c1:Py.Object.t -> c2:Py.Object.t -> unit -> Py.Object.t
(**
Divide one Hermite series by another.

Returns the quotient-with-remainder of two Hermite series
`c1` / `c2`.  The arguments are sequences of coefficients from lowest
order 'term' to highest, e.g., [1,2,3] represents the series
``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
[quo, rem] : ndarrays
    Of Hermite series coefficients representing the quotient and
    remainder.

See Also
--------
hermadd, hermsub, hermmulx, hermmul, hermpow

Notes
-----
In general, the (polynomial) division of one Hermite series by another
results in quotient and remainder terms that are not in the Hermite
polynomial basis set.  Thus, to express these results as a Hermite
series, it is necessary to 'reproject' the results onto the Hermite
basis set, which may produce 'unintuitive' (but correct) results; see
Examples section below.

Examples
--------
>>> from numpy.polynomial.hermite import hermdiv
>>> hermdiv([ 52.,  29.,  52.,   7.,   6.], [0, 1, 2])
(array([1., 2., 3.]), array([0.]))
>>> hermdiv([ 54.,  31.,  52.,   7.,   6.], [0, 1, 2])
(array([1., 2., 3.]), array([2., 2.]))
>>> hermdiv([ 53.,  30.,  52.,   7.,   6.], [0, 1, 2])
(array([1., 2., 3.]), array([1., 1.]))
*)

val hermfit : ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Least squares fit of Hermite series to data.

Return the coefficients of a Hermite series of degree `deg` that is the
least squares fit to the data values `y` given at points `x`. If `y` is
1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * H_1(x) + ... + c_n * H_n(x),

where `n` is `deg`.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.

Returns
-------
coef : ndarray, shape (M,) or (M, K)
    Hermite coefficients ordered from low to high. If `y` was 2-D,
    the coefficients for the data in column k  of `y` are in column
    `k`.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.  The
    warnings can be turned off by

    >>> import warnings
    >>> warnings.simplefilter('ignore', np.RankWarning)

See Also
--------
chebfit, legfit, lagfit, polyfit, hermefit
hermval : Evaluates a Hermite series.
hermvander : Vandermonde matrix of Hermite series.
hermweight : Hermite weight function
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the Hermite series `p` that
minimizes the sum of the weighted squared errors

.. math:: E = \sum_j w_j^2 * |y_j - p(x_j)|^2,

where the :math:`w_j` are the weights. This problem is solved by
setting up the (typically) overdetermined matrix equation

.. math:: V(x) * c = w * y,

where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
coefficients to be solved for, `w` are the weights, `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected, then a `RankWarning` will be issued. This means that the
coefficient values may be poorly determined. Using a lower order fit
will usually get rid of the warning.  The `rcond` parameter can also be
set to a value smaller than its default, but the resulting fit may be
spurious and have large contributions from roundoff error.

Fits using Hermite series are probably most useful when the data can be
approximated by ``sqrt(w(x)) * p(x)``, where `w(x)` is the Hermite
weight. In that case the weight ``sqrt(w(x[i])`` should be used
together with data values ``y[i]/sqrt(w(x[i])``. The weight function is
available as `hermweight`.

References
----------
.. [1] Wikipedia, 'Curve fitting',
       https://en.wikipedia.org/wiki/Curve_fitting

Examples
--------
>>> from numpy.polynomial.hermite import hermfit, hermval
>>> x = np.linspace(-10, 10)
>>> err = np.random.randn(len(x))/10
>>> y = hermval(x, [1, 2, 3]) + err
>>> hermfit(x, y, 2)
array([1.0218, 1.9986, 2.9999]) # may vary
*)

val hermfromroots : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Generate a Hermite series with given roots.

The function returns the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

in Hermite form, where the `r_n` are the roots specified in `roots`.
If a zero has multiplicity n, then it must appear in `roots` n times.
For instance, if 2 is a root of multiplicity three and 3 is a root of
multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
roots can appear in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * H_1(x) + ... +  c_n * H_n(x)

The coefficient of the last term is not generally 1 for monic
polynomials in Hermite form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of coefficients.  If all roots are real then `out` is a
    real array, if some of the roots are complex, then `out` is complex
    even if all the coefficients in the result are real (see Examples
    below).

See Also
--------
polyfromroots, legfromroots, lagfromroots, chebfromroots, hermefromroots

Examples
--------
>>> from numpy.polynomial.hermite import hermfromroots, hermval
>>> coef = hermfromroots((-1, 0, 1))
>>> hermval((-1, 0, 1), coef)
array([0.,  0.,  0.])
>>> coef = hermfromroots((-1j, 1j))
>>> hermval((-1j, 1j), coef)
array([0.+0.j, 0.+0.j])
*)

val hermgauss : int -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Gauss-Hermite quadrature.

Computes the sample points and weights for Gauss-Hermite quadrature.
These sample points and weights will correctly integrate polynomials of
degree :math:`2*deg - 1` or less over the interval :math:`[-\inf, \inf]`
with the weight function :math:`f(x) = \exp(-x^2)`.

Parameters
----------
deg : int
    Number of sample points and weights. It must be >= 1.

Returns
-------
x : ndarray
    1-D ndarray containing the sample points.
y : ndarray
    1-D ndarray containing the weights.

Notes
-----

.. versionadded:: 1.7.0

The results have only been tested up to degree 100, higher degrees may
be problematic. The weights are determined by using the fact that

.. math:: w_k = c / (H'_n(x_k) * H_{n-1}(x_k))

where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
is the k'th root of :math:`H_n`, and then scaling the results to get
the right value when integrating 1.
*)

val hermgrid2d : y:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 2-D Hermite series on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \sum_{i,j} c_{i,j} * H_i(a) * H_j(b)

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
hermval, hermval2d, hermval3d, hermgrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val hermgrid3d : y:Py.Object.t -> z:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.

This function returns the values:

.. math:: p(a,b,c) = \sum_{i,j,k} c_{i,j,k} * H_i(a) * H_j(b) * H_k(c)

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
hermval, hermval2d, hermgrid2d, hermval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val hermint : ?m:int -> ?k:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `Bool of bool | `F of float | `S of string] -> ?lbnd:[`F of float | `I of int | `Bool of bool | `S of string] -> ?scl:[`F of float | `I of int | `Bool of bool | `S of string] -> ?axis:int -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Integrate a Hermite series.

Returns the Hermite series coefficients `c` integrated `m` times from
`lbnd` along `axis`. At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ('Buyer
beware': note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.)  The argument `c` is an array of
coefficients from low to high degree along each axis, e.g., [1,2,3]
represents the series ``H_0 + 2*H_1 + 3*H_2`` while [[1,2],[1,2]]
represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +
2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.

Parameters
----------
c : array_like
    Array of Hermite series coefficients. If c is multidimensional the
    different axis correspond to different variables with the degree in
    each axis given by the corresponding index.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at
    ``lbnd`` is the first value in the list, the value of the second
    integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
    default), all constants are set to zero.  If ``m == 1``, a single
    scalar can be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    Hermite series coefficients of the integral.

Raises
------
ValueError
    If ``m < 0``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or
    ``np.ndim(scl) != 0``.

See Also
--------
hermder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.
Why is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`.  Then
:math:`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a` - perhaps not what one would have first thought.

Also note that, in general, the result of integrating a C-series needs
to be 'reprojected' onto the C-series basis set.  Thus, typically,
the result of this function is 'unintuitive,' albeit correct; see
Examples section below.

Examples
--------
>>> from numpy.polynomial.hermite import hermint
>>> hermint([1,2,3]) # integrate once, value 0 at 0.
array([1. , 0.5, 0.5, 0.5])
>>> hermint([1,2,3], m=2) # integrate twice, value & deriv 0 at 0
array([-0.5       ,  0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may vary
>>> hermint([1,2,3], k=1) # integrate once, value 1 at 0.
array([2. , 0.5, 0.5, 0.5])
>>> hermint([1,2,3], lbnd=-1) # integrate once, value 0 at -1
array([-2. ,  0.5,  0.5,  0.5])
>>> hermint([1,2,3], m=2, k=[1,2], lbnd=-1)
array([ 1.66666667, -0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may vary
*)

val hermline : off:Py.Object.t -> scl:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Hermite series whose graph is a straight line.



Parameters
----------
off, scl : scalars
    The specified line is given by ``off + scl*x``.

Returns
-------
y : ndarray
    This module's representation of the Hermite series for
    ``off + scl*x``.

See Also
--------
polyline, chebline

Examples
--------
>>> from numpy.polynomial.hermite import hermline, hermval
>>> hermval(0,hermline(3, 2))
3.0
>>> hermval(1,hermline(3, 2))
5.0
*)

val hermmul : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Multiply one Hermite series by another.

Returns the product of two Hermite series `c1` * `c2`.  The arguments
are sequences of coefficients, from lowest order 'term' to highest,
e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Hermite series coefficients representing their product.

See Also
--------
hermadd, hermsub, hermmulx, hermdiv, hermpow

Notes
-----
In general, the (polynomial) product of two C-series results in terms
that are not in the Hermite polynomial basis set.  Thus, to express
the product as a Hermite series, it is necessary to 'reproject' the
product onto said basis set, which may produce 'unintuitive' (but
correct) results; see Examples section below.

Examples
--------
>>> from numpy.polynomial.hermite import hermmul
>>> hermmul([1, 2, 3], [0, 1, 2])
array([52.,  29.,  52.,   7.,   6.])
*)

val hermmulx : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Multiply a Hermite series by x.

Multiply the Hermite series `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

See Also
--------
hermadd, hermsub, hermmul, hermdiv, hermpow

Notes
-----
The multiplication uses the recursion relationship for Hermite
polynomials in the form

.. math::

xP_i(x) = (P_{i + 1}(x)/2 + i*P_{i - 1}(x))

Examples
--------
>>> from numpy.polynomial.hermite import hermmulx
>>> hermmulx([1, 2, 3])
array([2. , 6.5, 1. , 1.5])
*)

val hermpow : ?maxpower:int -> c:[>`Ndarray] Obj.t -> pow:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Raise a Hermite series to a power.

Returns the Hermite series `c` raised to the power `pow`. The
argument `c` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``

Parameters
----------
c : array_like
    1-D array of Hermite series coefficients ordered from low to
    high.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Hermite series of power.

See Also
--------
hermadd, hermsub, hermmulx, hermmul, hermdiv

Examples
--------
>>> from numpy.polynomial.hermite import hermpow
>>> hermpow([1, 2, 3], 2)
array([81.,  52.,  82.,  12.,   9.])
*)

val hermroots : Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the roots of a Hermite series.

Return the roots (a.k.a. 'zeros') of the polynomial

.. math:: p(x) = \sum_i c[i] * H_i(x).

Parameters
----------
c : 1-D array_like
    1-D array of coefficients.

Returns
-------
out : ndarray
    Array of the roots of the series. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
polyroots, legroots, lagroots, chebroots, hermeroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the series for such
values. Roots with multiplicity greater than 1 will also show larger
errors as the value of the series near such points is relatively
insensitive to errors in the roots. Isolated roots near the origin can
be improved by a few iterations of Newton's method.

The Hermite series basis polynomials aren't powers of `x` so the
results of this function may seem unintuitive.

Examples
--------
>>> from numpy.polynomial.hermite import hermroots, hermfromroots
>>> coef = hermfromroots([-1, 0, 1])
>>> coef
array([0.   ,  0.25 ,  0.   ,  0.125])
>>> hermroots(coef)
array([-1.00000000e+00, -1.38777878e-17,  1.00000000e+00])
*)

val hermsub : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Subtract one Hermite series from another.

Returns the difference of two Hermite series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Hermite series coefficients representing their difference.

See Also
--------
hermadd, hermmulx, hermmul, hermdiv, hermpow

Notes
-----
Unlike multiplication, division, etc., the difference of two Hermite
series is a Hermite series (without having to 'reproject' the result
onto the basis set) so subtraction, just like that of 'standard'
polynomials, is simply 'component-wise.'

Examples
--------
>>> from numpy.polynomial.hermite import hermsub
>>> hermsub([1, 2, 3, 4], [1, 2, 3])
array([0.,  0.,  0.,  4.])
*)

val hermtrim : ?tol:[`F of float | `I of int] -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Remove 'small' 'trailing' coefficients from a polynomial.

'Small' means 'small in absolute value' and is controlled by the
parameter `tol`; 'trailing' means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be 'trimmed.'

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` < 0

See Also
--------
trimseq

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> pu.trimcoef((0,0,3,0,5,0,0))
array([0.,  0.,  3.,  0.,  5.])
>>> pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([0.])
>>> i = complex(0,1) # works for complex
>>> pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([0.0003+0.j   , 0.001 -0.001j])
*)

val hermval : ?tensor:bool -> c:[>`Ndarray] Obj.t -> [`Compatible_object of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
Evaluate an Hermite series at points x.

If `c` is of length `n + 1`, this function returns the value:

.. math:: p(x) = c_0 * H_0(x) + c_1 * H_1(x) + ... + c_n * H_n(x)

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, algebra_like
    The shape of the return value is described above.

See Also
--------
hermval2d, hermgrid2d, hermval3d, hermgrid3d

Notes
-----
The evaluation uses Clenshaw recursion, aka synthetic division.

Examples
--------
>>> from numpy.polynomial.hermite import hermval
>>> coef = [1,2,3]
>>> hermval(1, coef)
11.0
>>> hermval([[1,2],[3,4]], coef)
array([[ 11.,   51.],
       [115.,  203.]])
*)

val hermval2d : y:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 2-D Hermite series at points (x, y).

This function returns the values:

.. math:: p(x,y) = \sum_{i,j} c_{i,j} * H_i(x) * H_j(y)

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` is a 1-D array a one is implicitly appended to its shape to make
it 2-D. The shape of the result will be c.shape[2:] + x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and if it isn't an ndarray it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in ``c[i,j]``. If `c` has
    dimension greater than two the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points formed with
    pairs of corresponding values from `x` and `y`.

See Also
--------
hermval, hermgrid2d, hermval3d, hermgrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val hermval3d : y:Py.Object.t -> z:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 3-D Hermite series at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \sum_{i,j,k} c_{i,j,k} * H_i(x) * H_j(y) * H_k(z)

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimensional polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
hermval, hermval2d, hermgrid2d, hermgrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val hermvander : deg:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degree.

Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
`x`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., i] = H_i(x),

where `0 <= i <= deg`. The leading indices of `V` index the elements of
`x` and the last index is the degree of the Hermite polynomial.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
array ``V = hermvander(x, n)``, then ``np.dot(V, c)`` and
``hermval(x, c)`` are the same up to roundoff. This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of Hermite series of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray
    The pseudo-Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where The last index is the degree of the
    corresponding Hermite polynomial.  The dtype will be the same as
    the converted `x`.

Examples
--------
>>> from numpy.polynomial.hermite import hermvander
>>> x = np.array([-1, 0, 1])
>>> hermvander(x, 3)
array([[ 1., -2.,  2.,  4.],
       [ 1.,  0., -2., -0.],
       [ 1.,  2.,  2., -4.]])
*)

val hermvander2d : y:Py.Object.t -> deg:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (deg[1] + 1)*i + j] = H_i(x) * H_j(y),

where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the degrees of
the Hermite polynomials.

If ``V = hermvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``hermval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D Hermite
series of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
hermvander, hermvander3d, hermval2d, hermval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val hermvander3d : y:Py.Object.t -> z:Py.Object.t -> deg:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = H_i(x)*H_j(y)*H_k(z),

where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the degrees of the Hermite polynomials.

If ``V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and  ``np.dot(V, c.flat)`` and ``hermval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D Hermite
series of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
hermvander, hermvander3d, hermval2d, hermval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val hermweight : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Weight function of the Hermite polynomials.

The weight function is :math:`\exp(-x^2)` and the interval of
integration is :math:`[-\inf, \inf]`. the Hermite polynomials are
orthogonal, but not normalized, with respect to this weight function.

Parameters
----------
x : array_like
   Values at which the weight function will be computed.

Returns
-------
w : ndarray
   The weight function at `x`.

Notes
-----

.. versionadded:: 1.7.0
*)

val normalize_axis_index : ?msg_prefix:string -> axis:int -> ndim:int -> unit -> int
(**
normalize_axis_index(axis, ndim, msg_prefix=None)

Normalizes an axis index, `axis`, such that is a valid positive index into
the shape of array with `ndim` dimensions. Raises an AxisError with an
appropriate message if this is not possible.

Used internally by all axis-checking logic.

.. versionadded:: 1.13.0

Parameters
----------
axis : int
    The un-normalized index of the axis. Can be negative
ndim : int
    The number of dimensions of the array that `axis` should be normalized
    against
msg_prefix : str
    A prefix to put before the message, typically the name of the argument

Returns
-------
normalized_axis : int
    The normalized axis index, such that `0 <= normalized_axis < ndim`

Raises
------
AxisError
    If the axis index is invalid, when `-ndim <= axis < ndim` is false.

Examples
--------
>>> normalize_axis_index(0, ndim=3)
0
>>> normalize_axis_index(1, ndim=3)
1
>>> normalize_axis_index(-1, ndim=3)
2

>>> normalize_axis_index(3, ndim=3)
Traceback (most recent call last):
...
AxisError: axis 3 is out of bounds for array of dimension 3
>>> normalize_axis_index(-4, ndim=3, msg_prefix='axes_arg')
Traceback (most recent call last):
...
AxisError: axes_arg: axis -4 is out of bounds for array of dimension 3
*)

val poly2herm : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
poly2herm(pol)

Convert a polynomial to a Hermite series.

Convert an array representing the coefficients of a polynomial (relative
to the 'standard' basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Hermite series, ordered
from lowest to highest degree.

Parameters
----------
pol : array_like
    1-D array containing the polynomial coefficients

Returns
-------
c : ndarray
    1-D array containing the coefficients of the equivalent Hermite
    series.

See Also
--------
herm2poly

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy.polynomial.hermite import poly2herm
>>> poly2herm(np.arange(4))
array([1.   ,  2.75 ,  0.5  ,  0.375])
*)


end

module Hermite_e : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

val herme2poly : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Convert a Hermite series to a polynomial.

Convert an array representing the coefficients of a Hermite series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the 'standard' basis) ordered
from lowest to highest degree.

Parameters
----------
c : array_like
    1-D array containing the Hermite series coefficients, ordered
    from lowest order term to highest.

Returns
-------
pol : ndarray
    1-D array containing the coefficients of the equivalent polynomial
    (relative to the 'standard' basis) ordered from lowest order term
    to highest.

See Also
--------
poly2herme

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy.polynomial.hermite_e import herme2poly
>>> herme2poly([  2.,  10.,   2.,   3.])
array([0.,  1.,  2.,  3.])
*)

val hermeadd : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Add one Hermite series to another.

Returns the sum of two Hermite series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Hermite series of their sum.

See Also
--------
hermesub, hermemulx, hermemul, hermediv, hermepow

Notes
-----
Unlike multiplication, division, etc., the sum of two Hermite series
is a Hermite series (without having to 'reproject' the result onto
the basis set) so addition, just like that of 'standard' polynomials,
is simply 'component-wise.'

Examples
--------
>>> from numpy.polynomial.hermite_e import hermeadd
>>> hermeadd([1, 2, 3], [1, 2, 3, 4])
array([2.,  4.,  6.,  4.])
*)

val hermecompanion : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the scaled companion matrix of c.

The basis polynomials are scaled so that the companion matrix is
symmetric when `c` is an HermiteE basis polynomial. This provides
better eigenvalue estimates than the unscaled case and for basis
polynomials the eigenvalues are guaranteed to be real if
`numpy.linalg.eigvalsh` is used to obtain them.

Parameters
----------
c : array_like
    1-D array of HermiteE series coefficients ordered from low to high
    degree.

Returns
-------
mat : ndarray
    Scaled companion matrix of dimensions (deg, deg).

Notes
-----

.. versionadded:: 1.7.0
*)

val hermeder : ?m:int -> ?scl:[`F of float | `I of int | `Bool of bool | `S of string] -> ?axis:int -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Differentiate a Hermite_e series.

Returns the series coefficients `c` differentiated `m` times along
`axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable). The argument
`c` is an array of coefficients from low to high degree along each
axis, e.g., [1,2,3] represents the series ``1*He_0 + 2*He_1 + 3*He_2``
while [[1,2],[1,2]] represents ``1*He_0(x)*He_0(y) + 1*He_1(x)*He_0(y)
+ 2*He_0(x)*He_1(y) + 2*He_1(x)*He_1(y)`` if axis=0 is ``x`` and axis=1
is ``y``.

Parameters
----------
c : array_like
    Array of Hermite_e series coefficients. If `c` is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change of
    variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Hermite series of the derivative.

See Also
--------
hermeint

Notes
-----
In general, the result of differentiating a Hermite series does not
resemble the same operation on a power series. Thus the result of this
function may be 'unintuitive,' albeit correct; see Examples section
below.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermeder
>>> hermeder([ 1.,  1.,  1.,  1.])
array([1.,  2.,  3.])
>>> hermeder([-0.25,  1.,  1./2.,  1./3.,  1./4 ], m=2)
array([1.,  2.,  3.])
*)

val hermediv : c1:Py.Object.t -> c2:Py.Object.t -> unit -> Py.Object.t
(**
Divide one Hermite series by another.

Returns the quotient-with-remainder of two Hermite series
`c1` / `c2`.  The arguments are sequences of coefficients from lowest
order 'term' to highest, e.g., [1,2,3] represents the series
``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
[quo, rem] : ndarrays
    Of Hermite series coefficients representing the quotient and
    remainder.

See Also
--------
hermeadd, hermesub, hermemulx, hermemul, hermepow

Notes
-----
In general, the (polynomial) division of one Hermite series by another
results in quotient and remainder terms that are not in the Hermite
polynomial basis set.  Thus, to express these results as a Hermite
series, it is necessary to 'reproject' the results onto the Hermite
basis set, which may produce 'unintuitive' (but correct) results; see
Examples section below.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermediv
>>> hermediv([ 14.,  15.,  28.,   7.,   6.], [0, 1, 2])
(array([1., 2., 3.]), array([0.]))
>>> hermediv([ 15.,  17.,  28.,   7.,   6.], [0, 1, 2])
(array([1., 2., 3.]), array([1., 2.]))
*)

val hermefit : ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Least squares fit of Hermite series to data.

Return the coefficients of a HermiteE series of degree `deg` that is
the least squares fit to the data values `y` given at points `x`. If
`y` is 1-D the returned coefficients will also be 1-D. If `y` is 2-D
multiple fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * He_1(x) + ... + c_n * He_n(x),

where `n` is `deg`.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.

Returns
-------
coef : ndarray, shape (M,) or (M, K)
    Hermite coefficients ordered from low to high. If `y` was 2-D,
    the coefficients for the data in column k  of `y` are in column
    `k`.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.  The
    warnings can be turned off by

    >>> import warnings
    >>> warnings.simplefilter('ignore', np.RankWarning)

See Also
--------
chebfit, legfit, polyfit, hermfit, polyfit
hermeval : Evaluates a Hermite series.
hermevander : pseudo Vandermonde matrix of Hermite series.
hermeweight : HermiteE weight function.
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the HermiteE series `p` that
minimizes the sum of the weighted squared errors

.. math:: E = \sum_j w_j^2 * |y_j - p(x_j)|^2,

where the :math:`w_j` are the weights. This problem is solved by
setting up the (typically) overdetermined matrix equation

.. math:: V(x) * c = w * y,

where `V` is the pseudo Vandermonde matrix of `x`, the elements of `c`
are the coefficients to be solved for, and the elements of `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected, then a `RankWarning` will be issued. This means that the
coefficient values may be poorly determined. Using a lower order fit
will usually get rid of the warning.  The `rcond` parameter can also be
set to a value smaller than its default, but the resulting fit may be
spurious and have large contributions from roundoff error.

Fits using HermiteE series are probably most useful when the data can
be approximated by ``sqrt(w(x)) * p(x)``, where `w(x)` is the HermiteE
weight. In that case the weight ``sqrt(w(x[i])`` should be used
together with data values ``y[i]/sqrt(w(x[i])``. The weight function is
available as `hermeweight`.

References
----------
.. [1] Wikipedia, 'Curve fitting',
       https://en.wikipedia.org/wiki/Curve_fitting

Examples
--------
>>> from numpy.polynomial.hermite_e import hermefit, hermeval
>>> x = np.linspace(-10, 10)
>>> np.random.seed(123)
>>> err = np.random.randn(len(x))/10
>>> y = hermeval(x, [1, 2, 3]) + err
>>> hermefit(x, y, 2)
array([ 1.01690445,  1.99951418,  2.99948696]) # may vary
*)

val hermefromroots : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Generate a HermiteE series with given roots.

The function returns the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

in HermiteE form, where the `r_n` are the roots specified in `roots`.
If a zero has multiplicity n, then it must appear in `roots` n times.
For instance, if 2 is a root of multiplicity three and 3 is a root of
multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
roots can appear in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * He_1(x) + ... +  c_n * He_n(x)

The coefficient of the last term is not generally 1 for monic
polynomials in HermiteE form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of coefficients.  If all roots are real then `out` is a
    real array, if some of the roots are complex, then `out` is complex
    even if all the coefficients in the result are real (see Examples
    below).

See Also
--------
polyfromroots, legfromroots, lagfromroots, hermfromroots, chebfromroots

Examples
--------
>>> from numpy.polynomial.hermite_e import hermefromroots, hermeval
>>> coef = hermefromroots((-1, 0, 1))
>>> hermeval((-1, 0, 1), coef)
array([0., 0., 0.])
>>> coef = hermefromroots((-1j, 1j))
>>> hermeval((-1j, 1j), coef)
array([0.+0.j, 0.+0.j])
*)

val hermegauss : int -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Gauss-HermiteE quadrature.

Computes the sample points and weights for Gauss-HermiteE quadrature.
These sample points and weights will correctly integrate polynomials of
degree :math:`2*deg - 1` or less over the interval :math:`[-\inf, \inf]`
with the weight function :math:`f(x) = \exp(-x^2/2)`.

Parameters
----------
deg : int
    Number of sample points and weights. It must be >= 1.

Returns
-------
x : ndarray
    1-D ndarray containing the sample points.
y : ndarray
    1-D ndarray containing the weights.

Notes
-----

.. versionadded:: 1.7.0

The results have only been tested up to degree 100, higher degrees may
be problematic. The weights are determined by using the fact that

.. math:: w_k = c / (He'_n(x_k) * He_{n-1}(x_k))

where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
is the k'th root of :math:`He_n`, and then scaling the results to get
the right value when integrating 1.
*)

val hermegrid2d : y:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 2-D HermiteE series on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \sum_{i,j} c_{i,j} * H_i(a) * H_j(b)

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
hermeval, hermeval2d, hermeval3d, hermegrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val hermegrid3d : y:Py.Object.t -> z:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.

This function returns the values:

.. math:: p(a,b,c) = \sum_{i,j,k} c_{i,j,k} * He_i(a) * He_j(b) * He_k(c)

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
hermeval, hermeval2d, hermegrid2d, hermeval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val hermeint : ?m:int -> ?k:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `Bool of bool | `F of float | `S of string] -> ?lbnd:[`F of float | `I of int | `Bool of bool | `S of string] -> ?scl:[`F of float | `I of int | `Bool of bool | `S of string] -> ?axis:int -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Integrate a Hermite_e series.

Returns the Hermite_e series coefficients `c` integrated `m` times from
`lbnd` along `axis`. At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ('Buyer
beware': note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.)  The argument `c` is an array of
coefficients from low to high degree along each axis, e.g., [1,2,3]
represents the series ``H_0 + 2*H_1 + 3*H_2`` while [[1,2],[1,2]]
represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +
2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.

Parameters
----------
c : array_like
    Array of Hermite_e series coefficients. If c is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at
    ``lbnd`` is the first value in the list, the value of the second
    integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
    default), all constants are set to zero.  If ``m == 1``, a single
    scalar can be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    Hermite_e series coefficients of the integral.

Raises
------
ValueError
    If ``m < 0``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or
    ``np.ndim(scl) != 0``.

See Also
--------
hermeder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.
Why is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`.  Then
:math:`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a` - perhaps not what one would have first thought.

Also note that, in general, the result of integrating a C-series needs
to be 'reprojected' onto the C-series basis set.  Thus, typically,
the result of this function is 'unintuitive,' albeit correct; see
Examples section below.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermeint
>>> hermeint([1, 2, 3]) # integrate once, value 0 at 0.
array([1., 1., 1., 1.])
>>> hermeint([1, 2, 3], m=2) # integrate twice, value & deriv 0 at 0
array([-0.25      ,  1.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary
>>> hermeint([1, 2, 3], k=1) # integrate once, value 1 at 0.
array([2., 1., 1., 1.])
>>> hermeint([1, 2, 3], lbnd=-1) # integrate once, value 0 at -1
array([-1.,  1.,  1.,  1.])
>>> hermeint([1, 2, 3], m=2, k=[1, 2], lbnd=-1)
array([ 1.83333333,  0.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary
*)

val hermeline : off:Py.Object.t -> scl:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Hermite series whose graph is a straight line.



Parameters
----------
off, scl : scalars
    The specified line is given by ``off + scl*x``.

Returns
-------
y : ndarray
    This module's representation of the Hermite series for
    ``off + scl*x``.

See Also
--------
polyline, chebline

Examples
--------
>>> from numpy.polynomial.hermite_e import hermeline
>>> from numpy.polynomial.hermite_e import hermeline, hermeval
>>> hermeval(0,hermeline(3, 2))
3.0
>>> hermeval(1,hermeline(3, 2))
5.0
*)

val hermemul : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Multiply one Hermite series by another.

Returns the product of two Hermite series `c1` * `c2`.  The arguments
are sequences of coefficients, from lowest order 'term' to highest,
e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Hermite series coefficients representing their product.

See Also
--------
hermeadd, hermesub, hermemulx, hermediv, hermepow

Notes
-----
In general, the (polynomial) product of two C-series results in terms
that are not in the Hermite polynomial basis set.  Thus, to express
the product as a Hermite series, it is necessary to 'reproject' the
product onto said basis set, which may produce 'unintuitive' (but
correct) results; see Examples section below.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermemul
>>> hermemul([1, 2, 3], [0, 1, 2])
array([14.,  15.,  28.,   7.,   6.])
*)

val hermemulx : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Multiply a Hermite series by x.

Multiply the Hermite series `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

Notes
-----
The multiplication uses the recursion relationship for Hermite
polynomials in the form

.. math::

xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x)))

Examples
--------
>>> from numpy.polynomial.hermite_e import hermemulx
>>> hermemulx([1, 2, 3])
array([2.,  7.,  2.,  3.])
*)

val hermepow : ?maxpower:int -> c:[>`Ndarray] Obj.t -> pow:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Raise a Hermite series to a power.

Returns the Hermite series `c` raised to the power `pow`. The
argument `c` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``

Parameters
----------
c : array_like
    1-D array of Hermite series coefficients ordered from low to
    high.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Hermite series of power.

See Also
--------
hermeadd, hermesub, hermemulx, hermemul, hermediv

Examples
--------
>>> from numpy.polynomial.hermite_e import hermepow
>>> hermepow([1, 2, 3], 2)
array([23.,  28.,  46.,  12.,   9.])
*)

val hermeroots : Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the roots of a HermiteE series.

Return the roots (a.k.a. 'zeros') of the polynomial

.. math:: p(x) = \sum_i c[i] * He_i(x).

Parameters
----------
c : 1-D array_like
    1-D array of coefficients.

Returns
-------
out : ndarray
    Array of the roots of the series. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
polyroots, legroots, lagroots, hermroots, chebroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the series for such
values. Roots with multiplicity greater than 1 will also show larger
errors as the value of the series near such points is relatively
insensitive to errors in the roots. Isolated roots near the origin can
be improved by a few iterations of Newton's method.

The HermiteE series basis polynomials aren't powers of `x` so the
results of this function may seem unintuitive.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermeroots, hermefromroots
>>> coef = hermefromroots([-1, 0, 1])
>>> coef
array([0., 2., 0., 1.])
>>> hermeroots(coef)
array([-1.,  0.,  1.]) # may vary
*)

val hermesub : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Subtract one Hermite series from another.

Returns the difference of two Hermite series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Hermite series coefficients representing their difference.

See Also
--------
hermeadd, hermemulx, hermemul, hermediv, hermepow

Notes
-----
Unlike multiplication, division, etc., the difference of two Hermite
series is a Hermite series (without having to 'reproject' the result
onto the basis set) so subtraction, just like that of 'standard'
polynomials, is simply 'component-wise.'

Examples
--------
>>> from numpy.polynomial.hermite_e import hermesub
>>> hermesub([1, 2, 3, 4], [1, 2, 3])
array([0., 0., 0., 4.])
*)

val hermetrim : ?tol:[`F of float | `I of int] -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Remove 'small' 'trailing' coefficients from a polynomial.

'Small' means 'small in absolute value' and is controlled by the
parameter `tol`; 'trailing' means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be 'trimmed.'

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` < 0

See Also
--------
trimseq

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> pu.trimcoef((0,0,3,0,5,0,0))
array([0.,  0.,  3.,  0.,  5.])
>>> pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([0.])
>>> i = complex(0,1) # works for complex
>>> pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([0.0003+0.j   , 0.001 -0.001j])
*)

val hermeval : ?tensor:bool -> c:[>`Ndarray] Obj.t -> [`Compatible_object of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
Evaluate an HermiteE series at points x.

If `c` is of length `n + 1`, this function returns the value:

.. math:: p(x) = c_0 * He_0(x) + c_1 * He_1(x) + ... + c_n * He_n(x)

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, algebra_like
    The shape of the return value is described above.

See Also
--------
hermeval2d, hermegrid2d, hermeval3d, hermegrid3d

Notes
-----
The evaluation uses Clenshaw recursion, aka synthetic division.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermeval
>>> coef = [1,2,3]
>>> hermeval(1, coef)
3.0
>>> hermeval([[1,2],[3,4]], coef)
array([[ 3., 14.],
       [31., 54.]])
*)

val hermeval2d : y:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 2-D HermiteE series at points (x, y).

This function returns the values:

.. math:: p(x,y) = \sum_{i,j} c_{i,j} * He_i(x) * He_j(y)

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` is a 1-D array a one is implicitly appended to its shape to make
it 2-D. The shape of the result will be c.shape[2:] + x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and if it isn't an ndarray it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in ``c[i,j]``. If `c` has
    dimension greater than two the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points formed with
    pairs of corresponding values from `x` and `y`.

See Also
--------
hermeval, hermegrid2d, hermeval3d, hermegrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val hermeval3d : y:Py.Object.t -> z:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 3-D Hermite_e series at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \sum_{i,j,k} c_{i,j,k} * He_i(x) * He_j(y) * He_k(z)

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimensional polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
hermeval, hermeval2d, hermegrid2d, hermegrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val hermevander : deg:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degree.

Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
`x`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., i] = He_i(x),

where `0 <= i <= deg`. The leading indices of `V` index the elements of
`x` and the last index is the degree of the HermiteE polynomial.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
array ``V = hermevander(x, n)``, then ``np.dot(V, c)`` and
``hermeval(x, c)`` are the same up to roundoff. This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of HermiteE series of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray
    The pseudo-Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where The last index is the degree of the
    corresponding HermiteE polynomial.  The dtype will be the same as
    the converted `x`.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermevander
>>> x = np.array([-1, 0, 1])
>>> hermevander(x, 3)
array([[ 1., -1.,  0.,  2.],
       [ 1.,  0., -1., -0.],
       [ 1.,  1.,  0., -2.]])
*)

val hermevander2d : y:Py.Object.t -> deg:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (deg[1] + 1)*i + j] = He_i(x) * He_j(y),

where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the degrees of
the HermiteE polynomials.

If ``V = hermevander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``hermeval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D HermiteE
series of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to
    1-D arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
hermevander, hermevander3d, hermeval2d, hermeval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val hermevander3d : y:Py.Object.t -> z:Py.Object.t -> deg:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then Hehe pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = He_i(x)*He_j(y)*He_k(z),

where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the degrees of the HermiteE polynomials.

If ``V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and  ``np.dot(V, c.flat)`` and ``hermeval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D HermiteE
series of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
hermevander, hermevander3d, hermeval2d, hermeval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val hermeweight : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Weight function of the Hermite_e polynomials.

The weight function is :math:`\exp(-x^2/2)` and the interval of
integration is :math:`[-\inf, \inf]`. the HermiteE polynomials are
orthogonal, but not normalized, with respect to this weight function.

Parameters
----------
x : array_like
   Values at which the weight function will be computed.

Returns
-------
w : ndarray
   The weight function at `x`.

Notes
-----

.. versionadded:: 1.7.0
*)

val normalize_axis_index : ?msg_prefix:string -> axis:int -> ndim:int -> unit -> int
(**
normalize_axis_index(axis, ndim, msg_prefix=None)

Normalizes an axis index, `axis`, such that is a valid positive index into
the shape of array with `ndim` dimensions. Raises an AxisError with an
appropriate message if this is not possible.

Used internally by all axis-checking logic.

.. versionadded:: 1.13.0

Parameters
----------
axis : int
    The un-normalized index of the axis. Can be negative
ndim : int
    The number of dimensions of the array that `axis` should be normalized
    against
msg_prefix : str
    A prefix to put before the message, typically the name of the argument

Returns
-------
normalized_axis : int
    The normalized axis index, such that `0 <= normalized_axis < ndim`

Raises
------
AxisError
    If the axis index is invalid, when `-ndim <= axis < ndim` is false.

Examples
--------
>>> normalize_axis_index(0, ndim=3)
0
>>> normalize_axis_index(1, ndim=3)
1
>>> normalize_axis_index(-1, ndim=3)
2

>>> normalize_axis_index(3, ndim=3)
Traceback (most recent call last):
...
AxisError: axis 3 is out of bounds for array of dimension 3
>>> normalize_axis_index(-4, ndim=3, msg_prefix='axes_arg')
Traceback (most recent call last):
...
AxisError: axes_arg: axis -4 is out of bounds for array of dimension 3
*)

val poly2herme : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
poly2herme(pol)

Convert a polynomial to a Hermite series.

Convert an array representing the coefficients of a polynomial (relative
to the 'standard' basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Hermite series, ordered
from lowest to highest degree.

Parameters
----------
pol : array_like
    1-D array containing the polynomial coefficients

Returns
-------
c : ndarray
    1-D array containing the coefficients of the equivalent Hermite
    series.

See Also
--------
herme2poly

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy.polynomial.hermite_e import poly2herme
>>> poly2herme(np.arange(4))
array([  2.,  10.,   2.,   3.])
*)


end

module Laguerre' : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

val lag2poly : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Convert a Laguerre series to a polynomial.

Convert an array representing the coefficients of a Laguerre series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the 'standard' basis) ordered
from lowest to highest degree.

Parameters
----------
c : array_like
    1-D array containing the Laguerre series coefficients, ordered
    from lowest order term to highest.

Returns
-------
pol : ndarray
    1-D array containing the coefficients of the equivalent polynomial
    (relative to the 'standard' basis) ordered from lowest order term
    to highest.

See Also
--------
poly2lag

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy.polynomial.laguerre import lag2poly
>>> lag2poly([ 23., -63.,  58., -18.])
array([0., 1., 2., 3.])
*)

val lagadd : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Add one Laguerre series to another.

Returns the sum of two Laguerre series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Laguerre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Laguerre series of their sum.

See Also
--------
lagsub, lagmulx, lagmul, lagdiv, lagpow

Notes
-----
Unlike multiplication, division, etc., the sum of two Laguerre series
is a Laguerre series (without having to 'reproject' the result onto
the basis set) so addition, just like that of 'standard' polynomials,
is simply 'component-wise.'

Examples
--------
>>> from numpy.polynomial.laguerre import lagadd
>>> lagadd([1, 2, 3], [1, 2, 3, 4])
array([2.,  4.,  6.,  4.])
*)

val lagcompanion : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the companion matrix of c.

The usual companion matrix of the Laguerre polynomials is already
symmetric when `c` is a basis Laguerre polynomial, so no scaling is
applied.

Parameters
----------
c : array_like
    1-D array of Laguerre series coefficients ordered from low to high
    degree.

Returns
-------
mat : ndarray
    Companion matrix of dimensions (deg, deg).

Notes
-----

.. versionadded:: 1.7.0
*)

val lagder : ?m:int -> ?scl:[`F of float | `I of int | `Bool of bool | `S of string] -> ?axis:int -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Differentiate a Laguerre series.

Returns the Laguerre series coefficients `c` differentiated `m` times
along `axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable). The argument
`c` is an array of coefficients from low to high degree along each
axis, e.g., [1,2,3] represents the series ``1*L_0 + 2*L_1 + 3*L_2``
while [[1,2],[1,2]] represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +
2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is
``y``.

Parameters
----------
c : array_like
    Array of Laguerre series coefficients. If `c` is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change of
    variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Laguerre series of the derivative.

See Also
--------
lagint

Notes
-----
In general, the result of differentiating a Laguerre series does not
resemble the same operation on a power series. Thus the result of this
function may be 'unintuitive,' albeit correct; see Examples section
below.

Examples
--------
>>> from numpy.polynomial.laguerre import lagder
>>> lagder([ 1.,  1.,  1., -3.])
array([1.,  2.,  3.])
>>> lagder([ 1.,  0.,  0., -4.,  3.], m=2)
array([1.,  2.,  3.])
*)

val lagdiv : c1:Py.Object.t -> c2:Py.Object.t -> unit -> Py.Object.t
(**
Divide one Laguerre series by another.

Returns the quotient-with-remainder of two Laguerre series
`c1` / `c2`.  The arguments are sequences of coefficients from lowest
order 'term' to highest, e.g., [1,2,3] represents the series
``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Laguerre series coefficients ordered from low to
    high.

Returns
-------
[quo, rem] : ndarrays
    Of Laguerre series coefficients representing the quotient and
    remainder.

See Also
--------
lagadd, lagsub, lagmulx, lagmul, lagpow

Notes
-----
In general, the (polynomial) division of one Laguerre series by another
results in quotient and remainder terms that are not in the Laguerre
polynomial basis set.  Thus, to express these results as a Laguerre
series, it is necessary to 'reproject' the results onto the Laguerre
basis set, which may produce 'unintuitive' (but correct) results; see
Examples section below.

Examples
--------
>>> from numpy.polynomial.laguerre import lagdiv
>>> lagdiv([  8., -13.,  38., -51.,  36.], [0, 1, 2])
(array([1., 2., 3.]), array([0.]))
>>> lagdiv([  9., -12.,  38., -51.,  36.], [0, 1, 2])
(array([1., 2., 3.]), array([1., 1.]))
*)

val lagfit : ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Least squares fit of Laguerre series to data.

Return the coefficients of a Laguerre series of degree `deg` that is the
least squares fit to the data values `y` given at points `x`. If `y` is
1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * L_1(x) + ... + c_n * L_n(x),

where `n` is `deg`.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.

Returns
-------
coef : ndarray, shape (M,) or (M, K)
    Laguerre coefficients ordered from low to high. If `y` was 2-D,
    the coefficients for the data in column k  of `y` are in column
    `k`.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.  The
    warnings can be turned off by

    >>> import warnings
    >>> warnings.simplefilter('ignore', np.RankWarning)

See Also
--------
chebfit, legfit, polyfit, hermfit, hermefit
lagval : Evaluates a Laguerre series.
lagvander : pseudo Vandermonde matrix of Laguerre series.
lagweight : Laguerre weight function.
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the Laguerre series `p` that
minimizes the sum of the weighted squared errors

.. math:: E = \sum_j w_j^2 * |y_j - p(x_j)|^2,

where the :math:`w_j` are the weights. This problem is solved by
setting up as the (typically) overdetermined matrix equation

.. math:: V(x) * c = w * y,

where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
coefficients to be solved for, `w` are the weights, and `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected, then a `RankWarning` will be issued. This means that the
coefficient values may be poorly determined. Using a lower order fit
will usually get rid of the warning.  The `rcond` parameter can also be
set to a value smaller than its default, but the resulting fit may be
spurious and have large contributions from roundoff error.

Fits using Laguerre series are probably most useful when the data can
be approximated by ``sqrt(w(x)) * p(x)``, where `w(x)` is the Laguerre
weight. In that case the weight ``sqrt(w(x[i])`` should be used
together with data values ``y[i]/sqrt(w(x[i])``. The weight function is
available as `lagweight`.

References
----------
.. [1] Wikipedia, 'Curve fitting',
       https://en.wikipedia.org/wiki/Curve_fitting

Examples
--------
>>> from numpy.polynomial.laguerre import lagfit, lagval
>>> x = np.linspace(0, 10)
>>> err = np.random.randn(len(x))/10
>>> y = lagval(x, [1, 2, 3]) + err
>>> lagfit(x, y, 2)
array([ 0.96971004,  2.00193749,  3.00288744]) # may vary
*)

val lagfromroots : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Generate a Laguerre series with given roots.

The function returns the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

in Laguerre form, where the `r_n` are the roots specified in `roots`.
If a zero has multiplicity n, then it must appear in `roots` n times.
For instance, if 2 is a root of multiplicity three and 3 is a root of
multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
roots can appear in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * L_1(x) + ... +  c_n * L_n(x)

The coefficient of the last term is not generally 1 for monic
polynomials in Laguerre form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of coefficients.  If all roots are real then `out` is a
    real array, if some of the roots are complex, then `out` is complex
    even if all the coefficients in the result are real (see Examples
    below).

See Also
--------
polyfromroots, legfromroots, chebfromroots, hermfromroots, hermefromroots

Examples
--------
>>> from numpy.polynomial.laguerre import lagfromroots, lagval
>>> coef = lagfromroots((-1, 0, 1))
>>> lagval((-1, 0, 1), coef)
array([0.,  0.,  0.])
>>> coef = lagfromroots((-1j, 1j))
>>> lagval((-1j, 1j), coef)
array([0.+0.j, 0.+0.j])
*)

val laggauss : int -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Gauss-Laguerre quadrature.

Computes the sample points and weights for Gauss-Laguerre quadrature.
These sample points and weights will correctly integrate polynomials of
degree :math:`2*deg - 1` or less over the interval :math:`[0, \inf]`
with the weight function :math:`f(x) = \exp(-x)`.

Parameters
----------
deg : int
    Number of sample points and weights. It must be >= 1.

Returns
-------
x : ndarray
    1-D ndarray containing the sample points.
y : ndarray
    1-D ndarray containing the weights.

Notes
-----

.. versionadded:: 1.7.0

The results have only been tested up to degree 100 higher degrees may
be problematic. The weights are determined by using the fact that

.. math:: w_k = c / (L'_n(x_k) * L_{n-1}(x_k))

where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
is the k'th root of :math:`L_n`, and then scaling the results to get
the right value when integrating 1.
*)

val laggrid2d : y:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 2-D Laguerre series on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \sum_{i,j} c_{i,j} * L_i(a) * L_j(b)

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape + y.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j is contained in `c[i,j]`. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional Chebyshev series at points in the
    Cartesian product of `x` and `y`.

See Also
--------
lagval, lagval2d, lagval3d, laggrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val laggrid3d : y:Py.Object.t -> z:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.

This function returns the values:

.. math:: p(a,b,c) = \sum_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
lagval, lagval2d, laggrid2d, lagval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val lagint : ?m:int -> ?k:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `Bool of bool | `F of float | `S of string] -> ?lbnd:[`F of float | `I of int | `Bool of bool | `S of string] -> ?scl:[`F of float | `I of int | `Bool of bool | `S of string] -> ?axis:int -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Integrate a Laguerre series.

Returns the Laguerre series coefficients `c` integrated `m` times from
`lbnd` along `axis`. At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ('Buyer
beware': note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.)  The argument `c` is an array of
coefficients from low to high degree along each axis, e.g., [1,2,3]
represents the series ``L_0 + 2*L_1 + 3*L_2`` while [[1,2],[1,2]]
represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +
2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.


Parameters
----------
c : array_like
    Array of Laguerre series coefficients. If `c` is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at
    ``lbnd`` is the first value in the list, the value of the second
    integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
    default), all constants are set to zero.  If ``m == 1``, a single
    scalar can be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    Laguerre series coefficients of the integral.

Raises
------
ValueError
    If ``m < 0``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or
    ``np.ndim(scl) != 0``.

See Also
--------
lagder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.
Why is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`.  Then
:math:`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a` - perhaps not what one would have first thought.

Also note that, in general, the result of integrating a C-series needs
to be 'reprojected' onto the C-series basis set.  Thus, typically,
the result of this function is 'unintuitive,' albeit correct; see
Examples section below.

Examples
--------
>>> from numpy.polynomial.laguerre import lagint
>>> lagint([1,2,3])
array([ 1.,  1.,  1., -3.])
>>> lagint([1,2,3], m=2)
array([ 1.,  0.,  0., -4.,  3.])
>>> lagint([1,2,3], k=1)
array([ 2.,  1.,  1., -3.])
>>> lagint([1,2,3], lbnd=-1)
array([11.5,  1. ,  1. , -3. ])
>>> lagint([1,2], m=2, k=[1,2], lbnd=-1)
array([ 11.16666667,  -5.        ,  -3.        ,   2.        ]) # may vary
*)

val lagline : off:Py.Object.t -> scl:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Laguerre series whose graph is a straight line.



Parameters
----------
off, scl : scalars
    The specified line is given by ``off + scl*x``.

Returns
-------
y : ndarray
    This module's representation of the Laguerre series for
    ``off + scl*x``.

See Also
--------
polyline, chebline

Examples
--------
>>> from numpy.polynomial.laguerre import lagline, lagval
>>> lagval(0,lagline(3, 2))
3.0
>>> lagval(1,lagline(3, 2))
5.0
*)

val lagmul : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Multiply one Laguerre series by another.

Returns the product of two Laguerre series `c1` * `c2`.  The arguments
are sequences of coefficients, from lowest order 'term' to highest,
e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Laguerre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Laguerre series coefficients representing their product.

See Also
--------
lagadd, lagsub, lagmulx, lagdiv, lagpow

Notes
-----
In general, the (polynomial) product of two C-series results in terms
that are not in the Laguerre polynomial basis set.  Thus, to express
the product as a Laguerre series, it is necessary to 'reproject' the
product onto said basis set, which may produce 'unintuitive' (but
correct) results; see Examples section below.

Examples
--------
>>> from numpy.polynomial.laguerre import lagmul
>>> lagmul([1, 2, 3], [0, 1, 2])
array([  8., -13.,  38., -51.,  36.])
*)

val lagmulx : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Multiply a Laguerre series by x.

Multiply the Laguerre series `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of Laguerre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

See Also
--------
lagadd, lagsub, lagmul, lagdiv, lagpow

Notes
-----
The multiplication uses the recursion relationship for Laguerre
polynomials in the form

.. math::

xP_i(x) = (-(i + 1)*P_{i + 1}(x) + (2i + 1)P_{i}(x) - iP_{i - 1}(x))

Examples
--------
>>> from numpy.polynomial.laguerre import lagmulx
>>> lagmulx([1, 2, 3])
array([-1.,  -1.,  11.,  -9.])
*)

val lagpow : ?maxpower:int -> c:[>`Ndarray] Obj.t -> pow:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Raise a Laguerre series to a power.

Returns the Laguerre series `c` raised to the power `pow`. The
argument `c` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``

Parameters
----------
c : array_like
    1-D array of Laguerre series coefficients ordered from low to
    high.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Laguerre series of power.

See Also
--------
lagadd, lagsub, lagmulx, lagmul, lagdiv

Examples
--------
>>> from numpy.polynomial.laguerre import lagpow
>>> lagpow([1, 2, 3], 2)
array([ 14., -16.,  56., -72.,  54.])
*)

val lagroots : Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the roots of a Laguerre series.

Return the roots (a.k.a. 'zeros') of the polynomial

.. math:: p(x) = \sum_i c[i] * L_i(x).

Parameters
----------
c : 1-D array_like
    1-D array of coefficients.

Returns
-------
out : ndarray
    Array of the roots of the series. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
polyroots, legroots, chebroots, hermroots, hermeroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the series for such
values. Roots with multiplicity greater than 1 will also show larger
errors as the value of the series near such points is relatively
insensitive to errors in the roots. Isolated roots near the origin can
be improved by a few iterations of Newton's method.

The Laguerre series basis polynomials aren't powers of `x` so the
results of this function may seem unintuitive.

Examples
--------
>>> from numpy.polynomial.laguerre import lagroots, lagfromroots
>>> coef = lagfromroots([0, 1, 2])
>>> coef
array([  2.,  -8.,  12.,  -6.])
>>> lagroots(coef)
array([-4.4408921e-16,  1.0000000e+00,  2.0000000e+00])
*)

val lagsub : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Subtract one Laguerre series from another.

Returns the difference of two Laguerre series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Laguerre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Laguerre series coefficients representing their difference.

See Also
--------
lagadd, lagmulx, lagmul, lagdiv, lagpow

Notes
-----
Unlike multiplication, division, etc., the difference of two Laguerre
series is a Laguerre series (without having to 'reproject' the result
onto the basis set) so subtraction, just like that of 'standard'
polynomials, is simply 'component-wise.'

Examples
--------
>>> from numpy.polynomial.laguerre import lagsub
>>> lagsub([1, 2, 3, 4], [1, 2, 3])
array([0.,  0.,  0.,  4.])
*)

val lagtrim : ?tol:[`F of float | `I of int] -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Remove 'small' 'trailing' coefficients from a polynomial.

'Small' means 'small in absolute value' and is controlled by the
parameter `tol`; 'trailing' means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be 'trimmed.'

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` < 0

See Also
--------
trimseq

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> pu.trimcoef((0,0,3,0,5,0,0))
array([0.,  0.,  3.,  0.,  5.])
>>> pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([0.])
>>> i = complex(0,1) # works for complex
>>> pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([0.0003+0.j   , 0.001 -0.001j])
*)

val lagval : ?tensor:bool -> c:[>`Ndarray] Obj.t -> [`Compatible_object of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
Evaluate a Laguerre series at points x.

If `c` is of length `n + 1`, this function returns the value:

.. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, algebra_like
    The shape of the return value is described above.

See Also
--------
lagval2d, laggrid2d, lagval3d, laggrid3d

Notes
-----
The evaluation uses Clenshaw recursion, aka synthetic division.

Examples
--------
>>> from numpy.polynomial.laguerre import lagval
>>> coef = [1,2,3]
>>> lagval(1, coef)
-0.5
>>> lagval([[1,2],[3,4]], coef)
array([[-0.5, -4. ],
       [-4.5, -2. ]])
*)

val lagval2d : y:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 2-D Laguerre series at points (x, y).

This function returns the values:

.. math:: p(x,y) = \sum_{i,j} c_{i,j} * L_i(x) * L_j(y)

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` is a 1-D array a one is implicitly appended to its shape to make
it 2-D. The shape of the result will be c.shape[2:] + x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and if it isn't an ndarray it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in ``c[i,j]``. If `c` has
    dimension greater than two the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points formed with
    pairs of corresponding values from `x` and `y`.

See Also
--------
lagval, laggrid2d, lagval3d, laggrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val lagval3d : y:Py.Object.t -> z:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 3-D Laguerre series at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimension polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
lagval, lagval2d, laggrid2d, laggrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val lagvander : deg:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degree.

Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
`x`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., i] = L_i(x)

where `0 <= i <= deg`. The leading indices of `V` index the elements of
`x` and the last index is the degree of the Laguerre polynomial.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
array ``V = lagvander(x, n)``, then ``np.dot(V, c)`` and
``lagval(x, c)`` are the same up to roundoff. This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of Laguerre series of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray
    The pseudo-Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where The last index is the degree of the
    corresponding Laguerre polynomial.  The dtype will be the same as
    the converted `x`.

Examples
--------
>>> from numpy.polynomial.laguerre import lagvander
>>> x = np.array([0, 1, 2])
>>> lagvander(x, 3)
array([[ 1.        ,  1.        ,  1.        ,  1.        ],
       [ 1.        ,  0.        , -0.5       , -0.66666667],
       [ 1.        , -1.        , -1.        , -0.33333333]])
*)

val lagvander2d : y:Py.Object.t -> deg:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (deg[1] + 1)*i + j] = L_i(x) * L_j(y),

where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the degrees of
the Laguerre polynomials.

If ``V = lagvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``lagval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D Laguerre
series of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to
    1-D arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
lagvander, lagvander3d, lagval2d, lagval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val lagvander3d : y:Py.Object.t -> z:Py.Object.t -> deg:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = L_i(x)*L_j(y)*L_k(z),

where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the degrees of the Laguerre polynomials.

If ``V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and  ``np.dot(V, c.flat)`` and ``lagval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D Laguerre
series of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
lagvander, lagvander3d, lagval2d, lagval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val lagweight : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Weight function of the Laguerre polynomials.

The weight function is :math:`exp(-x)` and the interval of integration
is :math:`[0, \inf]`. The Laguerre polynomials are orthogonal, but not
normalized, with respect to this weight function.

Parameters
----------
x : array_like
   Values at which the weight function will be computed.

Returns
-------
w : ndarray
   The weight function at `x`.

Notes
-----

.. versionadded:: 1.7.0
*)

val normalize_axis_index : ?msg_prefix:string -> axis:int -> ndim:int -> unit -> int
(**
normalize_axis_index(axis, ndim, msg_prefix=None)

Normalizes an axis index, `axis`, such that is a valid positive index into
the shape of array with `ndim` dimensions. Raises an AxisError with an
appropriate message if this is not possible.

Used internally by all axis-checking logic.

.. versionadded:: 1.13.0

Parameters
----------
axis : int
    The un-normalized index of the axis. Can be negative
ndim : int
    The number of dimensions of the array that `axis` should be normalized
    against
msg_prefix : str
    A prefix to put before the message, typically the name of the argument

Returns
-------
normalized_axis : int
    The normalized axis index, such that `0 <= normalized_axis < ndim`

Raises
------
AxisError
    If the axis index is invalid, when `-ndim <= axis < ndim` is false.

Examples
--------
>>> normalize_axis_index(0, ndim=3)
0
>>> normalize_axis_index(1, ndim=3)
1
>>> normalize_axis_index(-1, ndim=3)
2

>>> normalize_axis_index(3, ndim=3)
Traceback (most recent call last):
...
AxisError: axis 3 is out of bounds for array of dimension 3
>>> normalize_axis_index(-4, ndim=3, msg_prefix='axes_arg')
Traceback (most recent call last):
...
AxisError: axes_arg: axis -4 is out of bounds for array of dimension 3
*)

val poly2lag : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
poly2lag(pol)

Convert a polynomial to a Laguerre series.

Convert an array representing the coefficients of a polynomial (relative
to the 'standard' basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Laguerre series, ordered
from lowest to highest degree.

Parameters
----------
pol : array_like
    1-D array containing the polynomial coefficients

Returns
-------
c : ndarray
    1-D array containing the coefficients of the equivalent Laguerre
    series.

See Also
--------
lag2poly

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy.polynomial.laguerre import poly2lag
>>> poly2lag(np.arange(4))
array([ 23., -63.,  58., -18.])
*)


end

module Legendre' : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

val leg2poly : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Convert a Legendre series to a polynomial.

Convert an array representing the coefficients of a Legendre series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the 'standard' basis) ordered
from lowest to highest degree.

Parameters
----------
c : array_like
    1-D array containing the Legendre series coefficients, ordered
    from lowest order term to highest.

Returns
-------
pol : ndarray
    1-D array containing the coefficients of the equivalent polynomial
    (relative to the 'standard' basis) ordered from lowest order term
    to highest.

See Also
--------
poly2leg

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy import polynomial as P
>>> c = P.Legendre(range(4))
>>> c
Legendre([0., 1., 2., 3.], domain=[-1,  1], window=[-1,  1])
>>> p = c.convert(kind=P.Polynomial)
>>> p
Polynomial([-1. , -3.5,  3. ,  7.5], domain=[-1.,  1.], window=[-1.,  1.])
>>> P.leg2poly(range(4))
array([-1. , -3.5,  3. ,  7.5])
*)

val legadd : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Add one Legendre series to another.

Returns the sum of two Legendre series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Legendre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Legendre series of their sum.

See Also
--------
legsub, legmulx, legmul, legdiv, legpow

Notes
-----
Unlike multiplication, division, etc., the sum of two Legendre series
is a Legendre series (without having to 'reproject' the result onto
the basis set) so addition, just like that of 'standard' polynomials,
is simply 'component-wise.'

Examples
--------
>>> from numpy.polynomial import legendre as L
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> L.legadd(c1,c2)
array([4.,  4.,  4.])
*)

val legcompanion : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the scaled companion matrix of c.

The basis polynomials are scaled so that the companion matrix is
symmetric when `c` is an Legendre basis polynomial. This provides
better eigenvalue estimates than the unscaled case and for basis
polynomials the eigenvalues are guaranteed to be real if
`numpy.linalg.eigvalsh` is used to obtain them.

Parameters
----------
c : array_like
    1-D array of Legendre series coefficients ordered from low to high
    degree.

Returns
-------
mat : ndarray
    Scaled companion matrix of dimensions (deg, deg).

Notes
-----

.. versionadded:: 1.7.0
*)

val legder : ?m:int -> ?scl:[`F of float | `I of int | `Bool of bool | `S of string] -> ?axis:int -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Differentiate a Legendre series.

Returns the Legendre series coefficients `c` differentiated `m` times
along `axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable). The argument
`c` is an array of coefficients from low to high degree along each
axis, e.g., [1,2,3] represents the series ``1*L_0 + 2*L_1 + 3*L_2``
while [[1,2],[1,2]] represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +
2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is
``y``.

Parameters
----------
c : array_like
    Array of Legendre series coefficients. If c is multidimensional the
    different axis correspond to different variables with the degree in
    each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change of
    variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Legendre series of the derivative.

See Also
--------
legint

Notes
-----
In general, the result of differentiating a Legendre series does not
resemble the same operation on a power series. Thus the result of this
function may be 'unintuitive,' albeit correct; see Examples section
below.

Examples
--------
>>> from numpy.polynomial import legendre as L
>>> c = (1,2,3,4)
>>> L.legder(c)
array([  6.,   9.,  20.])
>>> L.legder(c, 3)
array([60.])
>>> L.legder(c, scl=-1)
array([ -6.,  -9., -20.])
>>> L.legder(c, 2,-1)
array([  9.,  60.])
*)

val legdiv : c1:Py.Object.t -> c2:Py.Object.t -> unit -> Py.Object.t
(**
Divide one Legendre series by another.

Returns the quotient-with-remainder of two Legendre series
`c1` / `c2`.  The arguments are sequences of coefficients from lowest
order 'term' to highest, e.g., [1,2,3] represents the series
``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Legendre series coefficients ordered from low to
    high.

Returns
-------
quo, rem : ndarrays
    Of Legendre series coefficients representing the quotient and
    remainder.

See Also
--------
legadd, legsub, legmulx, legmul, legpow

Notes
-----
In general, the (polynomial) division of one Legendre series by another
results in quotient and remainder terms that are not in the Legendre
polynomial basis set.  Thus, to express these results as a Legendre
series, it is necessary to 'reproject' the results onto the Legendre
basis set, which may produce 'unintuitive' (but correct) results; see
Examples section below.

Examples
--------
>>> from numpy.polynomial import legendre as L
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> L.legdiv(c1,c2) # quotient 'intuitive,' remainder not
(array([3.]), array([-8., -4.]))
>>> c2 = (0,1,2,3)
>>> L.legdiv(c2,c1) # neither 'intuitive'
(array([-0.07407407,  1.66666667]), array([-1.03703704, -2.51851852])) # may vary
*)

val legfit : ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Least squares fit of Legendre series to data.

Return the coefficients of a Legendre series of degree `deg` that is the
least squares fit to the data values `y` given at points `x`. If `y` is
1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * L_1(x) + ... + c_n * L_n(x),

where `n` is `deg`.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.

    .. versionadded:: 1.5.0

Returns
-------
coef : ndarray, shape (M,) or (M, K)
    Legendre coefficients ordered from low to high. If `y` was
    2-D, the coefficients for the data in column k of `y` are in
    column `k`. If `deg` is specified as a list, coefficients for
    terms not included in the fit are set equal to zero in the
    returned `coef`.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.  The
    warnings can be turned off by

    >>> import warnings
    >>> warnings.simplefilter('ignore', np.RankWarning)

See Also
--------
chebfit, polyfit, lagfit, hermfit, hermefit
legval : Evaluates a Legendre series.
legvander : Vandermonde matrix of Legendre series.
legweight : Legendre weight function (= 1).
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the Legendre series `p` that
minimizes the sum of the weighted squared errors

.. math:: E = \sum_j w_j^2 * |y_j - p(x_j)|^2,

where :math:`w_j` are the weights. This problem is solved by setting up
as the (typically) overdetermined matrix equation

.. math:: V(x) * c = w * y,

where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
coefficients to be solved for, `w` are the weights, and `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected, then a `RankWarning` will be issued. This means that the
coefficient values may be poorly determined. Using a lower order fit
will usually get rid of the warning.  The `rcond` parameter can also be
set to a value smaller than its default, but the resulting fit may be
spurious and have large contributions from roundoff error.

Fits using Legendre series are usually better conditioned than fits
using power series, but much can depend on the distribution of the
sample points and the smoothness of the data. If the quality of the fit
is inadequate splines may be a good alternative.

References
----------
.. [1] Wikipedia, 'Curve fitting',
       https://en.wikipedia.org/wiki/Curve_fitting

Examples
--------
*)

val legfromroots : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Generate a Legendre series with given roots.

The function returns the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

in Legendre form, where the `r_n` are the roots specified in `roots`.
If a zero has multiplicity n, then it must appear in `roots` n times.
For instance, if 2 is a root of multiplicity three and 3 is a root of
multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
roots can appear in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * L_1(x) + ... +  c_n * L_n(x)

The coefficient of the last term is not generally 1 for monic
polynomials in Legendre form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of coefficients.  If all roots are real then `out` is a
    real array, if some of the roots are complex, then `out` is complex
    even if all the coefficients in the result are real (see Examples
    below).

See Also
--------
polyfromroots, chebfromroots, lagfromroots, hermfromroots, hermefromroots

Examples
--------
>>> import numpy.polynomial.legendre as L
>>> L.legfromroots((-1,0,1)) # x^3 - x relative to the standard basis
array([ 0. , -0.4,  0. ,  0.4])
>>> j = complex(0,1)
>>> L.legfromroots((-j,j)) # x^2 + 1 relative to the standard basis
array([ 1.33333333+0.j,  0.00000000+0.j,  0.66666667+0.j]) # may vary
*)

val leggauss : int -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Gauss-Legendre quadrature.

Computes the sample points and weights for Gauss-Legendre quadrature.
These sample points and weights will correctly integrate polynomials of
degree :math:`2*deg - 1` or less over the interval :math:`[-1, 1]` with
the weight function :math:`f(x) = 1`.

Parameters
----------
deg : int
    Number of sample points and weights. It must be >= 1.

Returns
-------
x : ndarray
    1-D ndarray containing the sample points.
y : ndarray
    1-D ndarray containing the weights.

Notes
-----

.. versionadded:: 1.7.0

The results have only been tested up to degree 100, higher degrees may
be problematic. The weights are determined by using the fact that

.. math:: w_k = c / (L'_n(x_k) * L_{n-1}(x_k))

where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
is the k'th root of :math:`L_n`, and then scaling the results to get
the right value when integrating 1.
*)

val leggrid2d : y:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 2-D Legendre series on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \sum_{i,j} c_{i,j} * L_i(a) * L_j(b)

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape + y.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j is contained in `c[i,j]`. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional Chebyshev series at points in the
    Cartesian product of `x` and `y`.

See Also
--------
legval, legval2d, legval3d, leggrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val leggrid3d : y:Py.Object.t -> z:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.

This function returns the values:

.. math:: p(a,b,c) = \sum_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
legval, legval2d, leggrid2d, legval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val legint : ?m:int -> ?k:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `Bool of bool | `F of float | `S of string] -> ?lbnd:[`F of float | `I of int | `Bool of bool | `S of string] -> ?scl:[`F of float | `I of int | `Bool of bool | `S of string] -> ?axis:int -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Integrate a Legendre series.

Returns the Legendre series coefficients `c` integrated `m` times from
`lbnd` along `axis`. At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ('Buyer
beware': note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.)  The argument `c` is an array of
coefficients from low to high degree along each axis, e.g., [1,2,3]
represents the series ``L_0 + 2*L_1 + 3*L_2`` while [[1,2],[1,2]]
represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +
2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.

Parameters
----------
c : array_like
    Array of Legendre series coefficients. If c is multidimensional the
    different axis correspond to different variables with the degree in
    each axis given by the corresponding index.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at
    ``lbnd`` is the first value in the list, the value of the second
    integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
    default), all constants are set to zero.  If ``m == 1``, a single
    scalar can be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    Legendre series coefficient array of the integral.

Raises
------
ValueError
    If ``m < 0``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or
    ``np.ndim(scl) != 0``.

See Also
--------
legder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.
Why is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`.  Then
:math:`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a` - perhaps not what one would have first thought.

Also note that, in general, the result of integrating a C-series needs
to be 'reprojected' onto the C-series basis set.  Thus, typically,
the result of this function is 'unintuitive,' albeit correct; see
Examples section below.

Examples
--------
>>> from numpy.polynomial import legendre as L
>>> c = (1,2,3)
>>> L.legint(c)
array([ 0.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary
>>> L.legint(c, 3)
array([  1.66666667e-02,  -1.78571429e-02,   4.76190476e-02, # may vary
         -1.73472348e-18,   1.90476190e-02,   9.52380952e-03])
>>> L.legint(c, k=3)
 array([ 3.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary
>>> L.legint(c, lbnd=-2)
array([ 7.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary
>>> L.legint(c, scl=2)
array([ 0.66666667,  0.8       ,  1.33333333,  1.2       ]) # may vary
*)

val legline : off:Py.Object.t -> scl:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Legendre series whose graph is a straight line.



Parameters
----------
off, scl : scalars
    The specified line is given by ``off + scl*x``.

Returns
-------
y : ndarray
    This module's representation of the Legendre series for
    ``off + scl*x``.

See Also
--------
polyline, chebline

Examples
--------
>>> import numpy.polynomial.legendre as L
>>> L.legline(3,2)
array([3, 2])
>>> L.legval(-3, L.legline(3,2)) # should be -3
-3.0
*)

val legmul : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Multiply one Legendre series by another.

Returns the product of two Legendre series `c1` * `c2`.  The arguments
are sequences of coefficients, from lowest order 'term' to highest,
e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Legendre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Legendre series coefficients representing their product.

See Also
--------
legadd, legsub, legmulx, legdiv, legpow

Notes
-----
In general, the (polynomial) product of two C-series results in terms
that are not in the Legendre polynomial basis set.  Thus, to express
the product as a Legendre series, it is necessary to 'reproject' the
product onto said basis set, which may produce 'unintuitive' (but
correct) results; see Examples section below.

Examples
--------
>>> from numpy.polynomial import legendre as L
>>> c1 = (1,2,3)
>>> c2 = (3,2)
>>> L.legmul(c1,c2) # multiplication requires 'reprojection'
array([  4.33333333,  10.4       ,  11.66666667,   3.6       ]) # may vary
*)

val legmulx : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Multiply a Legendre series by x.

Multiply the Legendre series `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of Legendre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

See Also
--------
legadd, legmul, legmul, legdiv, legpow

Notes
-----
The multiplication uses the recursion relationship for Legendre
polynomials in the form

.. math::

  xP_i(x) = ((i + 1)*P_{i + 1}(x) + i*P_{i - 1}(x))/(2i + 1)

Examples
--------
>>> from numpy.polynomial import legendre as L
>>> L.legmulx([1,2,3])
array([ 0.66666667, 2.2, 1.33333333, 1.8]) # may vary
*)

val legpow : ?maxpower:int -> c:[>`Ndarray] Obj.t -> pow:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Raise a Legendre series to a power.

Returns the Legendre series `c` raised to the power `pow`. The
argument `c` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``

Parameters
----------
c : array_like
    1-D array of Legendre series coefficients ordered from low to
    high.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Legendre series of power.

See Also
--------
legadd, legsub, legmulx, legmul, legdiv

Examples
--------
*)

val legroots : Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the roots of a Legendre series.

Return the roots (a.k.a. 'zeros') of the polynomial

.. math:: p(x) = \sum_i c[i] * L_i(x).

Parameters
----------
c : 1-D array_like
    1-D array of coefficients.

Returns
-------
out : ndarray
    Array of the roots of the series. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
polyroots, chebroots, lagroots, hermroots, hermeroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the series for such values.
Roots with multiplicity greater than 1 will also show larger errors as
the value of the series near such points is relatively insensitive to
errors in the roots. Isolated roots near the origin can be improved by
a few iterations of Newton's method.

The Legendre series basis polynomials aren't powers of ``x`` so the
results of this function may seem unintuitive.

Examples
--------
>>> import numpy.polynomial.legendre as leg
>>> leg.legroots((1, 2, 3, 4)) # 4L_3 + 3L_2 + 2L_1 + 1L_0, all real roots
array([-0.85099543, -0.11407192,  0.51506735]) # may vary
*)

val legsub : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Subtract one Legendre series from another.

Returns the difference of two Legendre series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Legendre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Legendre series coefficients representing their difference.

See Also
--------
legadd, legmulx, legmul, legdiv, legpow

Notes
-----
Unlike multiplication, division, etc., the difference of two Legendre
series is a Legendre series (without having to 'reproject' the result
onto the basis set) so subtraction, just like that of 'standard'
polynomials, is simply 'component-wise.'

Examples
--------
>>> from numpy.polynomial import legendre as L
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> L.legsub(c1,c2)
array([-2.,  0.,  2.])
>>> L.legsub(c2,c1) # -C.legsub(c1,c2)
array([ 2.,  0., -2.])
*)

val legtrim : ?tol:[`F of float | `I of int] -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Remove 'small' 'trailing' coefficients from a polynomial.

'Small' means 'small in absolute value' and is controlled by the
parameter `tol`; 'trailing' means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be 'trimmed.'

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` < 0

See Also
--------
trimseq

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> pu.trimcoef((0,0,3,0,5,0,0))
array([0.,  0.,  3.,  0.,  5.])
>>> pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([0.])
>>> i = complex(0,1) # works for complex
>>> pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([0.0003+0.j   , 0.001 -0.001j])
*)

val legval : ?tensor:bool -> c:[>`Ndarray] Obj.t -> [`Compatible_object of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
Evaluate a Legendre series at points x.

If `c` is of length `n + 1`, this function returns the value:

.. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, algebra_like
    The shape of the return value is described above.

See Also
--------
legval2d, leggrid2d, legval3d, leggrid3d

Notes
-----
The evaluation uses Clenshaw recursion, aka synthetic division.

Examples
--------
*)

val legval2d : y:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 2-D Legendre series at points (x, y).

This function returns the values:

.. math:: p(x,y) = \sum_{i,j} c_{i,j} * L_i(x) * L_j(y)

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` is a 1-D array a one is implicitly appended to its shape to make
it 2-D. The shape of the result will be c.shape[2:] + x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and if it isn't an ndarray it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in ``c[i,j]``. If `c` has
    dimension greater than two the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional Legendre series at points formed
    from pairs of corresponding values from `x` and `y`.

See Also
--------
legval, leggrid2d, legval3d, leggrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val legval3d : y:Py.Object.t -> z:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 3-D Legendre series at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimensional polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
legval, legval2d, leggrid2d, leggrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val legvander : deg:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degree.

Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
`x`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., i] = L_i(x)

where `0 <= i <= deg`. The leading indices of `V` index the elements of
`x` and the last index is the degree of the Legendre polynomial.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
array ``V = legvander(x, n)``, then ``np.dot(V, c)`` and
``legval(x, c)`` are the same up to roundoff. This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of Legendre series of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray
    The pseudo-Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where The last index is the degree of the
    corresponding Legendre polynomial.  The dtype will be the same as
    the converted `x`.
*)

val legvander2d : y:Py.Object.t -> deg:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (deg[1] + 1)*i + j] = L_i(x) * L_j(y),

where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the degrees of
the Legendre polynomials.

If ``V = legvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``legval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D Legendre
series of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to
    1-D arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
legvander, legvander3d, legval2d, legval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val legvander3d : y:Py.Object.t -> z:Py.Object.t -> deg:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = L_i(x)*L_j(y)*L_k(z),

where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the degrees of the Legendre polynomials.

If ``V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and ``np.dot(V, c.flat)`` and ``legval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D Legendre
series of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
legvander, legvander3d, legval2d, legval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val legweight : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Weight function of the Legendre polynomials.

The weight function is :math:`1` and the interval of integration is
:math:`[-1, 1]`. The Legendre polynomials are orthogonal, but not
normalized, with respect to this weight function.

Parameters
----------
x : array_like
   Values at which the weight function will be computed.

Returns
-------
w : ndarray
   The weight function at `x`.

Notes
-----

.. versionadded:: 1.7.0
*)

val normalize_axis_index : ?msg_prefix:string -> axis:int -> ndim:int -> unit -> int
(**
normalize_axis_index(axis, ndim, msg_prefix=None)

Normalizes an axis index, `axis`, such that is a valid positive index into
the shape of array with `ndim` dimensions. Raises an AxisError with an
appropriate message if this is not possible.

Used internally by all axis-checking logic.

.. versionadded:: 1.13.0

Parameters
----------
axis : int
    The un-normalized index of the axis. Can be negative
ndim : int
    The number of dimensions of the array that `axis` should be normalized
    against
msg_prefix : str
    A prefix to put before the message, typically the name of the argument

Returns
-------
normalized_axis : int
    The normalized axis index, such that `0 <= normalized_axis < ndim`

Raises
------
AxisError
    If the axis index is invalid, when `-ndim <= axis < ndim` is false.

Examples
--------
>>> normalize_axis_index(0, ndim=3)
0
>>> normalize_axis_index(1, ndim=3)
1
>>> normalize_axis_index(-1, ndim=3)
2

>>> normalize_axis_index(3, ndim=3)
Traceback (most recent call last):
...
AxisError: axis 3 is out of bounds for array of dimension 3
>>> normalize_axis_index(-4, ndim=3, msg_prefix='axes_arg')
Traceback (most recent call last):
...
AxisError: axes_arg: axis -4 is out of bounds for array of dimension 3
*)

val poly2leg : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Convert a polynomial to a Legendre series.

Convert an array representing the coefficients of a polynomial (relative
to the 'standard' basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Legendre series, ordered
from lowest to highest degree.

Parameters
----------
pol : array_like
    1-D array containing the polynomial coefficients

Returns
-------
c : ndarray
    1-D array containing the coefficients of the equivalent Legendre
    series.

See Also
--------
leg2poly

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy import polynomial as P
>>> p = P.Polynomial(np.arange(4))
>>> p
Polynomial([0.,  1.,  2.,  3.], domain=[-1,  1], window=[-1,  1])
>>> c = P.Legendre(P.legendre.poly2leg(p.coef))
>>> c
Legendre([ 1.  ,  3.25,  1.  ,  0.75], domain=[-1,  1], window=[-1,  1]) # may vary
*)


end

module Polynomial' : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

val normalize_axis_index : ?msg_prefix:string -> axis:int -> ndim:int -> unit -> int
(**
normalize_axis_index(axis, ndim, msg_prefix=None)

Normalizes an axis index, `axis`, such that is a valid positive index into
the shape of array with `ndim` dimensions. Raises an AxisError with an
appropriate message if this is not possible.

Used internally by all axis-checking logic.

.. versionadded:: 1.13.0

Parameters
----------
axis : int
    The un-normalized index of the axis. Can be negative
ndim : int
    The number of dimensions of the array that `axis` should be normalized
    against
msg_prefix : str
    A prefix to put before the message, typically the name of the argument

Returns
-------
normalized_axis : int
    The normalized axis index, such that `0 <= normalized_axis < ndim`

Raises
------
AxisError
    If the axis index is invalid, when `-ndim <= axis < ndim` is false.

Examples
--------
>>> normalize_axis_index(0, ndim=3)
0
>>> normalize_axis_index(1, ndim=3)
1
>>> normalize_axis_index(-1, ndim=3)
2

>>> normalize_axis_index(3, ndim=3)
Traceback (most recent call last):
...
AxisError: axis 3 is out of bounds for array of dimension 3
>>> normalize_axis_index(-4, ndim=3, msg_prefix='axes_arg')
Traceback (most recent call last):
...
AxisError: axes_arg: axis -4 is out of bounds for array of dimension 3
*)

val polyadd : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Add one polynomial to another.

Returns the sum of two polynomials `c1` + `c2`.  The arguments are
sequences of coefficients from lowest order term to highest, i.e.,
[1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of polynomial coefficients ordered from low to high.

Returns
-------
out : ndarray
    The coefficient array representing their sum.

See Also
--------
polysub, polymulx, polymul, polydiv, polypow

Examples
--------
>>> from numpy.polynomial import polynomial as P
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> sum = P.polyadd(c1,c2); sum
array([4.,  4.,  4.])
>>> P.polyval(2, sum) # 4 + 4(2) + 4(2**2)
28.0
*)

val polycompanion : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the companion matrix of c.

The companion matrix for power series cannot be made symmetric by
scaling the basis, so this function differs from those for the
orthogonal polynomials.

Parameters
----------
c : array_like
    1-D array of polynomial coefficients ordered from low to high
    degree.

Returns
-------
mat : ndarray
    Companion matrix of dimensions (deg, deg).

Notes
-----

.. versionadded:: 1.7.0
*)

val polyder : ?m:int -> ?scl:[`F of float | `I of int | `Bool of bool | `S of string] -> ?axis:int -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Differentiate a polynomial.

Returns the polynomial coefficients `c` differentiated `m` times along
`axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable).  The
argument `c` is an array of coefficients from low to high degree along
each axis, e.g., [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``
while [[1,2],[1,2]] represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is
``x`` and axis=1 is ``y``.

Parameters
----------
c : array_like
    Array of polynomial coefficients. If c is multidimensional the
    different axis correspond to different variables with the degree
    in each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change
    of variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Polynomial coefficients of the derivative.

See Also
--------
polyint

Examples
--------
>>> from numpy.polynomial import polynomial as P
>>> c = (1,2,3,4) # 1 + 2x + 3x**2 + 4x**3
>>> P.polyder(c) # (d/dx)(c) = 2 + 6x + 12x**2
array([  2.,   6.,  12.])
>>> P.polyder(c,3) # (d**3/dx**3)(c) = 24
array([24.])
>>> P.polyder(c,scl=-1) # (d/d(-x))(c) = -2 - 6x - 12x**2
array([ -2.,  -6., -12.])
>>> P.polyder(c,2,-1) # (d**2/d(-x)**2)(c) = 6 + 24x
array([  6.,  24.])
*)

val polydiv : c1:Py.Object.t -> c2:Py.Object.t -> unit -> Py.Object.t
(**
Divide one polynomial by another.

Returns the quotient-with-remainder of two polynomials `c1` / `c2`.
The arguments are sequences of coefficients, from lowest order term
to highest, e.g., [1,2,3] represents ``1 + 2*x + 3*x**2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of polynomial coefficients ordered from low to high.

Returns
-------
[quo, rem] : ndarrays
    Of coefficient series representing the quotient and remainder.

See Also
--------
polyadd, polysub, polymulx, polymul, polypow

Examples
--------
>>> from numpy.polynomial import polynomial as P
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> P.polydiv(c1,c2)
(array([3.]), array([-8., -4.]))
>>> P.polydiv(c2,c1)
(array([ 0.33333333]), array([ 2.66666667,  1.33333333])) # may vary
*)

val polyfit : ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> y:[>`Ndarray] Obj.t -> deg:[`T1_D_array_like of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Least-squares fit of a polynomial to data.

Return the coefficients of a polynomial of degree `deg` that is the
least squares fit to the data values `y` given at points `x`. If `y` is
1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * x + ... + c_n * x^n,

where `n` is `deg`.

Parameters
----------
x : array_like, shape (`M`,)
    x-coordinates of the `M` sample (data) points ``(x[i], y[i])``.
y : array_like, shape (`M`,) or (`M`, `K`)
    y-coordinates of the sample points.  Several sets of sample points
    sharing the same x-coordinates can be (independently) fit with one
    call to `polyfit` by passing in for `y` a 2-D array that contains
    one data set per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
rcond : float, optional
    Relative condition number of the fit.  Singular values smaller
    than `rcond`, relative to the largest singular value, will be
    ignored.  The default value is ``len(x)*eps``, where `eps` is the
    relative precision of the platform's float type, about 2e-16 in
    most cases.
full : bool, optional
    Switch determining the nature of the return value.  When ``False``
    (the default) just the coefficients are returned; when ``True``,
    diagnostic information from the singular value decomposition (used
    to solve the fit's matrix equation) is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.

    .. versionadded:: 1.5.0

Returns
-------
coef : ndarray, shape (`deg` + 1,) or (`deg` + 1, `K`)
    Polynomial coefficients ordered from low to high.  If `y` was 2-D,
    the coefficients in column `k` of `coef` represent the polynomial
    fit to the data in `y`'s `k`-th column.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.

Raises
------
RankWarning
    Raised if the matrix in the least-squares fit is rank deficient.
    The warning is only raised if `full` == False.  The warnings can
    be turned off by:

    >>> import warnings
    >>> warnings.simplefilter('ignore', np.RankWarning)

See Also
--------
chebfit, legfit, lagfit, hermfit, hermefit
polyval : Evaluates a polynomial.
polyvander : Vandermonde matrix for powers.
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the polynomial `p` that minimizes
the sum of the weighted squared errors

.. math :: E = \sum_j w_j^2 * |y_j - p(x_j)|^2,

where the :math:`w_j` are the weights. This problem is solved by
setting up the (typically) over-determined matrix equation:

.. math :: V(x) * c = w * y,

where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
coefficients to be solved for, `w` are the weights, and `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected (and `full` == ``False``), a `RankWarning` will be raised.
This means that the coefficient values may be poorly determined.
Fitting to a lower order polynomial will usually get rid of the warning
(but may not be what you want, of course; if you have independent
reason(s) for choosing the degree which isn't working, you may have to:
a) reconsider those reasons, and/or b) reconsider the quality of your
data).  The `rcond` parameter can also be set to a value smaller than
its default, but the resulting fit may be spurious and have large
contributions from roundoff error.

Polynomial fits using double precision tend to 'fail' at about
(polynomial) degree 20. Fits using Chebyshev or Legendre series are
generally better conditioned, but much can still depend on the
distribution of the sample points and the smoothness of the data.  If
the quality of the fit is inadequate, splines may be a good
alternative.

Examples
--------
>>> np.random.seed(123)
>>> from numpy.polynomial import polynomial as P
>>> x = np.linspace(-1,1,51) # x 'data': [-1, -0.96, ..., 0.96, 1]
>>> y = x**3 - x + np.random.randn(len(x)) # x^3 - x + N(0,1) 'noise'
>>> c, stats = P.polyfit(x,y,3,full=True)
>>> np.random.seed(123)
>>> c # c[0], c[2] should be approx. 0, c[1] approx. -1, c[3] approx. 1
array([ 0.01909725, -1.30598256, -0.00577963,  1.02644286]) # may vary
>>> stats # note the large SSR, explaining the rather poor results
 [array([ 38.06116253]), 4, array([ 1.38446749,  1.32119158,  0.50443316, # may vary
          0.28853036]), 1.1324274851176597e-014]

Same thing without the added noise

>>> y = x**3 - x
>>> c, stats = P.polyfit(x,y,3,full=True)
>>> c # c[0], c[2] should be 'very close to 0', c[1] ~= -1, c[3] ~= 1
array([-6.36925336e-18, -1.00000000e+00, -4.08053781e-16,  1.00000000e+00])
>>> stats # note the minuscule SSR
[array([  7.46346754e-31]), 4, array([ 1.38446749,  1.32119158, # may vary
           0.50443316,  0.28853036]), 1.1324274851176597e-014]
*)

val polyfromroots : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Generate a monic polynomial with given roots.

Return the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

where the `r_n` are the roots specified in `roots`.  If a zero has
multiplicity n, then it must appear in `roots` n times. For instance,
if 2 is a root of multiplicity three and 3 is a root of multiplicity 2,
then `roots` looks something like [2, 2, 2, 3, 3]. The roots can appear
in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * x + ... +  x^n

The coefficient of the last term is 1 for monic polynomials in this
form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of the polynomial's coefficients If all the roots are
    real, then `out` is also real, otherwise it is complex.  (see
    Examples below).

See Also
--------
chebfromroots, legfromroots, lagfromroots, hermfromroots
hermefromroots

Notes
-----
The coefficients are determined by multiplying together linear factors
of the form `(x - r_i)`, i.e.

.. math:: p(x) = (x - r_0) (x - r_1) ... (x - r_n)

where ``n == len(roots) - 1``; note that this implies that `1` is always
returned for :math:`a_n`.

Examples
--------
>>> from numpy.polynomial import polynomial as P
>>> P.polyfromroots((-1,0,1)) # x(x - 1)(x + 1) = x^3 - x
array([ 0., -1.,  0.,  1.])
>>> j = complex(0,1)
>>> P.polyfromroots((-j,j)) # complex returned, though values are real
array([1.+0.j,  0.+0.j,  1.+0.j])
*)

val polygrid2d : y:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 2-D polynomial on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \sum_{i,j} c_{i,j} * a^i * b^j

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape + y.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
polyval, polyval2d, polyval3d, polygrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val polygrid3d : y:Py.Object.t -> z:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 3-D polynomial on the Cartesian product of x, y and z.

This function returns the values:

.. math:: p(a,b,c) = \sum_{i,j,k} c_{i,j,k} * a^i * b^j * c^k

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
polyval, polyval2d, polygrid2d, polyval3d

Notes
-----

.. versionadded:: 1.7.0
*)

val polyint : ?m:int -> ?k:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `T_ of Py.Object.t | `Bool of bool | `F of float | `S of string] -> ?lbnd:[`F of float | `I of int | `Bool of bool | `S of string] -> ?scl:[`F of float | `I of int | `Bool of bool | `S of string] -> ?axis:int -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Integrate a polynomial.

Returns the polynomial coefficients `c` integrated `m` times from
`lbnd` along `axis`.  At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ('Buyer
beware': note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.) The argument `c` is an array of
coefficients, from low to high degree along each axis, e.g., [1,2,3]
represents the polynomial ``1 + 2*x + 3*x**2`` while [[1,2],[1,2]]
represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is ``x`` and axis=1 is
``y``.

Parameters
----------
c : array_like
    1-D array of polynomial coefficients, ordered from low to high.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at zero
    is the first value in the list, the value of the second integral
    at zero is the second value, etc.  If ``k == []`` (the default),
    all constants are set to zero.  If ``m == 1``, a single scalar can
    be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    Coefficient array of the integral.

Raises
------
ValueError
    If ``m < 1``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or
    ``np.ndim(scl) != 0``.

See Also
--------
polyder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.  Why
is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`. Then
:math:`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a` - perhaps not what one would have first thought.

Examples
--------
>>> from numpy.polynomial import polynomial as P
>>> c = (1,2,3)
>>> P.polyint(c) # should return array([0, 1, 1, 1])
array([0.,  1.,  1.,  1.])
>>> P.polyint(c,3) # should return array([0, 0, 0, 1/6, 1/12, 1/20])
 array([ 0.        ,  0.        ,  0.        ,  0.16666667,  0.08333333, # may vary
         0.05      ])
>>> P.polyint(c,k=3) # should return array([3, 1, 1, 1])
array([3.,  1.,  1.,  1.])
>>> P.polyint(c,lbnd=-2) # should return array([6, 1, 1, 1])
array([6.,  1.,  1.,  1.])
>>> P.polyint(c,scl=-2) # should return array([0, -2, -2, -2])
array([ 0., -2., -2., -2.])
*)

val polyline : off:Py.Object.t -> scl:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Returns an array representing a linear polynomial.

Parameters
----------
off, scl : scalars
    The 'y-intercept' and 'slope' of the line, respectively.

Returns
-------
y : ndarray
    This module's representation of the linear polynomial ``off +
    scl*x``.

See Also
--------
chebline

Examples
--------
>>> from numpy.polynomial import polynomial as P
>>> P.polyline(1,-1)
array([ 1, -1])
>>> P.polyval(1, P.polyline(1,-1)) # should be 0
0.0
*)

val polymul : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Multiply one polynomial by another.

Returns the product of two polynomials `c1` * `c2`.  The arguments are
sequences of coefficients, from lowest order term to highest, e.g.,
[1,2,3] represents the polynomial ``1 + 2*x + 3*x**2.``

Parameters
----------
c1, c2 : array_like
    1-D arrays of coefficients representing a polynomial, relative to the
    'standard' basis, and ordered from lowest order term to highest.

Returns
-------
out : ndarray
    Of the coefficients of their product.

See Also
--------
polyadd, polysub, polymulx, polydiv, polypow

Examples
--------
>>> from numpy.polynomial import polynomial as P
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> P.polymul(c1,c2)
array([  3.,   8.,  14.,   8.,   3.])
*)

val polymulx : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Multiply a polynomial by x.

Multiply the polynomial `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of polynomial coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

See Also
--------
polyadd, polysub, polymul, polydiv, polypow

Notes
-----

.. versionadded:: 1.5.0
*)

val polypow : ?maxpower:int -> c:[>`Ndarray] Obj.t -> pow:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Raise a polynomial to a power.

Returns the polynomial `c` raised to the power `pow`. The argument
`c` is a sequence of coefficients ordered from low to high. i.e.,
[1,2,3] is the series  ``1 + 2*x + 3*x**2.``

Parameters
----------
c : array_like
    1-D array of array of series coefficients ordered from low to
    high degree.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Power series of power.

See Also
--------
polyadd, polysub, polymulx, polymul, polydiv

Examples
--------
>>> from numpy.polynomial import polynomial as P
>>> P.polypow([1,2,3], 2)
array([ 1., 4., 10., 12., 9.])
*)

val polyroots : Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the roots of a polynomial.

Return the roots (a.k.a. 'zeros') of the polynomial

.. math:: p(x) = \sum_i c[i] * x^i.

Parameters
----------
c : 1-D array_like
    1-D array of polynomial coefficients.

Returns
-------
out : ndarray
    Array of the roots of the polynomial. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
chebroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the power series for such
values. Roots with multiplicity greater than 1 will also show larger
errors as the value of the series near such points is relatively
insensitive to errors in the roots. Isolated roots near the origin can
be improved by a few iterations of Newton's method.

Examples
--------
>>> import numpy.polynomial.polynomial as poly
>>> poly.polyroots(poly.polyfromroots((-1,0,1)))
array([-1.,  0.,  1.])
>>> poly.polyroots(poly.polyfromroots((-1,0,1))).dtype
dtype('float64')
>>> j = complex(0,1)
>>> poly.polyroots(poly.polyfromroots((-j,0,j)))
array([  0.00000000e+00+0.j,   0.00000000e+00+1.j,   2.77555756e-17-1.j]) # may vary
*)

val polysub : c1:Py.Object.t -> c2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Subtract one polynomial from another.

Returns the difference of two polynomials `c1` - `c2`.  The arguments
are sequences of coefficients from lowest order term to highest, i.e.,
[1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of polynomial coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of coefficients representing their difference.

See Also
--------
polyadd, polymulx, polymul, polydiv, polypow

Examples
--------
>>> from numpy.polynomial import polynomial as P
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> P.polysub(c1,c2)
array([-2.,  0.,  2.])
>>> P.polysub(c2,c1) # -P.polysub(c1,c2)
array([ 2.,  0., -2.])
*)

val polytrim : ?tol:[`F of float | `I of int] -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Remove 'small' 'trailing' coefficients from a polynomial.

'Small' means 'small in absolute value' and is controlled by the
parameter `tol`; 'trailing' means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be 'trimmed.'

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` < 0

See Also
--------
trimseq

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> pu.trimcoef((0,0,3,0,5,0,0))
array([0.,  0.,  3.,  0.,  5.])
>>> pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([0.])
>>> i = complex(0,1) # works for complex
>>> pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([0.0003+0.j   , 0.001 -0.001j])
*)

val polyval : ?tensor:bool -> c:[>`Ndarray] Obj.t -> [`Compatible_object of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
Evaluate a polynomial at points x.

If `c` is of length `n + 1`, this function returns the value

.. math:: p(x) = c_0 + c_1 * x + ... + c_n * x^n

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, compatible object
    The shape of the returned array is described above.

See Also
--------
polyval2d, polygrid2d, polyval3d, polygrid3d

Notes
-----
The evaluation uses Horner's method.

Examples
--------
>>> from numpy.polynomial.polynomial import polyval
>>> polyval(1, [1,2,3])
6.0
>>> a = np.arange(4).reshape(2,2)
>>> a
array([[0, 1],
       [2, 3]])
>>> polyval(a, [1,2,3])
array([[ 1.,   6.],
       [17.,  34.]])
>>> coef = np.arange(4).reshape(2,2) # multidimensional coefficients
>>> coef
array([[0, 1],
       [2, 3]])
>>> polyval([1,2], coef, tensor=True)
array([[2.,  4.],
       [4.,  7.]])
>>> polyval([1,2], coef, tensor=False)
array([2.,  7.])
*)

val polyval2d : y:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 2-D polynomial at points (x, y).

This function returns the value

.. math:: p(x,y) = \sum_{i,j} c_{i,j} * x^i * y^j

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in `c[i,j]`. If `c` has
    dimension greater than two the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points formed with
    pairs of corresponding values from `x` and `y`.

See Also
--------
polyval, polygrid2d, polyval3d, polygrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val polyval3d : y:Py.Object.t -> z:Py.Object.t -> c:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Evaluate a 3-D polynomial at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \sum_{i,j,k} c_{i,j,k} * x^i * y^j * z^k

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimensional polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
polyval, polyval2d, polygrid2d, polygrid3d

Notes
-----

.. versionadded:: 1.7.0
*)

val polyvalfromroots : ?tensor:bool -> r:[>`Ndarray] Obj.t -> [`Compatible_object of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
Evaluate a polynomial specified by its roots at points x.

If `r` is of length `N`, this function returns the value

.. math:: p(x) = \prod_{n=1}^{N} (x - r_n)

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `r`.

If `r` is a 1-D array, then `p(x)` will have the same shape as `x`.  If `r`
is multidimensional, then the shape of the result depends on the value of
`tensor`. If `tensor is ``True`` the shape will be r.shape[1:] + x.shape;
that is, each polynomial is evaluated at every value of `x`. If `tensor` is
``False``, the shape will be r.shape[1:]; that is, each polynomial is
evaluated only for the corresponding broadcast value of `x`. Note that
scalars have shape (,).

.. versionadded:: 1.12

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `r`.
r : array_like
    Array of roots. If `r` is multidimensional the first index is the
    root index, while the remaining indices enumerate multiple
    polynomials. For instance, in the two dimensional case the roots
    of each polynomial may be thought of as stored in the columns of `r`.
tensor : boolean, optional
    If True, the shape of the roots array is extended with ones on the
    right, one for each dimension of `x`. Scalars have dimension 0 for this
    action. The result is that every column of coefficients in `r` is
    evaluated for every element of `x`. If False, `x` is broadcast over the
    columns of `r` for the evaluation.  This keyword is useful when `r` is
    multidimensional. The default value is True.

Returns
-------
values : ndarray, compatible object
    The shape of the returned array is described above.

See Also
--------
polyroots, polyfromroots, polyval

Examples
--------
>>> from numpy.polynomial.polynomial import polyvalfromroots
>>> polyvalfromroots(1, [1,2,3])
0.0
>>> a = np.arange(4).reshape(2,2)
>>> a
array([[0, 1],
       [2, 3]])
>>> polyvalfromroots(a, [-1, 0, 1])
array([[-0.,   0.],
       [ 6.,  24.]])
>>> r = np.arange(-2, 2).reshape(2,2) # multidimensional coefficients
>>> r # each column of r defines one polynomial
array([[-2, -1],
       [ 0,  1]])
>>> b = [-2, 1]
>>> polyvalfromroots(b, r, tensor=True)
array([[-0.,  3.],
       [ 3., 0.]])
>>> polyvalfromroots(b, r, tensor=False)
array([-0.,  0.])
*)

val polyvander : deg:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Vandermonde matrix of given degree.

Returns the Vandermonde matrix of degree `deg` and sample points
`x`. The Vandermonde matrix is defined by

.. math:: V[..., i] = x^i,

where `0 <= i <= deg`. The leading indices of `V` index the elements of
`x` and the last index is the power of `x`.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
matrix ``V = polyvander(x, n)``, then ``np.dot(V, c)`` and
``polyval(x, c)`` are the same up to roundoff. This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of polynomials of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray.
    The Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where the last index is the power of `x`.
    The dtype will be the same as the converted `x`.

See Also
--------
polyvander2d, polyvander3d
*)

val polyvander2d : y:Py.Object.t -> deg:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (deg[1] + 1)*i + j] = x^i * y^j,

where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the powers of
`x` and `y`.

If ``V = polyvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``polyval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D polynomials
of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to
    1-D arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
polyvander, polyvander3d, polyval2d, polyval3d
*)

val polyvander3d : y:Py.Object.t -> z:Py.Object.t -> deg:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = x^i * y^j * z^k,

where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the powers of `x`, `y`, and `z`.

If ``V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and  ``np.dot(V, c.flat)`` and ``polyval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D polynomials
of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
polyvander, polyvander3d, polyval2d, polyval3d

Notes
-----

.. versionadded:: 1.7.0
*)


end

module Polyutils : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

module PolyBase : sig
type tag = [`PolyBase]
type t = [`Object | `PolyBase] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : unit -> t
(**
Base class for all polynomial types.

Deprecated in numpy 1.9.0, use the abstract
ABCPolyBase class instead. Note that the latter
requires a number of virtual functions to be
implemented.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module PolyDomainError : sig
type tag = [`PolyDomainError]
type t = [`BaseException | `Object | `PolyDomainError] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module PolyError : sig
type tag = [`PolyError]
type t = [`BaseException | `Object | `PolyError] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module RankWarning : sig
type tag = [`RankWarning]
type t = [`BaseException | `Object | `RankWarning] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val as_exception : t -> [`BaseException] Obj.t
val with_traceback : tb:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

val as_series : ?trim:bool -> alist:[>`Ndarray] Obj.t -> unit -> Py.Object.t
(**
Return argument as a list of 1-d arrays.

The returned list contains array(s) of dtype double, complex double, or
object.  A 1-d argument of shape ``(N,)`` is parsed into ``N`` arrays of
size one; a 2-d argument of shape ``(M,N)`` is parsed into ``M`` arrays
of size ``N`` (i.e., is 'parsed by row'); and a higher dimensional array
raises a Value Error if it is not first reshaped into either a 1-d or 2-d
array.

Parameters
----------
alist : array_like
    A 1- or 2-d array_like
trim : boolean, optional
    When True, trailing zeros are removed from the inputs.
    When False, the inputs are passed through intact.

Returns
-------
[a1, a2,...] : list of 1-D arrays
    A copy of the input data as a list of 1-d arrays.

Raises
------
ValueError
    Raised when `as_series` cannot convert its input to 1-d arrays, or at
    least one of the resulting arrays is empty.

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> a = np.arange(4)
>>> pu.as_series(a)
[array([0.]), array([1.]), array([2.]), array([3.])]
>>> b = np.arange(6).reshape((2,3))
>>> pu.as_series(b)
[array([0., 1., 2.]), array([3., 4., 5.])]

>>> pu.as_series((1, np.arange(3), np.arange(2, dtype=np.float16)))
[array([1.]), array([0., 1., 2.]), array([0., 1.])]

>>> pu.as_series([2, [1.1, 0.]])
[array([2.]), array([1.1])]

>>> pu.as_series([2, [1.1, 0.]], trim=False)
[array([2.]), array([1.1, 0. ])]
*)

val getdomain : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a domain suitable for given abscissae.

Find a domain suitable for a polynomial or Chebyshev series
defined at the values supplied.

Parameters
----------
x : array_like
    1-d array of abscissae whose domain will be determined.

Returns
-------
domain : ndarray
    1-d array containing two values.  If the inputs are complex, then
    the two returned points are the lower left and upper right corners
    of the smallest rectangle (aligned with the axes) in the complex
    plane containing the points `x`. If the inputs are real, then the
    two points are the ends of the smallest interval containing the
    points `x`.

See Also
--------
mapparms, mapdomain

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> points = np.arange(4)**2 - 5; points
array([-5, -4, -1,  4])
>>> pu.getdomain(points)
array([-5.,  4.])
>>> c = np.exp(complex(0,1)*np.pi*np.arange(12)/6) # unit circle
>>> pu.getdomain(c)
array([-1.-1.j,  1.+1.j])
*)

val mapdomain : old:Py.Object.t -> new_:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Apply linear map to input points.

The linear map ``offset + scale*x`` that maps the domain `old` to
the domain `new` is applied to the points `x`.

Parameters
----------
x : array_like
    Points to be mapped. If `x` is a subtype of ndarray the subtype
    will be preserved.
old, new : array_like
    The two domains that determine the map.  Each must (successfully)
    convert to 1-d arrays containing precisely two values.

Returns
-------
x_out : ndarray
    Array of points of the same shape as `x`, after application of the
    linear map between the two domains.

See Also
--------
getdomain, mapparms

Notes
-----
Effectively, this implements:

.. math ::
    x\_out = new[0] + m(x - old[0])

where

.. math ::
    m = \frac{new[1]-new[0]}{old[1]-old[0]}

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> old_domain = (-1,1)
>>> new_domain = (0,2*np.pi)
>>> x = np.linspace(-1,1,6); x
array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ])
>>> x_out = pu.mapdomain(x, old_domain, new_domain); x_out
array([ 0.        ,  1.25663706,  2.51327412,  3.76991118,  5.02654825, # may vary
        6.28318531])
>>> x - pu.mapdomain(x_out, new_domain, old_domain)
array([0., 0., 0., 0., 0., 0.])

Also works for complex numbers (and thus can be used to map any line in
the complex plane to any other line therein).

>>> i = complex(0,1)
>>> old = (-1 - i, 1 + i)
>>> new = (-1 + i, 1 - i)
>>> z = np.linspace(old[0], old[1], 6); z
array([-1. -1.j , -0.6-0.6j, -0.2-0.2j,  0.2+0.2j,  0.6+0.6j,  1. +1.j ])
>>> new_z = pu.mapdomain(z, old, new); new_z
array([-1.0+1.j , -0.6+0.6j, -0.2+0.2j,  0.2-0.2j,  0.6-0.6j,  1.0-1.j ]) # may vary
*)

val mapparms : old:Py.Object.t -> new_:Py.Object.t -> unit -> Py.Object.t
(**
Linear map parameters between domains.

Return the parameters of the linear map ``offset + scale*x`` that maps
`old` to `new` such that ``old[i] -> new[i]``, ``i = 0, 1``.

Parameters
----------
old, new : array_like
    Domains. Each domain must (successfully) convert to a 1-d array
    containing precisely two values.

Returns
-------
offset, scale : scalars
    The map ``L(x) = offset + scale*x`` maps the first domain to the
    second.

See Also
--------
getdomain, mapdomain

Notes
-----
Also works for complex numbers, and thus can be used to calculate the
parameters required to map any line in the complex plane to any other
line therein.

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> pu.mapparms((-1,1),(-1,1))
(0.0, 1.0)
>>> pu.mapparms((1,-1),(-1,1))
(-0.0, -1.0)
>>> i = complex(0,1)
>>> pu.mapparms((-i,-1),(1,i))
((1+1j), (1-0j))
*)

val trimcoef : ?tol:[`F of float | `I of int] -> c:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Remove 'small' 'trailing' coefficients from a polynomial.

'Small' means 'small in absolute value' and is controlled by the
parameter `tol`; 'trailing' means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be 'trimmed.'

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` < 0

See Also
--------
trimseq

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> pu.trimcoef((0,0,3,0,5,0,0))
array([0.,  0.,  3.,  0.,  5.])
>>> pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([0.])
>>> i = complex(0,1) # works for complex
>>> pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([0.0003+0.j   , 0.001 -0.001j])
*)

val trimseq : Py.Object.t -> Py.Object.t
(**
Remove small Poly series coefficients.

Parameters
----------
seq : sequence
    Sequence of Poly series coefficients. This routine fails for
    empty sequences.

Returns
-------
series : sequence
    Subsequence with trailing zeros removed. If the resulting sequence
    would be empty, return the first element. The returned sequence may
    or may not be a view.

Notes
-----
Do not lose the type info if the sequence contains unknown objects.
*)


end


end

module Random : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

module BitGenerator : sig
type tag = [`BitGenerator]
type t = [`BitGenerator | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?seed:[`I of int | `PyObject of Py.Object.t] -> unit -> t
(**
BitGenerator(seed=None)

Base Class for generic BitGenerators, which provide a stream
of random bits based on different algorithms. Must be overridden.

Parameters
----------
seed : {None, int, array_like[ints], SeedSequence}, optional
    A seed to initialize the `BitGenerator`. If None, then fresh,
    unpredictable entropy will be pulled from the OS. If an ``int`` or
    ``array_like[ints]`` is passed, then it will be passed to
    ~`numpy.random.SeedSequence` to derive the initial `BitGenerator` state.
    One may also pass in a `SeedSequence` instance.

Attributes
----------
lock : threading.Lock
    Lock instance that is shared so that the same BitGenerator can
    be used in multiple Generators without corrupting the state. Code that
    generates values from a bit generator should hold the bit generator's
    lock.

See Also
-------
SeedSequence
*)

val random_raw : ?size:int list -> [> tag] Obj.t -> Py.Object.t
(**
random_raw(self, size=None)

Return randoms as generated by the underlying BitGenerator

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.
output : bool, optional
    Output values.  Used for performance testing since the generated
    values are not returned.

Returns
-------
out : uint or ndarray
    Drawn samples.

Notes
-----
This method directly exposes the the raw underlying pseudo-random
number generator. All values are returned as unsigned 64-bit
values irrespective of the number of bits produced by the PRNG.

See the class docstring for the number of bits returned.
*)


(** Attribute lock: get value or raise Not_found if None.*)
val lock : t -> Py.Object.t

(** Attribute lock: get value as an option. *)
val lock_opt : t -> (Py.Object.t) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Generator : sig
type tag = [`Generator]
type t = [`Generator | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : Py.Object.t -> t
(**
Generator(bit_generator)

Container for the BitGenerators.

``Generator`` exposes a number of methods for generating random
numbers drawn from a variety of probability distributions. In addition to
the distribution-specific arguments, each method takes a keyword argument
`size` that defaults to ``None``. If `size` is ``None``, then a single
value is generated and returned. If `size` is an integer, then a 1-D
array filled with generated values is returned. If `size` is a tuple,
then an array with that shape is filled and returned.

The function :func:`numpy.random.default_rng` will instantiate
a `Generator` with numpy's default `BitGenerator`.

**No Compatibility Guarantee**

``Generator`` does not provide a version compatibility guarantee. In
particular, as better algorithms evolve the bit stream may change.

Parameters
----------
bit_generator : BitGenerator
    BitGenerator to use as the core generator.

Notes
-----
The Python stdlib module `random` contains pseudo-random number generator
with a number of methods that are similar to the ones available in
``Generator``. It uses Mersenne Twister, and this bit generator can
be accessed using ``MT19937``. ``Generator``, besides being
NumPy-aware, has the advantage that it provides a much larger number
of probability distributions to choose from.

Examples
--------
>>> from numpy.random import Generator, PCG64
>>> rg = Generator(PCG64())
>>> rg.standard_normal()
-0.203  # random

See Also
--------
default_rng : Recommended constructor for `Generator`.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module MT19937 : sig
type tag = [`MT19937]
type t = [`MT19937 | `Object] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?seed:[`I of int | `PyObject of Py.Object.t] -> unit -> t
(**
MT19937(seed=None)

Container for the Mersenne Twister pseudo-random number generator.

Parameters
----------
seed : {None, int, array_like[ints], SeedSequence}, optional
    A seed to initialize the `BitGenerator`. If None, then fresh,
    unpredictable entropy will be pulled from the OS. If an ``int`` or
    ``array_like[ints]`` is passed, then it will be passed to
    `SeedSequence` to derive the initial `BitGenerator` state. One may also
    pass in a `SeedSequence` instance.

Attributes
----------
lock: threading.Lock
    Lock instance that is shared so that the same bit git generator can
    be used in multiple Generators without corrupting the state. Code that
    generates values from a bit generator should hold the bit generator's
    lock.

Notes
-----
``MT19937`` provides a capsule containing function pointers that produce
doubles, and unsigned 32 and 64- bit integers [1]_. These are not
directly consumable in Python and must be consumed by a ``Generator``
or similar object that supports low-level access.

The Python stdlib module 'random' also contains a Mersenne Twister
pseudo-random number generator.

**State and Seeding**

The ``MT19937`` state vector consists of a 624-element array of
32-bit unsigned integers plus a single integer value between 0 and 624
that indexes the current position within the main array.

The input seed is processed by `SeedSequence` to fill the whole state. The
first element is reset such that only its most significant bit is set.

**Parallel Features**

The preferred way to use a BitGenerator in parallel applications is to use
the `SeedSequence.spawn` method to obtain entropy values, and to use these
to generate new BitGenerators:

>>> from numpy.random import Generator, MT19937, SeedSequence
>>> sg = SeedSequence(1234)
>>> rg = [Generator(MT19937(s)) for s in sg.spawn(10)]

Another method is to use `MT19937.jumped` which advances the state as-if
:math:`2^{128}` random numbers have been generated ([1]_, [2]_). This
allows the original sequence to be split so that distinct segments can be
used in each worker process. All generators should be chained to ensure
that the segments come from the same sequence.

>>> from numpy.random import Generator, MT19937, SeedSequence
>>> sg = SeedSequence(1234)
>>> bit_generator = MT19937(sg)
>>> rg = []
>>> for _ in range(10):
...    rg.append(Generator(bit_generator))
...    # Chain the BitGenerators
...    bit_generator = bit_generator.jumped()

**Compatibility Guarantee**

``MT19937`` makes a guarantee that a fixed seed and will always produce
the same random integer stream.

References
----------
.. [1] Hiroshi Haramoto, Makoto Matsumoto, and Pierre L'Ecuyer, 'A Fast
    Jump Ahead Algorithm for Linear Recurrences in a Polynomial Space',
    Sequences and Their Applications - SETA, 290--298, 2008.
.. [2] Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Franois
    Panneton, Pierre L'Ecuyer, 'Efficient Jump Ahead for F2-Linear
    Random Number Generators', INFORMS JOURNAL ON COMPUTING, Vol. 20,
    No. 3, Summer 2008, pp. 385-390.
*)

val jumped : ?jumps:[`I of int | `Positive of Py.Object.t] -> [> tag] Obj.t -> Py.Object.t
(**
jumped(jumps=1)

Returns a new bit generator with the state jumped

The state of the returned big generator is jumped as-if
2**(128 * jumps) random numbers have been generated.

Parameters
----------
jumps : integer, positive
    Number of times to jump the state of the bit generator returned

Returns
-------
bit_generator : MT19937
    New instance of generator jumped iter times
*)


(** Attribute lock: get value or raise Not_found if None.*)
val lock : t -> Py.Object.t

(** Attribute lock: get value as an option. *)
val lock_opt : t -> (Py.Object.t) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module PCG64 : sig
type tag = [`PCG64]
type t = [`Object | `PCG64] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?seed_seq:Py.Object.t -> unit -> t
(**
PCG64(seed_seq=None)

BitGenerator for the PCG-64 pseudo-random number generator.

Parameters
----------
seed : {None, int, array_like[ints], SeedSequence}, optional
    A seed to initialize the `BitGenerator`. If None, then fresh,
    unpredictable entropy will be pulled from the OS. If an ``int`` or
    ``array_like[ints]`` is passed, then it will be passed to
    `SeedSequence` to derive the initial `BitGenerator` state. One may also
    pass in a `SeedSequence` instance.

Notes
-----
PCG-64 is a 128-bit implementation of O'Neill's permutation congruential
generator ([1]_, [2]_). PCG-64 has a period of :math:`2^{128}` and supports
advancing an arbitrary number of steps as well as :math:`2^{127}` streams.
The specific member of the PCG family that we use is PCG XSL RR 128/64
as described in the paper ([2]_).

``PCG64`` provides a capsule containing function pointers that produce
doubles, and unsigned 32 and 64- bit integers. These are not
directly consumable in Python and must be consumed by a ``Generator``
or similar object that supports low-level access.

Supports the method :meth:`advance` to advance the RNG an arbitrary number of
steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned
integers.

**State and Seeding**

The ``PCG64`` state vector consists of 2 unsigned 128-bit values,
which are represented externally as Python ints. One is the state of the
PRNG, which is advanced by a linear congruential generator (LCG). The
second is a fixed odd increment used in the LCG.

The input seed is processed by `SeedSequence` to generate both values. The
increment is not independently settable.

**Parallel Features**

The preferred way to use a BitGenerator in parallel applications is to use
the `SeedSequence.spawn` method to obtain entropy values, and to use these
to generate new BitGenerators:

>>> from numpy.random import Generator, PCG64, SeedSequence
>>> sg = SeedSequence(1234)
>>> rg = [Generator(PCG64(s)) for s in sg.spawn(10)]

**Compatibility Guarantee**

``PCG64`` makes a guarantee that a fixed seed and will always produce
the same random integer stream.

References
----------
.. [1] `'PCG, A Family of Better Random Number Generators'
       <http://www.pcg-random.org/>`_
.. [2] O'Neill, Melissa E. `'PCG: A Family of Simple Fast Space-Efficient
       Statistically Good Algorithms for Random Number Generation'
       <https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf>`_
*)

val advance : delta:[`I of int | `Positive of Py.Object.t] -> [> tag] Obj.t -> t
(**
advance(delta)

Advance the underlying RNG as-if delta draws have occurred.

Parameters
----------
delta : integer, positive
    Number of draws to advance the RNG. Must be less than the
    size state variable in the underlying RNG.

Returns
-------
self : PCG64
    RNG advanced delta steps

Notes
-----
Advancing a RNG updates the underlying RNG state as-if a given
number of calls to the underlying RNG have been made. In general
there is not a one-to-one relationship between the number output
random values from a particular distribution and the number of
draws from the core RNG.  This occurs for two reasons:

* The random values are simulated using a rejection-based method
  and so, on average, more than one value from the underlying
  RNG is required to generate an single draw.
* The number of bits required to generate a simulated value
  differs from the number of bits generated by the underlying
  RNG.  For example, two 16-bit integer values can be simulated
  from a single draw of a 32-bit RNG.

Advancing the RNG state resets any pre-computed random numbers.
This is required to ensure exact reproducibility.
*)

val jumped : ?jumps:[`I of int | `Positive of Py.Object.t] -> [> tag] Obj.t -> Py.Object.t
(**
jumped(jumps=1)

Returns a new bit generator with the state jumped.

Jumps the state as-if jumps * 210306068529402873165736369884012333109
random numbers have been generated.

Parameters
----------
jumps : integer, positive
    Number of times to jump the state of the bit generator returned

Returns
-------
bit_generator : PCG64
    New instance of generator jumped iter times

Notes
-----
The step size is phi-1 when multiplied by 2**128 where phi is the
golden ratio.
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Philox : sig
type tag = [`Philox]
type t = [`Object | `Philox] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?seed:[`I of int | `PyObject of Py.Object.t] -> ?counter:[`I of int | `Ndarray of [>`Ndarray] Obj.t] -> ?key:[`I of int | `Ndarray of [>`Ndarray] Obj.t] -> unit -> t
(**
Philox(seed=None, counter=None, key=None)

Container for the Philox (4x64) pseudo-random number generator.

Parameters
----------
seed : {None, int, array_like[ints], SeedSequence}, optional
    A seed to initialize the `BitGenerator`. If None, then fresh,
    unpredictable entropy will be pulled from the OS. If an ``int`` or
    ``array_like[ints]`` is passed, then it will be passed to
    `SeedSequence` to derive the initial `BitGenerator` state. One may also
    pass in a `SeedSequence` instance.
counter : {None, int, array_like}, optional
    Counter to use in the Philox state. Can be either
    a Python int (long in 2.x) in [0, 2**256) or a 4-element uint64 array.
    If not provided, the RNG is initialized at 0.
key : {None, int, array_like}, optional
    Key to use in the Philox state.  Unlike ``seed``, the value in key is
    directly set. Can be either a Python int in [0, 2**128) or a 2-element
    uint64 array. `key` and ``seed`` cannot both be used.

Attributes
----------
lock: threading.Lock
    Lock instance that is shared so that the same bit git generator can
    be used in multiple Generators without corrupting the state. Code that
    generates values from a bit generator should hold the bit generator's
    lock.

Notes
-----
Philox is a 64-bit PRNG that uses a counter-based design based on weaker
(and faster) versions of cryptographic functions [1]_. Instances using
different values of the key produce independent sequences.  Philox has a
period of :math:`2^{256} - 1` and supports arbitrary advancing and jumping
the sequence in increments of :math:`2^{128}`. These features allow
multiple non-overlapping sequences to be generated.

``Philox`` provides a capsule containing function pointers that produce
doubles, and unsigned 32 and 64- bit integers. These are not
directly consumable in Python and must be consumed by a ``Generator``
or similar object that supports low-level access.

**State and Seeding**

The ``Philox`` state vector consists of a 256-bit value encoded as
a 4-element uint64 array and a 128-bit value encoded as a 2-element uint64
array. The former is a counter which is incremented by 1 for every 4 64-bit
randoms produced. The second is a key which determined the sequence
produced. Using different keys produces independent sequences.

The input ``seed`` is processed by `SeedSequence` to generate the key. The
counter is set to 0.

Alternately, one can omit the ``seed`` parameter and set the ``key`` and
``counter`` directly.

**Parallel Features**

The preferred way to use a BitGenerator in parallel applications is to use
the `SeedSequence.spawn` method to obtain entropy values, and to use these
to generate new BitGenerators:

>>> from numpy.random import Generator, Philox, SeedSequence
>>> sg = SeedSequence(1234)
>>> rg = [Generator(Philox(s)) for s in sg.spawn(10)]

``Philox`` can be used in parallel applications by calling the ``jumped``
method  to advances the state as-if :math:`2^{128}` random numbers have
been generated. Alternatively, ``advance`` can be used to advance the
counter for any positive step in [0, 2**256). When using ``jumped``, all
generators should be chained to ensure that the segments come from the same
sequence.

>>> from numpy.random import Generator, Philox
>>> bit_generator = Philox(1234)
>>> rg = []
>>> for _ in range(10):
...    rg.append(Generator(bit_generator))
...    bit_generator = bit_generator.jumped()

Alternatively, ``Philox`` can be used in parallel applications by using
a sequence of distinct keys where each instance uses different key.

>>> key = 2**96 + 2**33 + 2**17 + 2**9
>>> rg = [Generator(Philox(key=key+i)) for i in range(10)]

**Compatibility Guarantee**

``Philox`` makes a guarantee that a fixed ``seed`` will always produce
the same random integer stream.

Examples
--------
>>> from numpy.random import Generator, Philox
>>> rg = Generator(Philox(1234))
>>> rg.standard_normal()
0.123  # random

References
----------
.. [1] John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw,
       'Parallel Random Numbers: As Easy as 1, 2, 3,' Proceedings of
       the International Conference for High Performance Computing,
       Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011.
*)

val advance : delta:[`I of int | `Positive of Py.Object.t] -> [> tag] Obj.t -> t
(**
advance(delta)

Advance the underlying RNG as-if delta draws have occurred.

Parameters
----------
delta : integer, positive
    Number of draws to advance the RNG. Must be less than the
    size state variable in the underlying RNG.

Returns
-------
self : Philox
    RNG advanced delta steps

Notes
-----
Advancing a RNG updates the underlying RNG state as-if a given
number of calls to the underlying RNG have been made. In general
there is not a one-to-one relationship between the number output
random values from a particular distribution and the number of
draws from the core RNG.  This occurs for two reasons:

* The random values are simulated using a rejection-based method
  and so, on average, more than one value from the underlying
  RNG is required to generate an single draw.
* The number of bits required to generate a simulated value
  differs from the number of bits generated by the underlying
  RNG.  For example, two 16-bit integer values can be simulated
  from a single draw of a 32-bit RNG.

Advancing the RNG state resets any pre-computed random numbers.
This is required to ensure exact reproducibility.
*)

val jumped : ?jumps:[`I of int | `Positive of Py.Object.t] -> [> tag] Obj.t -> Py.Object.t
(**
jumped(jumps=1)

Returns a new bit generator with the state jumped

The state of the returned big generator is jumped as-if
2**(128 * jumps) random numbers have been generated.

Parameters
----------
jumps : integer, positive
    Number of times to jump the state of the bit generator returned

Returns
-------
bit_generator : Philox
    New instance of generator jumped iter times
*)


(** Attribute lock: get value or raise Not_found if None.*)
val lock : t -> Py.Object.t

(** Attribute lock: get value as an option. *)
val lock_opt : t -> (Py.Object.t) option


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module RandomState : sig
type tag = [`RandomState]
type t = [`Object | `RandomState] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?seed:[`BitGenerator of Py.Object.t | `I of int | `Ndarray of [>`Ndarray] Obj.t] -> unit -> t
(**
RandomState(seed=None)

Container for the slow Mersenne Twister pseudo-random number generator.
Consider using a different BitGenerator with the Generator container
instead.

`RandomState` and `Generator` expose a number of methods for generating
random numbers drawn from a variety of probability distributions. In
addition to the distribution-specific arguments, each method takes a
keyword argument `size` that defaults to ``None``. If `size` is ``None``,
then a single value is generated and returned. If `size` is an integer,
then a 1-D array filled with generated values is returned. If `size` is a
tuple, then an array with that shape is filled and returned.

**Compatibility Guarantee**

A fixed bit generator using a fixed seed and a fixed series of calls to
'RandomState' methods using the same parameters will always produce the
same results up to roundoff error except when the values were incorrect.
`RandomState` is effectively frozen and will only receive updates that
are required by changes in the the internals of Numpy. More substantial
changes, including algorithmic improvements, are reserved for
`Generator`.

Parameters
----------
seed : {None, int, array_like, BitGenerator}, optional
    Random seed used to initialize the pseudo-random number generator or
    an instantized BitGenerator.  If an integer or array, used as a seed for
    the MT19937 BitGenerator. Values can be any integer between 0 and
    2**32 - 1 inclusive, an array (or other sequence) of such integers,
    or ``None`` (the default).  If `seed` is ``None``, then the `MT19937`
    BitGenerator is initialized by reading data from ``/dev/urandom``
    (or the Windows analogue) if available or seed from the clock
    otherwise.

Notes
-----
The Python stdlib module 'random' also contains a Mersenne Twister
pseudo-random number generator with a number of methods that are similar
to the ones available in `RandomState`. `RandomState`, besides being
NumPy-aware, has the advantage that it provides a much larger number
of probability distributions to choose from.

See Also
--------
Generator
MT19937
numpy.random.BitGenerator
*)

val beta : ?size:int list -> b:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
beta(a, b, size=None)

Draw samples from a Beta distribution.

The Beta distribution is a special case of the Dirichlet distribution,
and is related to the Gamma distribution.  It has the probability
distribution function

.. math:: f(x; a,b) = \frac{1}{B(\alpha, \beta)} x^{\alpha - 1}
                                                 (1 - x)^{\beta - 1},

where the normalization, B, is the beta function,

.. math:: B(\alpha, \beta) = \int_0^1 t^{\alpha - 1}
                             (1 - t)^{\beta - 1} dt.

It is often seen in Bayesian inference and order statistics.

.. note::
    New code should use the ``beta`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Alpha, positive (>0).
b : float or array_like of floats
    Beta, positive (>0).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` and ``b`` are both scalars.
    Otherwise, ``np.broadcast(a, b).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized beta distribution.

See Also
--------
Generator.beta: which should be used for new code.
*)

val binomial : ?size:int list -> n:[`I of int | `Array_like_of_ints of Py.Object.t] -> p:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
binomial(n, p, size=None)

Draw samples from a binomial distribution.

Samples are drawn from a binomial distribution with specified
parameters, n trials and p probability of success where
n an integer >= 0 and p is in the interval [0,1]. (n may be
input as a float, but it is truncated to an integer in use)

.. note::
    New code should use the ``binomial`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
n : int or array_like of ints
    Parameter of the distribution, >= 0. Floats are also accepted,
    but they will be truncated to integers.
p : float or array_like of floats
    Parameter of the distribution, >= 0 and <=1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``n`` and ``p`` are both scalars.
    Otherwise, ``np.broadcast(n, p).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized binomial distribution, where
    each sample is equal to the number of successes over the n trials.

See Also
--------
scipy.stats.binom : probability density function, distribution or
    cumulative density function, etc.
Generator.binomial: which should be used for new code.

Notes
-----
The probability density for the binomial distribution is

.. math:: P(N) = \binom{n}{N}p^N(1-p)^{n-N},

where :math:`n` is the number of trials, :math:`p` is the probability
of success, and :math:`N` is the number of successes.

When estimating the standard error of a proportion in a population by
using a random sample, the normal distribution works well unless the
product p*n <=5, where p = population proportion estimate, and n =
number of samples, in which case the binomial distribution is used
instead. For example, a sample of 15 people shows 4 who are left
handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,
so the binomial distribution should be used in this case.

References
----------
.. [1] Dalgaard, Peter, 'Introductory Statistics with R',
       Springer-Verlag, 2002.
.. [2] Glantz, Stanton A. 'Primer of Biostatistics.', McGraw-Hill,
       Fifth Edition, 2002.
.. [3] Lentner, Marvin, 'Elementary Applied Statistics', Bogden
       and Quigley, 1972.
.. [4] Weisstein, Eric W. 'Binomial Distribution.' From MathWorld--A
       Wolfram Web Resource.
       http://mathworld.wolfram.com/BinomialDistribution.html
.. [5] Wikipedia, 'Binomial distribution',
       https://en.wikipedia.org/wiki/Binomial_distribution

Examples
--------
Draw samples from the distribution:

>>> n, p = 10, .5  # number of trials, probability of each trial
>>> s = np.random.binomial(n, p, 1000)
# result of flipping a coin 10 times, tested 1000 times.

A real world example. A company drills 9 wild-cat oil exploration
wells, each with an estimated probability of success of 0.1. All nine
wells fail. What is the probability of that happening?

Let's do 20,000 trials of the model, and count the number that
generate zero positive results.

>>> sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.
# answer = 0.38885, or 38%.
*)

val bytes : length:int -> [> tag] Obj.t -> string
(**
bytes(length)

Return random bytes.

.. note::
    New code should use the ``bytes`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
length : int
    Number of random bytes.

Returns
-------
out : str
    String of length `length`.

See Also
--------
Generator.bytes: which should be used for new code.

Examples
--------
>>> np.random.bytes(10)
' eh\x85\x022SZ\xbf\xa4' #random
*)

val chisquare : ?size:int list -> df:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
chisquare(df, size=None)

Draw samples from a chi-square distribution.

When `df` independent random variables, each with standard normal
distributions (mean 0, variance 1), are squared and summed, the
resulting distribution is chi-square (see Notes).  This distribution
is often used in hypothesis testing.

.. note::
    New code should use the ``chisquare`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
df : float or array_like of floats
     Number of degrees of freedom, must be > 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``df`` is a scalar.  Otherwise,
    ``np.array(df).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized chi-square distribution.

Raises
------
ValueError
    When `df` <= 0 or when an inappropriate `size` (e.g. ``size=-1``)
    is given.

See Also
--------
Generator.chisquare: which should be used for new code.

Notes
-----
The variable obtained by summing the squares of `df` independent,
standard normally distributed random variables:

.. math:: Q = \sum_{i=0}^{\mathtt{df}} X^2_i

is chi-square distributed, denoted

.. math:: Q \sim \chi^2_k.

The probability density function of the chi-squared distribution is

.. math:: p(x) = \frac{(1/2)^{k/2}}{\Gamma(k/2)}
                 x^{k/2 - 1} e^{-x/2},

where :math:`\Gamma` is the gamma function,

.. math:: \Gamma(x) = \int_0^{-\infty} t^{x - 1} e^{-t} dt.

References
----------
.. [1] NIST 'Engineering Statistics Handbook'
       https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm

Examples
--------
>>> np.random.chisquare(2,4)
array([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random
*)

val choice : ?size:int list -> ?replace:bool -> ?p:Py.Object.t -> [`T1_D_array_like of Py.Object.t | `I of int] -> [> tag] Obj.t -> Py.Object.t
(**
choice(a, size=None, replace=True, p=None)

Generates a random sample from a given 1-D array

        .. versionadded:: 1.7.0

.. note::
    New code should use the ``choice`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : 1-D array-like or int
    If an ndarray, a random sample is generated from its elements.
    If an int, the random sample is generated as if a were np.arange(a)
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.
replace : boolean, optional
    Whether the sample is with or without replacement
p : 1-D array-like, optional
    The probabilities associated with each entry in a.
    If not given the sample assumes a uniform distribution over all
    entries in a.

Returns
-------
samples : single item or ndarray
    The generated random samples

Raises
------
ValueError
    If a is an int and less than zero, if a or p are not 1-dimensional,
    if a is an array-like of size 0, if p is not a vector of
    probabilities, if a and p have different lengths, or if
    replace=False and the sample size is greater than the population
    size

See Also
--------
randint, shuffle, permutation
Generator.choice: which should be used in new code

Examples
--------
Generate a uniform random sample from np.arange(5) of size 3:

>>> np.random.choice(5, 3)
array([0, 3, 4]) # random
>>> #This is equivalent to np.random.randint(0,5,3)

Generate a non-uniform random sample from np.arange(5) of size 3:

>>> np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])
array([3, 3, 0]) # random

Generate a uniform random sample from np.arange(5) of size 3 without
replacement:

>>> np.random.choice(5, 3, replace=False)
array([3,1,0]) # random
>>> #This is equivalent to np.random.permutation(np.arange(5))[:3]

Generate a non-uniform random sample from np.arange(5) of size
3 without replacement:

>>> np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])
array([2, 3, 0]) # random

Any of the above can be repeated with an arbitrary array-like
instead of just integers. For instance:

>>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']
>>> np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])
array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random
      dtype='<U11')
*)

val dirichlet : ?size:int list -> alpha:[`Ndarray of [>`Ndarray] Obj.t | `Length_k of Py.Object.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
dirichlet(alpha, size=None)

Draw samples from the Dirichlet distribution.

Draw `size` samples of dimension k from a Dirichlet distribution. A
Dirichlet-distributed random variable can be seen as a multivariate
generalization of a Beta distribution. The Dirichlet distribution
is a conjugate prior of a multinomial distribution in Bayesian
inference.

.. note::
    New code should use the ``dirichlet`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
alpha : sequence of floats, length k
    Parameter of the distribution (length ``k`` for sample of
    length ``k``).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    vector of length ``k`` is returned.

Returns
-------
samples : ndarray,
    The drawn samples, of shape ``(size, k)``.

Raises
-------
ValueError
    If any value in ``alpha`` is less than or equal to zero

See Also
--------
Generator.dirichlet: which should be used for new code.

Notes
-----
The Dirichlet distribution is a distribution over vectors
:math:`x` that fulfil the conditions :math:`x_i>0` and
:math:`\sum_{i=1}^k x_i = 1`.

The probability density function :math:`p` of a
Dirichlet-distributed random vector :math:`X` is
proportional to

.. math:: p(x) \propto \prod_{i=1}^{k}{x^{\alpha_i-1}_i},

where :math:`\alpha` is a vector containing the positive
concentration parameters.

The method uses the following property for computation: let :math:`Y`
be a random vector which has components that follow a standard gamma
distribution, then :math:`X = \frac{1}{\sum_{i=1}^k{Y_i}} Y`
is Dirichlet-distributed

References
----------
.. [1] David McKay, 'Information Theory, Inference and Learning
       Algorithms,' chapter 23,
       http://www.inference.org.uk/mackay/itila/
.. [2] Wikipedia, 'Dirichlet distribution',
       https://en.wikipedia.org/wiki/Dirichlet_distribution

Examples
--------
Taking an example cited in Wikipedia, this distribution can be used if
one wanted to cut strings (each of initial length 1.0) into K pieces
with different lengths, where each piece had, on average, a designated
average length, but allowing some variation in the relative sizes of
the pieces.

>>> s = np.random.dirichlet((10, 5, 3), 20).transpose()

>>> import matplotlib.pyplot as plt
>>> plt.barh(range(20), s[0])
>>> plt.barh(range(20), s[1], left=s[0], color='g')
>>> plt.barh(range(20), s[2], left=s[0]+s[1], color='r')
>>> plt.title('Lengths of Strings')
*)

val exponential : ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
exponential(scale=1.0, size=None)

Draw samples from an exponential distribution.

Its probability density function is

.. math:: f(x; \frac{1}{\beta}) = \frac{1}{\beta} \exp(-\frac{x}{\beta}),

for ``x > 0`` and 0 elsewhere. :math:`\beta` is the scale parameter,
which is the inverse of the rate parameter :math:`\lambda = 1/\beta`.
The rate parameter is an alternative, widely used parameterization
of the exponential distribution [3]_.

The exponential distribution is a continuous analogue of the
geometric distribution.  It describes many common situations, such as
the size of raindrops measured over many rainstorms [1]_, or the time
between page requests to Wikipedia [2]_.

.. note::
    New code should use the ``exponential`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
scale : float or array_like of floats
    The scale parameter, :math:`\beta = 1/\lambda`. Must be
    non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``scale`` is a scalar.  Otherwise,
    ``np.array(scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized exponential distribution.

See Also
--------
Generator.exponential: which should be used for new code.

References
----------
.. [1] Peyton Z. Peebles Jr., 'Probability, Random Variables and
       Random Signal Principles', 4th ed, 2001, p. 57.
.. [2] Wikipedia, 'Poisson process',
       https://en.wikipedia.org/wiki/Poisson_process
.. [3] Wikipedia, 'Exponential distribution',
       https://en.wikipedia.org/wiki/Exponential_distribution
*)

val f : ?size:int list -> dfnum:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> dfden:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
f(dfnum, dfden, size=None)

Draw samples from an F distribution.

Samples are drawn from an F distribution with specified parameters,
`dfnum` (degrees of freedom in numerator) and `dfden` (degrees of
freedom in denominator), where both parameters must be greater than
zero.

The random variate of the F distribution (also known as the
Fisher distribution) is a continuous probability distribution
that arises in ANOVA tests, and is the ratio of two chi-square
variates.

.. note::
    New code should use the ``f`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
dfnum : float or array_like of floats
    Degrees of freedom in numerator, must be > 0.
dfden : float or array_like of float
    Degrees of freedom in denominator, must be > 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``dfnum`` and ``dfden`` are both scalars.
    Otherwise, ``np.broadcast(dfnum, dfden).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Fisher distribution.

See Also
--------
scipy.stats.f : probability density function, distribution or
    cumulative density function, etc.
Generator.f: which should be used for new code.

Notes
-----
The F statistic is used to compare in-group variances to between-group
variances. Calculating the distribution depends on the sampling, and
so it is a function of the respective degrees of freedom in the
problem.  The variable `dfnum` is the number of samples minus one, the
between-groups degrees of freedom, while `dfden` is the within-groups
degrees of freedom, the sum of the number of samples in each group
minus the number of groups.

References
----------
.. [1] Glantz, Stanton A. 'Primer of Biostatistics.', McGraw-Hill,
       Fifth Edition, 2002.
.. [2] Wikipedia, 'F-distribution',
       https://en.wikipedia.org/wiki/F-distribution

Examples
--------
An example from Glantz[1], pp 47-40:

Two groups, children of diabetics (25 people) and children from people
without diabetes (25 controls). Fasting blood glucose was measured,
case group had a mean value of 86.1, controls had a mean value of
82.2. Standard deviations were 2.09 and 2.49 respectively. Are these
data consistent with the null hypothesis that the parents diabetic
status does not affect their children's blood glucose levels?
Calculating the F statistic from the data gives a value of 36.01.

Draw samples from the distribution:

>>> dfnum = 1. # between group degrees of freedom
>>> dfden = 48. # within groups degrees of freedom
>>> s = np.random.f(dfnum, dfden, 1000)

The lower bound for the top 1% of the samples is :

>>> np.sort(s)[-10]
7.61988120985 # random

So there is about a 1% chance that the F statistic will exceed 7.62,
the measured value is 36, so the null hypothesis is rejected at the 1%
level.
*)

val gamma : ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
gamma(shape, scale=1.0, size=None)

Draw samples from a Gamma distribution.

Samples are drawn from a Gamma distribution with specified parameters,
`shape` (sometimes designated 'k') and `scale` (sometimes designated
'theta'), where both parameters are > 0.

.. note::
    New code should use the ``gamma`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
shape : float or array_like of floats
    The shape of the gamma distribution. Must be non-negative.
scale : float or array_like of floats, optional
    The scale of the gamma distribution. Must be non-negative.
    Default is equal to 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``shape`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(shape, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized gamma distribution.

See Also
--------
scipy.stats.gamma : probability density function, distribution or
    cumulative density function, etc.
Generator.gamma: which should be used for new code.

Notes
-----
The probability density for the Gamma distribution is

.. math:: p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},

where :math:`k` is the shape and :math:`\theta` the scale,
and :math:`\Gamma` is the Gamma function.

The Gamma distribution is often used to model the times to failure of
electronic components, and arises naturally in processes for which the
waiting times between Poisson distributed events are relevant.

References
----------
.. [1] Weisstein, Eric W. 'Gamma Distribution.' From MathWorld--A
       Wolfram Web Resource.
       http://mathworld.wolfram.com/GammaDistribution.html
.. [2] Wikipedia, 'Gamma distribution',
       https://en.wikipedia.org/wiki/Gamma_distribution

Examples
--------
Draw samples from the distribution:

>>> shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)
>>> s = np.random.gamma(shape, scale, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> import scipy.special as sps  # doctest: +SKIP
>>> count, bins, ignored = plt.hist(s, 50, density=True)
>>> y = bins**(shape-1)*(np.exp(-bins/scale) /  # doctest: +SKIP
...                      (sps.gamma(shape)*scale**shape))
>>> plt.plot(bins, y, linewidth=2, color='r')  # doctest: +SKIP
>>> plt.show()
*)

val geometric : ?size:int list -> p:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
geometric(p, size=None)

Draw samples from the geometric distribution.

Bernoulli trials are experiments with one of two outcomes:
success or failure (an example of such an experiment is flipping
a coin).  The geometric distribution models the number of trials
that must be run in order to achieve success.  It is therefore
supported on the positive integers, ``k = 1, 2, ...``.

The probability mass function of the geometric distribution is

.. math:: f(k) = (1 - p)^{k - 1} p

where `p` is the probability of success of an individual trial.

.. note::
    New code should use the ``geometric`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
p : float or array_like of floats
    The probability of success of an individual trial.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``p`` is a scalar.  Otherwise,
    ``np.array(p).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized geometric distribution.

See Also
--------
Generator.geometric: which should be used for new code.

Examples
--------
Draw ten thousand values from the geometric distribution,
with the probability of an individual success equal to 0.35:

>>> z = np.random.geometric(p=0.35, size=10000)

How many trials succeeded after a single run?

>>> (z == 1).sum() / 10000.
0.34889999999999999 #random
*)

val gumbel : ?loc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
gumbel(loc=0.0, scale=1.0, size=None)

Draw samples from a Gumbel distribution.

Draw samples from a Gumbel distribution with specified location and
scale.  For more information on the Gumbel distribution, see
Notes and References below.

.. note::
    New code should use the ``gumbel`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
loc : float or array_like of floats, optional
    The location of the mode of the distribution. Default is 0.
scale : float or array_like of floats, optional
    The scale parameter of the distribution. Default is 1. Must be non-
    negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``loc`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Gumbel distribution.

See Also
--------
scipy.stats.gumbel_l
scipy.stats.gumbel_r
scipy.stats.genextreme
weibull
Generator.gumbel: which should be used for new code.

Notes
-----
The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme
Value Type I) distribution is one of a class of Generalized Extreme
Value (GEV) distributions used in modeling extreme value problems.
The Gumbel is a special case of the Extreme Value Type I distribution
for maximums from distributions with 'exponential-like' tails.

The probability density for the Gumbel distribution is

.. math:: p(x) = \frac{e^{-(x - \mu)/ \beta}}{\beta} e^{ -e^{-(x - \mu)/
          \beta}},

where :math:`\mu` is the mode, a location parameter, and
:math:`\beta` is the scale parameter.

The Gumbel (named for German mathematician Emil Julius Gumbel) was used
very early in the hydrology literature, for modeling the occurrence of
flood events. It is also used for modeling maximum wind speed and
rainfall rates.  It is a 'fat-tailed' distribution - the probability of
an event in the tail of the distribution is larger than if one used a
Gaussian, hence the surprisingly frequent occurrence of 100-year
floods. Floods were initially modeled as a Gaussian process, which
underestimated the frequency of extreme events.

It is one of a class of extreme value distributions, the Generalized
Extreme Value (GEV) distributions, which also includes the Weibull and
Frechet.

The function has a mean of :math:`\mu + 0.57721\beta` and a variance
of :math:`\frac{\pi^2}{6}\beta^2`.

References
----------
.. [1] Gumbel, E. J., 'Statistics of Extremes,'
       New York: Columbia University Press, 1958.
.. [2] Reiss, R.-D. and Thomas, M., 'Statistical Analysis of Extreme
       Values from Insurance, Finance, Hydrology and Other Fields,'
       Basel: Birkhauser Verlag, 2001.

Examples
--------
Draw samples from the distribution:

>>> mu, beta = 0, 0.1 # location and scale
>>> s = np.random.gumbel(mu, beta, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp( -np.exp( -(bins - mu) /beta) ),
...          linewidth=2, color='r')
>>> plt.show()

Show how an extreme value distribution can arise from a Gaussian process
and compare to a Gaussian:

>>> means = []
>>> maxima = []
>>> for i in range(0,1000) :
...    a = np.random.normal(mu, beta, 1000)
...    means.append(a.mean())
...    maxima.append(a.max())
>>> count, bins, ignored = plt.hist(maxima, 30, density=True)
>>> beta = np.std(maxima) * np.sqrt(6) / np.pi
>>> mu = np.mean(maxima) - 0.57721*beta
>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp(-np.exp(-(bins - mu)/beta)),
...          linewidth=2, color='r')
>>> plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))
...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),
...          linewidth=2, color='g')
>>> plt.show()
*)

val hypergeometric : ?size:int list -> ngood:[`I of int | `Array_like_of_ints of Py.Object.t] -> nbad:[`I of int | `Array_like_of_ints of Py.Object.t] -> nsample:[`I of int | `Array_like_of_ints of Py.Object.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
hypergeometric(ngood, nbad, nsample, size=None)

Draw samples from a Hypergeometric distribution.

Samples are drawn from a hypergeometric distribution with specified
parameters, `ngood` (ways to make a good selection), `nbad` (ways to make
a bad selection), and `nsample` (number of items sampled, which is less
than or equal to the sum ``ngood + nbad``).

.. note::
    New code should use the ``hypergeometric`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
ngood : int or array_like of ints
    Number of ways to make a good selection.  Must be nonnegative.
nbad : int or array_like of ints
    Number of ways to make a bad selection.  Must be nonnegative.
nsample : int or array_like of ints
    Number of items sampled.  Must be at least 1 and at most
    ``ngood + nbad``.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if `ngood`, `nbad`, and `nsample`
    are all scalars.  Otherwise, ``np.broadcast(ngood, nbad, nsample).size``
    samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized hypergeometric distribution. Each
    sample is the number of good items within a randomly selected subset of
    size `nsample` taken from a set of `ngood` good items and `nbad` bad items.

See Also
--------
scipy.stats.hypergeom : probability density function, distribution or
    cumulative density function, etc.
Generator.hypergeometric: which should be used for new code.

Notes
-----
The probability density for the Hypergeometric distribution is

.. math:: P(x) = \frac{\binom{g}{x}\binom{b}{n-x}}{\binom{g+b}{n}},

where :math:`0 \le x \le n` and :math:`n-b \le x \le g`

for P(x) the probability of ``x`` good results in the drawn sample,
g = `ngood`, b = `nbad`, and n = `nsample`.

Consider an urn with black and white marbles in it, `ngood` of them
are black and `nbad` are white. If you draw `nsample` balls without
replacement, then the hypergeometric distribution describes the
distribution of black balls in the drawn sample.

Note that this distribution is very similar to the binomial
distribution, except that in this case, samples are drawn without
replacement, whereas in the Binomial case samples are drawn with
replacement (or the sample space is infinite). As the sample space
becomes large, this distribution approaches the binomial.

References
----------
.. [1] Lentner, Marvin, 'Elementary Applied Statistics', Bogden
       and Quigley, 1972.
.. [2] Weisstein, Eric W. 'Hypergeometric Distribution.' From
       MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/HypergeometricDistribution.html
.. [3] Wikipedia, 'Hypergeometric distribution',
       https://en.wikipedia.org/wiki/Hypergeometric_distribution

Examples
--------
Draw samples from the distribution:

>>> ngood, nbad, nsamp = 100, 2, 10
# number of good, number of bad, and number of samples
>>> s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)
>>> from matplotlib.pyplot import hist
>>> hist(s)
#   note that it is very unlikely to grab both bad items

Suppose you have an urn with 15 white and 15 black marbles.
If you pull 15 marbles at random, how likely is it that
12 or more of them are one color?

>>> s = np.random.hypergeometric(15, 15, 15, 100000)
>>> sum(s>=12)/100000. + sum(s<=3)/100000.
#   answer = 0.003 ... pretty unlikely!
*)

val laplace : ?loc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
laplace(loc=0.0, scale=1.0, size=None)

Draw samples from the Laplace or double exponential distribution with
specified location (or mean) and scale (decay).

The Laplace distribution is similar to the Gaussian/normal distribution,
but is sharper at the peak and has fatter tails. It represents the
difference between two independent, identically distributed exponential
random variables.

.. note::
    New code should use the ``laplace`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
loc : float or array_like of floats, optional
    The position, :math:`\mu`, of the distribution peak. Default is 0.
scale : float or array_like of floats, optional
    :math:`\lambda`, the exponential decay. Default is 1. Must be non-
    negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``loc`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Laplace distribution.

See Also
--------
Generator.laplace: which should be used for new code.

Notes
-----
It has the probability density function

.. math:: f(x; \mu, \lambda) = \frac{1}{2\lambda}
                               \exp\left(-\frac{ |x - \mu| }{\lambda}\right).

The first law of Laplace, from 1774, states that the frequency
of an error can be expressed as an exponential function of the
absolute magnitude of the error, which leads to the Laplace
distribution. For many problems in economics and health
sciences, this distribution seems to model the data better
than the standard Gaussian distribution.

References
----------
.. [1] Abramowitz, M. and Stegun, I. A. (Eds.). 'Handbook of
       Mathematical Functions with Formulas, Graphs, and Mathematical
       Tables, 9th printing,' New York: Dover, 1972.
.. [2] Kotz, Samuel, et. al. 'The Laplace Distribution and
       Generalizations, ' Birkhauser, 2001.
.. [3] Weisstein, Eric W. 'Laplace Distribution.'
       From MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/LaplaceDistribution.html
.. [4] Wikipedia, 'Laplace distribution',
       https://en.wikipedia.org/wiki/Laplace_distribution

Examples
--------
Draw samples from the distribution

>>> loc, scale = 0., 1.
>>> s = np.random.laplace(loc, scale, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> x = np.arange(-8., 8., .01)
>>> pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)
>>> plt.plot(x, pdf)

Plot Gaussian for comparison:

>>> g = (1/(scale * np.sqrt(2 * np.pi)) *
...      np.exp(-(x - loc)**2 / (2 * scale**2)))
>>> plt.plot(x,g)
*)

val logistic : ?loc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
logistic(loc=0.0, scale=1.0, size=None)

Draw samples from a logistic distribution.

Samples are drawn from a logistic distribution with specified
parameters, loc (location or mean, also median), and scale (>0).

.. note::
    New code should use the ``logistic`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
loc : float or array_like of floats, optional
    Parameter of the distribution. Default is 0.
scale : float or array_like of floats, optional
    Parameter of the distribution. Must be non-negative.
    Default is 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``loc`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized logistic distribution.

See Also
--------
scipy.stats.logistic : probability density function, distribution or
    cumulative density function, etc.
Generator.logistic: which should be used for new code.

Notes
-----
The probability density for the Logistic distribution is

.. math:: P(x) = P(x) = \frac{e^{-(x-\mu)/s}}{s(1+e^{-(x-\mu)/s})^2},

where :math:`\mu` = location and :math:`s` = scale.

The Logistic distribution is used in Extreme Value problems where it
can act as a mixture of Gumbel distributions, in Epidemiology, and by
the World Chess Federation (FIDE) where it is used in the Elo ranking
system, assuming the performance of each player is a logistically
distributed random variable.

References
----------
.. [1] Reiss, R.-D. and Thomas M. (2001), 'Statistical Analysis of
       Extreme Values, from Insurance, Finance, Hydrology and Other
       Fields,' Birkhauser Verlag, Basel, pp 132-133.
.. [2] Weisstein, Eric W. 'Logistic Distribution.' From
       MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/LogisticDistribution.html
.. [3] Wikipedia, 'Logistic-distribution',
       https://en.wikipedia.org/wiki/Logistic_distribution

Examples
--------
Draw samples from the distribution:

>>> loc, scale = 10, 1
>>> s = np.random.logistic(loc, scale, 10000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, bins=50)

#   plot against distribution

>>> def logist(x, loc, scale):
...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)
>>> lgst_val = logist(bins, loc, scale)
>>> plt.plot(bins, lgst_val * count.max() / lgst_val.max())
>>> plt.show()
*)

val lognormal : ?mean:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?sigma:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
lognormal(mean=0.0, sigma=1.0, size=None)

Draw samples from a log-normal distribution.

Draw samples from a log-normal distribution with specified mean,
standard deviation, and array shape.  Note that the mean and standard
deviation are not the values for the distribution itself, but of the
underlying normal distribution it is derived from.

.. note::
    New code should use the ``lognormal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
mean : float or array_like of floats, optional
    Mean value of the underlying normal distribution. Default is 0.
sigma : float or array_like of floats, optional
    Standard deviation of the underlying normal distribution. Must be
    non-negative. Default is 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``mean`` and ``sigma`` are both scalars.
    Otherwise, ``np.broadcast(mean, sigma).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized log-normal distribution.

See Also
--------
scipy.stats.lognorm : probability density function, distribution,
    cumulative density function, etc.
Generator.lognormal: which should be used for new code.

Notes
-----
A variable `x` has a log-normal distribution if `log(x)` is normally
distributed.  The probability density function for the log-normal
distribution is:

.. math:: p(x) = \frac{1}{\sigma x \sqrt{2\pi}}
                 e^{(-\frac{(ln(x)-\mu)^2}{2\sigma^2})}

where :math:`\mu` is the mean and :math:`\sigma` is the standard
deviation of the normally distributed logarithm of the variable.
A log-normal distribution results if a random variable is the *product*
of a large number of independent, identically-distributed variables in
the same way that a normal distribution results if the variable is the
*sum* of a large number of independent, identically-distributed
variables.

References
----------
.. [1] Limpert, E., Stahel, W. A., and Abbt, M., 'Log-normal
       Distributions across the Sciences: Keys and Clues,'
       BioScience, Vol. 51, No. 5, May, 2001.
       https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf
.. [2] Reiss, R.D. and Thomas, M., 'Statistical Analysis of Extreme
       Values,' Basel: Birkhauser Verlag, 2001, pp. 31-32.

Examples
--------
Draw samples from the distribution:

>>> mu, sigma = 3., 1. # mean and standard deviation
>>> s = np.random.lognormal(mu, sigma, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 100, density=True, align='mid')

>>> x = np.linspace(min(bins), max(bins), 10000)
>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))

>>> plt.plot(x, pdf, linewidth=2, color='r')
>>> plt.axis('tight')
>>> plt.show()

Demonstrate that taking the products of random samples from a uniform
distribution can be fit well by a log-normal probability density
function.

>>> # Generate a thousand samples: each is the product of 100 random
>>> # values, drawn from a normal distribution.
>>> b = []
>>> for i in range(1000):
...    a = 10. + np.random.standard_normal(100)
...    b.append(np.product(a))

>>> b = np.array(b) / np.min(b) # scale values to be positive
>>> count, bins, ignored = plt.hist(b, 100, density=True, align='mid')
>>> sigma = np.std(np.log(b))
>>> mu = np.mean(np.log(b))

>>> x = np.linspace(min(bins), max(bins), 10000)
>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))

>>> plt.plot(x, pdf, color='r', linewidth=2)
>>> plt.show()
*)

val logseries : ?size:int list -> p:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
logseries(p, size=None)

Draw samples from a logarithmic series distribution.

Samples are drawn from a log series distribution with specified
shape parameter, 0 < ``p`` < 1.

.. note::
    New code should use the ``logseries`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
p : float or array_like of floats
    Shape parameter for the distribution.  Must be in the range (0, 1).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``p`` is a scalar.  Otherwise,
    ``np.array(p).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized logarithmic series distribution.

See Also
--------
scipy.stats.logser : probability density function, distribution or
    cumulative density function, etc.
Generator.logseries: which should be used for new code.

Notes
-----
The probability density for the Log Series distribution is

.. math:: P(k) = \frac{-p^k}{k \ln(1-p)},

where p = probability.

The log series distribution is frequently used to represent species
richness and occurrence, first proposed by Fisher, Corbet, and
Williams in 1943 [2].  It may also be used to model the numbers of
occupants seen in cars [3].

References
----------
.. [1] Buzas, Martin A.; Culver, Stephen J.,  Understanding regional
       species diversity through the log series distribution of
       occurrences: BIODIVERSITY RESEARCH Diversity & Distributions,
       Volume 5, Number 5, September 1999 , pp. 187-195(9).
.. [2] Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The
       relation between the number of species and the number of
       individuals in a random sample of an animal population.
       Journal of Animal Ecology, 12:42-58.
.. [3] D. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small
       Data Sets, CRC Press, 1994.
.. [4] Wikipedia, 'Logarithmic distribution',
       https://en.wikipedia.org/wiki/Logarithmic_distribution

Examples
--------
Draw samples from the distribution:

>>> a = .6
>>> s = np.random.logseries(a, 10000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s)

#   plot against distribution

>>> def logseries(k, p):
...     return -p**k/(k*np.log(1-p))
>>> plt.plot(bins, logseries(bins, a)*count.max()/
...          logseries(bins, a).max(), 'r')
>>> plt.show()
*)

val multinomial : ?size:int list -> n:int -> pvals:[`Length_p of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
multinomial(n, pvals, size=None)

Draw samples from a multinomial distribution.

The multinomial distribution is a multivariate generalization of the
binomial distribution.  Take an experiment with one of ``p``
possible outcomes.  An example of such an experiment is throwing a dice,
where the outcome can be 1 through 6.  Each sample drawn from the
distribution represents `n` such experiments.  Its values,
``X_i = [X_0, X_1, ..., X_p]``, represent the number of times the
outcome was ``i``.

.. note::
    New code should use the ``multinomial`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
n : int
    Number of experiments.
pvals : sequence of floats, length p
    Probabilities of each of the ``p`` different outcomes.  These
    must sum to 1 (however, the last element is always assumed to
    account for the remaining probability, as long as
    ``sum(pvals[:-1]) <= 1)``.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : ndarray
    The drawn samples, of shape *size*, if that was provided.  If not,
    the shape is ``(N,)``.

    In other words, each entry ``out[i,j,...,:]`` is an N-dimensional
    value drawn from the distribution.

See Also
--------
Generator.multinomial: which should be used for new code.

Examples
--------
Throw a dice 20 times:

>>> np.random.multinomial(20, [1/6.]*6, size=1)
array([[4, 1, 7, 5, 2, 1]]) # random

It landed 4 times on 1, once on 2, etc.

Now, throw the dice 20 times, and 20 times again:

>>> np.random.multinomial(20, [1/6.]*6, size=2)
array([[3, 4, 3, 3, 4, 3], # random
       [2, 4, 3, 4, 0, 7]])

For the first run, we threw 3 times 1, 4 times 2, etc.  For the second,
we threw 2 times 1, 4 times 2, etc.

A loaded die is more likely to land on number 6:

>>> np.random.multinomial(100, [1/7.]*5 + [2/7.])
array([11, 16, 14, 17, 16, 26]) # random

The probability inputs should be normalized. As an implementation
detail, the value of the last entry is ignored and assumed to take
up any leftover probability mass, but this should not be relied on.
A biased coin which has twice as much weight on one side as on the
other should be sampled like so:

>>> np.random.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT
array([38, 62]) # random

not like:

>>> np.random.multinomial(100, [1.0, 2.0])  # WRONG
Traceback (most recent call last):
ValueError: pvals < 0, pvals > 1 or pvals contains NaNs
*)

val multivariate_normal : ?size:int list -> ?check_valid:[`Warn | `Raise | `Ignore] -> ?tol:float -> mean:Py.Object.t -> cov:Py.Object.t -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)

Draw random samples from a multivariate normal distribution.

The multivariate normal, multinormal or Gaussian distribution is a
generalization of the one-dimensional normal distribution to higher
dimensions.  Such a distribution is specified by its mean and
covariance matrix.  These parameters are analogous to the mean
(average or 'center') and variance (standard deviation, or 'width,'
squared) of the one-dimensional normal distribution.

.. note::
    New code should use the ``multivariate_normal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
mean : 1-D array_like, of length N
    Mean of the N-dimensional distribution.
cov : 2-D array_like, of shape (N, N)
    Covariance matrix of the distribution. It must be symmetric and
    positive-semidefinite for proper sampling.
size : int or tuple of ints, optional
    Given a shape of, for example, ``(m,n,k)``, ``m*n*k`` samples are
    generated, and packed in an `m`-by-`n`-by-`k` arrangement.  Because
    each sample is `N`-dimensional, the output shape is ``(m,n,k,N)``.
    If no shape is specified, a single (`N`-D) sample is returned.
check_valid : { 'warn', 'raise', 'ignore' }, optional
    Behavior when the covariance matrix is not positive semidefinite.
tol : float, optional
    Tolerance when checking the singular values in covariance matrix.
    cov is cast to double before the check.

Returns
-------
out : ndarray
    The drawn samples, of shape *size*, if that was provided.  If not,
    the shape is ``(N,)``.

    In other words, each entry ``out[i,j,...,:]`` is an N-dimensional
    value drawn from the distribution.

See Also
--------
Generator.multivariate_normal: which should be used for new code.

Notes
-----
The mean is a coordinate in N-dimensional space, which represents the
location where samples are most likely to be generated.  This is
analogous to the peak of the bell curve for the one-dimensional or
univariate normal distribution.

Covariance indicates the level to which two variables vary together.
From the multivariate normal distribution, we draw N-dimensional
samples, :math:`X = [x_1, x_2, ... x_N]`.  The covariance matrix
element :math:`C_{ij}` is the covariance of :math:`x_i` and :math:`x_j`.
The element :math:`C_{ii}` is the variance of :math:`x_i` (i.e. its
'spread').

Instead of specifying the full covariance matrix, popular
approximations include:

  - Spherical covariance (`cov` is a multiple of the identity matrix)
  - Diagonal covariance (`cov` has non-negative elements, and only on
    the diagonal)

This geometrical property can be seen in two dimensions by plotting
generated data-points:

>>> mean = [0, 0]
>>> cov = [[1, 0], [0, 100]]  # diagonal covariance

Diagonal covariance means that points are oriented along x or y-axis:

>>> import matplotlib.pyplot as plt
>>> x, y = np.random.multivariate_normal(mean, cov, 5000).T
>>> plt.plot(x, y, 'x')
>>> plt.axis('equal')
>>> plt.show()

Note that the covariance matrix must be positive semidefinite (a.k.a.
nonnegative-definite). Otherwise, the behavior of this method is
undefined and backwards compatibility is not guaranteed.

References
----------
.. [1] Papoulis, A., 'Probability, Random Variables, and Stochastic
       Processes,' 3rd ed., New York: McGraw-Hill, 1991.
.. [2] Duda, R. O., Hart, P. E., and Stork, D. G., 'Pattern
       Classification,' 2nd ed., New York: Wiley, 2001.

Examples
--------
>>> mean = (1, 2)
>>> cov = [[1, 0], [0, 1]]
>>> x = np.random.multivariate_normal(mean, cov, (3, 3))
>>> x.shape
(3, 3, 2)

The following is probably true, given that 0.6 is roughly twice the
standard deviation:

>>> list((x[0,0,:] - mean) < 0.6)
[True, True] # random
*)

val negative_binomial : ?size:int list -> n:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> p:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
negative_binomial(n, p, size=None)

Draw samples from a negative binomial distribution.

Samples are drawn from a negative binomial distribution with specified
parameters, `n` successes and `p` probability of success where `n`
is > 0 and `p` is in the interval [0, 1].

.. note::
    New code should use the ``negative_binomial`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
n : float or array_like of floats
    Parameter of the distribution, > 0.
p : float or array_like of floats
    Parameter of the distribution, >= 0 and <=1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``n`` and ``p`` are both scalars.
    Otherwise, ``np.broadcast(n, p).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized negative binomial distribution,
    where each sample is equal to N, the number of failures that
    occurred before a total of n successes was reached.

See Also
--------
Generator.negative_binomial: which should be used for new code.

Notes
-----
The probability mass function of the negative binomial distribution is

.. math:: P(N;n,p) = \frac{\Gamma(N+n)}{N!\Gamma(n)}p^{n}(1-p)^{N},

where :math:`n` is the number of successes, :math:`p` is the
probability of success, :math:`N+n` is the number of trials, and
:math:`\Gamma` is the gamma function. When :math:`n` is an integer,
:math:`\frac{\Gamma(N+n)}{N!\Gamma(n)} = \binom{N+n-1}{N}`, which is
the more common form of this term in the the pmf. The negative
binomial distribution gives the probability of N failures given n
successes, with a success on the last trial.

If one throws a die repeatedly until the third time a '1' appears,
then the probability distribution of the number of non-'1's that
appear before the third '1' is a negative binomial distribution.

References
----------
.. [1] Weisstein, Eric W. 'Negative Binomial Distribution.' From
       MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/NegativeBinomialDistribution.html
.. [2] Wikipedia, 'Negative binomial distribution',
       https://en.wikipedia.org/wiki/Negative_binomial_distribution

Examples
--------
Draw samples from the distribution:

A real world example. A company drills wild-cat oil
exploration wells, each with an estimated probability of
success of 0.1.  What is the probability of having one success
for each successive well, that is what is the probability of a
single success after drilling 5 wells, after 6 wells, etc.?

>>> s = np.random.negative_binomial(1, 0.1, 100000)
>>> for i in range(1, 11): # doctest: +SKIP
...    probability = sum(s<i) / 100000.
...    print(i, 'wells drilled, probability of one success =', probability)
*)

val noncentral_chisquare : ?size:int list -> df:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> nonc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
noncentral_chisquare(df, nonc, size=None)

Draw samples from a noncentral chi-square distribution.

The noncentral :math:`\chi^2` distribution is a generalization of
the :math:`\chi^2` distribution.

.. note::
    New code should use the ``noncentral_chisquare`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
df : float or array_like of floats
    Degrees of freedom, must be > 0.

    .. versionchanged:: 1.10.0
       Earlier NumPy versions required dfnum > 1.
nonc : float or array_like of floats
    Non-centrality, must be non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``df`` and ``nonc`` are both scalars.
    Otherwise, ``np.broadcast(df, nonc).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized noncentral chi-square distribution.

See Also
--------
Generator.noncentral_chisquare: which should be used for new code.

Notes
-----
The probability density function for the noncentral Chi-square
distribution is

.. math:: P(x;df,nonc) = \sum^{\infty}_{i=0}
                       \frac{e^{-nonc/2}(nonc/2)^{i}}{i!}
                       P_{Y_{df+2i}}(x),

where :math:`Y_{q}` is the Chi-square with q degrees of freedom.

References
----------
.. [1] Wikipedia, 'Noncentral chi-squared distribution'
       https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution

Examples
--------
Draw values from the distribution and plot the histogram

>>> import matplotlib.pyplot as plt
>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
...                   bins=200, density=True)
>>> plt.show()

Draw values from a noncentral chisquare with very small noncentrality,
and compare to a chisquare.

>>> plt.figure()
>>> values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),
...                   bins=np.arange(0., 25, .1), density=True)
>>> values2 = plt.hist(np.random.chisquare(3, 100000),
...                    bins=np.arange(0., 25, .1), density=True)
>>> plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')
>>> plt.show()

Demonstrate how large values of non-centrality lead to a more symmetric
distribution.

>>> plt.figure()
>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
...                   bins=200, density=True)
>>> plt.show()
*)

val noncentral_f : ?size:int list -> dfnum:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> dfden:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> nonc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
noncentral_f(dfnum, dfden, nonc, size=None)

Draw samples from the noncentral F distribution.

Samples are drawn from an F distribution with specified parameters,
`dfnum` (degrees of freedom in numerator) and `dfden` (degrees of
freedom in denominator), where both parameters > 1.
`nonc` is the non-centrality parameter.

.. note::
    New code should use the ``noncentral_f`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
dfnum : float or array_like of floats
    Numerator degrees of freedom, must be > 0.

    .. versionchanged:: 1.14.0
       Earlier NumPy versions required dfnum > 1.
dfden : float or array_like of floats
    Denominator degrees of freedom, must be > 0.
nonc : float or array_like of floats
    Non-centrality parameter, the sum of the squares of the numerator
    means, must be >= 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``dfnum``, ``dfden``, and ``nonc``
    are all scalars.  Otherwise, ``np.broadcast(dfnum, dfden, nonc).size``
    samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized noncentral Fisher distribution.

See Also
--------
Generator.noncentral_f: which should be used for new code.

Notes
-----
When calculating the power of an experiment (power = probability of
rejecting the null hypothesis when a specific alternative is true) the
non-central F statistic becomes important.  When the null hypothesis is
true, the F statistic follows a central F distribution. When the null
hypothesis is not true, then it follows a non-central F statistic.

References
----------
.. [1] Weisstein, Eric W. 'Noncentral F-Distribution.'
       From MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/NoncentralF-Distribution.html
.. [2] Wikipedia, 'Noncentral F-distribution',
       https://en.wikipedia.org/wiki/Noncentral_F-distribution

Examples
--------
In a study, testing for a specific alternative to the null hypothesis
requires use of the Noncentral F distribution. We need to calculate the
area in the tail of the distribution that exceeds the value of the F
distribution for the null hypothesis.  We'll plot the two probability
distributions for comparison.

>>> dfnum = 3 # between group deg of freedom
>>> dfden = 20 # within groups degrees of freedom
>>> nonc = 3.0
>>> nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)
>>> NF = np.histogram(nc_vals, bins=50, density=True)
>>> c_vals = np.random.f(dfnum, dfden, 1000000)
>>> F = np.histogram(c_vals, bins=50, density=True)
>>> import matplotlib.pyplot as plt
>>> plt.plot(F[1][1:], F[0])
>>> plt.plot(NF[1][1:], NF[0])
>>> plt.show()
*)

val normal : ?loc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
normal(loc=0.0, scale=1.0, size=None)

Draw random samples from a normal (Gaussian) distribution.

The probability density function of the normal distribution, first
derived by De Moivre and 200 years later by both Gauss and Laplace
independently [2]_, is often called the bell curve because of
its characteristic shape (see the example below).

The normal distributions occurs often in nature.  For example, it
describes the commonly occurring distribution of samples influenced
by a large number of tiny, random disturbances, each with its own
unique distribution [2]_.

.. note::
    New code should use the ``normal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
loc : float or array_like of floats
    Mean ('centre') of the distribution.
scale : float or array_like of floats
    Standard deviation (spread or 'width') of the distribution. Must be
    non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``loc`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized normal distribution.

See Also
--------
scipy.stats.norm : probability density function, distribution or
    cumulative density function, etc.
Generator.normal: which should be used for new code.

Notes
-----
The probability density for the Gaussian distribution is

.. math:: p(x) = \frac{1}{\sqrt{ 2 \pi \sigma^2 }}
                 e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} },

where :math:`\mu` is the mean and :math:`\sigma` the standard
deviation. The square of the standard deviation, :math:`\sigma^2`,
is called the variance.

The function has its peak at the mean, and its 'spread' increases with
the standard deviation (the function reaches 0.607 times its maximum at
:math:`x + \sigma` and :math:`x - \sigma` [2]_).  This implies that
normal is more likely to return samples lying close to the mean, rather
than those far away.

References
----------
.. [1] Wikipedia, 'Normal distribution',
       https://en.wikipedia.org/wiki/Normal_distribution
.. [2] P. R. Peebles Jr., 'Central Limit Theorem' in 'Probability,
       Random Variables and Random Signal Principles', 4th ed., 2001,
       pp. 51, 51, 125.

Examples
--------
Draw samples from the distribution:

>>> mu, sigma = 0, 0.1 # mean and standard deviation
>>> s = np.random.normal(mu, sigma, 1000)

Verify the mean and the variance:

>>> abs(mu - np.mean(s))
0.0  # may vary

>>> abs(sigma - np.std(s, ddof=1))
0.1  # may vary

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *
...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),
...          linewidth=2, color='r')
>>> plt.show()

Two-by-four array of samples from N(3, 6.25):

>>> np.random.normal(3, 2.5, size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
*)

val pareto : ?size:int list -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
pareto(a, size=None)

Draw samples from a Pareto II or Lomax distribution with
specified shape.

The Lomax or Pareto II distribution is a shifted Pareto
distribution. The classical Pareto distribution can be
obtained from the Lomax distribution by adding 1 and
multiplying by the scale parameter ``m`` (see Notes).  The
smallest value of the Lomax distribution is zero while for the
classical Pareto distribution it is ``mu``, where the standard
Pareto distribution has location ``mu = 1``.  Lomax can also
be considered as a simplified version of the Generalized
Pareto distribution (available in SciPy), with the scale set
to one and the location set to zero.

The Pareto distribution must be greater than zero, and is
unbounded above.  It is also known as the '80-20 rule'.  In
this distribution, 80 percent of the weights are in the lowest
20 percent of the range, while the other 20 percent fill the
remaining 80 percent of the range.

.. note::
    New code should use the ``pareto`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Shape of the distribution. Must be positive.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` is a scalar.  Otherwise,
    ``np.array(a).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Pareto distribution.

See Also
--------
scipy.stats.lomax : probability density function, distribution or
    cumulative density function, etc.
scipy.stats.genpareto : probability density function, distribution or
    cumulative density function, etc.
Generator.pareto: which should be used for new code.

Notes
-----
The probability density for the Pareto distribution is

.. math:: p(x) = \frac{am^a}{x^{a+1}}

where :math:`a` is the shape and :math:`m` the scale.

The Pareto distribution, named after the Italian economist
Vilfredo Pareto, is a power law probability distribution
useful in many real world problems.  Outside the field of
economics it is generally referred to as the Bradford
distribution. Pareto developed the distribution to describe
the distribution of wealth in an economy.  It has also found
use in insurance, web page access statistics, oil field sizes,
and many other problems, including the download frequency for
projects in Sourceforge [1]_.  It is one of the so-called
'fat-tailed' distributions.

References
----------
.. [1] Francis Hunt and Paul Johnson, On the Pareto Distribution of
       Sourceforge projects.
.. [2] Pareto, V. (1896). Course of Political Economy. Lausanne.
.. [3] Reiss, R.D., Thomas, M.(2001), Statistical Analysis of Extreme
       Values, Birkhauser Verlag, Basel, pp 23-30.
.. [4] Wikipedia, 'Pareto distribution',
       https://en.wikipedia.org/wiki/Pareto_distribution

Examples
--------
Draw samples from the distribution:

>>> a, m = 3., 2.  # shape and mode
>>> s = (np.random.pareto(a, 1000) + 1) * m

Display the histogram of the samples, along with the probability
density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, _ = plt.hist(s, 100, density=True)
>>> fit = a*m**a / bins**(a+1)
>>> plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')
>>> plt.show()
*)

val permutation : [`I of int | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
permutation(x)

Randomly permute a sequence, or return a permuted range.

If `x` is a multi-dimensional array, it is only shuffled along its
first index.

.. note::
    New code should use the ``permutation`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
x : int or array_like
    If `x` is an integer, randomly permute ``np.arange(x)``.
    If `x` is an array, make a copy and shuffle the elements
    randomly.

Returns
-------
out : ndarray
    Permuted sequence or array range.

See Also
--------
Generator.permutation: which should be used for new code.

Examples
--------
>>> np.random.permutation(10)
array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random

>>> np.random.permutation([1, 4, 9, 12, 15])
array([15,  1,  9,  4, 12]) # random

>>> arr = np.arange(9).reshape((3, 3))
>>> np.random.permutation(arr)
array([[6, 7, 8], # random
       [0, 1, 2],
       [3, 4, 5]])
*)

val poisson : ?lam:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
poisson(lam=1.0, size=None)

Draw samples from a Poisson distribution.

The Poisson distribution is the limit of the binomial distribution
for large N.

.. note::
    New code should use the ``poisson`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
lam : float or array_like of floats
    Expectation of interval, must be >= 0. A sequence of expectation
    intervals must be broadcastable over the requested size.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``lam`` is a scalar. Otherwise,
    ``np.array(lam).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Poisson distribution.

See Also
--------
Generator.poisson: which should be used for new code.

Notes
-----
The Poisson distribution

.. math:: f(k; \lambda)=\frac{\lambda^k e^{-\lambda}}{k!}

For events with an expected separation :math:`\lambda` the Poisson
distribution :math:`f(k; \lambda)` describes the probability of
:math:`k` events occurring within the observed
interval :math:`\lambda`.

Because the output is limited to the range of the C int64 type, a
ValueError is raised when `lam` is within 10 sigma of the maximum
representable value.

References
----------
.. [1] Weisstein, Eric W. 'Poisson Distribution.'
       From MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/PoissonDistribution.html
.. [2] Wikipedia, 'Poisson distribution',
       https://en.wikipedia.org/wiki/Poisson_distribution

Examples
--------
Draw samples from the distribution:

>>> import numpy as np
>>> s = np.random.poisson(5, 10000)

Display histogram of the sample:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 14, density=True)
>>> plt.show()

Draw each 100 values for lambda 100 and 500:

>>> s = np.random.poisson(lam=(100., 500.), size=(100, 2))
*)

val power : ?size:int list -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
power(a, size=None)

Draws samples in [0, 1] from a power distribution with positive
exponent a - 1.

Also known as the power function distribution.

.. note::
    New code should use the ``power`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Parameter of the distribution. Must be non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` is a scalar.  Otherwise,
    ``np.array(a).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized power distribution.

Raises
------
ValueError
    If a < 1.

See Also
--------
Generator.power: which should be used for new code.

Notes
-----
The probability density function is

.. math:: P(x; a) = ax^{a-1}, 0 \le x \le 1, a>0.

The power function distribution is just the inverse of the Pareto
distribution. It may also be seen as a special case of the Beta
distribution.

It is used, for example, in modeling the over-reporting of insurance
claims.

References
----------
.. [1] Christian Kleiber, Samuel Kotz, 'Statistical size distributions
       in economics and actuarial sciences', Wiley, 2003.
.. [2] Heckert, N. A. and Filliben, James J. 'NIST Handbook 148:
       Dataplot Reference Manual, Volume 2: Let Subcommands and Library
       Functions', National Institute of Standards and Technology
       Handbook Series, June 2003.
       https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf

Examples
--------
Draw samples from the distribution:

>>> a = 5. # shape
>>> samples = 1000
>>> s = np.random.power(a, samples)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, bins=30)
>>> x = np.linspace(0, 1, 100)
>>> y = a*x**(a-1.)
>>> normed_y = samples*np.diff(bins)[0]*y
>>> plt.plot(x, normed_y)
>>> plt.show()

Compare the power function distribution to the inverse of the Pareto.

>>> from scipy import stats # doctest: +SKIP
>>> rvs = np.random.power(5, 1000000)
>>> rvsp = np.random.pareto(5, 1000000)
>>> xx = np.linspace(0,1,100)
>>> powpdf = stats.powerlaw.pdf(xx,5)  # doctest: +SKIP

>>> plt.figure()
>>> plt.hist(rvs, bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  # doctest: +SKIP
>>> plt.title('np.random.power(5)')

>>> plt.figure()
>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  # doctest: +SKIP
>>> plt.title('inverse of 1 + np.random.pareto(5)')

>>> plt.figure()
>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  # doctest: +SKIP
>>> plt.title('inverse of stats.pareto(5)')
*)

val rand : d:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
rand(d0, d1, ..., dn)

Random values in a given shape.

.. note::
    This is a convenience function for users porting code from Matlab,
    and wraps `random_sample`. That function takes a
    tuple to specify the size of the output, which is consistent with
    other NumPy functions like `numpy.zeros` and `numpy.ones`.

Create an array of the given shape and populate it with
random samples from a uniform distribution
over ``[0, 1)``.

Parameters
----------
d0, d1, ..., dn : int, optional
    The dimensions of the returned array, must be non-negative.
    If no argument is given a single Python float is returned.

Returns
-------
out : ndarray, shape ``(d0, d1, ..., dn)``
    Random values.

See Also
--------
random

Examples
--------
>>> np.random.rand(3,2)
array([[ 0.14022471,  0.96360618],  #random
       [ 0.37601032,  0.25528411],  #random
       [ 0.49313049,  0.94909878]]) #random
*)

val randint : ?high:[`I of int | `Array_like_of_ints of Py.Object.t] -> ?size:int list -> ?dtype:Dtype.t -> low:[`I of int | `Array_like_of_ints of Py.Object.t] -> [> tag] Obj.t -> Py.Object.t
(**
randint(low, high=None, size=None, dtype=int)

Return random integers from `low` (inclusive) to `high` (exclusive).

Return random integers from the 'discrete uniform' distribution of
the specified dtype in the 'half-open' interval [`low`, `high`). If
`high` is None (the default), then results are from [0, `low`).

.. note::
    New code should use the ``integers`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
low : int or array-like of ints
    Lowest (signed) integers to be drawn from the distribution (unless
    ``high=None``, in which case this parameter is one above the
    *highest* such integer).
high : int or array-like of ints, optional
    If provided, one above the largest (signed) integer to be drawn
    from the distribution (see above for behavior if ``high=None``).
    If array-like, must contain integer values
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.
dtype : dtype, optional
    Desired dtype of the result. Byteorder must be native.
    The default value is int.

    .. versionadded:: 1.11.0

Returns
-------
out : int or ndarray of ints
    `size`-shaped array of random integers from the appropriate
    distribution, or a single such random int if `size` not provided.

See Also
--------
random_integers : similar to `randint`, only for the closed
    interval [`low`, `high`], and 1 is the lowest value if `high` is
    omitted.
Generator.integers: which should be used for new code.

Examples
--------
>>> np.random.randint(2, size=10)
array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random
>>> np.random.randint(1, size=10)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])

Generate a 2 x 4 array of ints between 0 and 4, inclusive:

>>> np.random.randint(5, size=(2, 4))
array([[4, 0, 2, 1], # random
       [3, 2, 2, 0]])

Generate a 1 x 3 array with 3 different upper bounds

>>> np.random.randint(1, [3, 5, 10])
array([2, 2, 9]) # random

Generate a 1 by 3 array with 3 different lower bounds

>>> np.random.randint([1, 5, 7], 10)
array([9, 8, 7]) # random

Generate a 2 by 4 array using broadcasting with dtype of uint8

>>> np.random.randint([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)
array([[ 8,  6,  9,  7], # random
       [ 1, 16,  9, 12]], dtype=uint8)
*)

val randn : d:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
randn(d0, d1, ..., dn)

Return a sample (or samples) from the 'standard normal' distribution.

.. note::
    This is a convenience function for users porting code from Matlab,
    and wraps `standard_normal`. That function takes a
    tuple to specify the size of the output, which is consistent with
    other NumPy functions like `numpy.zeros` and `numpy.ones`.

.. note::
    New code should use the ``standard_normal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

If positive int_like arguments are provided, `randn` generates an array
of shape ``(d0, d1, ..., dn)``, filled
with random floats sampled from a univariate 'normal' (Gaussian)
distribution of mean 0 and variance 1. A single float randomly sampled
from the distribution is returned if no argument is provided.

Parameters
----------
d0, d1, ..., dn : int, optional
    The dimensions of the returned array, must be non-negative.
    If no argument is given a single Python float is returned.

Returns
-------
Z : ndarray or float
    A ``(d0, d1, ..., dn)``-shaped array of floating-point samples from
    the standard normal distribution, or a single such float if
    no parameters were supplied.

See Also
--------
standard_normal : Similar, but takes a tuple as its argument.
normal : Also accepts mu and sigma arguments.
Generator.standard_normal: which should be used for new code.

Notes
-----
For random samples from :math:`N(\mu, \sigma^2)`, use:

``sigma * np.random.randn(...) + mu``

Examples
--------
>>> np.random.randn()
2.1923875335537315  # random

Two-by-four array of samples from N(3, 6.25):

>>> 3 + 2.5 * np.random.randn(2, 4)
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
*)

val random : ?size:int list -> [> tag] Obj.t -> Py.Object.t
(**
random(size=None)

Return random floats in the half-open interval [0.0, 1.0). Alias for
`random_sample` to ease forward-porting to the new random API.
*)

val random_integers : ?high:int -> ?size:int list -> low:int -> [> tag] Obj.t -> Py.Object.t
(**
random_integers(low, high=None, size=None)

Random integers of type `np.int_` between `low` and `high`, inclusive.

Return random integers of type `np.int_` from the 'discrete uniform'
distribution in the closed interval [`low`, `high`].  If `high` is
None (the default), then results are from [1, `low`]. The `np.int_`
type translates to the C long integer type and its precision
is platform dependent.

This function has been deprecated. Use randint instead.

.. deprecated:: 1.11.0

Parameters
----------
low : int
    Lowest (signed) integer to be drawn from the distribution (unless
    ``high=None``, in which case this parameter is the *highest* such
    integer).
high : int, optional
    If provided, the largest (signed) integer to be drawn from the
    distribution (see above for behavior if ``high=None``).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : int or ndarray of ints
    `size`-shaped array of random integers from the appropriate
    distribution, or a single such random int if `size` not provided.

See Also
--------
randint : Similar to `random_integers`, only for the half-open
    interval [`low`, `high`), and 0 is the lowest value if `high` is
    omitted.

Notes
-----
To sample from N evenly spaced floating-point numbers between a and b,
use::

  a + (b - a) * (np.random.random_integers(N) - 1) / (N - 1.)

Examples
--------
>>> np.random.random_integers(5)
4 # random
>>> type(np.random.random_integers(5))
<class 'numpy.int64'>
>>> np.random.random_integers(5, size=(3,2))
array([[5, 4], # random
       [3, 3],
       [4, 5]])

Choose five random numbers from the set of five evenly-spaced
numbers between 0 and 2.5, inclusive ( *i.e.*, from the set
:math:`{0, 5/8, 10/8, 15/8, 20/8}`):

>>> 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.
array([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ]) # random

Roll two six sided dice 1000 times and sum the results:

>>> d1 = np.random.random_integers(1, 6, 1000)
>>> d2 = np.random.random_integers(1, 6, 1000)
>>> dsums = d1 + d2

Display results as a histogram:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(dsums, 11, density=True)
>>> plt.show()
*)

val random_sample : ?size:int list -> [> tag] Obj.t -> Py.Object.t
(**
random_sample(size=None)

Return random floats in the half-open interval [0.0, 1.0).

Results are from the 'continuous uniform' distribution over the
stated interval.  To sample :math:`Unif[a, b), b > a` multiply
the output of `random_sample` by `(b-a)` and add `a`::

  (b - a) * random_sample() + a

.. note::
    New code should use the ``random`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray of floats
    Array of random floats of shape `size` (unless ``size=None``, in which
    case a single float is returned).

See Also
--------
Generator.random: which should be used for new code.

Examples
--------
>>> np.random.random_sample()
0.47108547995356098 # random
>>> type(np.random.random_sample())
<class 'float'>
>>> np.random.random_sample((5,))
array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random

Three-by-two array of random numbers from [-5, 0):

>>> 5 * np.random.random_sample((3, 2)) - 5
array([[-3.99149989, -0.52338984], # random
       [-2.99091858, -0.79479508],
       [-1.23204345, -1.75224494]])
*)

val rayleigh : ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
rayleigh(scale=1.0, size=None)

Draw samples from a Rayleigh distribution.

The :math:`\chi` and Weibull distributions are generalizations of the
Rayleigh.

.. note::
    New code should use the ``rayleigh`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
scale : float or array_like of floats, optional
    Scale, also equals the mode. Must be non-negative. Default is 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``scale`` is a scalar.  Otherwise,
    ``np.array(scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Rayleigh distribution.

See Also
--------
Generator.rayleigh: which should be used for new code.

Notes
-----
The probability density function for the Rayleigh distribution is

.. math:: P(x;scale) = \frac{x}{scale^2}e^{\frac{-x^2}{2 \cdotp scale^2}}

The Rayleigh distribution would arise, for example, if the East
and North components of the wind velocity had identical zero-mean
Gaussian distributions.  Then the wind speed would have a Rayleigh
distribution.

References
----------
.. [1] Brighton Webs Ltd., 'Rayleigh Distribution,'
       https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp
.. [2] Wikipedia, 'Rayleigh distribution'
       https://en.wikipedia.org/wiki/Rayleigh_distribution

Examples
--------
Draw values from the distribution and plot the histogram

>>> from matplotlib.pyplot import hist
>>> values = hist(np.random.rayleigh(3, 100000), bins=200, density=True)

Wave heights tend to follow a Rayleigh distribution. If the mean wave
height is 1 meter, what fraction of waves are likely to be larger than 3
meters?

>>> meanvalue = 1
>>> modevalue = np.sqrt(2 / np.pi) * meanvalue
>>> s = np.random.rayleigh(modevalue, 1000000)

The percentage of waves larger than 3 meters is:

>>> 100.*sum(s>3)/1000000.
0.087300000000000003 # random
*)

val set_state : state:Py.Object.t -> [> tag] Obj.t -> Py.Object.t
(**
set_state(state)

Set the internal state of the generator from a tuple.

For use if one has reason to manually (re-)set the internal state of
the bit generator used by the RandomState instance. By default,
RandomState uses the 'Mersenne Twister'[1]_ pseudo-random number
generating algorithm.

Parameters
----------
state : {tuple(str, ndarray of 624 uints, int, int, float), dict}
    The `state` tuple has the following items:

    1. the string 'MT19937', specifying the Mersenne Twister algorithm.
    2. a 1-D array of 624 unsigned integers ``keys``.
    3. an integer ``pos``.
    4. an integer ``has_gauss``.
    5. a float ``cached_gaussian``.

    If state is a dictionary, it is directly set using the BitGenerators
    `state` property.

Returns
-------
out : None
    Returns 'None' on success.

See Also
--------
get_state

Notes
-----
`set_state` and `get_state` are not needed to work with any of the
random distributions in NumPy. If the internal state is manually altered,
the user should know exactly what he/she is doing.

For backwards compatibility, the form (str, array of 624 uints, int) is
also accepted although it is missing some information about the cached
Gaussian value: ``state = ('MT19937', keys, pos)``.

References
----------
.. [1] M. Matsumoto and T. Nishimura, 'Mersenne Twister: A
   623-dimensionally equidistributed uniform pseudorandom number
   generator,' *ACM Trans. on Modeling and Computer Simulation*,
   Vol. 8, No. 1, pp. 3-30, Jan. 1998.
*)

val shuffle : [>`Ndarray] Obj.t -> [> tag] Obj.t -> Py.Object.t
(**
shuffle(x)

Modify a sequence in-place by shuffling its contents.

This function only shuffles the array along the first axis of a
multi-dimensional array. The order of sub-arrays is changed but
their contents remains the same.

.. note::
    New code should use the ``shuffle`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
x : array_like
    The array or list to be shuffled.

Returns
-------
None

See Also
--------
Generator.shuffle: which should be used for new code.

Examples
--------
>>> arr = np.arange(10)
>>> np.random.shuffle(arr)
>>> arr
[1 7 5 2 9 4 3 6 0 8] # random

Multi-dimensional arrays are only shuffled along the first axis:

>>> arr = np.arange(9).reshape((3, 3))
>>> np.random.shuffle(arr)
>>> arr
array([[3, 4, 5], # random
       [6, 7, 8],
       [0, 1, 2]])
*)

val standard_cauchy : ?size:int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
standard_cauchy(size=None)

Draw samples from a standard Cauchy distribution with mode = 0.

Also known as the Lorentz distribution.

.. note::
    New code should use the ``standard_cauchy`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
    The drawn samples.

See Also
--------
Generator.standard_cauchy: which should be used for new code.

Notes
-----
The probability density function for the full Cauchy distribution is

.. math:: P(x; x_0, \gamma) = \frac{1}{\pi \gamma \bigl[ 1+
          (\frac{x-x_0}{\gamma})^2 \bigr] }

and the Standard Cauchy distribution just sets :math:`x_0=0` and
:math:`\gamma=1`

The Cauchy distribution arises in the solution to the driven harmonic
oscillator problem, and also describes spectral line broadening. It
also describes the distribution of values at which a line tilted at
a random angle will cut the x axis.

When studying hypothesis tests that assume normality, seeing how the
tests perform on data from a Cauchy distribution is a good indicator of
their sensitivity to a heavy-tailed distribution, since the Cauchy looks
very much like a Gaussian distribution, but with heavier tails.

References
----------
.. [1] NIST/SEMATECH e-Handbook of Statistical Methods, 'Cauchy
      Distribution',
      https://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm
.. [2] Weisstein, Eric W. 'Cauchy Distribution.' From MathWorld--A
      Wolfram Web Resource.
      http://mathworld.wolfram.com/CauchyDistribution.html
.. [3] Wikipedia, 'Cauchy distribution'
      https://en.wikipedia.org/wiki/Cauchy_distribution

Examples
--------
Draw samples and plot the distribution:

>>> import matplotlib.pyplot as plt
>>> s = np.random.standard_cauchy(1000000)
>>> s = s[(s>-25) & (s<25)]  # truncate distribution so it plots well
>>> plt.hist(s, bins=100)
>>> plt.show()
*)

val standard_exponential : ?size:int list -> [> tag] Obj.t -> Py.Object.t
(**
standard_exponential(size=None)

Draw samples from the standard exponential distribution.

`standard_exponential` is identical to the exponential distribution
with a scale parameter of 1.

.. note::
    New code should use the ``standard_exponential`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray
    Drawn samples.

See Also
--------
Generator.standard_exponential: which should be used for new code.

Examples
--------
Output a 3x8000 array:

>>> n = np.random.standard_exponential((3, 8000))
*)

val standard_gamma : ?size:int list -> int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
standard_gamma(shape, size=None)

Draw samples from a standard Gamma distribution.

Samples are drawn from a Gamma distribution with specified parameters,
shape (sometimes designated 'k') and scale=1.

.. note::
    New code should use the ``standard_gamma`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
shape : float or array_like of floats
    Parameter, must be non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``shape`` is a scalar.  Otherwise,
    ``np.array(shape).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized standard gamma distribution.

See Also
--------
scipy.stats.gamma : probability density function, distribution or
    cumulative density function, etc.
Generator.standard_gamma: which should be used for new code.

Notes
-----
The probability density for the Gamma distribution is

.. math:: p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},

where :math:`k` is the shape and :math:`\theta` the scale,
and :math:`\Gamma` is the Gamma function.

The Gamma distribution is often used to model the times to failure of
electronic components, and arises naturally in processes for which the
waiting times between Poisson distributed events are relevant.

References
----------
.. [1] Weisstein, Eric W. 'Gamma Distribution.' From MathWorld--A
       Wolfram Web Resource.
       http://mathworld.wolfram.com/GammaDistribution.html
.. [2] Wikipedia, 'Gamma distribution',
       https://en.wikipedia.org/wiki/Gamma_distribution

Examples
--------
Draw samples from the distribution:

>>> shape, scale = 2., 1. # mean and width
>>> s = np.random.standard_gamma(shape, 1000000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> import scipy.special as sps  # doctest: +SKIP
>>> count, bins, ignored = plt.hist(s, 50, density=True)
>>> y = bins**(shape-1) * ((np.exp(-bins/scale))/  # doctest: +SKIP
...                       (sps.gamma(shape) * scale**shape))
>>> plt.plot(bins, y, linewidth=2, color='r')  # doctest: +SKIP
>>> plt.show()
*)

val standard_normal : ?size:int list -> [> tag] Obj.t -> Py.Object.t
(**
standard_normal(size=None)

Draw samples from a standard Normal distribution (mean=0, stdev=1).

.. note::
    New code should use the ``standard_normal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray
    A floating-point array of shape ``size`` of drawn samples, or a
    single sample if ``size`` was not specified.

See Also
--------
normal :
    Equivalent function with additional ``loc`` and ``scale`` arguments
    for setting the mean and standard deviation.
Generator.standard_normal: which should be used for new code.

Notes
-----
For random samples from :math:`N(\mu, \sigma^2)`, use one of::

    mu + sigma * np.random.standard_normal(size=...)
    np.random.normal(mu, sigma, size=...)

Examples
--------
>>> np.random.standard_normal()
2.1923875335537315 #random

>>> s = np.random.standard_normal(8000)
>>> s
array([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random
       -0.38672696, -0.4685006 ])                                # random
>>> s.shape
(8000,)
>>> s = np.random.standard_normal(size=(3, 4, 2))
>>> s.shape
(3, 4, 2)

Two-by-four array of samples from :math:`N(3, 6.25)`:

>>> 3 + 2.5 * np.random.standard_normal(size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
*)

val standard_t : ?size:int list -> df:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
standard_t(df, size=None)

Draw samples from a standard Student's t distribution with `df` degrees
of freedom.

A special case of the hyperbolic distribution.  As `df` gets
large, the result resembles that of the standard normal
distribution (`standard_normal`).

.. note::
    New code should use the ``standard_t`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
df : float or array_like of floats
    Degrees of freedom, must be > 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``df`` is a scalar.  Otherwise,
    ``np.array(df).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized standard Student's t distribution.

See Also
--------
Generator.standard_t: which should be used for new code.

Notes
-----
The probability density function for the t distribution is

.. math:: P(x, df) = \frac{\Gamma(\frac{df+1}{2})}{\sqrt{\pi df}
          \Gamma(\frac{df}{2})}\Bigl( 1+\frac{x^2}{df} \Bigr)^{-(df+1)/2}

The t test is based on an assumption that the data come from a
Normal distribution. The t test provides a way to test whether
the sample mean (that is the mean calculated from the data) is
a good estimate of the true mean.

The derivation of the t-distribution was first published in
1908 by William Gosset while working for the Guinness Brewery
in Dublin. Due to proprietary issues, he had to publish under
a pseudonym, and so he used the name Student.

References
----------
.. [1] Dalgaard, Peter, 'Introductory Statistics With R',
       Springer, 2002.
.. [2] Wikipedia, 'Student's t-distribution'
       https://en.wikipedia.org/wiki/Student's_t-distribution

Examples
--------
From Dalgaard page 83 [1]_, suppose the daily energy intake for 11
women in kilojoules (kJ) is:

>>> intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \
...                    7515, 8230, 8770])

Does their energy intake deviate systematically from the recommended
value of 7725 kJ?

We have 10 degrees of freedom, so is the sample mean within 95% of the
recommended value?

>>> s = np.random.standard_t(10, size=100000)
>>> np.mean(intake)
6753.636363636364
>>> intake.std(ddof=1)
1142.1232221373727

Calculate the t statistic, setting the ddof parameter to the unbiased
value so the divisor in the standard deviation will be degrees of
freedom, N-1.

>>> t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))
>>> import matplotlib.pyplot as plt
>>> h = plt.hist(s, bins=100, density=True)

For a one-sided t-test, how far out in the distribution does the t
statistic appear?

>>> np.sum(s<t) / float(len(s))
0.0090699999999999999  #random

So the p-value is about 0.009, which says the null hypothesis has a
probability of about 99% of being true.
*)

val tomaxint : ?size:int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
tomaxint(size=None)

Return a sample of uniformly distributed random integers in the interval
[0, ``np.iinfo(np.int_).max``]. The `np.int_` type translates to the C long
integer type and its precision is platform dependent.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : ndarray
    Drawn samples, with shape `size`.

See Also
--------
randint : Uniform sampling over a given half-open interval of integers.
random_integers : Uniform sampling over a given closed interval of
    integers.

Examples
--------
>>> rs = np.random.RandomState() # need a RandomState object
>>> rs.tomaxint((2,2,2))
array([[[1170048599, 1600360186], # random
        [ 739731006, 1947757578]],
       [[1871712945,  752307660],
        [1601631370, 1479324245]]])
>>> rs.tomaxint((2,2,2)) < np.iinfo(np.int_).max
array([[[ True,  True],
        [ True,  True]],
       [[ True,  True],
        [ True,  True]]])
*)

val triangular : ?size:int list -> left:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> mode:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> right:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
triangular(left, mode, right, size=None)

Draw samples from the triangular distribution over the
interval ``[left, right]``.

The triangular distribution is a continuous probability
distribution with lower limit left, peak at mode, and upper
limit right. Unlike the other distributions, these parameters
directly define the shape of the pdf.

.. note::
    New code should use the ``triangular`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
left : float or array_like of floats
    Lower limit.
mode : float or array_like of floats
    The value where the peak of the distribution occurs.
    The value must fulfill the condition ``left <= mode <= right``.
right : float or array_like of floats
    Upper limit, must be larger than `left`.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``left``, ``mode``, and ``right``
    are all scalars.  Otherwise, ``np.broadcast(left, mode, right).size``
    samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized triangular distribution.

See Also
--------
Generator.triangular: which should be used for new code.

Notes
-----
The probability density function for the triangular distribution is

.. math:: P(x;l, m, r) = \begin{cases}
          \frac{2(x-l)}{(r-l)(m-l)}& \text{for $l \leq x \leq m$},\\
          \frac{2(r-x)}{(r-l)(r-m)}& \text{for $m \leq x \leq r$},\\
          0& \text{otherwise}.
          \end{cases}

The triangular distribution is often used in ill-defined
problems where the underlying distribution is not known, but
some knowledge of the limits and mode exists. Often it is used
in simulations.

References
----------
.. [1] Wikipedia, 'Triangular distribution'
       https://en.wikipedia.org/wiki/Triangular_distribution

Examples
--------
Draw values from the distribution and plot the histogram:

>>> import matplotlib.pyplot as plt
>>> h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,
...              density=True)
>>> plt.show()
*)

val uniform : ?low:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?high:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
uniform(low=0.0, high=1.0, size=None)

Draw samples from a uniform distribution.

Samples are uniformly distributed over the half-open interval
``[low, high)`` (includes low, but excludes high).  In other words,
any value within the given interval is equally likely to be drawn
by `uniform`.

.. note::
    New code should use the ``uniform`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
low : float or array_like of floats, optional
    Lower boundary of the output interval.  All values generated will be
    greater than or equal to low.  The default value is 0.
high : float or array_like of floats
    Upper boundary of the output interval.  All values generated will be
    less than high.  The default value is 1.0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``low`` and ``high`` are both scalars.
    Otherwise, ``np.broadcast(low, high).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized uniform distribution.

See Also
--------
randint : Discrete uniform distribution, yielding integers.
random_integers : Discrete uniform distribution over the closed
                  interval ``[low, high]``.
random_sample : Floats uniformly distributed over ``[0, 1)``.
random : Alias for `random_sample`.
rand : Convenience function that accepts dimensions as input, e.g.,
       ``rand(2,2)`` would generate a 2-by-2 array of floats,
       uniformly distributed over ``[0, 1)``.
Generator.uniform: which should be used for new code.

Notes
-----
The probability density function of the uniform distribution is

.. math:: p(x) = \frac{1}{b - a}

anywhere within the interval ``[a, b)``, and zero elsewhere.

When ``high`` == ``low``, values of ``low`` will be returned.
If ``high`` < ``low``, the results are officially undefined
and may eventually raise an error, i.e. do not rely on this
function to behave when passed arguments satisfying that
inequality condition.

Examples
--------
Draw samples from the distribution:

>>> s = np.random.uniform(-1,0,1000)

All values are within the given interval:

>>> np.all(s >= -1)
True
>>> np.all(s < 0)
True

Display the histogram of the samples, along with the
probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 15, density=True)
>>> plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')
>>> plt.show()
*)

val vonmises : ?size:int list -> mu:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> kappa:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
vonmises(mu, kappa, size=None)

Draw samples from a von Mises distribution.

Samples are drawn from a von Mises distribution with specified mode
(mu) and dispersion (kappa), on the interval [-pi, pi].

The von Mises distribution (also known as the circular normal
distribution) is a continuous probability distribution on the unit
circle.  It may be thought of as the circular analogue of the normal
distribution.

.. note::
    New code should use the ``vonmises`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
mu : float or array_like of floats
    Mode ('center') of the distribution.
kappa : float or array_like of floats
    Dispersion of the distribution, has to be >=0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``mu`` and ``kappa`` are both scalars.
    Otherwise, ``np.broadcast(mu, kappa).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized von Mises distribution.

See Also
--------
scipy.stats.vonmises : probability density function, distribution, or
    cumulative density function, etc.
Generator.vonmises: which should be used for new code.

Notes
-----
The probability density for the von Mises distribution is

.. math:: p(x) = \frac{e^{\kappa cos(x-\mu)}}{2\pi I_0(\kappa)},

where :math:`\mu` is the mode and :math:`\kappa` the dispersion,
and :math:`I_0(\kappa)` is the modified Bessel function of order 0.

The von Mises is named for Richard Edler von Mises, who was born in
Austria-Hungary, in what is now the Ukraine.  He fled to the United
States in 1939 and became a professor at Harvard.  He worked in
probability theory, aerodynamics, fluid mechanics, and philosophy of
science.

References
----------
.. [1] Abramowitz, M. and Stegun, I. A. (Eds.). 'Handbook of
       Mathematical Functions with Formulas, Graphs, and Mathematical
       Tables, 9th printing,' New York: Dover, 1972.
.. [2] von Mises, R., 'Mathematical Theory of Probability
       and Statistics', New York: Academic Press, 1964.

Examples
--------
Draw samples from the distribution:

>>> mu, kappa = 0.0, 4.0 # mean and dispersion
>>> s = np.random.vonmises(mu, kappa, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> from scipy.special import i0  # doctest: +SKIP
>>> plt.hist(s, 50, density=True)
>>> x = np.linspace(-np.pi, np.pi, num=51)
>>> y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  # doctest: +SKIP
>>> plt.plot(x, y, linewidth=2, color='r')  # doctest: +SKIP
>>> plt.show()
*)

val wald : ?size:int list -> mean:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
wald(mean, scale, size=None)

Draw samples from a Wald, or inverse Gaussian, distribution.

As the scale approaches infinity, the distribution becomes more like a
Gaussian. Some references claim that the Wald is an inverse Gaussian
with mean equal to 1, but this is by no means universal.

The inverse Gaussian distribution was first studied in relationship to
Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian
because there is an inverse relationship between the time to cover a
unit distance and distance covered in unit time.

.. note::
    New code should use the ``wald`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
mean : float or array_like of floats
    Distribution mean, must be > 0.
scale : float or array_like of floats
    Scale parameter, must be > 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``mean`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(mean, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Wald distribution.

See Also
--------
Generator.wald: which should be used for new code.

Notes
-----
The probability density function for the Wald distribution is

.. math:: P(x;mean,scale) = \sqrt{\frac{scale}{2\pi x^3}}e^
                            \frac{-scale(x-mean)^2}{2\cdotp mean^2x}

As noted above the inverse Gaussian distribution first arise
from attempts to model Brownian motion. It is also a
competitor to the Weibull for use in reliability modeling and
modeling stock returns and interest rate processes.

References
----------
.. [1] Brighton Webs Ltd., Wald Distribution,
       https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp
.. [2] Chhikara, Raj S., and Folks, J. Leroy, 'The Inverse Gaussian
       Distribution: Theory : Methodology, and Applications', CRC Press,
       1988.
.. [3] Wikipedia, 'Inverse Gaussian distribution'
       https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution

Examples
--------
Draw values from the distribution and plot the histogram:

>>> import matplotlib.pyplot as plt
>>> h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True)
>>> plt.show()
*)

val weibull : ?size:int list -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
weibull(a, size=None)

Draw samples from a Weibull distribution.

Draw samples from a 1-parameter Weibull distribution with the given
shape parameter `a`.

.. math:: X = (-ln(U))^{1/a}

Here, U is drawn from the uniform distribution over (0,1].

The more common 2-parameter Weibull, including a scale parameter
:math:`\lambda` is just :math:`X = \lambda(-ln(U))^{1/a}`.

.. note::
    New code should use the ``weibull`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Shape parameter of the distribution.  Must be nonnegative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` is a scalar.  Otherwise,
    ``np.array(a).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Weibull distribution.

See Also
--------
scipy.stats.weibull_max
scipy.stats.weibull_min
scipy.stats.genextreme
gumbel
Generator.weibull: which should be used for new code.

Notes
-----
The Weibull (or Type III asymptotic extreme value distribution
for smallest values, SEV Type III, or Rosin-Rammler
distribution) is one of a class of Generalized Extreme Value
(GEV) distributions used in modeling extreme value problems.
This class includes the Gumbel and Frechet distributions.

The probability density for the Weibull distribution is

.. math:: p(x) = \frac{a}
                 {\lambda}(\frac{x}{\lambda})^{a-1}e^{-(x/\lambda)^a},

where :math:`a` is the shape and :math:`\lambda` the scale.

The function has its peak (the mode) at
:math:`\lambda(\frac{a-1}{a})^{1/a}`.

When ``a = 1``, the Weibull distribution reduces to the exponential
distribution.

References
----------
.. [1] Waloddi Weibull, Royal Technical University, Stockholm,
       1939 'A Statistical Theory Of The Strength Of Materials',
       Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939,
       Generalstabens Litografiska Anstalts Forlag, Stockholm.
.. [2] Waloddi Weibull, 'A Statistical Distribution Function of
       Wide Applicability', Journal Of Applied Mechanics ASME Paper
       1951.
.. [3] Wikipedia, 'Weibull distribution',
       https://en.wikipedia.org/wiki/Weibull_distribution

Examples
--------
Draw samples from the distribution:

>>> a = 5. # shape
>>> s = np.random.weibull(a, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> x = np.arange(1,100.)/50.
>>> def weib(x,n,a):
...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)

>>> count, bins, ignored = plt.hist(np.random.weibull(5.,1000))
>>> x = np.arange(1,100.)/50.
>>> scale = count.max()/weib(x, 1., 5.).max()
>>> plt.plot(x, weib(x, 1., 5.)*scale)
>>> plt.show()
*)

val zipf : ?size:int list -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [> tag] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
zipf(a, size=None)

Draw samples from a Zipf distribution.

Samples are drawn from a Zipf distribution with specified parameter
`a` > 1.

The Zipf distribution (also known as the zeta distribution) is a
continuous probability distribution that satisfies Zipf's law: the
frequency of an item is inversely proportional to its rank in a
frequency table.

.. note::
    New code should use the ``zipf`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Distribution parameter. Must be greater than 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` is a scalar. Otherwise,
    ``np.array(a).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Zipf distribution.

See Also
--------
scipy.stats.zipf : probability density function, distribution, or
    cumulative density function, etc.
Generator.zipf: which should be used for new code.

Notes
-----
The probability density for the Zipf distribution is

.. math:: p(x) = \frac{x^{-a}}{\zeta(a)},

where :math:`\zeta` is the Riemann Zeta function.

It is named for the American linguist George Kingsley Zipf, who noted
that the frequency of any word in a sample of a language is inversely
proportional to its rank in the frequency table.

References
----------
.. [1] Zipf, G. K., 'Selected Studies of the Principle of Relative
       Frequency in Language,' Cambridge, MA: Harvard Univ. Press,
       1932.

Examples
--------
Draw samples from the distribution:

>>> a = 2. # parameter
>>> s = np.random.zipf(a, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> from scipy import special  # doctest: +SKIP

Truncate s values at 50 so plot is interesting:

>>> count, bins, ignored = plt.hist(s[s<50], 50, density=True)
>>> x = np.arange(1., 50.)
>>> y = x**(-a) / special.zetac(a)  # doctest: +SKIP
>>> plt.plot(x, y/max(y), linewidth=2, color='r')  # doctest: +SKIP
>>> plt.show()
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module SFC64 : sig
type tag = [`SFC64]
type t = [`Object | `SFC64] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?seed:[`I of int | `PyObject of Py.Object.t] -> unit -> t
(**
SFC64(seed=None)

BitGenerator for Chris Doty-Humphrey's Small Fast Chaotic PRNG.

Parameters
----------
seed : {None, int, array_like[ints], SeedSequence}, optional
    A seed to initialize the `BitGenerator`. If None, then fresh,
    unpredictable entropy will be pulled from the OS. If an ``int`` or
    ``array_like[ints]`` is passed, then it will be passed to
    `SeedSequence` to derive the initial `BitGenerator` state. One may also
    pass in a `SeedSequence` instance.

Notes
-----
``SFC64`` is a 256-bit implementation of Chris Doty-Humphrey's Small Fast
Chaotic PRNG ([1]_). ``SFC64`` has a few different cycles that one might be
on, depending on the seed; the expected period will be about
:math:`2^{255}` ([2]_). ``SFC64`` incorporates a 64-bit counter which means
that the absolute minimum cycle length is :math:`2^{64}` and that distinct
seeds will not run into each other for at least :math:`2^{64}` iterations.

``SFC64`` provides a capsule containing function pointers that produce
doubles, and unsigned 32 and 64- bit integers. These are not
directly consumable in Python and must be consumed by a ``Generator``
or similar object that supports low-level access.

**State and Seeding**

The ``SFC64`` state vector consists of 4 unsigned 64-bit values. The last
is a 64-bit counter that increments by 1 each iteration.

The input seed is processed by `SeedSequence` to generate the first
3 values, then the ``SFC64`` algorithm is iterated a small number of times
to mix.

**Compatibility Guarantee**

``SFC64`` makes a guarantee that a fixed seed will always produce the same
random integer stream.

References
----------
.. [1] `'PractRand'
        <http://pracrand.sourceforge.net/RNG_engines.txt>`_
.. [2] `'Random Invertible Mapping Statistics'
        <http://www.pcg-random.org/posts/random-invertible-mapping-statistics.html>`_
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module SeedSequence : sig
type tag = [`SeedSequence]
type t = [`Object | `SeedSequence] Obj.t
val of_pyobject : Py.Object.t -> t
val to_pyobject : [> tag] Obj.t -> Py.Object.t

val create : ?entropy:[`I of int | `Sequence_int_ of Py.Object.t] -> ?spawn_key:Py.Object.t -> ?pool_size:Py.Object.t -> unit -> t
(**
SeedSequence(entropy=None, *, spawn_key=(), pool_size=4)

SeedSequence mixes sources of entropy in a reproducible way to set the
initial state for independent and very probably non-overlapping
BitGenerators.

Once the SeedSequence is instantiated, you can call the `generate_state`
method to get an appropriately sized seed. Calling `spawn(n) <spawn>` will
create ``n`` SeedSequences that can be used to seed independent
BitGenerators, i.e. for different threads.

Parameters
----------
entropy : {None, int, sequence[int]}, optional
    The entropy for creating a `SeedSequence`.
spawn_key : {(), sequence[int]}, optional
    A third source of entropy, used internally when calling
    `SeedSequence.spawn`
pool_size : {int}, optional
    Size of the pooled entropy to store. Default is 4 to give a 128-bit
    entropy pool. 8 (for 256 bits) is another reasonable choice if working
    with larger PRNGs, but there is very little to be gained by selecting
    another value.
n_children_spawned : {int}, optional
    The number of children already spawned. Only pass this if
    reconstructing a `SeedSequence` from a serialized form.

Notes
-----

Best practice for achieving reproducible bit streams is to use
the default ``None`` for the initial entropy, and then use
`SeedSequence.entropy` to log/pickle the `entropy` for reproducibility:

>>> sq1 = np.random.SeedSequence()
>>> sq1.entropy
243799254704924441050048792905230269161  # random
>>> sq2 = np.random.SeedSequence(sq1.entropy)
>>> np.all(sq1.generate_state(10) == sq2.generate_state(10))
True
*)

val generate_state : ?dtype:Py.Object.t -> n_words:int -> [> tag] Obj.t -> Py.Object.t
(**
generate_state(n_words, dtype=np.uint32)

Return the requested number of words for PRNG seeding.

A BitGenerator should call this method in its constructor with
an appropriate `n_words` parameter to properly seed itself.

Parameters
----------
n_words : int
dtype : np.uint32 or np.uint64, optional
    The size of each word. This should only be either `uint32` or
    `uint64`. Strings (`'uint32'`, `'uint64'`) are fine. Note that
    requesting `uint64` will draw twice as many bits as `uint32` for
    the same `n_words`. This is a convenience for `BitGenerator`s that
    express their states as `uint64` arrays.

Returns
-------
state : uint32 or uint64 array, shape=(n_words,)
*)

val spawn : n_children:int -> [> tag] Obj.t -> Py.Object.t
(**
spawn(n_children)

Spawn a number of child `SeedSequence` s by extending the
`spawn_key`.

Parameters
----------
n_children : int

Returns
-------
seqs : list of `SeedSequence` s
*)


(** Print the object to a human-readable representation. *)
val to_string : t -> string


(** Print the object to a human-readable representation. *)
val show : t -> string

(** Pretty-print the object to a formatter. *)
val pp : Format.formatter -> t -> unit [@@ocaml.toplevel_printer]


end

module Mtrand : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t

val beta : ?size:int list -> b:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
beta(a, b, size=None)

Draw samples from a Beta distribution.

The Beta distribution is a special case of the Dirichlet distribution,
and is related to the Gamma distribution.  It has the probability
distribution function

.. math:: f(x; a,b) = \frac{1}{B(\alpha, \beta)} x^{\alpha - 1}
                                                 (1 - x)^{\beta - 1},

where the normalization, B, is the beta function,

.. math:: B(\alpha, \beta) = \int_0^1 t^{\alpha - 1}
                             (1 - t)^{\beta - 1} dt.

It is often seen in Bayesian inference and order statistics.

.. note::
    New code should use the ``beta`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Alpha, positive (>0).
b : float or array_like of floats
    Beta, positive (>0).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` and ``b`` are both scalars.
    Otherwise, ``np.broadcast(a, b).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized beta distribution.

See Also
--------
Generator.beta: which should be used for new code.
*)

val binomial : ?size:int list -> n:[`I of int | `Array_like_of_ints of Py.Object.t] -> p:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
binomial(n, p, size=None)

Draw samples from a binomial distribution.

Samples are drawn from a binomial distribution with specified
parameters, n trials and p probability of success where
n an integer >= 0 and p is in the interval [0,1]. (n may be
input as a float, but it is truncated to an integer in use)

.. note::
    New code should use the ``binomial`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
n : int or array_like of ints
    Parameter of the distribution, >= 0. Floats are also accepted,
    but they will be truncated to integers.
p : float or array_like of floats
    Parameter of the distribution, >= 0 and <=1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``n`` and ``p`` are both scalars.
    Otherwise, ``np.broadcast(n, p).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized binomial distribution, where
    each sample is equal to the number of successes over the n trials.

See Also
--------
scipy.stats.binom : probability density function, distribution or
    cumulative density function, etc.
Generator.binomial: which should be used for new code.

Notes
-----
The probability density for the binomial distribution is

.. math:: P(N) = \binom{n}{N}p^N(1-p)^{n-N},

where :math:`n` is the number of trials, :math:`p` is the probability
of success, and :math:`N` is the number of successes.

When estimating the standard error of a proportion in a population by
using a random sample, the normal distribution works well unless the
product p*n <=5, where p = population proportion estimate, and n =
number of samples, in which case the binomial distribution is used
instead. For example, a sample of 15 people shows 4 who are left
handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,
so the binomial distribution should be used in this case.

References
----------
.. [1] Dalgaard, Peter, 'Introductory Statistics with R',
       Springer-Verlag, 2002.
.. [2] Glantz, Stanton A. 'Primer of Biostatistics.', McGraw-Hill,
       Fifth Edition, 2002.
.. [3] Lentner, Marvin, 'Elementary Applied Statistics', Bogden
       and Quigley, 1972.
.. [4] Weisstein, Eric W. 'Binomial Distribution.' From MathWorld--A
       Wolfram Web Resource.
       http://mathworld.wolfram.com/BinomialDistribution.html
.. [5] Wikipedia, 'Binomial distribution',
       https://en.wikipedia.org/wiki/Binomial_distribution

Examples
--------
Draw samples from the distribution:

>>> n, p = 10, .5  # number of trials, probability of each trial
>>> s = np.random.binomial(n, p, 1000)
# result of flipping a coin 10 times, tested 1000 times.

A real world example. A company drills 9 wild-cat oil exploration
wells, each with an estimated probability of success of 0.1. All nine
wells fail. What is the probability of that happening?

Let's do 20,000 trials of the model, and count the number that
generate zero positive results.

>>> sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.
# answer = 0.38885, or 38%.
*)

val bytes : int -> string
(**
bytes(length)

Return random bytes.

.. note::
    New code should use the ``bytes`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
length : int
    Number of random bytes.

Returns
-------
out : str
    String of length `length`.

See Also
--------
Generator.bytes: which should be used for new code.

Examples
--------
>>> np.random.bytes(10)
' eh\x85\x022SZ\xbf\xa4' #random
*)

val chisquare : ?size:int list -> df:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
chisquare(df, size=None)

Draw samples from a chi-square distribution.

When `df` independent random variables, each with standard normal
distributions (mean 0, variance 1), are squared and summed, the
resulting distribution is chi-square (see Notes).  This distribution
is often used in hypothesis testing.

.. note::
    New code should use the ``chisquare`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
df : float or array_like of floats
     Number of degrees of freedom, must be > 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``df`` is a scalar.  Otherwise,
    ``np.array(df).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized chi-square distribution.

Raises
------
ValueError
    When `df` <= 0 or when an inappropriate `size` (e.g. ``size=-1``)
    is given.

See Also
--------
Generator.chisquare: which should be used for new code.

Notes
-----
The variable obtained by summing the squares of `df` independent,
standard normally distributed random variables:

.. math:: Q = \sum_{i=0}^{\mathtt{df}} X^2_i

is chi-square distributed, denoted

.. math:: Q \sim \chi^2_k.

The probability density function of the chi-squared distribution is

.. math:: p(x) = \frac{(1/2)^{k/2}}{\Gamma(k/2)}
                 x^{k/2 - 1} e^{-x/2},

where :math:`\Gamma` is the gamma function,

.. math:: \Gamma(x) = \int_0^{-\infty} t^{x - 1} e^{-t} dt.

References
----------
.. [1] NIST 'Engineering Statistics Handbook'
       https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm

Examples
--------
>>> np.random.chisquare(2,4)
array([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random
*)

val choice : ?size:int list -> ?replace:bool -> ?p:Py.Object.t -> [`T1_D_array_like of Py.Object.t | `I of int] -> Py.Object.t
(**
choice(a, size=None, replace=True, p=None)

Generates a random sample from a given 1-D array

        .. versionadded:: 1.7.0

.. note::
    New code should use the ``choice`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : 1-D array-like or int
    If an ndarray, a random sample is generated from its elements.
    If an int, the random sample is generated as if a were np.arange(a)
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.
replace : boolean, optional
    Whether the sample is with or without replacement
p : 1-D array-like, optional
    The probabilities associated with each entry in a.
    If not given the sample assumes a uniform distribution over all
    entries in a.

Returns
-------
samples : single item or ndarray
    The generated random samples

Raises
------
ValueError
    If a is an int and less than zero, if a or p are not 1-dimensional,
    if a is an array-like of size 0, if p is not a vector of
    probabilities, if a and p have different lengths, or if
    replace=False and the sample size is greater than the population
    size

See Also
--------
randint, shuffle, permutation
Generator.choice: which should be used in new code

Examples
--------
Generate a uniform random sample from np.arange(5) of size 3:

>>> np.random.choice(5, 3)
array([0, 3, 4]) # random
>>> #This is equivalent to np.random.randint(0,5,3)

Generate a non-uniform random sample from np.arange(5) of size 3:

>>> np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])
array([3, 3, 0]) # random

Generate a uniform random sample from np.arange(5) of size 3 without
replacement:

>>> np.random.choice(5, 3, replace=False)
array([3,1,0]) # random
>>> #This is equivalent to np.random.permutation(np.arange(5))[:3]

Generate a non-uniform random sample from np.arange(5) of size
3 without replacement:

>>> np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])
array([2, 3, 0]) # random

Any of the above can be repeated with an arbitrary array-like
instead of just integers. For instance:

>>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']
>>> np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])
array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random
      dtype='<U11')
*)

val dirichlet : ?size:int list -> alpha:[`Ndarray of [>`Ndarray] Obj.t | `Length_k of Py.Object.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
dirichlet(alpha, size=None)

Draw samples from the Dirichlet distribution.

Draw `size` samples of dimension k from a Dirichlet distribution. A
Dirichlet-distributed random variable can be seen as a multivariate
generalization of a Beta distribution. The Dirichlet distribution
is a conjugate prior of a multinomial distribution in Bayesian
inference.

.. note::
    New code should use the ``dirichlet`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
alpha : sequence of floats, length k
    Parameter of the distribution (length ``k`` for sample of
    length ``k``).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    vector of length ``k`` is returned.

Returns
-------
samples : ndarray,
    The drawn samples, of shape ``(size, k)``.

Raises
-------
ValueError
    If any value in ``alpha`` is less than or equal to zero

See Also
--------
Generator.dirichlet: which should be used for new code.

Notes
-----
The Dirichlet distribution is a distribution over vectors
:math:`x` that fulfil the conditions :math:`x_i>0` and
:math:`\sum_{i=1}^k x_i = 1`.

The probability density function :math:`p` of a
Dirichlet-distributed random vector :math:`X` is
proportional to

.. math:: p(x) \propto \prod_{i=1}^{k}{x^{\alpha_i-1}_i},

where :math:`\alpha` is a vector containing the positive
concentration parameters.

The method uses the following property for computation: let :math:`Y`
be a random vector which has components that follow a standard gamma
distribution, then :math:`X = \frac{1}{\sum_{i=1}^k{Y_i}} Y`
is Dirichlet-distributed

References
----------
.. [1] David McKay, 'Information Theory, Inference and Learning
       Algorithms,' chapter 23,
       http://www.inference.org.uk/mackay/itila/
.. [2] Wikipedia, 'Dirichlet distribution',
       https://en.wikipedia.org/wiki/Dirichlet_distribution

Examples
--------
Taking an example cited in Wikipedia, this distribution can be used if
one wanted to cut strings (each of initial length 1.0) into K pieces
with different lengths, where each piece had, on average, a designated
average length, but allowing some variation in the relative sizes of
the pieces.

>>> s = np.random.dirichlet((10, 5, 3), 20).transpose()

>>> import matplotlib.pyplot as plt
>>> plt.barh(range(20), s[0])
>>> plt.barh(range(20), s[1], left=s[0], color='g')
>>> plt.barh(range(20), s[2], left=s[0]+s[1], color='r')
>>> plt.title('Lengths of Strings')
*)

val exponential : ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
exponential(scale=1.0, size=None)

Draw samples from an exponential distribution.

Its probability density function is

.. math:: f(x; \frac{1}{\beta}) = \frac{1}{\beta} \exp(-\frac{x}{\beta}),

for ``x > 0`` and 0 elsewhere. :math:`\beta` is the scale parameter,
which is the inverse of the rate parameter :math:`\lambda = 1/\beta`.
The rate parameter is an alternative, widely used parameterization
of the exponential distribution [3]_.

The exponential distribution is a continuous analogue of the
geometric distribution.  It describes many common situations, such as
the size of raindrops measured over many rainstorms [1]_, or the time
between page requests to Wikipedia [2]_.

.. note::
    New code should use the ``exponential`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
scale : float or array_like of floats
    The scale parameter, :math:`\beta = 1/\lambda`. Must be
    non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``scale`` is a scalar.  Otherwise,
    ``np.array(scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized exponential distribution.

See Also
--------
Generator.exponential: which should be used for new code.

References
----------
.. [1] Peyton Z. Peebles Jr., 'Probability, Random Variables and
       Random Signal Principles', 4th ed, 2001, p. 57.
.. [2] Wikipedia, 'Poisson process',
       https://en.wikipedia.org/wiki/Poisson_process
.. [3] Wikipedia, 'Exponential distribution',
       https://en.wikipedia.org/wiki/Exponential_distribution
*)

val f : ?size:int list -> dfnum:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> dfden:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
f(dfnum, dfden, size=None)

Draw samples from an F distribution.

Samples are drawn from an F distribution with specified parameters,
`dfnum` (degrees of freedom in numerator) and `dfden` (degrees of
freedom in denominator), where both parameters must be greater than
zero.

The random variate of the F distribution (also known as the
Fisher distribution) is a continuous probability distribution
that arises in ANOVA tests, and is the ratio of two chi-square
variates.

.. note::
    New code should use the ``f`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
dfnum : float or array_like of floats
    Degrees of freedom in numerator, must be > 0.
dfden : float or array_like of float
    Degrees of freedom in denominator, must be > 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``dfnum`` and ``dfden`` are both scalars.
    Otherwise, ``np.broadcast(dfnum, dfden).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Fisher distribution.

See Also
--------
scipy.stats.f : probability density function, distribution or
    cumulative density function, etc.
Generator.f: which should be used for new code.

Notes
-----
The F statistic is used to compare in-group variances to between-group
variances. Calculating the distribution depends on the sampling, and
so it is a function of the respective degrees of freedom in the
problem.  The variable `dfnum` is the number of samples minus one, the
between-groups degrees of freedom, while `dfden` is the within-groups
degrees of freedom, the sum of the number of samples in each group
minus the number of groups.

References
----------
.. [1] Glantz, Stanton A. 'Primer of Biostatistics.', McGraw-Hill,
       Fifth Edition, 2002.
.. [2] Wikipedia, 'F-distribution',
       https://en.wikipedia.org/wiki/F-distribution

Examples
--------
An example from Glantz[1], pp 47-40:

Two groups, children of diabetics (25 people) and children from people
without diabetes (25 controls). Fasting blood glucose was measured,
case group had a mean value of 86.1, controls had a mean value of
82.2. Standard deviations were 2.09 and 2.49 respectively. Are these
data consistent with the null hypothesis that the parents diabetic
status does not affect their children's blood glucose levels?
Calculating the F statistic from the data gives a value of 36.01.

Draw samples from the distribution:

>>> dfnum = 1. # between group degrees of freedom
>>> dfden = 48. # within groups degrees of freedom
>>> s = np.random.f(dfnum, dfden, 1000)

The lower bound for the top 1% of the samples is :

>>> np.sort(s)[-10]
7.61988120985 # random

So there is about a 1% chance that the F statistic will exceed 7.62,
the measured value is 36, so the null hypothesis is rejected at the 1%
level.
*)

val gamma : ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> int list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
gamma(shape, scale=1.0, size=None)

Draw samples from a Gamma distribution.

Samples are drawn from a Gamma distribution with specified parameters,
`shape` (sometimes designated 'k') and `scale` (sometimes designated
'theta'), where both parameters are > 0.

.. note::
    New code should use the ``gamma`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
shape : float or array_like of floats
    The shape of the gamma distribution. Must be non-negative.
scale : float or array_like of floats, optional
    The scale of the gamma distribution. Must be non-negative.
    Default is equal to 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``shape`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(shape, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized gamma distribution.

See Also
--------
scipy.stats.gamma : probability density function, distribution or
    cumulative density function, etc.
Generator.gamma: which should be used for new code.

Notes
-----
The probability density for the Gamma distribution is

.. math:: p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},

where :math:`k` is the shape and :math:`\theta` the scale,
and :math:`\Gamma` is the Gamma function.

The Gamma distribution is often used to model the times to failure of
electronic components, and arises naturally in processes for which the
waiting times between Poisson distributed events are relevant.

References
----------
.. [1] Weisstein, Eric W. 'Gamma Distribution.' From MathWorld--A
       Wolfram Web Resource.
       http://mathworld.wolfram.com/GammaDistribution.html
.. [2] Wikipedia, 'Gamma distribution',
       https://en.wikipedia.org/wiki/Gamma_distribution

Examples
--------
Draw samples from the distribution:

>>> shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)
>>> s = np.random.gamma(shape, scale, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> import scipy.special as sps  # doctest: +SKIP
>>> count, bins, ignored = plt.hist(s, 50, density=True)
>>> y = bins**(shape-1)*(np.exp(-bins/scale) /  # doctest: +SKIP
...                      (sps.gamma(shape)*scale**shape))
>>> plt.plot(bins, y, linewidth=2, color='r')  # doctest: +SKIP
>>> plt.show()
*)

val geometric : ?size:int list -> p:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
geometric(p, size=None)

Draw samples from the geometric distribution.

Bernoulli trials are experiments with one of two outcomes:
success or failure (an example of such an experiment is flipping
a coin).  The geometric distribution models the number of trials
that must be run in order to achieve success.  It is therefore
supported on the positive integers, ``k = 1, 2, ...``.

The probability mass function of the geometric distribution is

.. math:: f(k) = (1 - p)^{k - 1} p

where `p` is the probability of success of an individual trial.

.. note::
    New code should use the ``geometric`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
p : float or array_like of floats
    The probability of success of an individual trial.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``p`` is a scalar.  Otherwise,
    ``np.array(p).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized geometric distribution.

See Also
--------
Generator.geometric: which should be used for new code.

Examples
--------
Draw ten thousand values from the geometric distribution,
with the probability of an individual success equal to 0.35:

>>> z = np.random.geometric(p=0.35, size=10000)

How many trials succeeded after a single run?

>>> (z == 1).sum() / 10000.
0.34889999999999999 #random
*)

val gumbel : ?loc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
gumbel(loc=0.0, scale=1.0, size=None)

Draw samples from a Gumbel distribution.

Draw samples from a Gumbel distribution with specified location and
scale.  For more information on the Gumbel distribution, see
Notes and References below.

.. note::
    New code should use the ``gumbel`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
loc : float or array_like of floats, optional
    The location of the mode of the distribution. Default is 0.
scale : float or array_like of floats, optional
    The scale parameter of the distribution. Default is 1. Must be non-
    negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``loc`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Gumbel distribution.

See Also
--------
scipy.stats.gumbel_l
scipy.stats.gumbel_r
scipy.stats.genextreme
weibull
Generator.gumbel: which should be used for new code.

Notes
-----
The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme
Value Type I) distribution is one of a class of Generalized Extreme
Value (GEV) distributions used in modeling extreme value problems.
The Gumbel is a special case of the Extreme Value Type I distribution
for maximums from distributions with 'exponential-like' tails.

The probability density for the Gumbel distribution is

.. math:: p(x) = \frac{e^{-(x - \mu)/ \beta}}{\beta} e^{ -e^{-(x - \mu)/
          \beta}},

where :math:`\mu` is the mode, a location parameter, and
:math:`\beta` is the scale parameter.

The Gumbel (named for German mathematician Emil Julius Gumbel) was used
very early in the hydrology literature, for modeling the occurrence of
flood events. It is also used for modeling maximum wind speed and
rainfall rates.  It is a 'fat-tailed' distribution - the probability of
an event in the tail of the distribution is larger than if one used a
Gaussian, hence the surprisingly frequent occurrence of 100-year
floods. Floods were initially modeled as a Gaussian process, which
underestimated the frequency of extreme events.

It is one of a class of extreme value distributions, the Generalized
Extreme Value (GEV) distributions, which also includes the Weibull and
Frechet.

The function has a mean of :math:`\mu + 0.57721\beta` and a variance
of :math:`\frac{\pi^2}{6}\beta^2`.

References
----------
.. [1] Gumbel, E. J., 'Statistics of Extremes,'
       New York: Columbia University Press, 1958.
.. [2] Reiss, R.-D. and Thomas, M., 'Statistical Analysis of Extreme
       Values from Insurance, Finance, Hydrology and Other Fields,'
       Basel: Birkhauser Verlag, 2001.

Examples
--------
Draw samples from the distribution:

>>> mu, beta = 0, 0.1 # location and scale
>>> s = np.random.gumbel(mu, beta, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp( -np.exp( -(bins - mu) /beta) ),
...          linewidth=2, color='r')
>>> plt.show()

Show how an extreme value distribution can arise from a Gaussian process
and compare to a Gaussian:

>>> means = []
>>> maxima = []
>>> for i in range(0,1000) :
...    a = np.random.normal(mu, beta, 1000)
...    means.append(a.mean())
...    maxima.append(a.max())
>>> count, bins, ignored = plt.hist(maxima, 30, density=True)
>>> beta = np.std(maxima) * np.sqrt(6) / np.pi
>>> mu = np.mean(maxima) - 0.57721*beta
>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp(-np.exp(-(bins - mu)/beta)),
...          linewidth=2, color='r')
>>> plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))
...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),
...          linewidth=2, color='g')
>>> plt.show()
*)

val hypergeometric : ?size:int list -> ngood:[`I of int | `Array_like_of_ints of Py.Object.t] -> nbad:[`I of int | `Array_like_of_ints of Py.Object.t] -> nsample:[`I of int | `Array_like_of_ints of Py.Object.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
hypergeometric(ngood, nbad, nsample, size=None)

Draw samples from a Hypergeometric distribution.

Samples are drawn from a hypergeometric distribution with specified
parameters, `ngood` (ways to make a good selection), `nbad` (ways to make
a bad selection), and `nsample` (number of items sampled, which is less
than or equal to the sum ``ngood + nbad``).

.. note::
    New code should use the ``hypergeometric`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
ngood : int or array_like of ints
    Number of ways to make a good selection.  Must be nonnegative.
nbad : int or array_like of ints
    Number of ways to make a bad selection.  Must be nonnegative.
nsample : int or array_like of ints
    Number of items sampled.  Must be at least 1 and at most
    ``ngood + nbad``.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if `ngood`, `nbad`, and `nsample`
    are all scalars.  Otherwise, ``np.broadcast(ngood, nbad, nsample).size``
    samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized hypergeometric distribution. Each
    sample is the number of good items within a randomly selected subset of
    size `nsample` taken from a set of `ngood` good items and `nbad` bad items.

See Also
--------
scipy.stats.hypergeom : probability density function, distribution or
    cumulative density function, etc.
Generator.hypergeometric: which should be used for new code.

Notes
-----
The probability density for the Hypergeometric distribution is

.. math:: P(x) = \frac{\binom{g}{x}\binom{b}{n-x}}{\binom{g+b}{n}},

where :math:`0 \le x \le n` and :math:`n-b \le x \le g`

for P(x) the probability of ``x`` good results in the drawn sample,
g = `ngood`, b = `nbad`, and n = `nsample`.

Consider an urn with black and white marbles in it, `ngood` of them
are black and `nbad` are white. If you draw `nsample` balls without
replacement, then the hypergeometric distribution describes the
distribution of black balls in the drawn sample.

Note that this distribution is very similar to the binomial
distribution, except that in this case, samples are drawn without
replacement, whereas in the Binomial case samples are drawn with
replacement (or the sample space is infinite). As the sample space
becomes large, this distribution approaches the binomial.

References
----------
.. [1] Lentner, Marvin, 'Elementary Applied Statistics', Bogden
       and Quigley, 1972.
.. [2] Weisstein, Eric W. 'Hypergeometric Distribution.' From
       MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/HypergeometricDistribution.html
.. [3] Wikipedia, 'Hypergeometric distribution',
       https://en.wikipedia.org/wiki/Hypergeometric_distribution

Examples
--------
Draw samples from the distribution:

>>> ngood, nbad, nsamp = 100, 2, 10
# number of good, number of bad, and number of samples
>>> s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)
>>> from matplotlib.pyplot import hist
>>> hist(s)
#   note that it is very unlikely to grab both bad items

Suppose you have an urn with 15 white and 15 black marbles.
If you pull 15 marbles at random, how likely is it that
12 or more of them are one color?

>>> s = np.random.hypergeometric(15, 15, 15, 100000)
>>> sum(s>=12)/100000. + sum(s<=3)/100000.
#   answer = 0.003 ... pretty unlikely!
*)

val laplace : ?loc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
laplace(loc=0.0, scale=1.0, size=None)

Draw samples from the Laplace or double exponential distribution with
specified location (or mean) and scale (decay).

The Laplace distribution is similar to the Gaussian/normal distribution,
but is sharper at the peak and has fatter tails. It represents the
difference between two independent, identically distributed exponential
random variables.

.. note::
    New code should use the ``laplace`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
loc : float or array_like of floats, optional
    The position, :math:`\mu`, of the distribution peak. Default is 0.
scale : float or array_like of floats, optional
    :math:`\lambda`, the exponential decay. Default is 1. Must be non-
    negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``loc`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Laplace distribution.

See Also
--------
Generator.laplace: which should be used for new code.

Notes
-----
It has the probability density function

.. math:: f(x; \mu, \lambda) = \frac{1}{2\lambda}
                               \exp\left(-\frac{ |x - \mu| }{\lambda}\right).

The first law of Laplace, from 1774, states that the frequency
of an error can be expressed as an exponential function of the
absolute magnitude of the error, which leads to the Laplace
distribution. For many problems in economics and health
sciences, this distribution seems to model the data better
than the standard Gaussian distribution.

References
----------
.. [1] Abramowitz, M. and Stegun, I. A. (Eds.). 'Handbook of
       Mathematical Functions with Formulas, Graphs, and Mathematical
       Tables, 9th printing,' New York: Dover, 1972.
.. [2] Kotz, Samuel, et. al. 'The Laplace Distribution and
       Generalizations, ' Birkhauser, 2001.
.. [3] Weisstein, Eric W. 'Laplace Distribution.'
       From MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/LaplaceDistribution.html
.. [4] Wikipedia, 'Laplace distribution',
       https://en.wikipedia.org/wiki/Laplace_distribution

Examples
--------
Draw samples from the distribution

>>> loc, scale = 0., 1.
>>> s = np.random.laplace(loc, scale, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> x = np.arange(-8., 8., .01)
>>> pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)
>>> plt.plot(x, pdf)

Plot Gaussian for comparison:

>>> g = (1/(scale * np.sqrt(2 * np.pi)) *
...      np.exp(-(x - loc)**2 / (2 * scale**2)))
>>> plt.plot(x,g)
*)

val logistic : ?loc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
logistic(loc=0.0, scale=1.0, size=None)

Draw samples from a logistic distribution.

Samples are drawn from a logistic distribution with specified
parameters, loc (location or mean, also median), and scale (>0).

.. note::
    New code should use the ``logistic`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
loc : float or array_like of floats, optional
    Parameter of the distribution. Default is 0.
scale : float or array_like of floats, optional
    Parameter of the distribution. Must be non-negative.
    Default is 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``loc`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized logistic distribution.

See Also
--------
scipy.stats.logistic : probability density function, distribution or
    cumulative density function, etc.
Generator.logistic: which should be used for new code.

Notes
-----
The probability density for the Logistic distribution is

.. math:: P(x) = P(x) = \frac{e^{-(x-\mu)/s}}{s(1+e^{-(x-\mu)/s})^2},

where :math:`\mu` = location and :math:`s` = scale.

The Logistic distribution is used in Extreme Value problems where it
can act as a mixture of Gumbel distributions, in Epidemiology, and by
the World Chess Federation (FIDE) where it is used in the Elo ranking
system, assuming the performance of each player is a logistically
distributed random variable.

References
----------
.. [1] Reiss, R.-D. and Thomas M. (2001), 'Statistical Analysis of
       Extreme Values, from Insurance, Finance, Hydrology and Other
       Fields,' Birkhauser Verlag, Basel, pp 132-133.
.. [2] Weisstein, Eric W. 'Logistic Distribution.' From
       MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/LogisticDistribution.html
.. [3] Wikipedia, 'Logistic-distribution',
       https://en.wikipedia.org/wiki/Logistic_distribution

Examples
--------
Draw samples from the distribution:

>>> loc, scale = 10, 1
>>> s = np.random.logistic(loc, scale, 10000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, bins=50)

#   plot against distribution

>>> def logist(x, loc, scale):
...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)
>>> lgst_val = logist(bins, loc, scale)
>>> plt.plot(bins, lgst_val * count.max() / lgst_val.max())
>>> plt.show()
*)

val lognormal : ?mean:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?sigma:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
lognormal(mean=0.0, sigma=1.0, size=None)

Draw samples from a log-normal distribution.

Draw samples from a log-normal distribution with specified mean,
standard deviation, and array shape.  Note that the mean and standard
deviation are not the values for the distribution itself, but of the
underlying normal distribution it is derived from.

.. note::
    New code should use the ``lognormal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
mean : float or array_like of floats, optional
    Mean value of the underlying normal distribution. Default is 0.
sigma : float or array_like of floats, optional
    Standard deviation of the underlying normal distribution. Must be
    non-negative. Default is 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``mean`` and ``sigma`` are both scalars.
    Otherwise, ``np.broadcast(mean, sigma).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized log-normal distribution.

See Also
--------
scipy.stats.lognorm : probability density function, distribution,
    cumulative density function, etc.
Generator.lognormal: which should be used for new code.

Notes
-----
A variable `x` has a log-normal distribution if `log(x)` is normally
distributed.  The probability density function for the log-normal
distribution is:

.. math:: p(x) = \frac{1}{\sigma x \sqrt{2\pi}}
                 e^{(-\frac{(ln(x)-\mu)^2}{2\sigma^2})}

where :math:`\mu` is the mean and :math:`\sigma` is the standard
deviation of the normally distributed logarithm of the variable.
A log-normal distribution results if a random variable is the *product*
of a large number of independent, identically-distributed variables in
the same way that a normal distribution results if the variable is the
*sum* of a large number of independent, identically-distributed
variables.

References
----------
.. [1] Limpert, E., Stahel, W. A., and Abbt, M., 'Log-normal
       Distributions across the Sciences: Keys and Clues,'
       BioScience, Vol. 51, No. 5, May, 2001.
       https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf
.. [2] Reiss, R.D. and Thomas, M., 'Statistical Analysis of Extreme
       Values,' Basel: Birkhauser Verlag, 2001, pp. 31-32.

Examples
--------
Draw samples from the distribution:

>>> mu, sigma = 3., 1. # mean and standard deviation
>>> s = np.random.lognormal(mu, sigma, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 100, density=True, align='mid')

>>> x = np.linspace(min(bins), max(bins), 10000)
>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))

>>> plt.plot(x, pdf, linewidth=2, color='r')
>>> plt.axis('tight')
>>> plt.show()

Demonstrate that taking the products of random samples from a uniform
distribution can be fit well by a log-normal probability density
function.

>>> # Generate a thousand samples: each is the product of 100 random
>>> # values, drawn from a normal distribution.
>>> b = []
>>> for i in range(1000):
...    a = 10. + np.random.standard_normal(100)
...    b.append(np.product(a))

>>> b = np.array(b) / np.min(b) # scale values to be positive
>>> count, bins, ignored = plt.hist(b, 100, density=True, align='mid')
>>> sigma = np.std(np.log(b))
>>> mu = np.mean(np.log(b))

>>> x = np.linspace(min(bins), max(bins), 10000)
>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))

>>> plt.plot(x, pdf, color='r', linewidth=2)
>>> plt.show()
*)

val logseries : ?size:int list -> p:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
logseries(p, size=None)

Draw samples from a logarithmic series distribution.

Samples are drawn from a log series distribution with specified
shape parameter, 0 < ``p`` < 1.

.. note::
    New code should use the ``logseries`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
p : float or array_like of floats
    Shape parameter for the distribution.  Must be in the range (0, 1).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``p`` is a scalar.  Otherwise,
    ``np.array(p).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized logarithmic series distribution.

See Also
--------
scipy.stats.logser : probability density function, distribution or
    cumulative density function, etc.
Generator.logseries: which should be used for new code.

Notes
-----
The probability density for the Log Series distribution is

.. math:: P(k) = \frac{-p^k}{k \ln(1-p)},

where p = probability.

The log series distribution is frequently used to represent species
richness and occurrence, first proposed by Fisher, Corbet, and
Williams in 1943 [2].  It may also be used to model the numbers of
occupants seen in cars [3].

References
----------
.. [1] Buzas, Martin A.; Culver, Stephen J.,  Understanding regional
       species diversity through the log series distribution of
       occurrences: BIODIVERSITY RESEARCH Diversity & Distributions,
       Volume 5, Number 5, September 1999 , pp. 187-195(9).
.. [2] Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The
       relation between the number of species and the number of
       individuals in a random sample of an animal population.
       Journal of Animal Ecology, 12:42-58.
.. [3] D. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small
       Data Sets, CRC Press, 1994.
.. [4] Wikipedia, 'Logarithmic distribution',
       https://en.wikipedia.org/wiki/Logarithmic_distribution

Examples
--------
Draw samples from the distribution:

>>> a = .6
>>> s = np.random.logseries(a, 10000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s)

#   plot against distribution

>>> def logseries(k, p):
...     return -p**k/(k*np.log(1-p))
>>> plt.plot(bins, logseries(bins, a)*count.max()/
...          logseries(bins, a).max(), 'r')
>>> plt.show()
*)

val multinomial : ?size:int list -> n:int -> pvals:[`Length_p of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
multinomial(n, pvals, size=None)

Draw samples from a multinomial distribution.

The multinomial distribution is a multivariate generalization of the
binomial distribution.  Take an experiment with one of ``p``
possible outcomes.  An example of such an experiment is throwing a dice,
where the outcome can be 1 through 6.  Each sample drawn from the
distribution represents `n` such experiments.  Its values,
``X_i = [X_0, X_1, ..., X_p]``, represent the number of times the
outcome was ``i``.

.. note::
    New code should use the ``multinomial`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
n : int
    Number of experiments.
pvals : sequence of floats, length p
    Probabilities of each of the ``p`` different outcomes.  These
    must sum to 1 (however, the last element is always assumed to
    account for the remaining probability, as long as
    ``sum(pvals[:-1]) <= 1)``.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : ndarray
    The drawn samples, of shape *size*, if that was provided.  If not,
    the shape is ``(N,)``.

    In other words, each entry ``out[i,j,...,:]`` is an N-dimensional
    value drawn from the distribution.

See Also
--------
Generator.multinomial: which should be used for new code.

Examples
--------
Throw a dice 20 times:

>>> np.random.multinomial(20, [1/6.]*6, size=1)
array([[4, 1, 7, 5, 2, 1]]) # random

It landed 4 times on 1, once on 2, etc.

Now, throw the dice 20 times, and 20 times again:

>>> np.random.multinomial(20, [1/6.]*6, size=2)
array([[3, 4, 3, 3, 4, 3], # random
       [2, 4, 3, 4, 0, 7]])

For the first run, we threw 3 times 1, 4 times 2, etc.  For the second,
we threw 2 times 1, 4 times 2, etc.

A loaded die is more likely to land on number 6:

>>> np.random.multinomial(100, [1/7.]*5 + [2/7.])
array([11, 16, 14, 17, 16, 26]) # random

The probability inputs should be normalized. As an implementation
detail, the value of the last entry is ignored and assumed to take
up any leftover probability mass, but this should not be relied on.
A biased coin which has twice as much weight on one side as on the
other should be sampled like so:

>>> np.random.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT
array([38, 62]) # random

not like:

>>> np.random.multinomial(100, [1.0, 2.0])  # WRONG
Traceback (most recent call last):
ValueError: pvals < 0, pvals > 1 or pvals contains NaNs
*)

val multivariate_normal : ?size:int list -> ?check_valid:[`Warn | `Raise | `Ignore] -> ?tol:float -> mean:Py.Object.t -> cov:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)

Draw random samples from a multivariate normal distribution.

The multivariate normal, multinormal or Gaussian distribution is a
generalization of the one-dimensional normal distribution to higher
dimensions.  Such a distribution is specified by its mean and
covariance matrix.  These parameters are analogous to the mean
(average or 'center') and variance (standard deviation, or 'width,'
squared) of the one-dimensional normal distribution.

.. note::
    New code should use the ``multivariate_normal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
mean : 1-D array_like, of length N
    Mean of the N-dimensional distribution.
cov : 2-D array_like, of shape (N, N)
    Covariance matrix of the distribution. It must be symmetric and
    positive-semidefinite for proper sampling.
size : int or tuple of ints, optional
    Given a shape of, for example, ``(m,n,k)``, ``m*n*k`` samples are
    generated, and packed in an `m`-by-`n`-by-`k` arrangement.  Because
    each sample is `N`-dimensional, the output shape is ``(m,n,k,N)``.
    If no shape is specified, a single (`N`-D) sample is returned.
check_valid : { 'warn', 'raise', 'ignore' }, optional
    Behavior when the covariance matrix is not positive semidefinite.
tol : float, optional
    Tolerance when checking the singular values in covariance matrix.
    cov is cast to double before the check.

Returns
-------
out : ndarray
    The drawn samples, of shape *size*, if that was provided.  If not,
    the shape is ``(N,)``.

    In other words, each entry ``out[i,j,...,:]`` is an N-dimensional
    value drawn from the distribution.

See Also
--------
Generator.multivariate_normal: which should be used for new code.

Notes
-----
The mean is a coordinate in N-dimensional space, which represents the
location where samples are most likely to be generated.  This is
analogous to the peak of the bell curve for the one-dimensional or
univariate normal distribution.

Covariance indicates the level to which two variables vary together.
From the multivariate normal distribution, we draw N-dimensional
samples, :math:`X = [x_1, x_2, ... x_N]`.  The covariance matrix
element :math:`C_{ij}` is the covariance of :math:`x_i` and :math:`x_j`.
The element :math:`C_{ii}` is the variance of :math:`x_i` (i.e. its
'spread').

Instead of specifying the full covariance matrix, popular
approximations include:

  - Spherical covariance (`cov` is a multiple of the identity matrix)
  - Diagonal covariance (`cov` has non-negative elements, and only on
    the diagonal)

This geometrical property can be seen in two dimensions by plotting
generated data-points:

>>> mean = [0, 0]
>>> cov = [[1, 0], [0, 100]]  # diagonal covariance

Diagonal covariance means that points are oriented along x or y-axis:

>>> import matplotlib.pyplot as plt
>>> x, y = np.random.multivariate_normal(mean, cov, 5000).T
>>> plt.plot(x, y, 'x')
>>> plt.axis('equal')
>>> plt.show()

Note that the covariance matrix must be positive semidefinite (a.k.a.
nonnegative-definite). Otherwise, the behavior of this method is
undefined and backwards compatibility is not guaranteed.

References
----------
.. [1] Papoulis, A., 'Probability, Random Variables, and Stochastic
       Processes,' 3rd ed., New York: McGraw-Hill, 1991.
.. [2] Duda, R. O., Hart, P. E., and Stork, D. G., 'Pattern
       Classification,' 2nd ed., New York: Wiley, 2001.

Examples
--------
>>> mean = (1, 2)
>>> cov = [[1, 0], [0, 1]]
>>> x = np.random.multivariate_normal(mean, cov, (3, 3))
>>> x.shape
(3, 3, 2)

The following is probably true, given that 0.6 is roughly twice the
standard deviation:

>>> list((x[0,0,:] - mean) < 0.6)
[True, True] # random
*)

val negative_binomial : ?size:int list -> n:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> p:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
negative_binomial(n, p, size=None)

Draw samples from a negative binomial distribution.

Samples are drawn from a negative binomial distribution with specified
parameters, `n` successes and `p` probability of success where `n`
is > 0 and `p` is in the interval [0, 1].

.. note::
    New code should use the ``negative_binomial`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
n : float or array_like of floats
    Parameter of the distribution, > 0.
p : float or array_like of floats
    Parameter of the distribution, >= 0 and <=1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``n`` and ``p`` are both scalars.
    Otherwise, ``np.broadcast(n, p).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized negative binomial distribution,
    where each sample is equal to N, the number of failures that
    occurred before a total of n successes was reached.

See Also
--------
Generator.negative_binomial: which should be used for new code.

Notes
-----
The probability mass function of the negative binomial distribution is

.. math:: P(N;n,p) = \frac{\Gamma(N+n)}{N!\Gamma(n)}p^{n}(1-p)^{N},

where :math:`n` is the number of successes, :math:`p` is the
probability of success, :math:`N+n` is the number of trials, and
:math:`\Gamma` is the gamma function. When :math:`n` is an integer,
:math:`\frac{\Gamma(N+n)}{N!\Gamma(n)} = \binom{N+n-1}{N}`, which is
the more common form of this term in the the pmf. The negative
binomial distribution gives the probability of N failures given n
successes, with a success on the last trial.

If one throws a die repeatedly until the third time a '1' appears,
then the probability distribution of the number of non-'1's that
appear before the third '1' is a negative binomial distribution.

References
----------
.. [1] Weisstein, Eric W. 'Negative Binomial Distribution.' From
       MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/NegativeBinomialDistribution.html
.. [2] Wikipedia, 'Negative binomial distribution',
       https://en.wikipedia.org/wiki/Negative_binomial_distribution

Examples
--------
Draw samples from the distribution:

A real world example. A company drills wild-cat oil
exploration wells, each with an estimated probability of
success of 0.1.  What is the probability of having one success
for each successive well, that is what is the probability of a
single success after drilling 5 wells, after 6 wells, etc.?

>>> s = np.random.negative_binomial(1, 0.1, 100000)
>>> for i in range(1, 11): # doctest: +SKIP
...    probability = sum(s<i) / 100000.
...    print(i, 'wells drilled, probability of one success =', probability)
*)

val noncentral_chisquare : ?size:int list -> df:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> nonc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
noncentral_chisquare(df, nonc, size=None)

Draw samples from a noncentral chi-square distribution.

The noncentral :math:`\chi^2` distribution is a generalization of
the :math:`\chi^2` distribution.

.. note::
    New code should use the ``noncentral_chisquare`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
df : float or array_like of floats
    Degrees of freedom, must be > 0.

    .. versionchanged:: 1.10.0
       Earlier NumPy versions required dfnum > 1.
nonc : float or array_like of floats
    Non-centrality, must be non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``df`` and ``nonc`` are both scalars.
    Otherwise, ``np.broadcast(df, nonc).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized noncentral chi-square distribution.

See Also
--------
Generator.noncentral_chisquare: which should be used for new code.

Notes
-----
The probability density function for the noncentral Chi-square
distribution is

.. math:: P(x;df,nonc) = \sum^{\infty}_{i=0}
                       \frac{e^{-nonc/2}(nonc/2)^{i}}{i!}
                       P_{Y_{df+2i}}(x),

where :math:`Y_{q}` is the Chi-square with q degrees of freedom.

References
----------
.. [1] Wikipedia, 'Noncentral chi-squared distribution'
       https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution

Examples
--------
Draw values from the distribution and plot the histogram

>>> import matplotlib.pyplot as plt
>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
...                   bins=200, density=True)
>>> plt.show()

Draw values from a noncentral chisquare with very small noncentrality,
and compare to a chisquare.

>>> plt.figure()
>>> values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),
...                   bins=np.arange(0., 25, .1), density=True)
>>> values2 = plt.hist(np.random.chisquare(3, 100000),
...                    bins=np.arange(0., 25, .1), density=True)
>>> plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')
>>> plt.show()

Demonstrate how large values of non-centrality lead to a more symmetric
distribution.

>>> plt.figure()
>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
...                   bins=200, density=True)
>>> plt.show()
*)

val noncentral_f : ?size:int list -> dfnum:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> dfden:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> nonc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
noncentral_f(dfnum, dfden, nonc, size=None)

Draw samples from the noncentral F distribution.

Samples are drawn from an F distribution with specified parameters,
`dfnum` (degrees of freedom in numerator) and `dfden` (degrees of
freedom in denominator), where both parameters > 1.
`nonc` is the non-centrality parameter.

.. note::
    New code should use the ``noncentral_f`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
dfnum : float or array_like of floats
    Numerator degrees of freedom, must be > 0.

    .. versionchanged:: 1.14.0
       Earlier NumPy versions required dfnum > 1.
dfden : float or array_like of floats
    Denominator degrees of freedom, must be > 0.
nonc : float or array_like of floats
    Non-centrality parameter, the sum of the squares of the numerator
    means, must be >= 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``dfnum``, ``dfden``, and ``nonc``
    are all scalars.  Otherwise, ``np.broadcast(dfnum, dfden, nonc).size``
    samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized noncentral Fisher distribution.

See Also
--------
Generator.noncentral_f: which should be used for new code.

Notes
-----
When calculating the power of an experiment (power = probability of
rejecting the null hypothesis when a specific alternative is true) the
non-central F statistic becomes important.  When the null hypothesis is
true, the F statistic follows a central F distribution. When the null
hypothesis is not true, then it follows a non-central F statistic.

References
----------
.. [1] Weisstein, Eric W. 'Noncentral F-Distribution.'
       From MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/NoncentralF-Distribution.html
.. [2] Wikipedia, 'Noncentral F-distribution',
       https://en.wikipedia.org/wiki/Noncentral_F-distribution

Examples
--------
In a study, testing for a specific alternative to the null hypothesis
requires use of the Noncentral F distribution. We need to calculate the
area in the tail of the distribution that exceeds the value of the F
distribution for the null hypothesis.  We'll plot the two probability
distributions for comparison.

>>> dfnum = 3 # between group deg of freedom
>>> dfden = 20 # within groups degrees of freedom
>>> nonc = 3.0
>>> nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)
>>> NF = np.histogram(nc_vals, bins=50, density=True)
>>> c_vals = np.random.f(dfnum, dfden, 1000000)
>>> F = np.histogram(c_vals, bins=50, density=True)
>>> import matplotlib.pyplot as plt
>>> plt.plot(F[1][1:], F[0])
>>> plt.plot(NF[1][1:], NF[0])
>>> plt.show()
*)

val normal : ?loc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
normal(loc=0.0, scale=1.0, size=None)

Draw random samples from a normal (Gaussian) distribution.

The probability density function of the normal distribution, first
derived by De Moivre and 200 years later by both Gauss and Laplace
independently [2]_, is often called the bell curve because of
its characteristic shape (see the example below).

The normal distributions occurs often in nature.  For example, it
describes the commonly occurring distribution of samples influenced
by a large number of tiny, random disturbances, each with its own
unique distribution [2]_.

.. note::
    New code should use the ``normal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
loc : float or array_like of floats
    Mean ('centre') of the distribution.
scale : float or array_like of floats
    Standard deviation (spread or 'width') of the distribution. Must be
    non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``loc`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized normal distribution.

See Also
--------
scipy.stats.norm : probability density function, distribution or
    cumulative density function, etc.
Generator.normal: which should be used for new code.

Notes
-----
The probability density for the Gaussian distribution is

.. math:: p(x) = \frac{1}{\sqrt{ 2 \pi \sigma^2 }}
                 e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} },

where :math:`\mu` is the mean and :math:`\sigma` the standard
deviation. The square of the standard deviation, :math:`\sigma^2`,
is called the variance.

The function has its peak at the mean, and its 'spread' increases with
the standard deviation (the function reaches 0.607 times its maximum at
:math:`x + \sigma` and :math:`x - \sigma` [2]_).  This implies that
normal is more likely to return samples lying close to the mean, rather
than those far away.

References
----------
.. [1] Wikipedia, 'Normal distribution',
       https://en.wikipedia.org/wiki/Normal_distribution
.. [2] P. R. Peebles Jr., 'Central Limit Theorem' in 'Probability,
       Random Variables and Random Signal Principles', 4th ed., 2001,
       pp. 51, 51, 125.

Examples
--------
Draw samples from the distribution:

>>> mu, sigma = 0, 0.1 # mean and standard deviation
>>> s = np.random.normal(mu, sigma, 1000)

Verify the mean and the variance:

>>> abs(mu - np.mean(s))
0.0  # may vary

>>> abs(sigma - np.std(s, ddof=1))
0.1  # may vary

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *
...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),
...          linewidth=2, color='r')
>>> plt.show()

Two-by-four array of samples from N(3, 6.25):

>>> np.random.normal(3, 2.5, size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
*)

val pareto : ?size:int list -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
pareto(a, size=None)

Draw samples from a Pareto II or Lomax distribution with
specified shape.

The Lomax or Pareto II distribution is a shifted Pareto
distribution. The classical Pareto distribution can be
obtained from the Lomax distribution by adding 1 and
multiplying by the scale parameter ``m`` (see Notes).  The
smallest value of the Lomax distribution is zero while for the
classical Pareto distribution it is ``mu``, where the standard
Pareto distribution has location ``mu = 1``.  Lomax can also
be considered as a simplified version of the Generalized
Pareto distribution (available in SciPy), with the scale set
to one and the location set to zero.

The Pareto distribution must be greater than zero, and is
unbounded above.  It is also known as the '80-20 rule'.  In
this distribution, 80 percent of the weights are in the lowest
20 percent of the range, while the other 20 percent fill the
remaining 80 percent of the range.

.. note::
    New code should use the ``pareto`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Shape of the distribution. Must be positive.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` is a scalar.  Otherwise,
    ``np.array(a).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Pareto distribution.

See Also
--------
scipy.stats.lomax : probability density function, distribution or
    cumulative density function, etc.
scipy.stats.genpareto : probability density function, distribution or
    cumulative density function, etc.
Generator.pareto: which should be used for new code.

Notes
-----
The probability density for the Pareto distribution is

.. math:: p(x) = \frac{am^a}{x^{a+1}}

where :math:`a` is the shape and :math:`m` the scale.

The Pareto distribution, named after the Italian economist
Vilfredo Pareto, is a power law probability distribution
useful in many real world problems.  Outside the field of
economics it is generally referred to as the Bradford
distribution. Pareto developed the distribution to describe
the distribution of wealth in an economy.  It has also found
use in insurance, web page access statistics, oil field sizes,
and many other problems, including the download frequency for
projects in Sourceforge [1]_.  It is one of the so-called
'fat-tailed' distributions.

References
----------
.. [1] Francis Hunt and Paul Johnson, On the Pareto Distribution of
       Sourceforge projects.
.. [2] Pareto, V. (1896). Course of Political Economy. Lausanne.
.. [3] Reiss, R.D., Thomas, M.(2001), Statistical Analysis of Extreme
       Values, Birkhauser Verlag, Basel, pp 23-30.
.. [4] Wikipedia, 'Pareto distribution',
       https://en.wikipedia.org/wiki/Pareto_distribution

Examples
--------
Draw samples from the distribution:

>>> a, m = 3., 2.  # shape and mode
>>> s = (np.random.pareto(a, 1000) + 1) * m

Display the histogram of the samples, along with the probability
density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, _ = plt.hist(s, 100, density=True)
>>> fit = a*m**a / bins**(a+1)
>>> plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')
>>> plt.show()
*)

val permutation : [`I of int | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
permutation(x)

Randomly permute a sequence, or return a permuted range.

If `x` is a multi-dimensional array, it is only shuffled along its
first index.

.. note::
    New code should use the ``permutation`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
x : int or array_like
    If `x` is an integer, randomly permute ``np.arange(x)``.
    If `x` is an array, make a copy and shuffle the elements
    randomly.

Returns
-------
out : ndarray
    Permuted sequence or array range.

See Also
--------
Generator.permutation: which should be used for new code.

Examples
--------
>>> np.random.permutation(10)
array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random

>>> np.random.permutation([1, 4, 9, 12, 15])
array([15,  1,  9,  4, 12]) # random

>>> arr = np.arange(9).reshape((3, 3))
>>> np.random.permutation(arr)
array([[6, 7, 8], # random
       [0, 1, 2],
       [3, 4, 5]])
*)

val poisson : ?lam:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
poisson(lam=1.0, size=None)

Draw samples from a Poisson distribution.

The Poisson distribution is the limit of the binomial distribution
for large N.

.. note::
    New code should use the ``poisson`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
lam : float or array_like of floats
    Expectation of interval, must be >= 0. A sequence of expectation
    intervals must be broadcastable over the requested size.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``lam`` is a scalar. Otherwise,
    ``np.array(lam).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Poisson distribution.

See Also
--------
Generator.poisson: which should be used for new code.

Notes
-----
The Poisson distribution

.. math:: f(k; \lambda)=\frac{\lambda^k e^{-\lambda}}{k!}

For events with an expected separation :math:`\lambda` the Poisson
distribution :math:`f(k; \lambda)` describes the probability of
:math:`k` events occurring within the observed
interval :math:`\lambda`.

Because the output is limited to the range of the C int64 type, a
ValueError is raised when `lam` is within 10 sigma of the maximum
representable value.

References
----------
.. [1] Weisstein, Eric W. 'Poisson Distribution.'
       From MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/PoissonDistribution.html
.. [2] Wikipedia, 'Poisson distribution',
       https://en.wikipedia.org/wiki/Poisson_distribution

Examples
--------
Draw samples from the distribution:

>>> import numpy as np
>>> s = np.random.poisson(5, 10000)

Display histogram of the sample:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 14, density=True)
>>> plt.show()

Draw each 100 values for lambda 100 and 500:

>>> s = np.random.poisson(lam=(100., 500.), size=(100, 2))
*)

val power : ?size:int list -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
power(a, size=None)

Draws samples in [0, 1] from a power distribution with positive
exponent a - 1.

Also known as the power function distribution.

.. note::
    New code should use the ``power`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Parameter of the distribution. Must be non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` is a scalar.  Otherwise,
    ``np.array(a).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized power distribution.

Raises
------
ValueError
    If a < 1.

See Also
--------
Generator.power: which should be used for new code.

Notes
-----
The probability density function is

.. math:: P(x; a) = ax^{a-1}, 0 \le x \le 1, a>0.

The power function distribution is just the inverse of the Pareto
distribution. It may also be seen as a special case of the Beta
distribution.

It is used, for example, in modeling the over-reporting of insurance
claims.

References
----------
.. [1] Christian Kleiber, Samuel Kotz, 'Statistical size distributions
       in economics and actuarial sciences', Wiley, 2003.
.. [2] Heckert, N. A. and Filliben, James J. 'NIST Handbook 148:
       Dataplot Reference Manual, Volume 2: Let Subcommands and Library
       Functions', National Institute of Standards and Technology
       Handbook Series, June 2003.
       https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf

Examples
--------
Draw samples from the distribution:

>>> a = 5. # shape
>>> samples = 1000
>>> s = np.random.power(a, samples)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, bins=30)
>>> x = np.linspace(0, 1, 100)
>>> y = a*x**(a-1.)
>>> normed_y = samples*np.diff(bins)[0]*y
>>> plt.plot(x, normed_y)
>>> plt.show()

Compare the power function distribution to the inverse of the Pareto.

>>> from scipy import stats # doctest: +SKIP
>>> rvs = np.random.power(5, 1000000)
>>> rvsp = np.random.pareto(5, 1000000)
>>> xx = np.linspace(0,1,100)
>>> powpdf = stats.powerlaw.pdf(xx,5)  # doctest: +SKIP

>>> plt.figure()
>>> plt.hist(rvs, bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  # doctest: +SKIP
>>> plt.title('np.random.power(5)')

>>> plt.figure()
>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  # doctest: +SKIP
>>> plt.title('inverse of 1 + np.random.pareto(5)')

>>> plt.figure()
>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  # doctest: +SKIP
>>> plt.title('inverse of stats.pareto(5)')
*)

val rand : Py.Object.t -> Py.Object.t
(**
rand(d0, d1, ..., dn)

Random values in a given shape.

.. note::
    This is a convenience function for users porting code from Matlab,
    and wraps `random_sample`. That function takes a
    tuple to specify the size of the output, which is consistent with
    other NumPy functions like `numpy.zeros` and `numpy.ones`.

Create an array of the given shape and populate it with
random samples from a uniform distribution
over ``[0, 1)``.

Parameters
----------
d0, d1, ..., dn : int, optional
    The dimensions of the returned array, must be non-negative.
    If no argument is given a single Python float is returned.

Returns
-------
out : ndarray, shape ``(d0, d1, ..., dn)``
    Random values.

See Also
--------
random

Examples
--------
>>> np.random.rand(3,2)
array([[ 0.14022471,  0.96360618],  #random
       [ 0.37601032,  0.25528411],  #random
       [ 0.49313049,  0.94909878]]) #random
*)

val randint : ?high:[`I of int | `Array_like_of_ints of Py.Object.t] -> ?size:int list -> ?dtype:Dtype.t -> low:[`I of int | `Array_like_of_ints of Py.Object.t] -> unit -> Py.Object.t
(**
randint(low, high=None, size=None, dtype=int)

Return random integers from `low` (inclusive) to `high` (exclusive).

Return random integers from the 'discrete uniform' distribution of
the specified dtype in the 'half-open' interval [`low`, `high`). If
`high` is None (the default), then results are from [0, `low`).

.. note::
    New code should use the ``integers`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
low : int or array-like of ints
    Lowest (signed) integers to be drawn from the distribution (unless
    ``high=None``, in which case this parameter is one above the
    *highest* such integer).
high : int or array-like of ints, optional
    If provided, one above the largest (signed) integer to be drawn
    from the distribution (see above for behavior if ``high=None``).
    If array-like, must contain integer values
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.
dtype : dtype, optional
    Desired dtype of the result. Byteorder must be native.
    The default value is int.

    .. versionadded:: 1.11.0

Returns
-------
out : int or ndarray of ints
    `size`-shaped array of random integers from the appropriate
    distribution, or a single such random int if `size` not provided.

See Also
--------
random_integers : similar to `randint`, only for the closed
    interval [`low`, `high`], and 1 is the lowest value if `high` is
    omitted.
Generator.integers: which should be used for new code.

Examples
--------
>>> np.random.randint(2, size=10)
array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random
>>> np.random.randint(1, size=10)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])

Generate a 2 x 4 array of ints between 0 and 4, inclusive:

>>> np.random.randint(5, size=(2, 4))
array([[4, 0, 2, 1], # random
       [3, 2, 2, 0]])

Generate a 1 x 3 array with 3 different upper bounds

>>> np.random.randint(1, [3, 5, 10])
array([2, 2, 9]) # random

Generate a 1 by 3 array with 3 different lower bounds

>>> np.random.randint([1, 5, 7], 10)
array([9, 8, 7]) # random

Generate a 2 by 4 array using broadcasting with dtype of uint8

>>> np.random.randint([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)
array([[ 8,  6,  9,  7], # random
       [ 1, 16,  9, 12]], dtype=uint8)
*)

val randn : Py.Object.t -> Py.Object.t
(**
randn(d0, d1, ..., dn)

Return a sample (or samples) from the 'standard normal' distribution.

.. note::
    This is a convenience function for users porting code from Matlab,
    and wraps `standard_normal`. That function takes a
    tuple to specify the size of the output, which is consistent with
    other NumPy functions like `numpy.zeros` and `numpy.ones`.

.. note::
    New code should use the ``standard_normal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

If positive int_like arguments are provided, `randn` generates an array
of shape ``(d0, d1, ..., dn)``, filled
with random floats sampled from a univariate 'normal' (Gaussian)
distribution of mean 0 and variance 1. A single float randomly sampled
from the distribution is returned if no argument is provided.

Parameters
----------
d0, d1, ..., dn : int, optional
    The dimensions of the returned array, must be non-negative.
    If no argument is given a single Python float is returned.

Returns
-------
Z : ndarray or float
    A ``(d0, d1, ..., dn)``-shaped array of floating-point samples from
    the standard normal distribution, or a single such float if
    no parameters were supplied.

See Also
--------
standard_normal : Similar, but takes a tuple as its argument.
normal : Also accepts mu and sigma arguments.
Generator.standard_normal: which should be used for new code.

Notes
-----
For random samples from :math:`N(\mu, \sigma^2)`, use:

``sigma * np.random.randn(...) + mu``

Examples
--------
>>> np.random.randn()
2.1923875335537315  # random

Two-by-four array of samples from N(3, 6.25):

>>> 3 + 2.5 * np.random.randn(2, 4)
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
*)

val random : ?size:int list -> unit -> Py.Object.t
(**
random(size=None)

Return random floats in the half-open interval [0.0, 1.0). Alias for
`random_sample` to ease forward-porting to the new random API.
*)

val random_integers : ?high:int -> ?size:int list -> low:int -> unit -> Py.Object.t
(**
random_integers(low, high=None, size=None)

Random integers of type `np.int_` between `low` and `high`, inclusive.

Return random integers of type `np.int_` from the 'discrete uniform'
distribution in the closed interval [`low`, `high`].  If `high` is
None (the default), then results are from [1, `low`]. The `np.int_`
type translates to the C long integer type and its precision
is platform dependent.

This function has been deprecated. Use randint instead.

.. deprecated:: 1.11.0

Parameters
----------
low : int
    Lowest (signed) integer to be drawn from the distribution (unless
    ``high=None``, in which case this parameter is the *highest* such
    integer).
high : int, optional
    If provided, the largest (signed) integer to be drawn from the
    distribution (see above for behavior if ``high=None``).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : int or ndarray of ints
    `size`-shaped array of random integers from the appropriate
    distribution, or a single such random int if `size` not provided.

See Also
--------
randint : Similar to `random_integers`, only for the half-open
    interval [`low`, `high`), and 0 is the lowest value if `high` is
    omitted.

Notes
-----
To sample from N evenly spaced floating-point numbers between a and b,
use::

  a + (b - a) * (np.random.random_integers(N) - 1) / (N - 1.)

Examples
--------
>>> np.random.random_integers(5)
4 # random
>>> type(np.random.random_integers(5))
<class 'numpy.int64'>
>>> np.random.random_integers(5, size=(3,2))
array([[5, 4], # random
       [3, 3],
       [4, 5]])

Choose five random numbers from the set of five evenly-spaced
numbers between 0 and 2.5, inclusive ( *i.e.*, from the set
:math:`{0, 5/8, 10/8, 15/8, 20/8}`):

>>> 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.
array([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ]) # random

Roll two six sided dice 1000 times and sum the results:

>>> d1 = np.random.random_integers(1, 6, 1000)
>>> d2 = np.random.random_integers(1, 6, 1000)
>>> dsums = d1 + d2

Display results as a histogram:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(dsums, 11, density=True)
>>> plt.show()
*)

val random_sample : ?size:int list -> unit -> Py.Object.t
(**
random_sample(size=None)

Return random floats in the half-open interval [0.0, 1.0).

Results are from the 'continuous uniform' distribution over the
stated interval.  To sample :math:`Unif[a, b), b > a` multiply
the output of `random_sample` by `(b-a)` and add `a`::

  (b - a) * random_sample() + a

.. note::
    New code should use the ``random`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray of floats
    Array of random floats of shape `size` (unless ``size=None``, in which
    case a single float is returned).

See Also
--------
Generator.random: which should be used for new code.

Examples
--------
>>> np.random.random_sample()
0.47108547995356098 # random
>>> type(np.random.random_sample())
<class 'float'>
>>> np.random.random_sample((5,))
array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random

Three-by-two array of random numbers from [-5, 0):

>>> 5 * np.random.random_sample((3, 2)) - 5
array([[-3.99149989, -0.52338984], # random
       [-2.99091858, -0.79479508],
       [-1.23204345, -1.75224494]])
*)

val rayleigh : ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
rayleigh(scale=1.0, size=None)

Draw samples from a Rayleigh distribution.

The :math:`\chi` and Weibull distributions are generalizations of the
Rayleigh.

.. note::
    New code should use the ``rayleigh`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
scale : float or array_like of floats, optional
    Scale, also equals the mode. Must be non-negative. Default is 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``scale`` is a scalar.  Otherwise,
    ``np.array(scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Rayleigh distribution.

See Also
--------
Generator.rayleigh: which should be used for new code.

Notes
-----
The probability density function for the Rayleigh distribution is

.. math:: P(x;scale) = \frac{x}{scale^2}e^{\frac{-x^2}{2 \cdotp scale^2}}

The Rayleigh distribution would arise, for example, if the East
and North components of the wind velocity had identical zero-mean
Gaussian distributions.  Then the wind speed would have a Rayleigh
distribution.

References
----------
.. [1] Brighton Webs Ltd., 'Rayleigh Distribution,'
       https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp
.. [2] Wikipedia, 'Rayleigh distribution'
       https://en.wikipedia.org/wiki/Rayleigh_distribution

Examples
--------
Draw values from the distribution and plot the histogram

>>> from matplotlib.pyplot import hist
>>> values = hist(np.random.rayleigh(3, 100000), bins=200, density=True)

Wave heights tend to follow a Rayleigh distribution. If the mean wave
height is 1 meter, what fraction of waves are likely to be larger than 3
meters?

>>> meanvalue = 1
>>> modevalue = np.sqrt(2 / np.pi) * meanvalue
>>> s = np.random.rayleigh(modevalue, 1000000)

The percentage of waves larger than 3 meters is:

>>> 100.*sum(s>3)/1000000.
0.087300000000000003 # random
*)

val set_state : Py.Object.t -> Py.Object.t
(**
set_state(state)

Set the internal state of the generator from a tuple.

For use if one has reason to manually (re-)set the internal state of
the bit generator used by the RandomState instance. By default,
RandomState uses the 'Mersenne Twister'[1]_ pseudo-random number
generating algorithm.

Parameters
----------
state : {tuple(str, ndarray of 624 uints, int, int, float), dict}
    The `state` tuple has the following items:

    1. the string 'MT19937', specifying the Mersenne Twister algorithm.
    2. a 1-D array of 624 unsigned integers ``keys``.
    3. an integer ``pos``.
    4. an integer ``has_gauss``.
    5. a float ``cached_gaussian``.

    If state is a dictionary, it is directly set using the BitGenerators
    `state` property.

Returns
-------
out : None
    Returns 'None' on success.

See Also
--------
get_state

Notes
-----
`set_state` and `get_state` are not needed to work with any of the
random distributions in NumPy. If the internal state is manually altered,
the user should know exactly what he/she is doing.

For backwards compatibility, the form (str, array of 624 uints, int) is
also accepted although it is missing some information about the cached
Gaussian value: ``state = ('MT19937', keys, pos)``.

References
----------
.. [1] M. Matsumoto and T. Nishimura, 'Mersenne Twister: A
   623-dimensionally equidistributed uniform pseudorandom number
   generator,' *ACM Trans. on Modeling and Computer Simulation*,
   Vol. 8, No. 1, pp. 3-30, Jan. 1998.
*)

val shuffle : [>`Ndarray] Obj.t -> Py.Object.t
(**
shuffle(x)

Modify a sequence in-place by shuffling its contents.

This function only shuffles the array along the first axis of a
multi-dimensional array. The order of sub-arrays is changed but
their contents remains the same.

.. note::
    New code should use the ``shuffle`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
x : array_like
    The array or list to be shuffled.

Returns
-------
None

See Also
--------
Generator.shuffle: which should be used for new code.

Examples
--------
>>> arr = np.arange(10)
>>> np.random.shuffle(arr)
>>> arr
[1 7 5 2 9 4 3 6 0 8] # random

Multi-dimensional arrays are only shuffled along the first axis:

>>> arr = np.arange(9).reshape((3, 3))
>>> np.random.shuffle(arr)
>>> arr
array([[3, 4, 5], # random
       [6, 7, 8],
       [0, 1, 2]])
*)

val standard_cauchy : ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
standard_cauchy(size=None)

Draw samples from a standard Cauchy distribution with mode = 0.

Also known as the Lorentz distribution.

.. note::
    New code should use the ``standard_cauchy`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
    The drawn samples.

See Also
--------
Generator.standard_cauchy: which should be used for new code.

Notes
-----
The probability density function for the full Cauchy distribution is

.. math:: P(x; x_0, \gamma) = \frac{1}{\pi \gamma \bigl[ 1+
          (\frac{x-x_0}{\gamma})^2 \bigr] }

and the Standard Cauchy distribution just sets :math:`x_0=0` and
:math:`\gamma=1`

The Cauchy distribution arises in the solution to the driven harmonic
oscillator problem, and also describes spectral line broadening. It
also describes the distribution of values at which a line tilted at
a random angle will cut the x axis.

When studying hypothesis tests that assume normality, seeing how the
tests perform on data from a Cauchy distribution is a good indicator of
their sensitivity to a heavy-tailed distribution, since the Cauchy looks
very much like a Gaussian distribution, but with heavier tails.

References
----------
.. [1] NIST/SEMATECH e-Handbook of Statistical Methods, 'Cauchy
      Distribution',
      https://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm
.. [2] Weisstein, Eric W. 'Cauchy Distribution.' From MathWorld--A
      Wolfram Web Resource.
      http://mathworld.wolfram.com/CauchyDistribution.html
.. [3] Wikipedia, 'Cauchy distribution'
      https://en.wikipedia.org/wiki/Cauchy_distribution

Examples
--------
Draw samples and plot the distribution:

>>> import matplotlib.pyplot as plt
>>> s = np.random.standard_cauchy(1000000)
>>> s = s[(s>-25) & (s<25)]  # truncate distribution so it plots well
>>> plt.hist(s, bins=100)
>>> plt.show()
*)

val standard_exponential : ?size:int list -> unit -> Py.Object.t
(**
standard_exponential(size=None)

Draw samples from the standard exponential distribution.

`standard_exponential` is identical to the exponential distribution
with a scale parameter of 1.

.. note::
    New code should use the ``standard_exponential`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray
    Drawn samples.

See Also
--------
Generator.standard_exponential: which should be used for new code.

Examples
--------
Output a 3x8000 array:

>>> n = np.random.standard_exponential((3, 8000))
*)

val standard_gamma : ?size:int list -> int list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
standard_gamma(shape, size=None)

Draw samples from a standard Gamma distribution.

Samples are drawn from a Gamma distribution with specified parameters,
shape (sometimes designated 'k') and scale=1.

.. note::
    New code should use the ``standard_gamma`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
shape : float or array_like of floats
    Parameter, must be non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``shape`` is a scalar.  Otherwise,
    ``np.array(shape).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized standard gamma distribution.

See Also
--------
scipy.stats.gamma : probability density function, distribution or
    cumulative density function, etc.
Generator.standard_gamma: which should be used for new code.

Notes
-----
The probability density for the Gamma distribution is

.. math:: p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},

where :math:`k` is the shape and :math:`\theta` the scale,
and :math:`\Gamma` is the Gamma function.

The Gamma distribution is often used to model the times to failure of
electronic components, and arises naturally in processes for which the
waiting times between Poisson distributed events are relevant.

References
----------
.. [1] Weisstein, Eric W. 'Gamma Distribution.' From MathWorld--A
       Wolfram Web Resource.
       http://mathworld.wolfram.com/GammaDistribution.html
.. [2] Wikipedia, 'Gamma distribution',
       https://en.wikipedia.org/wiki/Gamma_distribution

Examples
--------
Draw samples from the distribution:

>>> shape, scale = 2., 1. # mean and width
>>> s = np.random.standard_gamma(shape, 1000000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> import scipy.special as sps  # doctest: +SKIP
>>> count, bins, ignored = plt.hist(s, 50, density=True)
>>> y = bins**(shape-1) * ((np.exp(-bins/scale))/  # doctest: +SKIP
...                       (sps.gamma(shape) * scale**shape))
>>> plt.plot(bins, y, linewidth=2, color='r')  # doctest: +SKIP
>>> plt.show()
*)

val standard_normal : ?size:int list -> unit -> Py.Object.t
(**
standard_normal(size=None)

Draw samples from a standard Normal distribution (mean=0, stdev=1).

.. note::
    New code should use the ``standard_normal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray
    A floating-point array of shape ``size`` of drawn samples, or a
    single sample if ``size`` was not specified.

See Also
--------
normal :
    Equivalent function with additional ``loc`` and ``scale`` arguments
    for setting the mean and standard deviation.
Generator.standard_normal: which should be used for new code.

Notes
-----
For random samples from :math:`N(\mu, \sigma^2)`, use one of::

    mu + sigma * np.random.standard_normal(size=...)
    np.random.normal(mu, sigma, size=...)

Examples
--------
>>> np.random.standard_normal()
2.1923875335537315 #random

>>> s = np.random.standard_normal(8000)
>>> s
array([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random
       -0.38672696, -0.4685006 ])                                # random
>>> s.shape
(8000,)
>>> s = np.random.standard_normal(size=(3, 4, 2))
>>> s.shape
(3, 4, 2)

Two-by-four array of samples from :math:`N(3, 6.25)`:

>>> 3 + 2.5 * np.random.standard_normal(size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
*)

val standard_t : ?size:int list -> df:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
standard_t(df, size=None)

Draw samples from a standard Student's t distribution with `df` degrees
of freedom.

A special case of the hyperbolic distribution.  As `df` gets
large, the result resembles that of the standard normal
distribution (`standard_normal`).

.. note::
    New code should use the ``standard_t`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
df : float or array_like of floats
    Degrees of freedom, must be > 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``df`` is a scalar.  Otherwise,
    ``np.array(df).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized standard Student's t distribution.

See Also
--------
Generator.standard_t: which should be used for new code.

Notes
-----
The probability density function for the t distribution is

.. math:: P(x, df) = \frac{\Gamma(\frac{df+1}{2})}{\sqrt{\pi df}
          \Gamma(\frac{df}{2})}\Bigl( 1+\frac{x^2}{df} \Bigr)^{-(df+1)/2}

The t test is based on an assumption that the data come from a
Normal distribution. The t test provides a way to test whether
the sample mean (that is the mean calculated from the data) is
a good estimate of the true mean.

The derivation of the t-distribution was first published in
1908 by William Gosset while working for the Guinness Brewery
in Dublin. Due to proprietary issues, he had to publish under
a pseudonym, and so he used the name Student.

References
----------
.. [1] Dalgaard, Peter, 'Introductory Statistics With R',
       Springer, 2002.
.. [2] Wikipedia, 'Student's t-distribution'
       https://en.wikipedia.org/wiki/Student's_t-distribution

Examples
--------
From Dalgaard page 83 [1]_, suppose the daily energy intake for 11
women in kilojoules (kJ) is:

>>> intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \
...                    7515, 8230, 8770])

Does their energy intake deviate systematically from the recommended
value of 7725 kJ?

We have 10 degrees of freedom, so is the sample mean within 95% of the
recommended value?

>>> s = np.random.standard_t(10, size=100000)
>>> np.mean(intake)
6753.636363636364
>>> intake.std(ddof=1)
1142.1232221373727

Calculate the t statistic, setting the ddof parameter to the unbiased
value so the divisor in the standard deviation will be degrees of
freedom, N-1.

>>> t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))
>>> import matplotlib.pyplot as plt
>>> h = plt.hist(s, bins=100, density=True)

For a one-sided t-test, how far out in the distribution does the t
statistic appear?

>>> np.sum(s<t) / float(len(s))
0.0090699999999999999  #random

So the p-value is about 0.009, which says the null hypothesis has a
probability of about 99% of being true.
*)

val triangular : ?size:int list -> left:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> mode:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> right:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
triangular(left, mode, right, size=None)

Draw samples from the triangular distribution over the
interval ``[left, right]``.

The triangular distribution is a continuous probability
distribution with lower limit left, peak at mode, and upper
limit right. Unlike the other distributions, these parameters
directly define the shape of the pdf.

.. note::
    New code should use the ``triangular`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
left : float or array_like of floats
    Lower limit.
mode : float or array_like of floats
    The value where the peak of the distribution occurs.
    The value must fulfill the condition ``left <= mode <= right``.
right : float or array_like of floats
    Upper limit, must be larger than `left`.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``left``, ``mode``, and ``right``
    are all scalars.  Otherwise, ``np.broadcast(left, mode, right).size``
    samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized triangular distribution.

See Also
--------
Generator.triangular: which should be used for new code.

Notes
-----
The probability density function for the triangular distribution is

.. math:: P(x;l, m, r) = \begin{cases}
          \frac{2(x-l)}{(r-l)(m-l)}& \text{for $l \leq x \leq m$},\\
          \frac{2(r-x)}{(r-l)(r-m)}& \text{for $m \leq x \leq r$},\\
          0& \text{otherwise}.
          \end{cases}

The triangular distribution is often used in ill-defined
problems where the underlying distribution is not known, but
some knowledge of the limits and mode exists. Often it is used
in simulations.

References
----------
.. [1] Wikipedia, 'Triangular distribution'
       https://en.wikipedia.org/wiki/Triangular_distribution

Examples
--------
Draw values from the distribution and plot the histogram:

>>> import matplotlib.pyplot as plt
>>> h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,
...              density=True)
>>> plt.show()
*)

val uniform : ?low:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?high:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
uniform(low=0.0, high=1.0, size=None)

Draw samples from a uniform distribution.

Samples are uniformly distributed over the half-open interval
``[low, high)`` (includes low, but excludes high).  In other words,
any value within the given interval is equally likely to be drawn
by `uniform`.

.. note::
    New code should use the ``uniform`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
low : float or array_like of floats, optional
    Lower boundary of the output interval.  All values generated will be
    greater than or equal to low.  The default value is 0.
high : float or array_like of floats
    Upper boundary of the output interval.  All values generated will be
    less than high.  The default value is 1.0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``low`` and ``high`` are both scalars.
    Otherwise, ``np.broadcast(low, high).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized uniform distribution.

See Also
--------
randint : Discrete uniform distribution, yielding integers.
random_integers : Discrete uniform distribution over the closed
                  interval ``[low, high]``.
random_sample : Floats uniformly distributed over ``[0, 1)``.
random : Alias for `random_sample`.
rand : Convenience function that accepts dimensions as input, e.g.,
       ``rand(2,2)`` would generate a 2-by-2 array of floats,
       uniformly distributed over ``[0, 1)``.
Generator.uniform: which should be used for new code.

Notes
-----
The probability density function of the uniform distribution is

.. math:: p(x) = \frac{1}{b - a}

anywhere within the interval ``[a, b)``, and zero elsewhere.

When ``high`` == ``low``, values of ``low`` will be returned.
If ``high`` < ``low``, the results are officially undefined
and may eventually raise an error, i.e. do not rely on this
function to behave when passed arguments satisfying that
inequality condition.

Examples
--------
Draw samples from the distribution:

>>> s = np.random.uniform(-1,0,1000)

All values are within the given interval:

>>> np.all(s >= -1)
True
>>> np.all(s < 0)
True

Display the histogram of the samples, along with the
probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 15, density=True)
>>> plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')
>>> plt.show()
*)

val vonmises : ?size:int list -> mu:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> kappa:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
vonmises(mu, kappa, size=None)

Draw samples from a von Mises distribution.

Samples are drawn from a von Mises distribution with specified mode
(mu) and dispersion (kappa), on the interval [-pi, pi].

The von Mises distribution (also known as the circular normal
distribution) is a continuous probability distribution on the unit
circle.  It may be thought of as the circular analogue of the normal
distribution.

.. note::
    New code should use the ``vonmises`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
mu : float or array_like of floats
    Mode ('center') of the distribution.
kappa : float or array_like of floats
    Dispersion of the distribution, has to be >=0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``mu`` and ``kappa`` are both scalars.
    Otherwise, ``np.broadcast(mu, kappa).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized von Mises distribution.

See Also
--------
scipy.stats.vonmises : probability density function, distribution, or
    cumulative density function, etc.
Generator.vonmises: which should be used for new code.

Notes
-----
The probability density for the von Mises distribution is

.. math:: p(x) = \frac{e^{\kappa cos(x-\mu)}}{2\pi I_0(\kappa)},

where :math:`\mu` is the mode and :math:`\kappa` the dispersion,
and :math:`I_0(\kappa)` is the modified Bessel function of order 0.

The von Mises is named for Richard Edler von Mises, who was born in
Austria-Hungary, in what is now the Ukraine.  He fled to the United
States in 1939 and became a professor at Harvard.  He worked in
probability theory, aerodynamics, fluid mechanics, and philosophy of
science.

References
----------
.. [1] Abramowitz, M. and Stegun, I. A. (Eds.). 'Handbook of
       Mathematical Functions with Formulas, Graphs, and Mathematical
       Tables, 9th printing,' New York: Dover, 1972.
.. [2] von Mises, R., 'Mathematical Theory of Probability
       and Statistics', New York: Academic Press, 1964.

Examples
--------
Draw samples from the distribution:

>>> mu, kappa = 0.0, 4.0 # mean and dispersion
>>> s = np.random.vonmises(mu, kappa, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> from scipy.special import i0  # doctest: +SKIP
>>> plt.hist(s, 50, density=True)
>>> x = np.linspace(-np.pi, np.pi, num=51)
>>> y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  # doctest: +SKIP
>>> plt.plot(x, y, linewidth=2, color='r')  # doctest: +SKIP
>>> plt.show()
*)

val wald : ?size:int list -> mean:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
wald(mean, scale, size=None)

Draw samples from a Wald, or inverse Gaussian, distribution.

As the scale approaches infinity, the distribution becomes more like a
Gaussian. Some references claim that the Wald is an inverse Gaussian
with mean equal to 1, but this is by no means universal.

The inverse Gaussian distribution was first studied in relationship to
Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian
because there is an inverse relationship between the time to cover a
unit distance and distance covered in unit time.

.. note::
    New code should use the ``wald`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
mean : float or array_like of floats
    Distribution mean, must be > 0.
scale : float or array_like of floats
    Scale parameter, must be > 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``mean`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(mean, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Wald distribution.

See Also
--------
Generator.wald: which should be used for new code.

Notes
-----
The probability density function for the Wald distribution is

.. math:: P(x;mean,scale) = \sqrt{\frac{scale}{2\pi x^3}}e^
                            \frac{-scale(x-mean)^2}{2\cdotp mean^2x}

As noted above the inverse Gaussian distribution first arise
from attempts to model Brownian motion. It is also a
competitor to the Weibull for use in reliability modeling and
modeling stock returns and interest rate processes.

References
----------
.. [1] Brighton Webs Ltd., Wald Distribution,
       https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp
.. [2] Chhikara, Raj S., and Folks, J. Leroy, 'The Inverse Gaussian
       Distribution: Theory : Methodology, and Applications', CRC Press,
       1988.
.. [3] Wikipedia, 'Inverse Gaussian distribution'
       https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution

Examples
--------
Draw values from the distribution and plot the histogram:

>>> import matplotlib.pyplot as plt
>>> h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True)
>>> plt.show()
*)

val weibull : ?size:int list -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
weibull(a, size=None)

Draw samples from a Weibull distribution.

Draw samples from a 1-parameter Weibull distribution with the given
shape parameter `a`.

.. math:: X = (-ln(U))^{1/a}

Here, U is drawn from the uniform distribution over (0,1].

The more common 2-parameter Weibull, including a scale parameter
:math:`\lambda` is just :math:`X = \lambda(-ln(U))^{1/a}`.

.. note::
    New code should use the ``weibull`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Shape parameter of the distribution.  Must be nonnegative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` is a scalar.  Otherwise,
    ``np.array(a).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Weibull distribution.

See Also
--------
scipy.stats.weibull_max
scipy.stats.weibull_min
scipy.stats.genextreme
gumbel
Generator.weibull: which should be used for new code.

Notes
-----
The Weibull (or Type III asymptotic extreme value distribution
for smallest values, SEV Type III, or Rosin-Rammler
distribution) is one of a class of Generalized Extreme Value
(GEV) distributions used in modeling extreme value problems.
This class includes the Gumbel and Frechet distributions.

The probability density for the Weibull distribution is

.. math:: p(x) = \frac{a}
                 {\lambda}(\frac{x}{\lambda})^{a-1}e^{-(x/\lambda)^a},

where :math:`a` is the shape and :math:`\lambda` the scale.

The function has its peak (the mode) at
:math:`\lambda(\frac{a-1}{a})^{1/a}`.

When ``a = 1``, the Weibull distribution reduces to the exponential
distribution.

References
----------
.. [1] Waloddi Weibull, Royal Technical University, Stockholm,
       1939 'A Statistical Theory Of The Strength Of Materials',
       Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939,
       Generalstabens Litografiska Anstalts Forlag, Stockholm.
.. [2] Waloddi Weibull, 'A Statistical Distribution Function of
       Wide Applicability', Journal Of Applied Mechanics ASME Paper
       1951.
.. [3] Wikipedia, 'Weibull distribution',
       https://en.wikipedia.org/wiki/Weibull_distribution

Examples
--------
Draw samples from the distribution:

>>> a = 5. # shape
>>> s = np.random.weibull(a, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> x = np.arange(1,100.)/50.
>>> def weib(x,n,a):
...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)

>>> count, bins, ignored = plt.hist(np.random.weibull(5.,1000))
>>> x = np.arange(1,100.)/50.
>>> scale = count.max()/weib(x, 1., 5.).max()
>>> plt.plot(x, weib(x, 1., 5.)*scale)
>>> plt.show()
*)

val zipf : ?size:int list -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
zipf(a, size=None)

Draw samples from a Zipf distribution.

Samples are drawn from a Zipf distribution with specified parameter
`a` > 1.

The Zipf distribution (also known as the zeta distribution) is a
continuous probability distribution that satisfies Zipf's law: the
frequency of an item is inversely proportional to its rank in a
frequency table.

.. note::
    New code should use the ``zipf`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Distribution parameter. Must be greater than 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` is a scalar. Otherwise,
    ``np.array(a).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Zipf distribution.

See Also
--------
scipy.stats.zipf : probability density function, distribution, or
    cumulative density function, etc.
Generator.zipf: which should be used for new code.

Notes
-----
The probability density for the Zipf distribution is

.. math:: p(x) = \frac{x^{-a}}{\zeta(a)},

where :math:`\zeta` is the Riemann Zeta function.

It is named for the American linguist George Kingsley Zipf, who noted
that the frequency of any word in a sample of a language is inversely
proportional to its rank in the frequency table.

References
----------
.. [1] Zipf, G. K., 'Selected Studies of the Principle of Relative
       Frequency in Language,' Cambridge, MA: Harvard Univ. Press,
       1932.

Examples
--------
Draw samples from the distribution:

>>> a = 2. # parameter
>>> s = np.random.zipf(a, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> from scipy import special  # doctest: +SKIP

Truncate s values at 50 so plot is interesting:

>>> count, bins, ignored = plt.hist(s[s<50], 50, density=True)
>>> x = np.arange(1., 50.)
>>> y = x**(-a) / special.zetac(a)  # doctest: +SKIP
>>> plt.plot(x, y/max(y), linewidth=2, color='r')  # doctest: +SKIP
>>> plt.show()
*)


end

val beta : ?size:int list -> b:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
beta(a, b, size=None)

Draw samples from a Beta distribution.

The Beta distribution is a special case of the Dirichlet distribution,
and is related to the Gamma distribution.  It has the probability
distribution function

.. math:: f(x; a,b) = \frac{1}{B(\alpha, \beta)} x^{\alpha - 1}
                                                 (1 - x)^{\beta - 1},

where the normalization, B, is the beta function,

.. math:: B(\alpha, \beta) = \int_0^1 t^{\alpha - 1}
                             (1 - t)^{\beta - 1} dt.

It is often seen in Bayesian inference and order statistics.

.. note::
    New code should use the ``beta`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Alpha, positive (>0).
b : float or array_like of floats
    Beta, positive (>0).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` and ``b`` are both scalars.
    Otherwise, ``np.broadcast(a, b).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized beta distribution.

See Also
--------
Generator.beta: which should be used for new code.
*)

val binomial : ?size:int list -> n:[`I of int | `Array_like_of_ints of Py.Object.t] -> p:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
binomial(n, p, size=None)

Draw samples from a binomial distribution.

Samples are drawn from a binomial distribution with specified
parameters, n trials and p probability of success where
n an integer >= 0 and p is in the interval [0,1]. (n may be
input as a float, but it is truncated to an integer in use)

.. note::
    New code should use the ``binomial`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
n : int or array_like of ints
    Parameter of the distribution, >= 0. Floats are also accepted,
    but they will be truncated to integers.
p : float or array_like of floats
    Parameter of the distribution, >= 0 and <=1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``n`` and ``p`` are both scalars.
    Otherwise, ``np.broadcast(n, p).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized binomial distribution, where
    each sample is equal to the number of successes over the n trials.

See Also
--------
scipy.stats.binom : probability density function, distribution or
    cumulative density function, etc.
Generator.binomial: which should be used for new code.

Notes
-----
The probability density for the binomial distribution is

.. math:: P(N) = \binom{n}{N}p^N(1-p)^{n-N},

where :math:`n` is the number of trials, :math:`p` is the probability
of success, and :math:`N` is the number of successes.

When estimating the standard error of a proportion in a population by
using a random sample, the normal distribution works well unless the
product p*n <=5, where p = population proportion estimate, and n =
number of samples, in which case the binomial distribution is used
instead. For example, a sample of 15 people shows 4 who are left
handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,
so the binomial distribution should be used in this case.

References
----------
.. [1] Dalgaard, Peter, 'Introductory Statistics with R',
       Springer-Verlag, 2002.
.. [2] Glantz, Stanton A. 'Primer of Biostatistics.', McGraw-Hill,
       Fifth Edition, 2002.
.. [3] Lentner, Marvin, 'Elementary Applied Statistics', Bogden
       and Quigley, 1972.
.. [4] Weisstein, Eric W. 'Binomial Distribution.' From MathWorld--A
       Wolfram Web Resource.
       http://mathworld.wolfram.com/BinomialDistribution.html
.. [5] Wikipedia, 'Binomial distribution',
       https://en.wikipedia.org/wiki/Binomial_distribution

Examples
--------
Draw samples from the distribution:

>>> n, p = 10, .5  # number of trials, probability of each trial
>>> s = np.random.binomial(n, p, 1000)
# result of flipping a coin 10 times, tested 1000 times.

A real world example. A company drills 9 wild-cat oil exploration
wells, each with an estimated probability of success of 0.1. All nine
wells fail. What is the probability of that happening?

Let's do 20,000 trials of the model, and count the number that
generate zero positive results.

>>> sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.
# answer = 0.38885, or 38%.
*)

val bytes : int -> string
(**
bytes(length)

Return random bytes.

.. note::
    New code should use the ``bytes`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
length : int
    Number of random bytes.

Returns
-------
out : str
    String of length `length`.

See Also
--------
Generator.bytes: which should be used for new code.

Examples
--------
>>> np.random.bytes(10)
' eh\x85\x022SZ\xbf\xa4' #random
*)

val chisquare : ?size:int list -> df:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
chisquare(df, size=None)

Draw samples from a chi-square distribution.

When `df` independent random variables, each with standard normal
distributions (mean 0, variance 1), are squared and summed, the
resulting distribution is chi-square (see Notes).  This distribution
is often used in hypothesis testing.

.. note::
    New code should use the ``chisquare`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
df : float or array_like of floats
     Number of degrees of freedom, must be > 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``df`` is a scalar.  Otherwise,
    ``np.array(df).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized chi-square distribution.

Raises
------
ValueError
    When `df` <= 0 or when an inappropriate `size` (e.g. ``size=-1``)
    is given.

See Also
--------
Generator.chisquare: which should be used for new code.

Notes
-----
The variable obtained by summing the squares of `df` independent,
standard normally distributed random variables:

.. math:: Q = \sum_{i=0}^{\mathtt{df}} X^2_i

is chi-square distributed, denoted

.. math:: Q \sim \chi^2_k.

The probability density function of the chi-squared distribution is

.. math:: p(x) = \frac{(1/2)^{k/2}}{\Gamma(k/2)}
                 x^{k/2 - 1} e^{-x/2},

where :math:`\Gamma` is the gamma function,

.. math:: \Gamma(x) = \int_0^{-\infty} t^{x - 1} e^{-t} dt.

References
----------
.. [1] NIST 'Engineering Statistics Handbook'
       https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm

Examples
--------
>>> np.random.chisquare(2,4)
array([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random
*)

val choice : ?size:int list -> ?replace:bool -> ?p:Py.Object.t -> [`T1_D_array_like of Py.Object.t | `I of int] -> Py.Object.t
(**
choice(a, size=None, replace=True, p=None)

Generates a random sample from a given 1-D array

        .. versionadded:: 1.7.0

.. note::
    New code should use the ``choice`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : 1-D array-like or int
    If an ndarray, a random sample is generated from its elements.
    If an int, the random sample is generated as if a were np.arange(a)
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.
replace : boolean, optional
    Whether the sample is with or without replacement
p : 1-D array-like, optional
    The probabilities associated with each entry in a.
    If not given the sample assumes a uniform distribution over all
    entries in a.

Returns
-------
samples : single item or ndarray
    The generated random samples

Raises
------
ValueError
    If a is an int and less than zero, if a or p are not 1-dimensional,
    if a is an array-like of size 0, if p is not a vector of
    probabilities, if a and p have different lengths, or if
    replace=False and the sample size is greater than the population
    size

See Also
--------
randint, shuffle, permutation
Generator.choice: which should be used in new code

Examples
--------
Generate a uniform random sample from np.arange(5) of size 3:

>>> np.random.choice(5, 3)
array([0, 3, 4]) # random
>>> #This is equivalent to np.random.randint(0,5,3)

Generate a non-uniform random sample from np.arange(5) of size 3:

>>> np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])
array([3, 3, 0]) # random

Generate a uniform random sample from np.arange(5) of size 3 without
replacement:

>>> np.random.choice(5, 3, replace=False)
array([3,1,0]) # random
>>> #This is equivalent to np.random.permutation(np.arange(5))[:3]

Generate a non-uniform random sample from np.arange(5) of size
3 without replacement:

>>> np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])
array([2, 3, 0]) # random

Any of the above can be repeated with an arbitrary array-like
instead of just integers. For instance:

>>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']
>>> np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])
array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random
      dtype='<U11')
*)

val dirichlet : ?size:int list -> alpha:[`Ndarray of [>`Ndarray] Obj.t | `Length_k of Py.Object.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
dirichlet(alpha, size=None)

Draw samples from the Dirichlet distribution.

Draw `size` samples of dimension k from a Dirichlet distribution. A
Dirichlet-distributed random variable can be seen as a multivariate
generalization of a Beta distribution. The Dirichlet distribution
is a conjugate prior of a multinomial distribution in Bayesian
inference.

.. note::
    New code should use the ``dirichlet`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
alpha : sequence of floats, length k
    Parameter of the distribution (length ``k`` for sample of
    length ``k``).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    vector of length ``k`` is returned.

Returns
-------
samples : ndarray,
    The drawn samples, of shape ``(size, k)``.

Raises
-------
ValueError
    If any value in ``alpha`` is less than or equal to zero

See Also
--------
Generator.dirichlet: which should be used for new code.

Notes
-----
The Dirichlet distribution is a distribution over vectors
:math:`x` that fulfil the conditions :math:`x_i>0` and
:math:`\sum_{i=1}^k x_i = 1`.

The probability density function :math:`p` of a
Dirichlet-distributed random vector :math:`X` is
proportional to

.. math:: p(x) \propto \prod_{i=1}^{k}{x^{\alpha_i-1}_i},

where :math:`\alpha` is a vector containing the positive
concentration parameters.

The method uses the following property for computation: let :math:`Y`
be a random vector which has components that follow a standard gamma
distribution, then :math:`X = \frac{1}{\sum_{i=1}^k{Y_i}} Y`
is Dirichlet-distributed

References
----------
.. [1] David McKay, 'Information Theory, Inference and Learning
       Algorithms,' chapter 23,
       http://www.inference.org.uk/mackay/itila/
.. [2] Wikipedia, 'Dirichlet distribution',
       https://en.wikipedia.org/wiki/Dirichlet_distribution

Examples
--------
Taking an example cited in Wikipedia, this distribution can be used if
one wanted to cut strings (each of initial length 1.0) into K pieces
with different lengths, where each piece had, on average, a designated
average length, but allowing some variation in the relative sizes of
the pieces.

>>> s = np.random.dirichlet((10, 5, 3), 20).transpose()

>>> import matplotlib.pyplot as plt
>>> plt.barh(range(20), s[0])
>>> plt.barh(range(20), s[1], left=s[0], color='g')
>>> plt.barh(range(20), s[2], left=s[0]+s[1], color='r')
>>> plt.title('Lengths of Strings')
*)

val exponential : ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
exponential(scale=1.0, size=None)

Draw samples from an exponential distribution.

Its probability density function is

.. math:: f(x; \frac{1}{\beta}) = \frac{1}{\beta} \exp(-\frac{x}{\beta}),

for ``x > 0`` and 0 elsewhere. :math:`\beta` is the scale parameter,
which is the inverse of the rate parameter :math:`\lambda = 1/\beta`.
The rate parameter is an alternative, widely used parameterization
of the exponential distribution [3]_.

The exponential distribution is a continuous analogue of the
geometric distribution.  It describes many common situations, such as
the size of raindrops measured over many rainstorms [1]_, or the time
between page requests to Wikipedia [2]_.

.. note::
    New code should use the ``exponential`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
scale : float or array_like of floats
    The scale parameter, :math:`\beta = 1/\lambda`. Must be
    non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``scale`` is a scalar.  Otherwise,
    ``np.array(scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized exponential distribution.

See Also
--------
Generator.exponential: which should be used for new code.

References
----------
.. [1] Peyton Z. Peebles Jr., 'Probability, Random Variables and
       Random Signal Principles', 4th ed, 2001, p. 57.
.. [2] Wikipedia, 'Poisson process',
       https://en.wikipedia.org/wiki/Poisson_process
.. [3] Wikipedia, 'Exponential distribution',
       https://en.wikipedia.org/wiki/Exponential_distribution
*)

val f : ?size:int list -> dfnum:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> dfden:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
f(dfnum, dfden, size=None)

Draw samples from an F distribution.

Samples are drawn from an F distribution with specified parameters,
`dfnum` (degrees of freedom in numerator) and `dfden` (degrees of
freedom in denominator), where both parameters must be greater than
zero.

The random variate of the F distribution (also known as the
Fisher distribution) is a continuous probability distribution
that arises in ANOVA tests, and is the ratio of two chi-square
variates.

.. note::
    New code should use the ``f`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
dfnum : float or array_like of floats
    Degrees of freedom in numerator, must be > 0.
dfden : float or array_like of float
    Degrees of freedom in denominator, must be > 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``dfnum`` and ``dfden`` are both scalars.
    Otherwise, ``np.broadcast(dfnum, dfden).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Fisher distribution.

See Also
--------
scipy.stats.f : probability density function, distribution or
    cumulative density function, etc.
Generator.f: which should be used for new code.

Notes
-----
The F statistic is used to compare in-group variances to between-group
variances. Calculating the distribution depends on the sampling, and
so it is a function of the respective degrees of freedom in the
problem.  The variable `dfnum` is the number of samples minus one, the
between-groups degrees of freedom, while `dfden` is the within-groups
degrees of freedom, the sum of the number of samples in each group
minus the number of groups.

References
----------
.. [1] Glantz, Stanton A. 'Primer of Biostatistics.', McGraw-Hill,
       Fifth Edition, 2002.
.. [2] Wikipedia, 'F-distribution',
       https://en.wikipedia.org/wiki/F-distribution

Examples
--------
An example from Glantz[1], pp 47-40:

Two groups, children of diabetics (25 people) and children from people
without diabetes (25 controls). Fasting blood glucose was measured,
case group had a mean value of 86.1, controls had a mean value of
82.2. Standard deviations were 2.09 and 2.49 respectively. Are these
data consistent with the null hypothesis that the parents diabetic
status does not affect their children's blood glucose levels?
Calculating the F statistic from the data gives a value of 36.01.

Draw samples from the distribution:

>>> dfnum = 1. # between group degrees of freedom
>>> dfden = 48. # within groups degrees of freedom
>>> s = np.random.f(dfnum, dfden, 1000)

The lower bound for the top 1% of the samples is :

>>> np.sort(s)[-10]
7.61988120985 # random

So there is about a 1% chance that the F statistic will exceed 7.62,
the measured value is 36, so the null hypothesis is rejected at the 1%
level.
*)

val gamma : ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> int list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
gamma(shape, scale=1.0, size=None)

Draw samples from a Gamma distribution.

Samples are drawn from a Gamma distribution with specified parameters,
`shape` (sometimes designated 'k') and `scale` (sometimes designated
'theta'), where both parameters are > 0.

.. note::
    New code should use the ``gamma`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
shape : float or array_like of floats
    The shape of the gamma distribution. Must be non-negative.
scale : float or array_like of floats, optional
    The scale of the gamma distribution. Must be non-negative.
    Default is equal to 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``shape`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(shape, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized gamma distribution.

See Also
--------
scipy.stats.gamma : probability density function, distribution or
    cumulative density function, etc.
Generator.gamma: which should be used for new code.

Notes
-----
The probability density for the Gamma distribution is

.. math:: p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},

where :math:`k` is the shape and :math:`\theta` the scale,
and :math:`\Gamma` is the Gamma function.

The Gamma distribution is often used to model the times to failure of
electronic components, and arises naturally in processes for which the
waiting times between Poisson distributed events are relevant.

References
----------
.. [1] Weisstein, Eric W. 'Gamma Distribution.' From MathWorld--A
       Wolfram Web Resource.
       http://mathworld.wolfram.com/GammaDistribution.html
.. [2] Wikipedia, 'Gamma distribution',
       https://en.wikipedia.org/wiki/Gamma_distribution

Examples
--------
Draw samples from the distribution:

>>> shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)
>>> s = np.random.gamma(shape, scale, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> import scipy.special as sps  # doctest: +SKIP
>>> count, bins, ignored = plt.hist(s, 50, density=True)
>>> y = bins**(shape-1)*(np.exp(-bins/scale) /  # doctest: +SKIP
...                      (sps.gamma(shape)*scale**shape))
>>> plt.plot(bins, y, linewidth=2, color='r')  # doctest: +SKIP
>>> plt.show()
*)

val geometric : ?size:int list -> p:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
geometric(p, size=None)

Draw samples from the geometric distribution.

Bernoulli trials are experiments with one of two outcomes:
success or failure (an example of such an experiment is flipping
a coin).  The geometric distribution models the number of trials
that must be run in order to achieve success.  It is therefore
supported on the positive integers, ``k = 1, 2, ...``.

The probability mass function of the geometric distribution is

.. math:: f(k) = (1 - p)^{k - 1} p

where `p` is the probability of success of an individual trial.

.. note::
    New code should use the ``geometric`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
p : float or array_like of floats
    The probability of success of an individual trial.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``p`` is a scalar.  Otherwise,
    ``np.array(p).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized geometric distribution.

See Also
--------
Generator.geometric: which should be used for new code.

Examples
--------
Draw ten thousand values from the geometric distribution,
with the probability of an individual success equal to 0.35:

>>> z = np.random.geometric(p=0.35, size=10000)

How many trials succeeded after a single run?

>>> (z == 1).sum() / 10000.
0.34889999999999999 #random
*)

val gumbel : ?loc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
gumbel(loc=0.0, scale=1.0, size=None)

Draw samples from a Gumbel distribution.

Draw samples from a Gumbel distribution with specified location and
scale.  For more information on the Gumbel distribution, see
Notes and References below.

.. note::
    New code should use the ``gumbel`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
loc : float or array_like of floats, optional
    The location of the mode of the distribution. Default is 0.
scale : float or array_like of floats, optional
    The scale parameter of the distribution. Default is 1. Must be non-
    negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``loc`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Gumbel distribution.

See Also
--------
scipy.stats.gumbel_l
scipy.stats.gumbel_r
scipy.stats.genextreme
weibull
Generator.gumbel: which should be used for new code.

Notes
-----
The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme
Value Type I) distribution is one of a class of Generalized Extreme
Value (GEV) distributions used in modeling extreme value problems.
The Gumbel is a special case of the Extreme Value Type I distribution
for maximums from distributions with 'exponential-like' tails.

The probability density for the Gumbel distribution is

.. math:: p(x) = \frac{e^{-(x - \mu)/ \beta}}{\beta} e^{ -e^{-(x - \mu)/
          \beta}},

where :math:`\mu` is the mode, a location parameter, and
:math:`\beta` is the scale parameter.

The Gumbel (named for German mathematician Emil Julius Gumbel) was used
very early in the hydrology literature, for modeling the occurrence of
flood events. It is also used for modeling maximum wind speed and
rainfall rates.  It is a 'fat-tailed' distribution - the probability of
an event in the tail of the distribution is larger than if one used a
Gaussian, hence the surprisingly frequent occurrence of 100-year
floods. Floods were initially modeled as a Gaussian process, which
underestimated the frequency of extreme events.

It is one of a class of extreme value distributions, the Generalized
Extreme Value (GEV) distributions, which also includes the Weibull and
Frechet.

The function has a mean of :math:`\mu + 0.57721\beta` and a variance
of :math:`\frac{\pi^2}{6}\beta^2`.

References
----------
.. [1] Gumbel, E. J., 'Statistics of Extremes,'
       New York: Columbia University Press, 1958.
.. [2] Reiss, R.-D. and Thomas, M., 'Statistical Analysis of Extreme
       Values from Insurance, Finance, Hydrology and Other Fields,'
       Basel: Birkhauser Verlag, 2001.

Examples
--------
Draw samples from the distribution:

>>> mu, beta = 0, 0.1 # location and scale
>>> s = np.random.gumbel(mu, beta, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp( -np.exp( -(bins - mu) /beta) ),
...          linewidth=2, color='r')
>>> plt.show()

Show how an extreme value distribution can arise from a Gaussian process
and compare to a Gaussian:

>>> means = []
>>> maxima = []
>>> for i in range(0,1000) :
...    a = np.random.normal(mu, beta, 1000)
...    means.append(a.mean())
...    maxima.append(a.max())
>>> count, bins, ignored = plt.hist(maxima, 30, density=True)
>>> beta = np.std(maxima) * np.sqrt(6) / np.pi
>>> mu = np.mean(maxima) - 0.57721*beta
>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp(-np.exp(-(bins - mu)/beta)),
...          linewidth=2, color='r')
>>> plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))
...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),
...          linewidth=2, color='g')
>>> plt.show()
*)

val hypergeometric : ?size:int list -> ngood:[`I of int | `Array_like_of_ints of Py.Object.t] -> nbad:[`I of int | `Array_like_of_ints of Py.Object.t] -> nsample:[`I of int | `Array_like_of_ints of Py.Object.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
hypergeometric(ngood, nbad, nsample, size=None)

Draw samples from a Hypergeometric distribution.

Samples are drawn from a hypergeometric distribution with specified
parameters, `ngood` (ways to make a good selection), `nbad` (ways to make
a bad selection), and `nsample` (number of items sampled, which is less
than or equal to the sum ``ngood + nbad``).

.. note::
    New code should use the ``hypergeometric`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
ngood : int or array_like of ints
    Number of ways to make a good selection.  Must be nonnegative.
nbad : int or array_like of ints
    Number of ways to make a bad selection.  Must be nonnegative.
nsample : int or array_like of ints
    Number of items sampled.  Must be at least 1 and at most
    ``ngood + nbad``.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if `ngood`, `nbad`, and `nsample`
    are all scalars.  Otherwise, ``np.broadcast(ngood, nbad, nsample).size``
    samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized hypergeometric distribution. Each
    sample is the number of good items within a randomly selected subset of
    size `nsample` taken from a set of `ngood` good items and `nbad` bad items.

See Also
--------
scipy.stats.hypergeom : probability density function, distribution or
    cumulative density function, etc.
Generator.hypergeometric: which should be used for new code.

Notes
-----
The probability density for the Hypergeometric distribution is

.. math:: P(x) = \frac{\binom{g}{x}\binom{b}{n-x}}{\binom{g+b}{n}},

where :math:`0 \le x \le n` and :math:`n-b \le x \le g`

for P(x) the probability of ``x`` good results in the drawn sample,
g = `ngood`, b = `nbad`, and n = `nsample`.

Consider an urn with black and white marbles in it, `ngood` of them
are black and `nbad` are white. If you draw `nsample` balls without
replacement, then the hypergeometric distribution describes the
distribution of black balls in the drawn sample.

Note that this distribution is very similar to the binomial
distribution, except that in this case, samples are drawn without
replacement, whereas in the Binomial case samples are drawn with
replacement (or the sample space is infinite). As the sample space
becomes large, this distribution approaches the binomial.

References
----------
.. [1] Lentner, Marvin, 'Elementary Applied Statistics', Bogden
       and Quigley, 1972.
.. [2] Weisstein, Eric W. 'Hypergeometric Distribution.' From
       MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/HypergeometricDistribution.html
.. [3] Wikipedia, 'Hypergeometric distribution',
       https://en.wikipedia.org/wiki/Hypergeometric_distribution

Examples
--------
Draw samples from the distribution:

>>> ngood, nbad, nsamp = 100, 2, 10
# number of good, number of bad, and number of samples
>>> s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)
>>> from matplotlib.pyplot import hist
>>> hist(s)
#   note that it is very unlikely to grab both bad items

Suppose you have an urn with 15 white and 15 black marbles.
If you pull 15 marbles at random, how likely is it that
12 or more of them are one color?

>>> s = np.random.hypergeometric(15, 15, 15, 100000)
>>> sum(s>=12)/100000. + sum(s<=3)/100000.
#   answer = 0.003 ... pretty unlikely!
*)

val laplace : ?loc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
laplace(loc=0.0, scale=1.0, size=None)

Draw samples from the Laplace or double exponential distribution with
specified location (or mean) and scale (decay).

The Laplace distribution is similar to the Gaussian/normal distribution,
but is sharper at the peak and has fatter tails. It represents the
difference between two independent, identically distributed exponential
random variables.

.. note::
    New code should use the ``laplace`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
loc : float or array_like of floats, optional
    The position, :math:`\mu`, of the distribution peak. Default is 0.
scale : float or array_like of floats, optional
    :math:`\lambda`, the exponential decay. Default is 1. Must be non-
    negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``loc`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Laplace distribution.

See Also
--------
Generator.laplace: which should be used for new code.

Notes
-----
It has the probability density function

.. math:: f(x; \mu, \lambda) = \frac{1}{2\lambda}
                               \exp\left(-\frac{ |x - \mu| }{\lambda}\right).

The first law of Laplace, from 1774, states that the frequency
of an error can be expressed as an exponential function of the
absolute magnitude of the error, which leads to the Laplace
distribution. For many problems in economics and health
sciences, this distribution seems to model the data better
than the standard Gaussian distribution.

References
----------
.. [1] Abramowitz, M. and Stegun, I. A. (Eds.). 'Handbook of
       Mathematical Functions with Formulas, Graphs, and Mathematical
       Tables, 9th printing,' New York: Dover, 1972.
.. [2] Kotz, Samuel, et. al. 'The Laplace Distribution and
       Generalizations, ' Birkhauser, 2001.
.. [3] Weisstein, Eric W. 'Laplace Distribution.'
       From MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/LaplaceDistribution.html
.. [4] Wikipedia, 'Laplace distribution',
       https://en.wikipedia.org/wiki/Laplace_distribution

Examples
--------
Draw samples from the distribution

>>> loc, scale = 0., 1.
>>> s = np.random.laplace(loc, scale, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> x = np.arange(-8., 8., .01)
>>> pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)
>>> plt.plot(x, pdf)

Plot Gaussian for comparison:

>>> g = (1/(scale * np.sqrt(2 * np.pi)) *
...      np.exp(-(x - loc)**2 / (2 * scale**2)))
>>> plt.plot(x,g)
*)

val logistic : ?loc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
logistic(loc=0.0, scale=1.0, size=None)

Draw samples from a logistic distribution.

Samples are drawn from a logistic distribution with specified
parameters, loc (location or mean, also median), and scale (>0).

.. note::
    New code should use the ``logistic`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
loc : float or array_like of floats, optional
    Parameter of the distribution. Default is 0.
scale : float or array_like of floats, optional
    Parameter of the distribution. Must be non-negative.
    Default is 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``loc`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized logistic distribution.

See Also
--------
scipy.stats.logistic : probability density function, distribution or
    cumulative density function, etc.
Generator.logistic: which should be used for new code.

Notes
-----
The probability density for the Logistic distribution is

.. math:: P(x) = P(x) = \frac{e^{-(x-\mu)/s}}{s(1+e^{-(x-\mu)/s})^2},

where :math:`\mu` = location and :math:`s` = scale.

The Logistic distribution is used in Extreme Value problems where it
can act as a mixture of Gumbel distributions, in Epidemiology, and by
the World Chess Federation (FIDE) where it is used in the Elo ranking
system, assuming the performance of each player is a logistically
distributed random variable.

References
----------
.. [1] Reiss, R.-D. and Thomas M. (2001), 'Statistical Analysis of
       Extreme Values, from Insurance, Finance, Hydrology and Other
       Fields,' Birkhauser Verlag, Basel, pp 132-133.
.. [2] Weisstein, Eric W. 'Logistic Distribution.' From
       MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/LogisticDistribution.html
.. [3] Wikipedia, 'Logistic-distribution',
       https://en.wikipedia.org/wiki/Logistic_distribution

Examples
--------
Draw samples from the distribution:

>>> loc, scale = 10, 1
>>> s = np.random.logistic(loc, scale, 10000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, bins=50)

#   plot against distribution

>>> def logist(x, loc, scale):
...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)
>>> lgst_val = logist(bins, loc, scale)
>>> plt.plot(bins, lgst_val * count.max() / lgst_val.max())
>>> plt.show()
*)

val lognormal : ?mean:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?sigma:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
lognormal(mean=0.0, sigma=1.0, size=None)

Draw samples from a log-normal distribution.

Draw samples from a log-normal distribution with specified mean,
standard deviation, and array shape.  Note that the mean and standard
deviation are not the values for the distribution itself, but of the
underlying normal distribution it is derived from.

.. note::
    New code should use the ``lognormal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
mean : float or array_like of floats, optional
    Mean value of the underlying normal distribution. Default is 0.
sigma : float or array_like of floats, optional
    Standard deviation of the underlying normal distribution. Must be
    non-negative. Default is 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``mean`` and ``sigma`` are both scalars.
    Otherwise, ``np.broadcast(mean, sigma).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized log-normal distribution.

See Also
--------
scipy.stats.lognorm : probability density function, distribution,
    cumulative density function, etc.
Generator.lognormal: which should be used for new code.

Notes
-----
A variable `x` has a log-normal distribution if `log(x)` is normally
distributed.  The probability density function for the log-normal
distribution is:

.. math:: p(x) = \frac{1}{\sigma x \sqrt{2\pi}}
                 e^{(-\frac{(ln(x)-\mu)^2}{2\sigma^2})}

where :math:`\mu` is the mean and :math:`\sigma` is the standard
deviation of the normally distributed logarithm of the variable.
A log-normal distribution results if a random variable is the *product*
of a large number of independent, identically-distributed variables in
the same way that a normal distribution results if the variable is the
*sum* of a large number of independent, identically-distributed
variables.

References
----------
.. [1] Limpert, E., Stahel, W. A., and Abbt, M., 'Log-normal
       Distributions across the Sciences: Keys and Clues,'
       BioScience, Vol. 51, No. 5, May, 2001.
       https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf
.. [2] Reiss, R.D. and Thomas, M., 'Statistical Analysis of Extreme
       Values,' Basel: Birkhauser Verlag, 2001, pp. 31-32.

Examples
--------
Draw samples from the distribution:

>>> mu, sigma = 3., 1. # mean and standard deviation
>>> s = np.random.lognormal(mu, sigma, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 100, density=True, align='mid')

>>> x = np.linspace(min(bins), max(bins), 10000)
>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))

>>> plt.plot(x, pdf, linewidth=2, color='r')
>>> plt.axis('tight')
>>> plt.show()

Demonstrate that taking the products of random samples from a uniform
distribution can be fit well by a log-normal probability density
function.

>>> # Generate a thousand samples: each is the product of 100 random
>>> # values, drawn from a normal distribution.
>>> b = []
>>> for i in range(1000):
...    a = 10. + np.random.standard_normal(100)
...    b.append(np.product(a))

>>> b = np.array(b) / np.min(b) # scale values to be positive
>>> count, bins, ignored = plt.hist(b, 100, density=True, align='mid')
>>> sigma = np.std(np.log(b))
>>> mu = np.mean(np.log(b))

>>> x = np.linspace(min(bins), max(bins), 10000)
>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))

>>> plt.plot(x, pdf, color='r', linewidth=2)
>>> plt.show()
*)

val logseries : ?size:int list -> p:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
logseries(p, size=None)

Draw samples from a logarithmic series distribution.

Samples are drawn from a log series distribution with specified
shape parameter, 0 < ``p`` < 1.

.. note::
    New code should use the ``logseries`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
p : float or array_like of floats
    Shape parameter for the distribution.  Must be in the range (0, 1).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``p`` is a scalar.  Otherwise,
    ``np.array(p).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized logarithmic series distribution.

See Also
--------
scipy.stats.logser : probability density function, distribution or
    cumulative density function, etc.
Generator.logseries: which should be used for new code.

Notes
-----
The probability density for the Log Series distribution is

.. math:: P(k) = \frac{-p^k}{k \ln(1-p)},

where p = probability.

The log series distribution is frequently used to represent species
richness and occurrence, first proposed by Fisher, Corbet, and
Williams in 1943 [2].  It may also be used to model the numbers of
occupants seen in cars [3].

References
----------
.. [1] Buzas, Martin A.; Culver, Stephen J.,  Understanding regional
       species diversity through the log series distribution of
       occurrences: BIODIVERSITY RESEARCH Diversity & Distributions,
       Volume 5, Number 5, September 1999 , pp. 187-195(9).
.. [2] Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The
       relation between the number of species and the number of
       individuals in a random sample of an animal population.
       Journal of Animal Ecology, 12:42-58.
.. [3] D. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small
       Data Sets, CRC Press, 1994.
.. [4] Wikipedia, 'Logarithmic distribution',
       https://en.wikipedia.org/wiki/Logarithmic_distribution

Examples
--------
Draw samples from the distribution:

>>> a = .6
>>> s = np.random.logseries(a, 10000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s)

#   plot against distribution

>>> def logseries(k, p):
...     return -p**k/(k*np.log(1-p))
>>> plt.plot(bins, logseries(bins, a)*count.max()/
...          logseries(bins, a).max(), 'r')
>>> plt.show()
*)

val multinomial : ?size:int list -> n:int -> pvals:[`Length_p of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
multinomial(n, pvals, size=None)

Draw samples from a multinomial distribution.

The multinomial distribution is a multivariate generalization of the
binomial distribution.  Take an experiment with one of ``p``
possible outcomes.  An example of such an experiment is throwing a dice,
where the outcome can be 1 through 6.  Each sample drawn from the
distribution represents `n` such experiments.  Its values,
``X_i = [X_0, X_1, ..., X_p]``, represent the number of times the
outcome was ``i``.

.. note::
    New code should use the ``multinomial`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
n : int
    Number of experiments.
pvals : sequence of floats, length p
    Probabilities of each of the ``p`` different outcomes.  These
    must sum to 1 (however, the last element is always assumed to
    account for the remaining probability, as long as
    ``sum(pvals[:-1]) <= 1)``.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : ndarray
    The drawn samples, of shape *size*, if that was provided.  If not,
    the shape is ``(N,)``.

    In other words, each entry ``out[i,j,...,:]`` is an N-dimensional
    value drawn from the distribution.

See Also
--------
Generator.multinomial: which should be used for new code.

Examples
--------
Throw a dice 20 times:

>>> np.random.multinomial(20, [1/6.]*6, size=1)
array([[4, 1, 7, 5, 2, 1]]) # random

It landed 4 times on 1, once on 2, etc.

Now, throw the dice 20 times, and 20 times again:

>>> np.random.multinomial(20, [1/6.]*6, size=2)
array([[3, 4, 3, 3, 4, 3], # random
       [2, 4, 3, 4, 0, 7]])

For the first run, we threw 3 times 1, 4 times 2, etc.  For the second,
we threw 2 times 1, 4 times 2, etc.

A loaded die is more likely to land on number 6:

>>> np.random.multinomial(100, [1/7.]*5 + [2/7.])
array([11, 16, 14, 17, 16, 26]) # random

The probability inputs should be normalized. As an implementation
detail, the value of the last entry is ignored and assumed to take
up any leftover probability mass, but this should not be relied on.
A biased coin which has twice as much weight on one side as on the
other should be sampled like so:

>>> np.random.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT
array([38, 62]) # random

not like:

>>> np.random.multinomial(100, [1.0, 2.0])  # WRONG
Traceback (most recent call last):
ValueError: pvals < 0, pvals > 1 or pvals contains NaNs
*)

val multivariate_normal : ?size:int list -> ?check_valid:[`Warn | `Raise | `Ignore] -> ?tol:float -> mean:Py.Object.t -> cov:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)

Draw random samples from a multivariate normal distribution.

The multivariate normal, multinormal or Gaussian distribution is a
generalization of the one-dimensional normal distribution to higher
dimensions.  Such a distribution is specified by its mean and
covariance matrix.  These parameters are analogous to the mean
(average or 'center') and variance (standard deviation, or 'width,'
squared) of the one-dimensional normal distribution.

.. note::
    New code should use the ``multivariate_normal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
mean : 1-D array_like, of length N
    Mean of the N-dimensional distribution.
cov : 2-D array_like, of shape (N, N)
    Covariance matrix of the distribution. It must be symmetric and
    positive-semidefinite for proper sampling.
size : int or tuple of ints, optional
    Given a shape of, for example, ``(m,n,k)``, ``m*n*k`` samples are
    generated, and packed in an `m`-by-`n`-by-`k` arrangement.  Because
    each sample is `N`-dimensional, the output shape is ``(m,n,k,N)``.
    If no shape is specified, a single (`N`-D) sample is returned.
check_valid : { 'warn', 'raise', 'ignore' }, optional
    Behavior when the covariance matrix is not positive semidefinite.
tol : float, optional
    Tolerance when checking the singular values in covariance matrix.
    cov is cast to double before the check.

Returns
-------
out : ndarray
    The drawn samples, of shape *size*, if that was provided.  If not,
    the shape is ``(N,)``.

    In other words, each entry ``out[i,j,...,:]`` is an N-dimensional
    value drawn from the distribution.

See Also
--------
Generator.multivariate_normal: which should be used for new code.

Notes
-----
The mean is a coordinate in N-dimensional space, which represents the
location where samples are most likely to be generated.  This is
analogous to the peak of the bell curve for the one-dimensional or
univariate normal distribution.

Covariance indicates the level to which two variables vary together.
From the multivariate normal distribution, we draw N-dimensional
samples, :math:`X = [x_1, x_2, ... x_N]`.  The covariance matrix
element :math:`C_{ij}` is the covariance of :math:`x_i` and :math:`x_j`.
The element :math:`C_{ii}` is the variance of :math:`x_i` (i.e. its
'spread').

Instead of specifying the full covariance matrix, popular
approximations include:

  - Spherical covariance (`cov` is a multiple of the identity matrix)
  - Diagonal covariance (`cov` has non-negative elements, and only on
    the diagonal)

This geometrical property can be seen in two dimensions by plotting
generated data-points:

>>> mean = [0, 0]
>>> cov = [[1, 0], [0, 100]]  # diagonal covariance

Diagonal covariance means that points are oriented along x or y-axis:

>>> import matplotlib.pyplot as plt
>>> x, y = np.random.multivariate_normal(mean, cov, 5000).T
>>> plt.plot(x, y, 'x')
>>> plt.axis('equal')
>>> plt.show()

Note that the covariance matrix must be positive semidefinite (a.k.a.
nonnegative-definite). Otherwise, the behavior of this method is
undefined and backwards compatibility is not guaranteed.

References
----------
.. [1] Papoulis, A., 'Probability, Random Variables, and Stochastic
       Processes,' 3rd ed., New York: McGraw-Hill, 1991.
.. [2] Duda, R. O., Hart, P. E., and Stork, D. G., 'Pattern
       Classification,' 2nd ed., New York: Wiley, 2001.

Examples
--------
>>> mean = (1, 2)
>>> cov = [[1, 0], [0, 1]]
>>> x = np.random.multivariate_normal(mean, cov, (3, 3))
>>> x.shape
(3, 3, 2)

The following is probably true, given that 0.6 is roughly twice the
standard deviation:

>>> list((x[0,0,:] - mean) < 0.6)
[True, True] # random
*)

val negative_binomial : ?size:int list -> n:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> p:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
negative_binomial(n, p, size=None)

Draw samples from a negative binomial distribution.

Samples are drawn from a negative binomial distribution with specified
parameters, `n` successes and `p` probability of success where `n`
is > 0 and `p` is in the interval [0, 1].

.. note::
    New code should use the ``negative_binomial`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
n : float or array_like of floats
    Parameter of the distribution, > 0.
p : float or array_like of floats
    Parameter of the distribution, >= 0 and <=1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``n`` and ``p`` are both scalars.
    Otherwise, ``np.broadcast(n, p).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized negative binomial distribution,
    where each sample is equal to N, the number of failures that
    occurred before a total of n successes was reached.

See Also
--------
Generator.negative_binomial: which should be used for new code.

Notes
-----
The probability mass function of the negative binomial distribution is

.. math:: P(N;n,p) = \frac{\Gamma(N+n)}{N!\Gamma(n)}p^{n}(1-p)^{N},

where :math:`n` is the number of successes, :math:`p` is the
probability of success, :math:`N+n` is the number of trials, and
:math:`\Gamma` is the gamma function. When :math:`n` is an integer,
:math:`\frac{\Gamma(N+n)}{N!\Gamma(n)} = \binom{N+n-1}{N}`, which is
the more common form of this term in the the pmf. The negative
binomial distribution gives the probability of N failures given n
successes, with a success on the last trial.

If one throws a die repeatedly until the third time a '1' appears,
then the probability distribution of the number of non-'1's that
appear before the third '1' is a negative binomial distribution.

References
----------
.. [1] Weisstein, Eric W. 'Negative Binomial Distribution.' From
       MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/NegativeBinomialDistribution.html
.. [2] Wikipedia, 'Negative binomial distribution',
       https://en.wikipedia.org/wiki/Negative_binomial_distribution

Examples
--------
Draw samples from the distribution:

A real world example. A company drills wild-cat oil
exploration wells, each with an estimated probability of
success of 0.1.  What is the probability of having one success
for each successive well, that is what is the probability of a
single success after drilling 5 wells, after 6 wells, etc.?

>>> s = np.random.negative_binomial(1, 0.1, 100000)
>>> for i in range(1, 11): # doctest: +SKIP
...    probability = sum(s<i) / 100000.
...    print(i, 'wells drilled, probability of one success =', probability)
*)

val noncentral_chisquare : ?size:int list -> df:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> nonc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
noncentral_chisquare(df, nonc, size=None)

Draw samples from a noncentral chi-square distribution.

The noncentral :math:`\chi^2` distribution is a generalization of
the :math:`\chi^2` distribution.

.. note::
    New code should use the ``noncentral_chisquare`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
df : float or array_like of floats
    Degrees of freedom, must be > 0.

    .. versionchanged:: 1.10.0
       Earlier NumPy versions required dfnum > 1.
nonc : float or array_like of floats
    Non-centrality, must be non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``df`` and ``nonc`` are both scalars.
    Otherwise, ``np.broadcast(df, nonc).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized noncentral chi-square distribution.

See Also
--------
Generator.noncentral_chisquare: which should be used for new code.

Notes
-----
The probability density function for the noncentral Chi-square
distribution is

.. math:: P(x;df,nonc) = \sum^{\infty}_{i=0}
                       \frac{e^{-nonc/2}(nonc/2)^{i}}{i!}
                       P_{Y_{df+2i}}(x),

where :math:`Y_{q}` is the Chi-square with q degrees of freedom.

References
----------
.. [1] Wikipedia, 'Noncentral chi-squared distribution'
       https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution

Examples
--------
Draw values from the distribution and plot the histogram

>>> import matplotlib.pyplot as plt
>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
...                   bins=200, density=True)
>>> plt.show()

Draw values from a noncentral chisquare with very small noncentrality,
and compare to a chisquare.

>>> plt.figure()
>>> values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),
...                   bins=np.arange(0., 25, .1), density=True)
>>> values2 = plt.hist(np.random.chisquare(3, 100000),
...                    bins=np.arange(0., 25, .1), density=True)
>>> plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')
>>> plt.show()

Demonstrate how large values of non-centrality lead to a more symmetric
distribution.

>>> plt.figure()
>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
...                   bins=200, density=True)
>>> plt.show()
*)

val noncentral_f : ?size:int list -> dfnum:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> dfden:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> nonc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
noncentral_f(dfnum, dfden, nonc, size=None)

Draw samples from the noncentral F distribution.

Samples are drawn from an F distribution with specified parameters,
`dfnum` (degrees of freedom in numerator) and `dfden` (degrees of
freedom in denominator), where both parameters > 1.
`nonc` is the non-centrality parameter.

.. note::
    New code should use the ``noncentral_f`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
dfnum : float or array_like of floats
    Numerator degrees of freedom, must be > 0.

    .. versionchanged:: 1.14.0
       Earlier NumPy versions required dfnum > 1.
dfden : float or array_like of floats
    Denominator degrees of freedom, must be > 0.
nonc : float or array_like of floats
    Non-centrality parameter, the sum of the squares of the numerator
    means, must be >= 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``dfnum``, ``dfden``, and ``nonc``
    are all scalars.  Otherwise, ``np.broadcast(dfnum, dfden, nonc).size``
    samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized noncentral Fisher distribution.

See Also
--------
Generator.noncentral_f: which should be used for new code.

Notes
-----
When calculating the power of an experiment (power = probability of
rejecting the null hypothesis when a specific alternative is true) the
non-central F statistic becomes important.  When the null hypothesis is
true, the F statistic follows a central F distribution. When the null
hypothesis is not true, then it follows a non-central F statistic.

References
----------
.. [1] Weisstein, Eric W. 'Noncentral F-Distribution.'
       From MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/NoncentralF-Distribution.html
.. [2] Wikipedia, 'Noncentral F-distribution',
       https://en.wikipedia.org/wiki/Noncentral_F-distribution

Examples
--------
In a study, testing for a specific alternative to the null hypothesis
requires use of the Noncentral F distribution. We need to calculate the
area in the tail of the distribution that exceeds the value of the F
distribution for the null hypothesis.  We'll plot the two probability
distributions for comparison.

>>> dfnum = 3 # between group deg of freedom
>>> dfden = 20 # within groups degrees of freedom
>>> nonc = 3.0
>>> nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)
>>> NF = np.histogram(nc_vals, bins=50, density=True)
>>> c_vals = np.random.f(dfnum, dfden, 1000000)
>>> F = np.histogram(c_vals, bins=50, density=True)
>>> import matplotlib.pyplot as plt
>>> plt.plot(F[1][1:], F[0])
>>> plt.plot(NF[1][1:], NF[0])
>>> plt.show()
*)

val normal : ?loc:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
normal(loc=0.0, scale=1.0, size=None)

Draw random samples from a normal (Gaussian) distribution.

The probability density function of the normal distribution, first
derived by De Moivre and 200 years later by both Gauss and Laplace
independently [2]_, is often called the bell curve because of
its characteristic shape (see the example below).

The normal distributions occurs often in nature.  For example, it
describes the commonly occurring distribution of samples influenced
by a large number of tiny, random disturbances, each with its own
unique distribution [2]_.

.. note::
    New code should use the ``normal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
loc : float or array_like of floats
    Mean ('centre') of the distribution.
scale : float or array_like of floats
    Standard deviation (spread or 'width') of the distribution. Must be
    non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``loc`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(loc, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized normal distribution.

See Also
--------
scipy.stats.norm : probability density function, distribution or
    cumulative density function, etc.
Generator.normal: which should be used for new code.

Notes
-----
The probability density for the Gaussian distribution is

.. math:: p(x) = \frac{1}{\sqrt{ 2 \pi \sigma^2 }}
                 e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} },

where :math:`\mu` is the mean and :math:`\sigma` the standard
deviation. The square of the standard deviation, :math:`\sigma^2`,
is called the variance.

The function has its peak at the mean, and its 'spread' increases with
the standard deviation (the function reaches 0.607 times its maximum at
:math:`x + \sigma` and :math:`x - \sigma` [2]_).  This implies that
normal is more likely to return samples lying close to the mean, rather
than those far away.

References
----------
.. [1] Wikipedia, 'Normal distribution',
       https://en.wikipedia.org/wiki/Normal_distribution
.. [2] P. R. Peebles Jr., 'Central Limit Theorem' in 'Probability,
       Random Variables and Random Signal Principles', 4th ed., 2001,
       pp. 51, 51, 125.

Examples
--------
Draw samples from the distribution:

>>> mu, sigma = 0, 0.1 # mean and standard deviation
>>> s = np.random.normal(mu, sigma, 1000)

Verify the mean and the variance:

>>> abs(mu - np.mean(s))
0.0  # may vary

>>> abs(sigma - np.std(s, ddof=1))
0.1  # may vary

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *
...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),
...          linewidth=2, color='r')
>>> plt.show()

Two-by-four array of samples from N(3, 6.25):

>>> np.random.normal(3, 2.5, size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
*)

val pareto : ?size:int list -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
pareto(a, size=None)

Draw samples from a Pareto II or Lomax distribution with
specified shape.

The Lomax or Pareto II distribution is a shifted Pareto
distribution. The classical Pareto distribution can be
obtained from the Lomax distribution by adding 1 and
multiplying by the scale parameter ``m`` (see Notes).  The
smallest value of the Lomax distribution is zero while for the
classical Pareto distribution it is ``mu``, where the standard
Pareto distribution has location ``mu = 1``.  Lomax can also
be considered as a simplified version of the Generalized
Pareto distribution (available in SciPy), with the scale set
to one and the location set to zero.

The Pareto distribution must be greater than zero, and is
unbounded above.  It is also known as the '80-20 rule'.  In
this distribution, 80 percent of the weights are in the lowest
20 percent of the range, while the other 20 percent fill the
remaining 80 percent of the range.

.. note::
    New code should use the ``pareto`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Shape of the distribution. Must be positive.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` is a scalar.  Otherwise,
    ``np.array(a).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Pareto distribution.

See Also
--------
scipy.stats.lomax : probability density function, distribution or
    cumulative density function, etc.
scipy.stats.genpareto : probability density function, distribution or
    cumulative density function, etc.
Generator.pareto: which should be used for new code.

Notes
-----
The probability density for the Pareto distribution is

.. math:: p(x) = \frac{am^a}{x^{a+1}}

where :math:`a` is the shape and :math:`m` the scale.

The Pareto distribution, named after the Italian economist
Vilfredo Pareto, is a power law probability distribution
useful in many real world problems.  Outside the field of
economics it is generally referred to as the Bradford
distribution. Pareto developed the distribution to describe
the distribution of wealth in an economy.  It has also found
use in insurance, web page access statistics, oil field sizes,
and many other problems, including the download frequency for
projects in Sourceforge [1]_.  It is one of the so-called
'fat-tailed' distributions.

References
----------
.. [1] Francis Hunt and Paul Johnson, On the Pareto Distribution of
       Sourceforge projects.
.. [2] Pareto, V. (1896). Course of Political Economy. Lausanne.
.. [3] Reiss, R.D., Thomas, M.(2001), Statistical Analysis of Extreme
       Values, Birkhauser Verlag, Basel, pp 23-30.
.. [4] Wikipedia, 'Pareto distribution',
       https://en.wikipedia.org/wiki/Pareto_distribution

Examples
--------
Draw samples from the distribution:

>>> a, m = 3., 2.  # shape and mode
>>> s = (np.random.pareto(a, 1000) + 1) * m

Display the histogram of the samples, along with the probability
density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, _ = plt.hist(s, 100, density=True)
>>> fit = a*m**a / bins**(a+1)
>>> plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')
>>> plt.show()
*)

val permutation : [`I of int | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
permutation(x)

Randomly permute a sequence, or return a permuted range.

If `x` is a multi-dimensional array, it is only shuffled along its
first index.

.. note::
    New code should use the ``permutation`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
x : int or array_like
    If `x` is an integer, randomly permute ``np.arange(x)``.
    If `x` is an array, make a copy and shuffle the elements
    randomly.

Returns
-------
out : ndarray
    Permuted sequence or array range.

See Also
--------
Generator.permutation: which should be used for new code.

Examples
--------
>>> np.random.permutation(10)
array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random

>>> np.random.permutation([1, 4, 9, 12, 15])
array([15,  1,  9,  4, 12]) # random

>>> arr = np.arange(9).reshape((3, 3))
>>> np.random.permutation(arr)
array([[6, 7, 8], # random
       [0, 1, 2],
       [3, 4, 5]])
*)

val poisson : ?lam:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
poisson(lam=1.0, size=None)

Draw samples from a Poisson distribution.

The Poisson distribution is the limit of the binomial distribution
for large N.

.. note::
    New code should use the ``poisson`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
lam : float or array_like of floats
    Expectation of interval, must be >= 0. A sequence of expectation
    intervals must be broadcastable over the requested size.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``lam`` is a scalar. Otherwise,
    ``np.array(lam).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Poisson distribution.

See Also
--------
Generator.poisson: which should be used for new code.

Notes
-----
The Poisson distribution

.. math:: f(k; \lambda)=\frac{\lambda^k e^{-\lambda}}{k!}

For events with an expected separation :math:`\lambda` the Poisson
distribution :math:`f(k; \lambda)` describes the probability of
:math:`k` events occurring within the observed
interval :math:`\lambda`.

Because the output is limited to the range of the C int64 type, a
ValueError is raised when `lam` is within 10 sigma of the maximum
representable value.

References
----------
.. [1] Weisstein, Eric W. 'Poisson Distribution.'
       From MathWorld--A Wolfram Web Resource.
       http://mathworld.wolfram.com/PoissonDistribution.html
.. [2] Wikipedia, 'Poisson distribution',
       https://en.wikipedia.org/wiki/Poisson_distribution

Examples
--------
Draw samples from the distribution:

>>> import numpy as np
>>> s = np.random.poisson(5, 10000)

Display histogram of the sample:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 14, density=True)
>>> plt.show()

Draw each 100 values for lambda 100 and 500:

>>> s = np.random.poisson(lam=(100., 500.), size=(100, 2))
*)

val power : ?size:int list -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
power(a, size=None)

Draws samples in [0, 1] from a power distribution with positive
exponent a - 1.

Also known as the power function distribution.

.. note::
    New code should use the ``power`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Parameter of the distribution. Must be non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` is a scalar.  Otherwise,
    ``np.array(a).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized power distribution.

Raises
------
ValueError
    If a < 1.

See Also
--------
Generator.power: which should be used for new code.

Notes
-----
The probability density function is

.. math:: P(x; a) = ax^{a-1}, 0 \le x \le 1, a>0.

The power function distribution is just the inverse of the Pareto
distribution. It may also be seen as a special case of the Beta
distribution.

It is used, for example, in modeling the over-reporting of insurance
claims.

References
----------
.. [1] Christian Kleiber, Samuel Kotz, 'Statistical size distributions
       in economics and actuarial sciences', Wiley, 2003.
.. [2] Heckert, N. A. and Filliben, James J. 'NIST Handbook 148:
       Dataplot Reference Manual, Volume 2: Let Subcommands and Library
       Functions', National Institute of Standards and Technology
       Handbook Series, June 2003.
       https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf

Examples
--------
Draw samples from the distribution:

>>> a = 5. # shape
>>> samples = 1000
>>> s = np.random.power(a, samples)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, bins=30)
>>> x = np.linspace(0, 1, 100)
>>> y = a*x**(a-1.)
>>> normed_y = samples*np.diff(bins)[0]*y
>>> plt.plot(x, normed_y)
>>> plt.show()

Compare the power function distribution to the inverse of the Pareto.

>>> from scipy import stats # doctest: +SKIP
>>> rvs = np.random.power(5, 1000000)
>>> rvsp = np.random.pareto(5, 1000000)
>>> xx = np.linspace(0,1,100)
>>> powpdf = stats.powerlaw.pdf(xx,5)  # doctest: +SKIP

>>> plt.figure()
>>> plt.hist(rvs, bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  # doctest: +SKIP
>>> plt.title('np.random.power(5)')

>>> plt.figure()
>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  # doctest: +SKIP
>>> plt.title('inverse of 1 + np.random.pareto(5)')

>>> plt.figure()
>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  # doctest: +SKIP
>>> plt.title('inverse of stats.pareto(5)')
*)

val rand : Py.Object.t -> Py.Object.t
(**
rand(d0, d1, ..., dn)

Random values in a given shape.

.. note::
    This is a convenience function for users porting code from Matlab,
    and wraps `random_sample`. That function takes a
    tuple to specify the size of the output, which is consistent with
    other NumPy functions like `numpy.zeros` and `numpy.ones`.

Create an array of the given shape and populate it with
random samples from a uniform distribution
over ``[0, 1)``.

Parameters
----------
d0, d1, ..., dn : int, optional
    The dimensions of the returned array, must be non-negative.
    If no argument is given a single Python float is returned.

Returns
-------
out : ndarray, shape ``(d0, d1, ..., dn)``
    Random values.

See Also
--------
random

Examples
--------
>>> np.random.rand(3,2)
array([[ 0.14022471,  0.96360618],  #random
       [ 0.37601032,  0.25528411],  #random
       [ 0.49313049,  0.94909878]]) #random
*)

val randint : ?high:[`I of int | `Array_like_of_ints of Py.Object.t] -> ?size:int list -> ?dtype:Dtype.t -> low:[`I of int | `Array_like_of_ints of Py.Object.t] -> unit -> Py.Object.t
(**
randint(low, high=None, size=None, dtype=int)

Return random integers from `low` (inclusive) to `high` (exclusive).

Return random integers from the 'discrete uniform' distribution of
the specified dtype in the 'half-open' interval [`low`, `high`). If
`high` is None (the default), then results are from [0, `low`).

.. note::
    New code should use the ``integers`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
low : int or array-like of ints
    Lowest (signed) integers to be drawn from the distribution (unless
    ``high=None``, in which case this parameter is one above the
    *highest* such integer).
high : int or array-like of ints, optional
    If provided, one above the largest (signed) integer to be drawn
    from the distribution (see above for behavior if ``high=None``).
    If array-like, must contain integer values
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.
dtype : dtype, optional
    Desired dtype of the result. Byteorder must be native.
    The default value is int.

    .. versionadded:: 1.11.0

Returns
-------
out : int or ndarray of ints
    `size`-shaped array of random integers from the appropriate
    distribution, or a single such random int if `size` not provided.

See Also
--------
random_integers : similar to `randint`, only for the closed
    interval [`low`, `high`], and 1 is the lowest value if `high` is
    omitted.
Generator.integers: which should be used for new code.

Examples
--------
>>> np.random.randint(2, size=10)
array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random
>>> np.random.randint(1, size=10)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])

Generate a 2 x 4 array of ints between 0 and 4, inclusive:

>>> np.random.randint(5, size=(2, 4))
array([[4, 0, 2, 1], # random
       [3, 2, 2, 0]])

Generate a 1 x 3 array with 3 different upper bounds

>>> np.random.randint(1, [3, 5, 10])
array([2, 2, 9]) # random

Generate a 1 by 3 array with 3 different lower bounds

>>> np.random.randint([1, 5, 7], 10)
array([9, 8, 7]) # random

Generate a 2 by 4 array using broadcasting with dtype of uint8

>>> np.random.randint([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)
array([[ 8,  6,  9,  7], # random
       [ 1, 16,  9, 12]], dtype=uint8)
*)

val randn : int list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
randn(d0, d1, ..., dn)

Return a sample (or samples) from the 'standard normal' distribution.

.. note::
    This is a convenience function for users porting code from Matlab,
    and wraps `standard_normal`. That function takes a
    tuple to specify the size of the output, which is consistent with
    other NumPy functions like `numpy.zeros` and `numpy.ones`.

.. note::
    New code should use the ``standard_normal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

If positive int_like arguments are provided, `randn` generates an array
of shape ``(d0, d1, ..., dn)``, filled
with random floats sampled from a univariate 'normal' (Gaussian)
distribution of mean 0 and variance 1. A single float randomly sampled
from the distribution is returned if no argument is provided.

Parameters
----------
d0, d1, ..., dn : int, optional
    The dimensions of the returned array, must be non-negative.
    If no argument is given a single Python float is returned.

Returns
-------
Z : ndarray or float
    A ``(d0, d1, ..., dn)``-shaped array of floating-point samples from
    the standard normal distribution, or a single such float if
    no parameters were supplied.

See Also
--------
standard_normal : Similar, but takes a tuple as its argument.
normal : Also accepts mu and sigma arguments.
Generator.standard_normal: which should be used for new code.

Notes
-----
For random samples from :math:`N(\mu, \sigma^2)`, use:

``sigma * np.random.randn(...) + mu``

Examples
--------
>>> np.random.randn()
2.1923875335537315  # random

Two-by-four array of samples from N(3, 6.25):

>>> 3 + 2.5 * np.random.randn(2, 4)
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
*)

val random : ?size:int list -> unit -> Py.Object.t
(**
random(size=None)

Return random floats in the half-open interval [0.0, 1.0). Alias for
`random_sample` to ease forward-porting to the new random API.
*)

val random_integers : ?high:int -> ?size:int list -> low:int -> unit -> Py.Object.t
(**
random_integers(low, high=None, size=None)

Random integers of type `np.int_` between `low` and `high`, inclusive.

Return random integers of type `np.int_` from the 'discrete uniform'
distribution in the closed interval [`low`, `high`].  If `high` is
None (the default), then results are from [1, `low`]. The `np.int_`
type translates to the C long integer type and its precision
is platform dependent.

This function has been deprecated. Use randint instead.

.. deprecated:: 1.11.0

Parameters
----------
low : int
    Lowest (signed) integer to be drawn from the distribution (unless
    ``high=None``, in which case this parameter is the *highest* such
    integer).
high : int, optional
    If provided, the largest (signed) integer to be drawn from the
    distribution (see above for behavior if ``high=None``).
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : int or ndarray of ints
    `size`-shaped array of random integers from the appropriate
    distribution, or a single such random int if `size` not provided.

See Also
--------
randint : Similar to `random_integers`, only for the half-open
    interval [`low`, `high`), and 0 is the lowest value if `high` is
    omitted.

Notes
-----
To sample from N evenly spaced floating-point numbers between a and b,
use::

  a + (b - a) * (np.random.random_integers(N) - 1) / (N - 1.)

Examples
--------
>>> np.random.random_integers(5)
4 # random
>>> type(np.random.random_integers(5))
<class 'numpy.int64'>
>>> np.random.random_integers(5, size=(3,2))
array([[5, 4], # random
       [3, 3],
       [4, 5]])

Choose five random numbers from the set of five evenly-spaced
numbers between 0 and 2.5, inclusive ( *i.e.*, from the set
:math:`{0, 5/8, 10/8, 15/8, 20/8}`):

>>> 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.
array([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ]) # random

Roll two six sided dice 1000 times and sum the results:

>>> d1 = np.random.random_integers(1, 6, 1000)
>>> d2 = np.random.random_integers(1, 6, 1000)
>>> dsums = d1 + d2

Display results as a histogram:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(dsums, 11, density=True)
>>> plt.show()
*)

val random_sample : ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
random_sample(size=None)

Return random floats in the half-open interval [0.0, 1.0).

Results are from the 'continuous uniform' distribution over the
stated interval.  To sample :math:`Unif[a, b), b > a` multiply
the output of `random_sample` by `(b-a)` and add `a`::

  (b - a) * random_sample() + a

.. note::
    New code should use the ``random`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray of floats
    Array of random floats of shape `size` (unless ``size=None``, in which
    case a single float is returned).

See Also
--------
Generator.random: which should be used for new code.

Examples
--------
>>> np.random.random_sample()
0.47108547995356098 # random
>>> type(np.random.random_sample())
<class 'float'>
>>> np.random.random_sample((5,))
array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random

Three-by-two array of random numbers from [-5, 0):

>>> 5 * np.random.random_sample((3, 2)) - 5
array([[-3.99149989, -0.52338984], # random
       [-2.99091858, -0.79479508],
       [-1.23204345, -1.75224494]])
*)

val rayleigh : ?scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
rayleigh(scale=1.0, size=None)

Draw samples from a Rayleigh distribution.

The :math:`\chi` and Weibull distributions are generalizations of the
Rayleigh.

.. note::
    New code should use the ``rayleigh`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
scale : float or array_like of floats, optional
    Scale, also equals the mode. Must be non-negative. Default is 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``scale`` is a scalar.  Otherwise,
    ``np.array(scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Rayleigh distribution.

See Also
--------
Generator.rayleigh: which should be used for new code.

Notes
-----
The probability density function for the Rayleigh distribution is

.. math:: P(x;scale) = \frac{x}{scale^2}e^{\frac{-x^2}{2 \cdotp scale^2}}

The Rayleigh distribution would arise, for example, if the East
and North components of the wind velocity had identical zero-mean
Gaussian distributions.  Then the wind speed would have a Rayleigh
distribution.

References
----------
.. [1] Brighton Webs Ltd., 'Rayleigh Distribution,'
       https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp
.. [2] Wikipedia, 'Rayleigh distribution'
       https://en.wikipedia.org/wiki/Rayleigh_distribution

Examples
--------
Draw values from the distribution and plot the histogram

>>> from matplotlib.pyplot import hist
>>> values = hist(np.random.rayleigh(3, 100000), bins=200, density=True)

Wave heights tend to follow a Rayleigh distribution. If the mean wave
height is 1 meter, what fraction of waves are likely to be larger than 3
meters?

>>> meanvalue = 1
>>> modevalue = np.sqrt(2 / np.pi) * meanvalue
>>> s = np.random.rayleigh(modevalue, 1000000)

The percentage of waves larger than 3 meters is:

>>> 100.*sum(s>3)/1000000.
0.087300000000000003 # random
*)

val seed : int -> unit
(**
seed(self, seed=None)

Reseed a legacy MT19937 BitGenerator

Notes
-----
This is a convenience, legacy function.

The best practice is to **not** reseed a BitGenerator, rather to
recreate a new one. This method is here for legacy reasons.
This example demonstrates best practice.

>>> from numpy.random import MT19937
>>> from numpy.random import RandomState, SeedSequence
>>> rs = RandomState(MT19937(SeedSequence(123456789)))
# Later, you want to restart the stream
>>> rs = RandomState(MT19937(SeedSequence(987654321)))
*)

val set_state : Py.Object.t -> Py.Object.t
(**
set_state(state)

Set the internal state of the generator from a tuple.

For use if one has reason to manually (re-)set the internal state of
the bit generator used by the RandomState instance. By default,
RandomState uses the 'Mersenne Twister'[1]_ pseudo-random number
generating algorithm.

Parameters
----------
state : {tuple(str, ndarray of 624 uints, int, int, float), dict}
    The `state` tuple has the following items:

    1. the string 'MT19937', specifying the Mersenne Twister algorithm.
    2. a 1-D array of 624 unsigned integers ``keys``.
    3. an integer ``pos``.
    4. an integer ``has_gauss``.
    5. a float ``cached_gaussian``.

    If state is a dictionary, it is directly set using the BitGenerators
    `state` property.

Returns
-------
out : None
    Returns 'None' on success.

See Also
--------
get_state

Notes
-----
`set_state` and `get_state` are not needed to work with any of the
random distributions in NumPy. If the internal state is manually altered,
the user should know exactly what he/she is doing.

For backwards compatibility, the form (str, array of 624 uints, int) is
also accepted although it is missing some information about the cached
Gaussian value: ``state = ('MT19937', keys, pos)``.

References
----------
.. [1] M. Matsumoto and T. Nishimura, 'Mersenne Twister: A
   623-dimensionally equidistributed uniform pseudorandom number
   generator,' *ACM Trans. on Modeling and Computer Simulation*,
   Vol. 8, No. 1, pp. 3-30, Jan. 1998.
*)

val shuffle : [>`Ndarray] Obj.t -> Py.Object.t
(**
shuffle(x)

Modify a sequence in-place by shuffling its contents.

This function only shuffles the array along the first axis of a
multi-dimensional array. The order of sub-arrays is changed but
their contents remains the same.

.. note::
    New code should use the ``shuffle`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
x : array_like
    The array or list to be shuffled.

Returns
-------
None

See Also
--------
Generator.shuffle: which should be used for new code.

Examples
--------
>>> arr = np.arange(10)
>>> np.random.shuffle(arr)
>>> arr
[1 7 5 2 9 4 3 6 0 8] # random

Multi-dimensional arrays are only shuffled along the first axis:

>>> arr = np.arange(9).reshape((3, 3))
>>> np.random.shuffle(arr)
>>> arr
array([[3, 4, 5], # random
       [6, 7, 8],
       [0, 1, 2]])
*)

val standard_cauchy : ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
standard_cauchy(size=None)

Draw samples from a standard Cauchy distribution with mode = 0.

Also known as the Lorentz distribution.

.. note::
    New code should use the ``standard_cauchy`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
samples : ndarray or scalar
    The drawn samples.

See Also
--------
Generator.standard_cauchy: which should be used for new code.

Notes
-----
The probability density function for the full Cauchy distribution is

.. math:: P(x; x_0, \gamma) = \frac{1}{\pi \gamma \bigl[ 1+
          (\frac{x-x_0}{\gamma})^2 \bigr] }

and the Standard Cauchy distribution just sets :math:`x_0=0` and
:math:`\gamma=1`

The Cauchy distribution arises in the solution to the driven harmonic
oscillator problem, and also describes spectral line broadening. It
also describes the distribution of values at which a line tilted at
a random angle will cut the x axis.

When studying hypothesis tests that assume normality, seeing how the
tests perform on data from a Cauchy distribution is a good indicator of
their sensitivity to a heavy-tailed distribution, since the Cauchy looks
very much like a Gaussian distribution, but with heavier tails.

References
----------
.. [1] NIST/SEMATECH e-Handbook of Statistical Methods, 'Cauchy
      Distribution',
      https://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm
.. [2] Weisstein, Eric W. 'Cauchy Distribution.' From MathWorld--A
      Wolfram Web Resource.
      http://mathworld.wolfram.com/CauchyDistribution.html
.. [3] Wikipedia, 'Cauchy distribution'
      https://en.wikipedia.org/wiki/Cauchy_distribution

Examples
--------
Draw samples and plot the distribution:

>>> import matplotlib.pyplot as plt
>>> s = np.random.standard_cauchy(1000000)
>>> s = s[(s>-25) & (s<25)]  # truncate distribution so it plots well
>>> plt.hist(s, bins=100)
>>> plt.show()
*)

val standard_exponential : ?size:int list -> unit -> Py.Object.t
(**
standard_exponential(size=None)

Draw samples from the standard exponential distribution.

`standard_exponential` is identical to the exponential distribution
with a scale parameter of 1.

.. note::
    New code should use the ``standard_exponential`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray
    Drawn samples.

See Also
--------
Generator.standard_exponential: which should be used for new code.

Examples
--------
Output a 3x8000 array:

>>> n = np.random.standard_exponential((3, 8000))
*)

val standard_gamma : ?size:int list -> int list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
standard_gamma(shape, size=None)

Draw samples from a standard Gamma distribution.

Samples are drawn from a Gamma distribution with specified parameters,
shape (sometimes designated 'k') and scale=1.

.. note::
    New code should use the ``standard_gamma`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
shape : float or array_like of floats
    Parameter, must be non-negative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``shape`` is a scalar.  Otherwise,
    ``np.array(shape).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized standard gamma distribution.

See Also
--------
scipy.stats.gamma : probability density function, distribution or
    cumulative density function, etc.
Generator.standard_gamma: which should be used for new code.

Notes
-----
The probability density for the Gamma distribution is

.. math:: p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)},

where :math:`k` is the shape and :math:`\theta` the scale,
and :math:`\Gamma` is the Gamma function.

The Gamma distribution is often used to model the times to failure of
electronic components, and arises naturally in processes for which the
waiting times between Poisson distributed events are relevant.

References
----------
.. [1] Weisstein, Eric W. 'Gamma Distribution.' From MathWorld--A
       Wolfram Web Resource.
       http://mathworld.wolfram.com/GammaDistribution.html
.. [2] Wikipedia, 'Gamma distribution',
       https://en.wikipedia.org/wiki/Gamma_distribution

Examples
--------
Draw samples from the distribution:

>>> shape, scale = 2., 1. # mean and width
>>> s = np.random.standard_gamma(shape, 1000000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> import scipy.special as sps  # doctest: +SKIP
>>> count, bins, ignored = plt.hist(s, 50, density=True)
>>> y = bins**(shape-1) * ((np.exp(-bins/scale))/  # doctest: +SKIP
...                       (sps.gamma(shape) * scale**shape))
>>> plt.plot(bins, y, linewidth=2, color='r')  # doctest: +SKIP
>>> plt.show()
*)

val standard_normal : ?size:int list -> unit -> Py.Object.t
(**
standard_normal(size=None)

Draw samples from a standard Normal distribution (mean=0, stdev=1).

.. note::
    New code should use the ``standard_normal`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  Default is None, in which case a
    single value is returned.

Returns
-------
out : float or ndarray
    A floating-point array of shape ``size`` of drawn samples, or a
    single sample if ``size`` was not specified.

See Also
--------
normal :
    Equivalent function with additional ``loc`` and ``scale`` arguments
    for setting the mean and standard deviation.
Generator.standard_normal: which should be used for new code.

Notes
-----
For random samples from :math:`N(\mu, \sigma^2)`, use one of::

    mu + sigma * np.random.standard_normal(size=...)
    np.random.normal(mu, sigma, size=...)

Examples
--------
>>> np.random.standard_normal()
2.1923875335537315 #random

>>> s = np.random.standard_normal(8000)
>>> s
array([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random
       -0.38672696, -0.4685006 ])                                # random
>>> s.shape
(8000,)
>>> s = np.random.standard_normal(size=(3, 4, 2))
>>> s.shape
(3, 4, 2)

Two-by-four array of samples from :math:`N(3, 6.25)`:

>>> 3 + 2.5 * np.random.standard_normal(size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
*)

val standard_t : ?size:int list -> df:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
standard_t(df, size=None)

Draw samples from a standard Student's t distribution with `df` degrees
of freedom.

A special case of the hyperbolic distribution.  As `df` gets
large, the result resembles that of the standard normal
distribution (`standard_normal`).

.. note::
    New code should use the ``standard_t`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
df : float or array_like of floats
    Degrees of freedom, must be > 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``df`` is a scalar.  Otherwise,
    ``np.array(df).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized standard Student's t distribution.

See Also
--------
Generator.standard_t: which should be used for new code.

Notes
-----
The probability density function for the t distribution is

.. math:: P(x, df) = \frac{\Gamma(\frac{df+1}{2})}{\sqrt{\pi df}
          \Gamma(\frac{df}{2})}\Bigl( 1+\frac{x^2}{df} \Bigr)^{-(df+1)/2}

The t test is based on an assumption that the data come from a
Normal distribution. The t test provides a way to test whether
the sample mean (that is the mean calculated from the data) is
a good estimate of the true mean.

The derivation of the t-distribution was first published in
1908 by William Gosset while working for the Guinness Brewery
in Dublin. Due to proprietary issues, he had to publish under
a pseudonym, and so he used the name Student.

References
----------
.. [1] Dalgaard, Peter, 'Introductory Statistics With R',
       Springer, 2002.
.. [2] Wikipedia, 'Student's t-distribution'
       https://en.wikipedia.org/wiki/Student's_t-distribution

Examples
--------
From Dalgaard page 83 [1]_, suppose the daily energy intake for 11
women in kilojoules (kJ) is:

>>> intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \
...                    7515, 8230, 8770])

Does their energy intake deviate systematically from the recommended
value of 7725 kJ?

We have 10 degrees of freedom, so is the sample mean within 95% of the
recommended value?

>>> s = np.random.standard_t(10, size=100000)
>>> np.mean(intake)
6753.636363636364
>>> intake.std(ddof=1)
1142.1232221373727

Calculate the t statistic, setting the ddof parameter to the unbiased
value so the divisor in the standard deviation will be degrees of
freedom, N-1.

>>> t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))
>>> import matplotlib.pyplot as plt
>>> h = plt.hist(s, bins=100, density=True)

For a one-sided t-test, how far out in the distribution does the t
statistic appear?

>>> np.sum(s<t) / float(len(s))
0.0090699999999999999  #random

So the p-value is about 0.009, which says the null hypothesis has a
probability of about 99% of being true.
*)

val triangular : ?size:int list -> left:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> mode:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> right:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
triangular(left, mode, right, size=None)

Draw samples from the triangular distribution over the
interval ``[left, right]``.

The triangular distribution is a continuous probability
distribution with lower limit left, peak at mode, and upper
limit right. Unlike the other distributions, these parameters
directly define the shape of the pdf.

.. note::
    New code should use the ``triangular`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
left : float or array_like of floats
    Lower limit.
mode : float or array_like of floats
    The value where the peak of the distribution occurs.
    The value must fulfill the condition ``left <= mode <= right``.
right : float or array_like of floats
    Upper limit, must be larger than `left`.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``left``, ``mode``, and ``right``
    are all scalars.  Otherwise, ``np.broadcast(left, mode, right).size``
    samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized triangular distribution.

See Also
--------
Generator.triangular: which should be used for new code.

Notes
-----
The probability density function for the triangular distribution is

.. math:: P(x;l, m, r) = \begin{cases}
          \frac{2(x-l)}{(r-l)(m-l)}& \text{for $l \leq x \leq m$},\\
          \frac{2(r-x)}{(r-l)(r-m)}& \text{for $m \leq x \leq r$},\\
          0& \text{otherwise}.
          \end{cases}

The triangular distribution is often used in ill-defined
problems where the underlying distribution is not known, but
some knowledge of the limits and mode exists. Often it is used
in simulations.

References
----------
.. [1] Wikipedia, 'Triangular distribution'
       https://en.wikipedia.org/wiki/Triangular_distribution

Examples
--------
Draw values from the distribution and plot the histogram:

>>> import matplotlib.pyplot as plt
>>> h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,
...              density=True)
>>> plt.show()
*)

val uniform : ?low:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?high:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> ?size:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
uniform(low=0.0, high=1.0, size=None)

Draw samples from a uniform distribution.

Samples are uniformly distributed over the half-open interval
``[low, high)`` (includes low, but excludes high).  In other words,
any value within the given interval is equally likely to be drawn
by `uniform`.

.. note::
    New code should use the ``uniform`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
low : float or array_like of floats, optional
    Lower boundary of the output interval.  All values generated will be
    greater than or equal to low.  The default value is 0.
high : float or array_like of floats
    Upper boundary of the output interval.  All values generated will be
    less than high.  The default value is 1.0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``low`` and ``high`` are both scalars.
    Otherwise, ``np.broadcast(low, high).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized uniform distribution.

See Also
--------
randint : Discrete uniform distribution, yielding integers.
random_integers : Discrete uniform distribution over the closed
                  interval ``[low, high]``.
random_sample : Floats uniformly distributed over ``[0, 1)``.
random : Alias for `random_sample`.
rand : Convenience function that accepts dimensions as input, e.g.,
       ``rand(2,2)`` would generate a 2-by-2 array of floats,
       uniformly distributed over ``[0, 1)``.
Generator.uniform: which should be used for new code.

Notes
-----
The probability density function of the uniform distribution is

.. math:: p(x) = \frac{1}{b - a}

anywhere within the interval ``[a, b)``, and zero elsewhere.

When ``high`` == ``low``, values of ``low`` will be returned.
If ``high`` < ``low``, the results are officially undefined
and may eventually raise an error, i.e. do not rely on this
function to behave when passed arguments satisfying that
inequality condition.

Examples
--------
Draw samples from the distribution:

>>> s = np.random.uniform(-1,0,1000)

All values are within the given interval:

>>> np.all(s >= -1)
True
>>> np.all(s < 0)
True

Display the histogram of the samples, along with the
probability density function:

>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 15, density=True)
>>> plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')
>>> plt.show()
*)

val vonmises : ?size:int list -> mu:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> kappa:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
vonmises(mu, kappa, size=None)

Draw samples from a von Mises distribution.

Samples are drawn from a von Mises distribution with specified mode
(mu) and dispersion (kappa), on the interval [-pi, pi].

The von Mises distribution (also known as the circular normal
distribution) is a continuous probability distribution on the unit
circle.  It may be thought of as the circular analogue of the normal
distribution.

.. note::
    New code should use the ``vonmises`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
mu : float or array_like of floats
    Mode ('center') of the distribution.
kappa : float or array_like of floats
    Dispersion of the distribution, has to be >=0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``mu`` and ``kappa`` are both scalars.
    Otherwise, ``np.broadcast(mu, kappa).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized von Mises distribution.

See Also
--------
scipy.stats.vonmises : probability density function, distribution, or
    cumulative density function, etc.
Generator.vonmises: which should be used for new code.

Notes
-----
The probability density for the von Mises distribution is

.. math:: p(x) = \frac{e^{\kappa cos(x-\mu)}}{2\pi I_0(\kappa)},

where :math:`\mu` is the mode and :math:`\kappa` the dispersion,
and :math:`I_0(\kappa)` is the modified Bessel function of order 0.

The von Mises is named for Richard Edler von Mises, who was born in
Austria-Hungary, in what is now the Ukraine.  He fled to the United
States in 1939 and became a professor at Harvard.  He worked in
probability theory, aerodynamics, fluid mechanics, and philosophy of
science.

References
----------
.. [1] Abramowitz, M. and Stegun, I. A. (Eds.). 'Handbook of
       Mathematical Functions with Formulas, Graphs, and Mathematical
       Tables, 9th printing,' New York: Dover, 1972.
.. [2] von Mises, R., 'Mathematical Theory of Probability
       and Statistics', New York: Academic Press, 1964.

Examples
--------
Draw samples from the distribution:

>>> mu, kappa = 0.0, 4.0 # mean and dispersion
>>> s = np.random.vonmises(mu, kappa, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> from scipy.special import i0  # doctest: +SKIP
>>> plt.hist(s, 50, density=True)
>>> x = np.linspace(-np.pi, np.pi, num=51)
>>> y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  # doctest: +SKIP
>>> plt.plot(x, y, linewidth=2, color='r')  # doctest: +SKIP
>>> plt.show()
*)

val wald : ?size:int list -> mean:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> scale:[`F of float | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
wald(mean, scale, size=None)

Draw samples from a Wald, or inverse Gaussian, distribution.

As the scale approaches infinity, the distribution becomes more like a
Gaussian. Some references claim that the Wald is an inverse Gaussian
with mean equal to 1, but this is by no means universal.

The inverse Gaussian distribution was first studied in relationship to
Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian
because there is an inverse relationship between the time to cover a
unit distance and distance covered in unit time.

.. note::
    New code should use the ``wald`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
mean : float or array_like of floats
    Distribution mean, must be > 0.
scale : float or array_like of floats
    Scale parameter, must be > 0.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``mean`` and ``scale`` are both scalars.
    Otherwise, ``np.broadcast(mean, scale).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Wald distribution.

See Also
--------
Generator.wald: which should be used for new code.

Notes
-----
The probability density function for the Wald distribution is

.. math:: P(x;mean,scale) = \sqrt{\frac{scale}{2\pi x^3}}e^
                            \frac{-scale(x-mean)^2}{2\cdotp mean^2x}

As noted above the inverse Gaussian distribution first arise
from attempts to model Brownian motion. It is also a
competitor to the Weibull for use in reliability modeling and
modeling stock returns and interest rate processes.

References
----------
.. [1] Brighton Webs Ltd., Wald Distribution,
       https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp
.. [2] Chhikara, Raj S., and Folks, J. Leroy, 'The Inverse Gaussian
       Distribution: Theory : Methodology, and Applications', CRC Press,
       1988.
.. [3] Wikipedia, 'Inverse Gaussian distribution'
       https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution

Examples
--------
Draw values from the distribution and plot the histogram:

>>> import matplotlib.pyplot as plt
>>> h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True)
>>> plt.show()
*)

val weibull : ?size:int list -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
weibull(a, size=None)

Draw samples from a Weibull distribution.

Draw samples from a 1-parameter Weibull distribution with the given
shape parameter `a`.

.. math:: X = (-ln(U))^{1/a}

Here, U is drawn from the uniform distribution over (0,1].

The more common 2-parameter Weibull, including a scale parameter
:math:`\lambda` is just :math:`X = \lambda(-ln(U))^{1/a}`.

.. note::
    New code should use the ``weibull`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Shape parameter of the distribution.  Must be nonnegative.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` is a scalar.  Otherwise,
    ``np.array(a).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Weibull distribution.

See Also
--------
scipy.stats.weibull_max
scipy.stats.weibull_min
scipy.stats.genextreme
gumbel
Generator.weibull: which should be used for new code.

Notes
-----
The Weibull (or Type III asymptotic extreme value distribution
for smallest values, SEV Type III, or Rosin-Rammler
distribution) is one of a class of Generalized Extreme Value
(GEV) distributions used in modeling extreme value problems.
This class includes the Gumbel and Frechet distributions.

The probability density for the Weibull distribution is

.. math:: p(x) = \frac{a}
                 {\lambda}(\frac{x}{\lambda})^{a-1}e^{-(x/\lambda)^a},

where :math:`a` is the shape and :math:`\lambda` the scale.

The function has its peak (the mode) at
:math:`\lambda(\frac{a-1}{a})^{1/a}`.

When ``a = 1``, the Weibull distribution reduces to the exponential
distribution.

References
----------
.. [1] Waloddi Weibull, Royal Technical University, Stockholm,
       1939 'A Statistical Theory Of The Strength Of Materials',
       Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939,
       Generalstabens Litografiska Anstalts Forlag, Stockholm.
.. [2] Waloddi Weibull, 'A Statistical Distribution Function of
       Wide Applicability', Journal Of Applied Mechanics ASME Paper
       1951.
.. [3] Wikipedia, 'Weibull distribution',
       https://en.wikipedia.org/wiki/Weibull_distribution

Examples
--------
Draw samples from the distribution:

>>> a = 5. # shape
>>> s = np.random.weibull(a, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> x = np.arange(1,100.)/50.
>>> def weib(x,n,a):
...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)

>>> count, bins, ignored = plt.hist(np.random.weibull(5.,1000))
>>> x = np.arange(1,100.)/50.
>>> scale = count.max()/weib(x, 1., 5.).max()
>>> plt.plot(x, weib(x, 1., 5.)*scale)
>>> plt.show()
*)

val zipf : ?size:int list -> [`F of float | `Ndarray of [>`Ndarray] Obj.t] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
zipf(a, size=None)

Draw samples from a Zipf distribution.

Samples are drawn from a Zipf distribution with specified parameter
`a` > 1.

The Zipf distribution (also known as the zeta distribution) is a
continuous probability distribution that satisfies Zipf's law: the
frequency of an item is inversely proportional to its rank in a
frequency table.

.. note::
    New code should use the ``zipf`` method of a ``default_rng()``
    instance instead; see `random-quick-start`.

Parameters
----------
a : float or array_like of floats
    Distribution parameter. Must be greater than 1.
size : int or tuple of ints, optional
    Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
    ``m * n * k`` samples are drawn.  If size is ``None`` (default),
    a single value is returned if ``a`` is a scalar. Otherwise,
    ``np.array(a).size`` samples are drawn.

Returns
-------
out : ndarray or scalar
    Drawn samples from the parameterized Zipf distribution.

See Also
--------
scipy.stats.zipf : probability density function, distribution, or
    cumulative density function, etc.
Generator.zipf: which should be used for new code.

Notes
-----
The probability density for the Zipf distribution is

.. math:: p(x) = \frac{x^{-a}}{\zeta(a)},

where :math:`\zeta` is the Riemann Zeta function.

It is named for the American linguist George Kingsley Zipf, who noted
that the frequency of any word in a sample of a language is inversely
proportional to its rank in the frequency table.

References
----------
.. [1] Zipf, G. K., 'Selected Studies of the Principle of Relative
       Frequency in Language,' Cambridge, MA: Harvard Univ. Press,
       1932.

Examples
--------
Draw samples from the distribution:

>>> a = 2. # parameter
>>> s = np.random.zipf(a, 1000)

Display the histogram of the samples, along with
the probability density function:

>>> import matplotlib.pyplot as plt
>>> from scipy import special  # doctest: +SKIP

Truncate s values at 50 so plot is interesting:

>>> count, bins, ignored = plt.hist(s[s<50], 50, density=True)
>>> x = np.arange(1., 50.)
>>> y = x**(-a) / special.zetac(a)  # doctest: +SKIP
>>> plt.plot(x, y/max(y), linewidth=2, color='r')  # doctest: +SKIP
>>> plt.show()
*)


end

module Version : sig
(** Get an attribute of this module as a Py.Object.t.
                   This is useful to pass a Python function to another function. *)
val get_py : string -> Py.Object.t


end

val abs : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Calculate the absolute value element-wise.

``np.abs`` is a shorthand for this function.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
absolute : ndarray
    An ndarray containing the absolute value of
    each element in `x`.  For complex input, ``a + ib``, the
    absolute value is :math:`\sqrt{ a^2 + b^2 }`.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> x = np.array([-1.2, 1.2])
>>> np.absolute(x)
array([ 1.2,  1.2])
>>> np.absolute(1.2 + 1j)
1.5620499351813308

Plot the function over ``[-10, 10]``:

>>> import matplotlib.pyplot as plt

>>> x = np.linspace(start=-10, stop=10, num=101)
>>> plt.plot(x, np.absolute(x))
>>> plt.show()

Plot the function over the complex plane:

>>> xx = x + 1j * x[:, np.newaxis]
>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
>>> plt.show()
*)

val absolute : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Calculate the absolute value element-wise.

``np.abs`` is a shorthand for this function.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
absolute : ndarray
    An ndarray containing the absolute value of
    each element in `x`.  For complex input, ``a + ib``, the
    absolute value is :math:`\sqrt{ a^2 + b^2 }`.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> x = np.array([-1.2, 1.2])
>>> np.absolute(x)
array([ 1.2,  1.2])
>>> np.absolute(1.2 + 1j)
1.5620499351813308

Plot the function over ``[-10, 10]``:

>>> import matplotlib.pyplot as plt

>>> x = np.linspace(start=-10, stop=10, num=101)
>>> plt.plot(x, np.absolute(x))
>>> plt.show()

Plot the function over the complex plane:

>>> xx = x + 1j * x[:, np.newaxis]
>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
>>> plt.show()
*)

val add : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Add arguments element-wise.

Parameters
----------
x1, x2 : array_like
    The arrays to be added. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
add : ndarray or scalar
    The sum of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
Equivalent to `x1` + `x2` in terms of array broadcasting.

Examples
--------
>>> np.add(1.0, 4.0)
5.0
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.add(x1, x2)
array([[  0.,   2.,   4.],
       [  3.,   5.,   7.],
       [  6.,   8.,  10.]])
*)

val add_docstring : obj:Py.Object.t -> docstring:Py.Object.t -> unit -> Py.Object.t
(**
add_docstring(obj, docstring)

Add a docstring to a built-in obj if possible.
If the obj already has a docstring raise a RuntimeError
If this routine does not know how to add a docstring to the object
raise a TypeError
*)

val add_newdoc : ?warn_on_python:bool -> place:string -> obj:string -> doc:[`S of string | `PyObject of Py.Object.t] -> unit -> Py.Object.t
(**
Add documentation to an existing object, typically one defined in C

The purpose is to allow easier editing of the docstrings without requiring
a re-compile. This exists primarily for internal use within numpy itself.

Parameters
----------
place : str
    The absolute name of the module to import from
obj : str
    The name of the object to add documentation to, typically a class or
    function name
doc : {str, Tuple[str, str], List[Tuple[str, str]]}
    If a string, the documentation to apply to `obj`

    If a tuple, then the first element is interpreted as an attribute of
    `obj` and the second as the docstring to apply - ``(method, docstring)``

    If a list, then each element of the list should be a tuple of length
    two - ``[(method1, docstring1), (method2, docstring2), ...]``
warn_on_python : bool
    If True, the default, emit `UserWarning` if this is used to attach
    documentation to a pure-python object.

Notes
-----
This routine never raises an error if the docstring can't be written, but
will raise an error if the object being documented does not exist.

This routine cannot modify read-only docstrings, as appear
in new-style classes or built-in functions. Because this
routine never raises an error the caller must check manually
that the docstrings were changed.

Since this function grabs the ``char *`` from a c-level str object and puts
it into the ``tp_doc`` slot of the type of `obj`, it violates a number of
C-API best-practices, by:

- modifying a `PyTypeObject` after calling `PyType_Ready`
- calling `Py_INCREF` on the str and losing the reference, so the str
  will never be released

If possible it should be avoided.
*)

val add_newdoc_ufunc : ufunc:Py.Object.t -> new_docstring:string -> unit -> Py.Object.t
(**
add_ufunc_docstring(ufunc, new_docstring)

Replace the docstring for a ufunc with new_docstring.
This method will only work if the current docstring for
the ufunc is NULL. (At the C level, i.e. when ufunc->doc is NULL.)

Parameters
----------
ufunc : numpy.ufunc
    A ufunc whose current doc is NULL.
new_docstring : string
    The new docstring for the ufunc.

Notes
-----
This method allocates memory for new_docstring on
the heap. Technically this creates a mempory leak, since this
memory will not be reclaimed until the end of the program
even if the ufunc itself is removed. However this will only
be a problem if the user is repeatedly creating ufuncs with
no documentation, adding documentation via add_newdoc_ufunc,
and then throwing away the ufunc.
*)

val alen : [>`Ndarray] Obj.t -> int
(**
Return the length of the first dimension of the input array.

Parameters
----------
a : array_like
   Input array.

Returns
-------
alen : int
   Length of the first dimension of `a`.

See Also
--------
shape, size

Examples
--------
>>> a = np.zeros((7,4,5))
>>> a.shape[0]
7
>>> np.alen(a)
7
*)

val all : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Test whether all array elements along a given axis evaluate to True.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : None or int or tuple of ints, optional
    Axis or axes along which a logical AND reduction is performed.
    The default (``axis=None``) is to perform a logical AND over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a reduction is performed on multiple
    axes, instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternate output array in which to place the result.
    It must have the same shape as the expected output and its
    type is preserved (e.g., if ``dtype(out)`` is float, the result
    will consist of 0.0's and 1.0's). See `ufuncs-output-type` for more
    details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `all` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
all : ndarray, bool
    A new boolean or array is returned unless `out` is specified,
    in which case a reference to `out` is returned.

See Also
--------
ndarray.all : equivalent method

any : Test whether any element along a given axis evaluates to True.

Notes
-----
Not a Number (NaN), positive infinity and negative infinity
evaluate to `True` because these are not equal to zero.

Examples
--------
>>> np.all([[True,False],[True,True]])
False

>>> np.all([[True,False],[True,True]], axis=0)
array([ True, False])

>>> np.all([-1, 4, 5])
True

>>> np.all([1.0, np.nan])
True

>>> o=np.array(False)
>>> z=np.all([-1, 4, 5], out=o)
>>> id(z), id(o), z
(28293632, 28293632, array(True)) # may vary
*)

val allclose : ?rtol:float -> ?atol:float -> ?equal_nan:bool -> b:Py.Object.t -> Py.Object.t -> bool
(**
Returns True if two arrays are element-wise equal within a tolerance.

The tolerance values are positive, typically very small numbers.  The
relative difference (`rtol` * abs(`b`)) and the absolute difference
`atol` are added together to compare against the absolute difference
between `a` and `b`.

NaNs are treated as equal if they are in the same place and if
``equal_nan=True``.  Infs are treated as equal if they are in the same
place and of the same sign in both arrays.

Parameters
----------
a, b : array_like
    Input arrays to compare.
rtol : float
    The relative tolerance parameter (see Notes).
atol : float
    The absolute tolerance parameter (see Notes).
equal_nan : bool
    Whether to compare NaN's as equal.  If True, NaN's in `a` will be
    considered equal to NaN's in `b` in the output array.

    .. versionadded:: 1.10.0

Returns
-------
allclose : bool
    Returns True if the two arrays are equal within the given
    tolerance; False otherwise.

See Also
--------
isclose, all, any, equal

Notes
-----
If the following equation is element-wise True, then allclose returns
True.

 absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))

The above equation is not symmetric in `a` and `b`, so that
``allclose(a, b)`` might be different from ``allclose(b, a)`` in
some rare cases.

The comparison of `a` and `b` uses standard broadcasting, which
means that `a` and `b` need not have the same shape in order for
``allclose(a, b)`` to evaluate to True.  The same is true for
`equal` but not `array_equal`.

Examples
--------
>>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])
False
>>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])
True
>>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])
False
>>> np.allclose([1.0, np.nan], [1.0, np.nan])
False
>>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
True
*)

val alltrue : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
Check if all elements of input array are true.

See Also
--------
numpy.all : Equivalent function; see for details.
*)

val amax : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> ?initial:[`F of float | `I of int | `Bool of bool | `S of string] -> ?where:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the maximum of an array or maximum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, the maximum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `amax` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

initial : scalar, optional
    The minimum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to compare for the maximum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.17.0

Returns
-------
amax : ndarray or scalar
    Maximum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amin :
    The minimum value of an array along a given axis, propagating any NaNs.
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
argmax :
    Return the indices of the maximum values.

nanmin, minimum, fmin

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.

Don't use `amax` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
``amax(a, axis=0)``.

Examples
--------
>>> a = np.arange(4).reshape((2,2))
>>> a
array([[0, 1],
       [2, 3]])
>>> np.amax(a)           # Maximum of the flattened array
3
>>> np.amax(a, axis=0)   # Maxima along the first axis
array([2, 3])
>>> np.amax(a, axis=1)   # Maxima along the second axis
array([1, 3])
>>> np.amax(a, where=[False, True], initial=-1, axis=0)
array([-1,  3])
>>> b = np.arange(5, dtype=float)
>>> b[2] = np.NaN
>>> np.amax(b)
nan
>>> np.amax(b, where=~np.isnan(b), initial=-1)
4.0
>>> np.nanmax(b)
4.0

You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:

>>> np.max([[-50], [10]], axis=-1, initial=0)
array([ 0, 10])

Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.

>>> np.max([5], initial=6)
6
>>> max([5], default=6)
5
*)

val amin : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> ?initial:[`F of float | `I of int | `Bool of bool | `S of string] -> ?where:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the minimum of an array or minimum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, the minimum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `amin` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

initial : scalar, optional
    The maximum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to compare for the minimum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.17.0

Returns
-------
amin : ndarray or scalar
    Minimum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amax :
    The maximum value of an array along a given axis, propagating any NaNs.
nanmin :
    The minimum value of an array along a given axis, ignoring any NaNs.
minimum :
    Element-wise minimum of two arrays, propagating any NaNs.
fmin :
    Element-wise minimum of two arrays, ignoring any NaNs.
argmin :
    Return the indices of the minimum values.

nanmax, maximum, fmax

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.

Don't use `amin` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
``amin(a, axis=0)``.

Examples
--------
>>> a = np.arange(4).reshape((2,2))
>>> a
array([[0, 1],
       [2, 3]])
>>> np.amin(a)           # Minimum of the flattened array
0
>>> np.amin(a, axis=0)   # Minima along the first axis
array([0, 1])
>>> np.amin(a, axis=1)   # Minima along the second axis
array([0, 2])
>>> np.amin(a, where=[False, True], initial=10, axis=0)
array([10,  1])

>>> b = np.arange(5, dtype=float)
>>> b[2] = np.NaN
>>> np.amin(b)
nan
>>> np.amin(b, where=~np.isnan(b), initial=10)
0.0
>>> np.nanmin(b)
0.0

>>> np.min([[-50], [10]], axis=-1, initial=0)
array([-50,   0])

Notice that the initial value is used as one of the elements for which the
minimum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.

Notice that this isn't the same as Python's ``default`` argument.

>>> np.min([6], initial=5)
5
>>> min([6], default=5)
6
*)

val angle : ?deg:bool -> z:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the angle of the complex argument.

Parameters
----------
z : array_like
    A complex number or sequence of complex numbers.
deg : bool, optional
    Return angle in degrees if True, radians if False (default).

Returns
-------
angle : ndarray or scalar
    The counterclockwise angle from the positive real axis on the complex
    plane in the range ``(-pi, pi]``, with dtype as numpy.float64.

    ..versionchanged:: 1.16.0
        This function works on subclasses of ndarray like `ma.array`.

See Also
--------
arctan2
absolute

Examples
--------
>>> np.angle([1.0, 1.0j, 1+1j])               # in radians
array([ 0.        ,  1.57079633,  0.78539816]) # may vary
>>> np.angle(1+1j, deg=True)                  # in degrees
45.0
*)

val any : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Test whether any array element along a given axis evaluates to True.

Returns single boolean unless `axis` is not ``None``

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : None or int or tuple of ints, optional
    Axis or axes along which a logical OR reduction is performed.
    The default (``axis=None``) is to perform a logical OR over all
    the dimensions of the input array. `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a reduction is performed on multiple
    axes, instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output and its type is preserved
    (e.g., if it is of type float, then it will remain so, returning
    1.0 for True and 0.0 for False, regardless of the type of `a`).
    See `ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `any` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
any : bool or ndarray
    A new boolean or `ndarray` is returned unless `out` is specified,
    in which case a reference to `out` is returned.

See Also
--------
ndarray.any : equivalent method

all : Test whether all elements along a given axis evaluate to True.

Notes
-----
Not a Number (NaN), positive infinity and negative infinity evaluate
to `True` because these are not equal to zero.

Examples
--------
>>> np.any([[True, False], [True, True]])
True

>>> np.any([[True, False], [False, False]], axis=0)
array([ True, False])

>>> np.any([-1, 0, 5])
True

>>> np.any(np.nan)
True

>>> o=np.array(False)
>>> z=np.any([-1, 4, 5], out=o)
>>> z, o
(array(True), array(True))
>>> # Check now that z is a reference to o
>>> z is o
True
>>> id(z), id(o) # identity of z and o              # doctest: +SKIP
(191614240, 191614240)
*)

val append : ?axis:int -> arr:[>`Ndarray] Obj.t -> values:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Append values to the end of an array.

Parameters
----------
arr : array_like
    Values are appended to a copy of this array.
values : array_like
    These values are appended to a copy of `arr`.  It must be of the
    correct shape (the same shape as `arr`, excluding `axis`).  If
    `axis` is not specified, `values` can be any shape and will be
    flattened before use.
axis : int, optional
    The axis along which `values` are appended.  If `axis` is not
    given, both `arr` and `values` are flattened before use.

Returns
-------
append : ndarray
    A copy of `arr` with `values` appended to `axis`.  Note that
    `append` does not occur in-place: a new array is allocated and
    filled.  If `axis` is None, `out` is a flattened array.

See Also
--------
insert : Insert elements into an array.
delete : Delete elements from an array.

Examples
--------
>>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])
array([1, 2, 3, ..., 7, 8, 9])

When `axis` is specified, `values` must have the correct shape.

>>> np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
>>> np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)
Traceback (most recent call last):
    ...
ValueError: all the input arrays must have same number of dimensions
*)

val apply_along_axis : ?kwargs:(string * Py.Object.t) list -> func1d:Py.Object.t -> axis:int -> arr:Py.Object.t -> Py.Object.t list -> Py.Object.t
(**
Apply a function to 1-D slices along the given axis.

Execute `func1d(a, *args)` where `func1d` operates on 1-D arrays and `a`
is a 1-D slice of `arr` along `axis`.

This is equivalent to (but faster than) the following use of `ndindex` and
`s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices::

    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
    for ii in ndindex(Ni):
        for kk in ndindex(Nk):
            f = func1d(arr[ii + s_[:,] + kk])
            Nj = f.shape
            for jj in ndindex(Nj):
                out[ii + jj + kk] = f[jj]

Equivalently, eliminating the inner loop, this can be expressed as::

    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
    for ii in ndindex(Ni):
        for kk in ndindex(Nk):
            out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])

Parameters
----------
func1d : function (M,) -> (Nj...)
    This function should accept 1-D arrays. It is applied to 1-D
    slices of `arr` along the specified axis.
axis : integer
    Axis along which `arr` is sliced.
arr : ndarray (Ni..., M, Nk...)
    Input array.
args : any
    Additional arguments to `func1d`.
kwargs : any
    Additional named arguments to `func1d`.

    .. versionadded:: 1.9.0


Returns
-------
out : ndarray  (Ni..., Nj..., Nk...)
    The output array. The shape of `out` is identical to the shape of
    `arr`, except along the `axis` dimension. This axis is removed, and
    replaced with new dimensions equal to the shape of the return value
    of `func1d`. So if `func1d` returns a scalar `out` will have one
    fewer dimensions than `arr`.

See Also
--------
apply_over_axes : Apply a function repeatedly over multiple axes.

Examples
--------
>>> def my_func(a):
...     '''Average first and last element of a 1-D array'''
...     return (a[0] + a[-1]) * 0.5
>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
>>> np.apply_along_axis(my_func, 0, b)
array([4., 5., 6.])
>>> np.apply_along_axis(my_func, 1, b)
array([2.,  5.,  8.])

For a function that returns a 1D array, the number of dimensions in
`outarr` is the same as `arr`.

>>> b = np.array([[8,1,7], [4,3,9], [5,2,6]])
>>> np.apply_along_axis(sorted, 1, b)
array([[1, 7, 8],
       [3, 4, 9],
       [2, 5, 6]])

For a function that returns a higher dimensional array, those dimensions
are inserted in place of the `axis` dimension.

>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
>>> np.apply_along_axis(np.diag, -1, b)
array([[[1, 0, 0],
        [0, 2, 0],
        [0, 0, 3]],
       [[4, 0, 0],
        [0, 5, 0],
        [0, 0, 6]],
       [[7, 0, 0],
        [0, 8, 0],
        [0, 0, 9]]])
*)

val apply_over_axes : func:Py.Object.t -> axes:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Apply a function repeatedly over multiple axes.

`func` is called as `res = func(a, axis)`, where `axis` is the first
element of `axes`.  The result `res` of the function call must have
either the same dimensions as `a` or one less dimension.  If `res`
has one less dimension than `a`, a dimension is inserted before
`axis`.  The call to `func` is then repeated for each axis in `axes`,
with `res` as the first argument.

Parameters
----------
func : function
    This function must take two arguments, `func(a, axis)`.
a : array_like
    Input array.
axes : array_like
    Axes over which `func` is applied; the elements must be integers.

Returns
-------
apply_over_axis : ndarray
    The output array.  The number of dimensions is the same as `a`,
    but the shape can be different.  This depends on whether `func`
    changes the shape of its output with respect to its input.

See Also
--------
apply_along_axis :
    Apply a function to 1-D slices of an array along the given axis.

Notes
------
This function is equivalent to tuple axis arguments to reorderable ufuncs
with keepdims=True. Tuple axis arguments to ufuncs have been available since
version 1.7.0.

Examples
--------
>>> a = np.arange(24).reshape(2,3,4)
>>> a
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],
       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

Sum over axes 0 and 2. The result has same number of dimensions
as the original array:

>>> np.apply_over_axes(np.sum, a, [0,2])
array([[[ 60],
        [ 92],
        [124]]])

Tuple axis arguments to ufuncs are equivalent:

>>> np.sum(a, axis=(0,2), keepdims=True)
array([[[ 60],
        [ 92],
        [124]]])
*)

val arange : ?start:[`F of float | `I of int] -> ?step:[`F of float | `I of int] -> ?dtype:Dtype.t -> stop:[`F of float | `I of int] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arange([start,] stop[, step,], dtype=None)

Return evenly spaced values within a given interval.

Values are generated within the half-open interval ``[start, stop)``
(in other words, the interval including `start` but excluding `stop`).
For integer arguments the function is equivalent to the Python built-in
`range` function, but returns an ndarray rather than a list.

When using a non-integer step, such as 0.1, the results will often not
be consistent.  It is better to use `numpy.linspace` for these cases.

Parameters
----------
start : number, optional
    Start of interval.  The interval includes this value.  The default
    start value is 0.
stop : number
    End of interval.  The interval does not include this value, except
    in some cases where `step` is not an integer and floating point
    round-off affects the length of `out`.
step : number, optional
    Spacing between values.  For any output `out`, this is the distance
    between two adjacent values, ``out[i+1] - out[i]``.  The default
    step size is 1.  If `step` is specified as a position argument,
    `start` must also be given.
dtype : dtype
    The type of the output array.  If `dtype` is not given, infer the data
    type from the other input arguments.

Returns
-------
arange : ndarray
    Array of evenly spaced values.

    For floating point arguments, the length of the result is
    ``ceil((stop - start)/step)``.  Because of floating point overflow,
    this rule may result in the last element of `out` being greater
    than `stop`.

See Also
--------
numpy.linspace : Evenly spaced numbers with careful handling of endpoints.
numpy.ogrid: Arrays of evenly spaced numbers in N-dimensions.
numpy.mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.

Examples
--------
>>> np.arange(3)
array([0, 1, 2])
>>> np.arange(3.0)
array([ 0.,  1.,  2.])
>>> np.arange(3,7)
array([3, 4, 5, 6])
>>> np.arange(3,7,2)
array([3, 5])
*)

val arccos : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Trigonometric inverse cosine, element-wise.

The inverse of `cos` so that, if ``y = cos(x)``, then ``x = arccos(y)``.

Parameters
----------
x : array_like
    `x`-coordinate on the unit circle.
    For real arguments, the domain is [-1, 1].
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
angle : ndarray
    The angle of the ray intersecting the unit circle at the given
    `x`-coordinate in radians [0, pi].
    This is a scalar if `x` is a scalar.

See Also
--------
cos, arctan, arcsin, emath.arccos

Notes
-----
`arccos` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `cos(z) = x`. The convention is to return
the angle `z` whose real part lies in `[0, pi]`.

For real-valued input data types, `arccos` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arccos` is a complex analytic function that
has branch cuts `[-inf, -1]` and `[1, inf]` and is continuous from
above on the former and from below on the latter.

The inverse `cos` is also known as `acos` or cos^-1.

References
----------
M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/

Examples
--------
We expect the arccos of 1 to be 0, and of -1 to be pi:

>>> np.arccos([1, -1])
array([ 0.        ,  3.14159265])

Plot arccos:

>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-1, 1, num=100)
>>> plt.plot(x, np.arccos(x))
>>> plt.axis('tight')
>>> plt.show()
*)

val arccosh : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Inverse hyperbolic cosine, element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
arccosh : ndarray
    Array of the same shape as `x`.
    This is a scalar if `x` is a scalar.

See Also
--------

cosh, arcsinh, sinh, arctanh, tanh

Notes
-----
`arccosh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `cosh(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi, pi]` and the real part in
``[0, inf]``.

For real-valued input data types, `arccosh` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arccosh` is a complex analytical function that
has a branch cut `[-inf, 1]` and is continuous from above on it.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Inverse hyperbolic function',
       https://en.wikipedia.org/wiki/Arccosh

Examples
--------
>>> np.arccosh([np.e, 10.0])
array([ 1.65745445,  2.99322285])
>>> np.arccosh(1)
0.0
*)

val arcsin : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Inverse sine, element-wise.

Parameters
----------
x : array_like
    `y`-coordinate on the unit circle.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
angle : ndarray
    The inverse sine of each element in `x`, in radians and in the
    closed interval ``[-pi/2, pi/2]``.
    This is a scalar if `x` is a scalar.

See Also
--------
sin, cos, arccos, tan, arctan, arctan2, emath.arcsin

Notes
-----
`arcsin` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that :math:`sin(z) = x`.  The convention is to
return the angle `z` whose real part lies in [-pi/2, pi/2].

For real-valued input data types, *arcsin* always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arcsin` is a complex analytic function that
has, by convention, the branch cuts [-inf, -1] and [1, inf]  and is
continuous from above on the former and from below on the latter.

The inverse sine is also known as `asin` or sin^{-1}.

References
----------
Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,
10th printing, New York: Dover, 1964, pp. 79ff.
http://www.math.sfu.ca/~cbm/aands/

Examples
--------
>>> np.arcsin(1)     # pi/2
1.5707963267948966
>>> np.arcsin(-1)    # -pi/2
-1.5707963267948966
>>> np.arcsin(0)
0.0
*)

val arcsinh : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Inverse hyperbolic sine element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Array of the same shape as `x`.
    This is a scalar if `x` is a scalar.

Notes
-----
`arcsinh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `sinh(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi/2, pi/2]`.

For real-valued input data types, `arcsinh` always returns real output.
For each value that cannot be expressed as a real number or infinity, it
returns ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arccos` is a complex analytical function that
has branch cuts `[1j, infj]` and `[-1j, -infj]` and is continuous from
the right on the former and from the left on the latter.

The inverse hyperbolic sine is also known as `asinh` or ``sinh^-1``.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Inverse hyperbolic function',
       https://en.wikipedia.org/wiki/Arcsinh

Examples
--------
>>> np.arcsinh(np.array([np.e, 10.0]))
array([ 1.72538256,  2.99822295])
*)

val arctan : ?out:Py.Object.t -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Trigonometric inverse tangent, element-wise.

The inverse of tan, so that if ``y = tan(x)`` then ``x = arctan(y)``.

Parameters
----------
x : array_like
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Out has the same shape as `x`.  Its real part is in
    ``[-pi/2, pi/2]`` (``arctan(+/-inf)`` returns ``+/-pi/2``).
    This is a scalar if `x` is a scalar.

See Also
--------
arctan2 : The 'four quadrant' arctan of the angle formed by (`x`, `y`)
    and the positive `x`-axis.
angle : Argument of complex values.

Notes
-----
`arctan` is a multi-valued function: for each `x` there are infinitely
many numbers `z` such that tan(`z`) = `x`.  The convention is to return
the angle `z` whose real part lies in [-pi/2, pi/2].

For real-valued input data types, `arctan` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arctan` is a complex analytic function that
has [`1j, infj`] and [`-1j, -infj`] as branch cuts, and is continuous
from the left on the former and from the right on the latter.

The inverse tangent is also known as `atan` or tan^{-1}.

References
----------
Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,
10th printing, New York: Dover, 1964, pp. 79.
http://www.math.sfu.ca/~cbm/aands/

Examples
--------
We expect the arctan of 0 to be 0, and of 1 to be pi/4:

>>> np.arctan([0, 1])
array([ 0.        ,  0.78539816])

>>> np.pi/4
0.78539816339744828

Plot arctan:

>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-10, 10)
>>> plt.plot(x, np.arctan(x))
>>> plt.axis('tight')
>>> plt.show()
*)

val arctan2 : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Element-wise arc tangent of ``x1/x2`` choosing the quadrant correctly.

The quadrant (i.e., branch) is chosen so that ``arctan2(x1, x2)`` is
the signed angle in radians between the ray ending at the origin and
passing through the point (1,0), and the ray ending at the origin and
passing through the point (`x2`, `x1`).  (Note the role reversal: the
'`y`-coordinate' is the first function parameter, the '`x`-coordinate'
is the second.)  By IEEE convention, this function is defined for
`x2` = +/-0 and for either or both of `x1` and `x2` = +/-inf (see
Notes for specific values).

This function is not defined for complex-valued arguments; for the
so-called argument of complex values, use `angle`.

Parameters
----------
x1 : array_like, real-valued
    `y`-coordinates.
x2 : array_like, real-valued
    `x`-coordinates. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
angle : ndarray
    Array of angles in radians, in the range ``[-pi, pi]``.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
arctan, tan, angle

Notes
-----
*arctan2* is identical to the `atan2` function of the underlying
C library.  The following special values are defined in the C
standard: [1]_

====== ====== ================
`x1`   `x2`   `arctan2(x1,x2)`
====== ====== ================
+/- 0  +0     +/- 0
+/- 0  -0     +/- pi
 > 0   +/-inf +0 / +pi
 < 0   +/-inf -0 / -pi
+/-inf +inf   +/- (pi/4)
+/-inf -inf   +/- (3*pi/4)
====== ====== ================

Note that +0 and -0 are distinct floating point numbers, as are +inf
and -inf.

References
----------
.. [1] ISO/IEC standard 9899:1999, 'Programming language C.'

Examples
--------
Consider four points in different quadrants:

>>> x = np.array([-1, +1, +1, -1])
>>> y = np.array([-1, -1, +1, +1])
>>> np.arctan2(y, x) * 180 / np.pi
array([-135.,  -45.,   45.,  135.])

Note the order of the parameters. `arctan2` is defined also when `x2` = 0
and at several other special points, obtaining values in
the range ``[-pi, pi]``:

>>> np.arctan2([1., -1.], [0., 0.])
array([ 1.57079633, -1.57079633])
>>> np.arctan2([0., 0., np.inf], [+0., -0., np.inf])
array([ 0.        ,  3.14159265,  0.78539816])
*)

val arctanh : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Inverse hyperbolic tangent element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Array of the same shape as `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
emath.arctanh

Notes
-----
`arctanh` is a multivalued function: for each `x` there are infinitely
many numbers `z` such that `tanh(z) = x`. The convention is to return
the `z` whose imaginary part lies in `[-pi/2, pi/2]`.

For real-valued input data types, `arctanh` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `arctanh` is a complex analytical function
that has branch cuts `[-1, -inf]` and `[1, inf]` and is continuous from
above on the former and from below on the latter.

The inverse hyperbolic tangent is also known as `atanh` or ``tanh^-1``.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Inverse hyperbolic function',
       https://en.wikipedia.org/wiki/Arctanh

Examples
--------
>>> np.arctanh([0, -0.5])
array([ 0.        , -0.54930614])
*)

val argmax : ?axis:int -> ?out:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Returns the indices of the maximum values along an axis.

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    By default, the index is into the flattened array, otherwise
    along the specified axis.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and dtype.

Returns
-------
index_array : ndarray of ints
    Array of indices into the array. It has the same shape as `a.shape`
    with the dimension along `axis` removed.

See Also
--------
ndarray.argmax, argmin
amax : The maximum value along a given axis.
unravel_index : Convert a flat index into an index tuple.
take_along_axis : Apply ``np.expand_dims(index_array, axis)`` 
                  from argmax to an array as if by calling max.

Notes
-----
In case of multiple occurrences of the maximum values, the indices
corresponding to the first occurrence are returned.

Examples
--------
>>> a = np.arange(6).reshape(2,3) + 10
>>> a
array([[10, 11, 12],
       [13, 14, 15]])
>>> np.argmax(a)
5
>>> np.argmax(a, axis=0)
array([1, 1, 1])
>>> np.argmax(a, axis=1)
array([2, 2])

Indexes of the maximal elements of a N-dimensional array:

>>> ind = np.unravel_index(np.argmax(a, axis=None), a.shape)
>>> ind
(1, 2)
>>> a[ind]
15

>>> b = np.arange(6)
>>> b[1] = 5
>>> b
array([0, 5, 2, 3, 4, 5])
>>> np.argmax(b)  # Only the first occurrence is returned.
1

>>> x = np.array([[4,2,3], [1,0,3]])
>>> index_array = np.argmax(x, axis=-1)
>>> # Same as np.max(x, axis=-1, keepdims=True)
>>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)
array([[4],
       [3]])
>>> # Same as np.max(x, axis=-1)
>>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)
array([4, 3])
*)

val argmin : ?axis:int -> ?out:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Returns the indices of the minimum values along an axis.

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    By default, the index is into the flattened array, otherwise
    along the specified axis.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and dtype.

Returns
-------
index_array : ndarray of ints
    Array of indices into the array. It has the same shape as `a.shape`
    with the dimension along `axis` removed.

See Also
--------
ndarray.argmin, argmax
amin : The minimum value along a given axis.
unravel_index : Convert a flat index into an index tuple.
take_along_axis : Apply ``np.expand_dims(index_array, axis)`` 
                  from argmin to an array as if by calling min.

Notes
-----
In case of multiple occurrences of the minimum values, the indices
corresponding to the first occurrence are returned.

Examples
--------
>>> a = np.arange(6).reshape(2,3) + 10
>>> a
array([[10, 11, 12],
       [13, 14, 15]])
>>> np.argmin(a)
0
>>> np.argmin(a, axis=0)
array([0, 0, 0])
>>> np.argmin(a, axis=1)
array([0, 0])

Indices of the minimum elements of a N-dimensional array:

>>> ind = np.unravel_index(np.argmin(a, axis=None), a.shape)
>>> ind
(0, 0)
>>> a[ind]
10

>>> b = np.arange(6) + 10
>>> b[4] = 10
>>> b
array([10, 11, 12, 13, 10, 15])
>>> np.argmin(b)  # Only the first occurrence is returned.
0

>>> x = np.array([[4,2,3], [1,0,3]])
>>> index_array = np.argmin(x, axis=-1)
>>> # Same as np.min(x, axis=-1, keepdims=True)
>>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)
array([[2],
       [0]])
>>> # Same as np.max(x, axis=-1)
>>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)
array([2, 0])
*)

val argpartition : ?axis:[`I of int | `None] -> ?kind:[`Introselect] -> ?order:[`StringList of string list | `S of string] -> kth:[`Is of int list | `I of int] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Perform an indirect partition along the given axis using the
algorithm specified by the `kind` keyword. It returns an array of
indices of the same shape as `a` that index data along the given
axis in partitioned order.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array to sort.
kth : int or sequence of ints
    Element index to partition by. The k-th element will be in its
    final sorted position and all smaller elements will be moved
    before it and all larger elements behind it. The order all
    elements in the partitions is undefined. If provided with a
    sequence of k-th it will partition all of them into their sorted
    position at once.
axis : int or None, optional
    Axis along which to sort. The default is -1 (the last axis). If
    None, the flattened array is used.
kind : {'introselect'}, optional
    Selection algorithm. Default is 'introselect'
order : str or list of str, optional
    When `a` is an array with fields defined, this argument
    specifies which fields to compare first, second, etc. A single
    field can be specified as a string, and not all fields need be
    specified, but unspecified fields will still be used, in the
    order in which they come up in the dtype, to break ties.

Returns
-------
index_array : ndarray, int
    Array of indices that partition `a` along the specified axis.
    If `a` is one-dimensional, ``a[index_array]`` yields a partitioned `a`.
    More generally, ``np.take_along_axis(a, index_array, axis=a)`` always
    yields the partitioned `a`, irrespective of dimensionality.

See Also
--------
partition : Describes partition algorithms used.
ndarray.partition : Inplace partition.
argsort : Full indirect sort.
take_along_axis : Apply ``index_array`` from argpartition 
                  to an array as if by calling partition.

Notes
-----
See `partition` for notes on the different selection algorithms.

Examples
--------
One dimensional array:

>>> x = np.array([3, 4, 2, 1])
>>> x[np.argpartition(x, 3)]
array([2, 1, 3, 4])
>>> x[np.argpartition(x, (1, 3))]
array([1, 2, 3, 4])

>>> x = [3, 4, 2, 1]
>>> np.array(x)[np.argpartition(x, 3)]
array([2, 1, 3, 4])

Multi-dimensional array:

>>> x = np.array([[3, 4, 2], [1, 3, 1]])
>>> index_array = np.argpartition(x, kth=1, axis=-1)
>>> np.take_along_axis(x, index_array, axis=-1)  # same as np.partition(x, kth=1)
array([[2, 3, 4],
       [1, 1, 3]])
*)

val argsort : ?axis:[`I of int | `None] -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[`StringList of string list | `S of string] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Returns the indices that would sort an array.

Perform an indirect sort along the given axis using the algorithm specified
by the `kind` keyword. It returns an array of indices of the same shape as
`a` that index data along the given axis in sorted order.

Parameters
----------
a : array_like
    Array to sort.
axis : int or None, optional
    Axis along which to sort.  The default is -1 (the last axis). If None,
    the flattened array is used.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
    and 'mergesort' use timsort under the covers and, in general, the
    actual implementation will vary with data type. The 'mergesort' option
    is retained for backwards compatibility.

    .. versionchanged:: 1.15.0.
       The 'stable' option was added.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  A single field can
    be specified as a string, and not all fields need be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

Returns
-------
index_array : ndarray, int
    Array of indices that sort `a` along the specified `axis`.
    If `a` is one-dimensional, ``a[index_array]`` yields a sorted `a`.
    More generally, ``np.take_along_axis(a, index_array, axis=axis)``
    always yields the sorted `a`, irrespective of dimensionality.

See Also
--------
sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
ndarray.sort : Inplace sort.
argpartition : Indirect partial sort.
take_along_axis : Apply ``index_array`` from argsort 
                  to an array as if by calling sort.

Notes
-----
See `sort` for notes on the different sorting algorithms.

As of NumPy 1.4.0 `argsort` works with real/complex arrays containing
nan values. The enhanced sort order is documented in `sort`.

Examples
--------
One dimensional array:

>>> x = np.array([3, 1, 2])
>>> np.argsort(x)
array([1, 2, 0])

Two-dimensional array:

>>> x = np.array([[0, 3], [2, 2]])
>>> x
array([[0, 3],
       [2, 2]])

>>> ind = np.argsort(x, axis=0)  # sorts along first axis (down)
>>> ind
array([[0, 1],
       [1, 0]])
>>> np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)
array([[0, 2],
       [2, 3]])

>>> ind = np.argsort(x, axis=1)  # sorts along last axis (across)
>>> ind
array([[0, 1],
       [0, 1]])
>>> np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)
array([[0, 3],
       [2, 2]])

Indices of the sorted elements of a N-dimensional array:

>>> ind = np.unravel_index(np.argsort(x, axis=None), x.shape)
>>> ind
(array([0, 1, 1, 0]), array([0, 0, 1, 1]))
>>> x[ind]  # same as np.sort(x, axis=None)
array([0, 2, 2, 3])

Sorting with keys:

>>> x = np.array([(1, 0), (0, 1)], dtype=[('x', '<i4'), ('y', '<i4')])
>>> x
array([(1, 0), (0, 1)],
      dtype=[('x', '<i4'), ('y', '<i4')])

>>> np.argsort(x, order=('x','y'))
array([1, 0])

>>> np.argsort(x, order=('y','x'))
array([0, 1])
*)

val argwhere : [>`Ndarray] Obj.t -> Py.Object.t
(**
Find the indices of array elements that are non-zero, grouped by element.

Parameters
----------
a : array_like
    Input data.

Returns
-------
index_array : (N, a.ndim) ndarray
    Indices of elements that are non-zero. Indices are grouped by element.
    This array will have shape ``(N, a.ndim)`` where ``N`` is the number of
    non-zero items.

See Also
--------
where, nonzero

Notes
-----
``np.argwhere(a)`` is almost the same as ``np.transpose(np.nonzero(a))``,
but produces a result of the correct shape for a 0D array.

The output of ``argwhere`` is not suitable for indexing arrays.
For this purpose use ``nonzero(a)`` instead.

Examples
--------
>>> x = np.arange(6).reshape(2,3)
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.argwhere(x>1)
array([[0, 2],
       [1, 0],
       [1, 1],
       [1, 2]])
*)

val around : ?decimals:int -> ?out:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Evenly round to the given number of decimals.

Parameters
----------
a : array_like
    Input data.
decimals : int, optional
    Number of decimal places to round to (default: 0).  If
    decimals is negative, it specifies the number of positions to
    the left of the decimal point.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output, but the type of the output
    values will be cast if necessary. See `ufuncs-output-type` for more
    details.

Returns
-------
rounded_array : ndarray
    An array of the same type as `a`, containing the rounded values.
    Unless `out` was specified, a new array is created.  A reference to
    the result is returned.

    The real and imaginary parts of complex numbers are rounded
    separately.  The result of rounding a float is a float.

See Also
--------
ndarray.round : equivalent method

ceil, fix, floor, rint, trunc


Notes
-----
For values exactly halfway between rounded decimal values, NumPy
rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
-0.5 and 0.5 round to 0.0, etc.

``np.around`` uses a fast but sometimes inexact algorithm to round
floating-point datatypes. For positive `decimals` it is equivalent to
``np.true_divide(np.rint(a * 10**decimals), 10**decimals)``, which has
error due to the inexact representation of decimal fractions in the IEEE
floating point standard [1]_ and errors introduced when scaling by powers
of ten. For instance, note the extra '1' in the following:

    >>> np.round(56294995342131.5, 3)
    56294995342131.51

If your goal is to print such values with a fixed number of decimals, it is
preferable to use numpy's float printing routines to limit the number of
printed decimals:

    >>> np.format_float_positional(56294995342131.5, precision=3)
    '56294995342131.5'

The float printing routines use an accurate but much more computationally
demanding algorithm to compute the number of digits after the decimal
point.

Alternatively, Python's builtin `round` function uses a more accurate
but slower algorithm for 64-bit floating point values:

    >>> round(56294995342131.5, 3)
    56294995342131.5
    >>> np.round(16.055, 2), round(16.055, 2)  # equals 16.0549999999999997
    (16.06, 16.05)


References
----------
.. [1] 'Lecture Notes on the Status of IEEE 754', William Kahan,
       https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF
.. [2] 'How Futile are Mindless Assessments of
       Roundoff in Floating-Point Computation?', William Kahan,
       https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf

Examples
--------
>>> np.around([0.37, 1.64])
array([0.,  2.])
>>> np.around([0.37, 1.64], decimals=1)
array([0.4,  1.6])
>>> np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value
array([0.,  2.,  2.,  4.,  4.])
>>> np.around([1,2,3,11], decimals=1) # ndarray of ints is returned
array([ 1,  2,  3, 11])
>>> np.around([1,2,3,11], decimals=-1)
array([ 0,  0,  0, 10])
*)

val array : ?dtype:Dtype.t -> ?copy:bool -> ?order:[`K | `A | `C | `F] -> ?subok:bool -> ?ndmin:int -> object_:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)

Create an array.

Parameters
----------
object : array_like
    An array, any object exposing the array interface, an object whose
    __array__ method returns an array, or any (nested) sequence.
dtype : data-type, optional
    The desired data-type for the array.  If not given, then the type will
    be determined as the minimum type required to hold the objects in the
    sequence.
copy : bool, optional
    If true (default), then the object is copied.  Otherwise, a copy will
    only be made if __array__ returns a copy, if obj is a nested sequence,
    or if a copy is needed to satisfy any of the other requirements
    (`dtype`, `order`, etc.).
order : {'K', 'A', 'C', 'F'}, optional
    Specify the memory layout of the array. If object is not an array, the
    newly created array will be in C order (row major) unless 'F' is
    specified, in which case it will be in Fortran order (column major).
    If object is an array the following holds.

    ===== ========= ===================================================
    order  no copy                     copy=True
    ===== ========= ===================================================
    'K'   unchanged F & C order preserved, otherwise most similar order
    'A'   unchanged F order if input is F and not C, otherwise C order
    'C'   C order   C order
    'F'   F order   F order
    ===== ========= ===================================================

    When ``copy=False`` and a copy is made for other reasons, the result is
    the same as if ``copy=True``, with some exceptions for `A`, see the
    Notes section. The default order is 'K'.
subok : bool, optional
    If True, then sub-classes will be passed-through, otherwise
    the returned array will be forced to be a base-class array (default).
ndmin : int, optional
    Specifies the minimum number of dimensions that the resulting
    array should have.  Ones will be pre-pended to the shape as
    needed to meet this requirement.

Returns
-------
out : ndarray
    An array object satisfying the specified requirements.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Notes
-----
When order is 'A' and `object` is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.

Examples
--------
>>> np.array([1, 2, 3])
array([1, 2, 3])

Upcasting:

>>> np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])

More than one dimension:

>>> np.array([[1, 2], [3, 4]])
array([[1, 2],
       [3, 4]])

Minimum dimensions 2:

>>> np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])

Type provided:

>>> np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])

Data-type consisting of more than one element:

>>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])
>>> x['a']
array([1, 3])

Creating an array from sub-classes:

>>> np.array(np.mat('1 2; 3 4'))
array([[1, 2],
       [3, 4]])

>>> np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
        [3, 4]])
*)

val array2string : ?max_line_width:int -> ?precision:int -> ?suppress_small:bool -> ?separator:string -> ?prefix:string -> ?style:Py.Object.t -> ?formatter:Py.Object.t -> ?threshold:int -> ?edgeitems:int -> ?sign:[`Space | `Plus | `Minus] -> ?floatmode:string -> ?suffix:Py.Object.t -> ?kwarg:(string * Py.Object.t) list -> [>`Ndarray] Obj.t -> string
(**
Return a string representation of an array.

Parameters
----------
a : array_like
    Input array.
max_line_width : int, optional
    Inserts newlines if text is longer than `max_line_width`.
    Defaults to ``numpy.get_printoptions()['linewidth']``.
precision : int or None, optional
    Floating point precision.
    Defaults to ``numpy.get_printoptions()['precision']``.
suppress_small : bool, optional
    Represent numbers 'very close' to zero as zero; default is False.
    Very close is defined by precision: if the precision is 8, e.g.,
    numbers smaller (in absolute value) than 5e-9 are represented as
    zero.
    Defaults to ``numpy.get_printoptions()['suppress']``.
separator : str, optional
    Inserted between elements.
prefix : str, optional
suffix: str, optional
    The length of the prefix and suffix strings are used to respectively
    align and wrap the output. An array is typically printed as::

      prefix + array2string(a) + suffix

    The output is left-padded by the length of the prefix string, and
    wrapping is forced at the column ``max_line_width - len(suffix)``.
    It should be noted that the content of prefix and suffix strings are
    not included in the output.
style : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.14.0
formatter : dict of callables, optional
    If not None, the keys should indicate the type(s) that the respective
    formatting function applies to.  Callables should return a string.
    Types that are not specified (by their corresponding keys) are handled
    by the default formatters.  Individual types for which a formatter
    can be set are:

    - 'bool'
    - 'int'
    - 'timedelta' : a `numpy.timedelta64`
    - 'datetime' : a `numpy.datetime64`
    - 'float'
    - 'longfloat' : 128-bit floats
    - 'complexfloat'
    - 'longcomplexfloat' : composed of two 128-bit floats
    - 'void' : type `numpy.void`
    - 'numpystr' : types `numpy.string_` and `numpy.unicode_`
    - 'str' : all other strings

    Other keys that can be used to set a group of types at once are:

    - 'all' : sets all types
    - 'int_kind' : sets 'int'
    - 'float_kind' : sets 'float' and 'longfloat'
    - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
    - 'str_kind' : sets 'str' and 'numpystr'
threshold : int, optional
    Total number of array elements which trigger summarization
    rather than full repr.
    Defaults to ``numpy.get_printoptions()['threshold']``.
edgeitems : int, optional
    Number of array items in summary at beginning and end of
    each dimension.
    Defaults to ``numpy.get_printoptions()['edgeitems']``.
sign : string, either '-', '+', or ' ', optional
    Controls printing of the sign of floating-point types. If '+', always
    print the sign of positive values. If ' ', always prints a space
    (whitespace character) in the sign position of positive values.  If
    '-', omit the sign character of positive values.
    Defaults to ``numpy.get_printoptions()['sign']``.
floatmode : str, optional
    Controls the interpretation of the `precision` option for
    floating-point types.
    Defaults to ``numpy.get_printoptions()['floatmode']``.
    Can take the following values:

    - 'fixed': Always print exactly `precision` fractional digits,
      even if this would print more or fewer digits than
      necessary to specify the value uniquely.
    - 'unique': Print the minimum number of fractional digits necessary
      to represent each value uniquely. Different elements may
      have a different number of digits.  The value of the
      `precision` option is ignored.
    - 'maxprec': Print at most `precision` fractional digits, but if
      an element can be uniquely represented with fewer digits
      only print it with that many.
    - 'maxprec_equal': Print at most `precision` fractional digits,
      but if every element in the array can be uniquely
      represented with an equal number of fewer digits, use that
      many digits for all elements.
legacy : string or `False`, optional
    If set to the string `'1.13'` enables 1.13 legacy printing mode. This
    approximates numpy 1.13 print output by including a space in the sign
    position of floats and different behavior for 0d arrays. If set to
    `False`, disables legacy mode. Unrecognized strings will be ignored
    with a warning for forward compatibility.

    .. versionadded:: 1.14.0

Returns
-------
array_str : str
    String representation of the array.

Raises
------
TypeError
    if a callable in `formatter` does not return a string.

See Also
--------
array_str, array_repr, set_printoptions, get_printoptions

Notes
-----
If a formatter is specified for a certain type, the `precision` keyword is
ignored for that type.

This is a very flexible function; `array_repr` and `array_str` are using
`array2string` internally so keywords with the same name should work
identically in all three functions.

Examples
--------
>>> x = np.array([1e-16,1,2,3])
>>> np.array2string(x, precision=2, separator=',',
...                       suppress_small=True)
'[0.,1.,2.,3.]'

>>> x  = np.arange(3.)
>>> np.array2string(x, formatter={'float_kind':lambda x: '%.2f' % x})
'[0.00 1.00 2.00]'

>>> x  = np.arange(3)
>>> np.array2string(x, formatter={'int':lambda x: hex(x)})
'[0x0 0x1 0x2]'
*)

val array_equal : a1:Py.Object.t -> a2:Py.Object.t -> unit -> bool
(**
True if two arrays have the same shape and elements, False otherwise.

Parameters
----------
a1, a2 : array_like
    Input arrays.

Returns
-------
b : bool
    Returns True if the arrays are equal.

See Also
--------
allclose: Returns True if two arrays are element-wise equal within a
          tolerance.
array_equiv: Returns True if input arrays are shape consistent and all
             elements equal.

Examples
--------
>>> np.array_equal([1, 2], [1, 2])
True
>>> np.array_equal(np.array([1, 2]), np.array([1, 2]))
True
>>> np.array_equal([1, 2], [1, 2, 3])
False
>>> np.array_equal([1, 2], [1, 4])
False
*)

val array_equiv : a1:Py.Object.t -> a2:Py.Object.t -> unit -> bool
(**
Returns True if input arrays are shape consistent and all elements equal.

Shape consistent means they are either the same shape, or one input array
can be broadcasted to create the same shape as the other one.

Parameters
----------
a1, a2 : array_like
    Input arrays.

Returns
-------
out : bool
    True if equivalent, False otherwise.

Examples
--------
>>> np.array_equiv([1, 2], [1, 2])
True
>>> np.array_equiv([1, 2], [1, 3])
False

Showing the shape equivalence:

>>> np.array_equiv([1, 2], [[1, 2], [1, 2]])
True
>>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])
False

>>> np.array_equiv([1, 2], [[1, 2], [1, 3]])
False
*)

val array_repr : ?max_line_width:int -> ?precision:int -> ?suppress_small:bool -> arr:[>`Ndarray] Obj.t -> unit -> string
(**
Return the string representation of an array.

Parameters
----------
arr : ndarray
    Input array.
max_line_width : int, optional
    Inserts newlines if text is longer than `max_line_width`.
    Defaults to ``numpy.get_printoptions()['linewidth']``.
precision : int, optional
    Floating point precision.
    Defaults to ``numpy.get_printoptions()['precision']``.
suppress_small : bool, optional
    Represent numbers 'very close' to zero as zero; default is False.
    Very close is defined by precision: if the precision is 8, e.g.,
    numbers smaller (in absolute value) than 5e-9 are represented as
    zero.
    Defaults to ``numpy.get_printoptions()['suppress']``.

Returns
-------
string : str
  The string representation of an array.

See Also
--------
array_str, array2string, set_printoptions

Examples
--------
>>> np.array_repr(np.array([1,2]))
'array([1, 2])'
>>> np.array_repr(np.ma.array([0.]))
'MaskedArray([0.])'
>>> np.array_repr(np.array([], np.int32))
'array([], dtype=int32)'

>>> x = np.array([1e-6, 4e-7, 2, 3])
>>> np.array_repr(x, precision=6, suppress_small=True)
'array([0.000001,  0.      ,  2.      ,  3.      ])'
*)

val array_split : ?axis:Py.Object.t -> ary:Py.Object.t -> indices_or_sections:Py.Object.t -> unit -> Py.Object.t
(**
Split an array into multiple sub-arrays.

Please refer to the ``split`` documentation.  The only difference
between these functions is that ``array_split`` allows
`indices_or_sections` to be an integer that does *not* equally
divide the axis. For an array of length l that should be split
into n sections, it returns l % n sub-arrays of size l//n + 1
and the rest of size l//n.

See Also
--------
split : Split array into multiple sub-arrays of equal size.

Examples
--------
>>> x = np.arange(8.0)
>>> np.array_split(x, 3)
    [array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])]

>>> x = np.arange(7.0)
>>> np.array_split(x, 3)
    [array([0.,  1.,  2.]), array([3.,  4.]), array([5.,  6.])]
*)

val array_str : ?max_line_width:int -> ?precision:int -> ?suppress_small:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Return a string representation of the data in an array.

The data in the array is returned as a single string.  This function is
similar to `array_repr`, the difference being that `array_repr` also
returns information on the kind of array and its data type.

Parameters
----------
a : ndarray
    Input array.
max_line_width : int, optional
    Inserts newlines if text is longer than `max_line_width`.
    Defaults to ``numpy.get_printoptions()['linewidth']``.
precision : int, optional
    Floating point precision.
    Defaults to ``numpy.get_printoptions()['precision']``.
suppress_small : bool, optional
    Represent numbers 'very close' to zero as zero; default is False.
    Very close is defined by precision: if the precision is 8, e.g.,
    numbers smaller (in absolute value) than 5e-9 are represented as
    zero.
    Defaults to ``numpy.get_printoptions()['suppress']``.

See Also
--------
array2string, array_repr, set_printoptions

Examples
--------
>>> np.array_str(np.arange(3))
'[0 1 2]'
*)

val asanyarray : ?dtype:Dtype.t -> ?order:[`C | `F] -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Convert the input to an ndarray, but pass ndarray subclasses through.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes scalars, lists, lists of tuples, tuples, tuples of tuples,
    tuples of lists, and ndarrays.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major (C-style) or column-major
    (Fortran-style) memory representation.  Defaults to 'C'.

Returns
-------
out : ndarray or an ndarray subclass
    Array interpretation of `a`.  If `a` is an ndarray or a subclass
    of ndarray, it is returned as-is and no copy is performed.

See Also
--------
asarray : Similar function which always returns ndarrays.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
asarray_chkfinite : Similar function which checks input for NaNs and
                    Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array:

>>> a = [1, 2]
>>> np.asanyarray(a)
array([1, 2])

Instances of `ndarray` subclasses are passed through as-is:

>>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
>>> np.asanyarray(a) is a
True
*)

val asarray : ?dtype:Dtype.t -> ?order:[`C | `F] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Convert the input to an array.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major (C-style) or
    column-major (Fortran-style) memory representation.
    Defaults to 'C'.

Returns
-------
out : ndarray
    Array interpretation of `a`.  No copy is performed if the input
    is already an ndarray with matching dtype and order.  If `a` is a
    subclass of ndarray, a base class ndarray is returned.

See Also
--------
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array:

>>> a = [1, 2]
>>> np.asarray(a)
array([1, 2])

Existing arrays are not copied:

>>> a = np.array([1, 2])
>>> np.asarray(a) is a
True

If `dtype` is set, array is copied only if dtype does not match:

>>> a = np.array([1, 2], dtype=np.float32)
>>> np.asarray(a, dtype=np.float32) is a
True
>>> np.asarray(a, dtype=np.float64) is a
False

Contrary to `asanyarray`, ndarray subclasses are not passed through:

>>> issubclass(np.recarray, np.ndarray)
True
>>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
>>> np.asarray(a) is a
False
>>> np.asanyarray(a) is a
True
*)

val asarray_chkfinite : ?dtype:Dtype.t -> ?order:[`C | `F] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Convert the input to an array, checking for NaNs or Infs.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.  Success requires no NaNs or Infs.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
     Whether to use row-major (C-style) or
     column-major (Fortran-style) memory representation.
     Defaults to 'C'.

Returns
-------
out : ndarray
    Array interpretation of `a`.  No copy is performed if the input
    is already an ndarray.  If `a` is a subclass of ndarray, a base
    class ndarray is returned.

Raises
------
ValueError
    Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).

See Also
--------
asarray : Create and array.
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array.  If all elements are finite
``asarray_chkfinite`` is identical to ``asarray``.

>>> a = [1, 2]
>>> np.asarray_chkfinite(a, dtype=float)
array([1., 2.])

Raises ValueError if array_like contains Nans or Infs.

>>> a = [1, 2, np.inf]
>>> try:
...     np.asarray_chkfinite(a)
... except ValueError:
...     print('ValueError')
...
ValueError
*)

val ascontiguousarray : ?dtype:[`Dtype_object of Py.Object.t | `S of string] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a contiguous array (ndim >= 1) in memory (C order).

Parameters
----------
a : array_like
    Input array.
dtype : str or dtype object, optional
    Data-type of returned array.

Returns
-------
out : ndarray
    Contiguous array of same shape and content as `a`, with type `dtype`
    if specified.

See Also
--------
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
require : Return an ndarray that satisfies requirements.
ndarray.flags : Information about the memory layout of the array.

Examples
--------
>>> x = np.arange(6).reshape(2,3)
>>> np.ascontiguousarray(x, dtype=np.float32)
array([[0., 1., 2.],
       [3., 4., 5.]], dtype=float32)
>>> x.flags['C_CONTIGUOUS']
True

Note: This function returns an array with at least one-dimension (1-d) 
so it will not preserve 0-d arrays.  
*)

val asfarray : ?dtype:[`Dtype_object of Py.Object.t | `S of string] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an array converted to a float type.

Parameters
----------
a : array_like
    The input array.
dtype : str or dtype object, optional
    Float type code to coerce input array `a`.  If `dtype` is one of the
    'int' dtypes, it is replaced with float64.

Returns
-------
out : ndarray
    The input `a` as a float ndarray.

Examples
--------
>>> np.asfarray([2, 3])
array([2.,  3.])
>>> np.asfarray([2, 3], dtype='float')
array([2.,  3.])
>>> np.asfarray([2, 3], dtype='int8')
array([2.,  3.])
*)

val asfortranarray : ?dtype:[`Dtype_object of Py.Object.t | `S of string] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an array (ndim >= 1) laid out in Fortran order in memory.

Parameters
----------
a : array_like
    Input array.
dtype : str or dtype object, optional
    By default, the data-type is inferred from the input data.

Returns
-------
out : ndarray
    The input `a` in Fortran, or column-major, order.

See Also
--------
ascontiguousarray : Convert input to a contiguous (C order) array.
asanyarray : Convert input to an ndarray with either row or
    column-major memory order.
require : Return an ndarray that satisfies requirements.
ndarray.flags : Information about the memory layout of the array.

Examples
--------
>>> x = np.arange(6).reshape(2,3)
>>> y = np.asfortranarray(x)
>>> x.flags['F_CONTIGUOUS']
False
>>> y.flags['F_CONTIGUOUS']
True

Note: This function returns an array with at least one-dimension (1-d) 
so it will not preserve 0-d arrays.  
*)

val asmatrix : ?dtype:Dtype.t -> data:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Interpret the input as a matrix.

Unlike `matrix`, `asmatrix` does not make a copy if the input is already
a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.

Parameters
----------
data : array_like
    Input data.
dtype : data-type
   Data-type of the output matrix.

Returns
-------
mat : matrix
    `data` interpreted as a matrix.

Examples
--------
>>> x = np.array([[1, 2], [3, 4]])

>>> m = np.asmatrix(x)

>>> x[0,0] = 5

>>> m
matrix([[5, 2],
        [3, 4]])
*)

val asscalar : [>`Ndarray] Obj.t -> Py.Object.t
(**
Convert an array of size 1 to its scalar equivalent.

.. deprecated:: 1.16

    Deprecated, use `numpy.ndarray.item()` instead.

Parameters
----------
a : ndarray
    Input array of size 1.

Returns
-------
out : scalar
    Scalar representation of `a`. The output data type is the same type
    returned by the input's `item` method.

Examples
--------
>>> np.asscalar(np.array([24]))
24
*)

val atleast_1d : Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Convert inputs to arrays with at least one dimension.

Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.

Parameters
----------
arys1, arys2, ... : array_like
    One or more input arrays.

Returns
-------
ret : ndarray
    An array, or list of arrays, each with ``a.ndim >= 1``.
    Copies are made only if necessary.

See Also
--------
atleast_2d, atleast_3d

Examples
--------
>>> np.atleast_1d(1.0)
array([1.])

>>> x = np.arange(9.0).reshape(3,3)
>>> np.atleast_1d(x)
array([[0., 1., 2.],
       [3., 4., 5.],
       [6., 7., 8.]])
>>> np.atleast_1d(x) is x
True

>>> np.atleast_1d(1, [3, 4])
[array([1]), array([3, 4])]
*)

val atleast_2d : Py.Object.t list -> Py.Object.t
(**
View inputs as arrays with at least two dimensions.

Parameters
----------
arys1, arys2, ... : array_like
    One or more array-like sequences.  Non-array inputs are converted
    to arrays.  Arrays that already have two or more dimensions are
    preserved.

Returns
-------
res, res2, ... : ndarray
    An array, or list of arrays, each with ``a.ndim >= 2``.
    Copies are avoided where possible, and views with two or more
    dimensions are returned.

See Also
--------
atleast_1d, atleast_3d

Examples
--------
>>> np.atleast_2d(3.0)
array([[3.]])

>>> x = np.arange(3.0)
>>> np.atleast_2d(x)
array([[0., 1., 2.]])
>>> np.atleast_2d(x).base is x
True

>>> np.atleast_2d(1, [1, 2], [[1, 2]])
[array([[1]]), array([[1, 2]]), array([[1, 2]])]
*)

val atleast_3d : Py.Object.t list -> Py.Object.t
(**
View inputs as arrays with at least three dimensions.

Parameters
----------
arys1, arys2, ... : array_like
    One or more array-like sequences.  Non-array inputs are converted to
    arrays.  Arrays that already have three or more dimensions are
    preserved.

Returns
-------
res1, res2, ... : ndarray
    An array, or list of arrays, each with ``a.ndim >= 3``.  Copies are
    avoided where possible, and views with three or more dimensions are
    returned.  For example, a 1-D array of shape ``(N,)`` becomes a view
    of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a
    view of shape ``(M, N, 1)``.

See Also
--------
atleast_1d, atleast_2d

Examples
--------
>>> np.atleast_3d(3.0)
array([[[3.]]])

>>> x = np.arange(3.0)
>>> np.atleast_3d(x).shape
(1, 3, 1)

>>> x = np.arange(12.0).reshape(4,3)
>>> np.atleast_3d(x).shape
(4, 3, 1)
>>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself
True

>>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):
...     print(arr, arr.shape) # doctest: +SKIP
...
[[[1]
  [2]]] (1, 2, 1)
[[[1]
  [2]]] (1, 2, 1)
[[[1 2]]] (1, 1, 2)
*)

val average : ?axis:int list -> ?weights:[>`Ndarray] Obj.t -> ?returned:bool -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the weighted average along the specified axis.

Parameters
----------
a : array_like
    Array containing data to be averaged. If `a` is not an array, a
    conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which to average `a`.  The default,
    axis=None, will average over all of the elements of the input array.
    If axis is negative it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If axis is a tuple of ints, averaging is performed on all of the axes
    specified in the tuple instead of a single axis or all the axes as
    before.
weights : array_like, optional
    An array of weights associated with the values in `a`. Each value in
    `a` contributes to the average according to its associated weight.
    The weights array can either be 1-D (in which case its length must be
    the size of `a` along the given axis) or of the same shape as `a`.
    If `weights=None`, then all data in `a` are assumed to have a
    weight equal to one.  The 1-D calculation is::

        avg = sum(a * weights) / sum(weights)

    The only constraint on `weights` is that `sum(weights)` must not be 0.
returned : bool, optional
    Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)
    is returned, otherwise only the average is returned.
    If `weights=None`, `sum_of_weights` is equivalent to the number of
    elements over which the average is taken.

Returns
-------
retval, [sum_of_weights] : array_type or double
    Return the average along the specified axis. When `returned` is `True`,
    return a tuple with the average as the first element and the sum
    of the weights as the second element. `sum_of_weights` is of the
    same type as `retval`. The result dtype follows a genereal pattern.
    If `weights` is None, the result dtype will be that of `a` , or ``float64``
    if `a` is integral. Otherwise, if `weights` is not None and `a` is non-
    integral, the result type will be the type of lowest precision capable of
    representing values of both `a` and `weights`. If `a` happens to be
    integral, the previous rules still applies but the result dtype will
    at least be ``float64``.

Raises
------
ZeroDivisionError
    When all weights along axis are zero. See `numpy.ma.average` for a
    version robust to this type of error.
TypeError
    When the length of 1D `weights` is not the same as the shape of `a`
    along axis.

See Also
--------
mean

ma.average : average for masked arrays -- useful if your data contains
             'missing' values
numpy.result_type : Returns the type that results from applying the
                    numpy type promotion rules to the arguments.

Examples
--------
>>> data = np.arange(1, 5)
>>> data
array([1, 2, 3, 4])
>>> np.average(data)
2.5
>>> np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))
4.0

>>> data = np.arange(6).reshape((3,2))
>>> data
array([[0, 1],
       [2, 3],
       [4, 5]])
>>> np.average(data, axis=1, weights=[1./4, 3./4])
array([0.75, 2.75, 4.75])
>>> np.average(data, weights=[1./4, 3./4])
Traceback (most recent call last):
    ...
TypeError: Axis must be specified when shapes of a and weights differ.

>>> a = np.ones(5, dtype=np.float128)
>>> w = np.ones(5, dtype=np.complex64)
>>> avg = np.average(a, weights=w)
>>> print(avg.dtype)
complex256
*)

val bartlett : int -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the Bartlett window.

The Bartlett window is very similar to a triangular window, except
that the end points are at zero.  It is often used in signal
processing for tapering a signal, without generating too much
ripple in the frequency domain.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : array
    The triangular window, with the maximum value normalized to one
    (the value one appears only if the number of samples is odd), with
    the first and last samples equal to zero.

See Also
--------
blackman, hamming, hanning, kaiser

Notes
-----
The Bartlett window is defined as

.. math:: w(n) = \frac{2}{M-1} \left(
          \frac{M-1}{2} - \left|n - \frac{M-1}{2}\right|
          \right)

Most references to the Bartlett window come from the signal
processing literature, where it is used as one of many windowing
functions for smoothing values.  Note that convolution with this
window produces linear interpolation.  It is also known as an
apodization (which means'removing the foot', i.e. smoothing
discontinuities at the beginning and end of the sampled signal) or
tapering function. The fourier transform of the Bartlett is the product
of two sinc functions.
Note the excellent discussion in Kanasewich.

References
----------
.. [1] M.S. Bartlett, 'Periodogram Analysis and Continuous Spectra',
       Biometrika 37, 1-16, 1950.
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics',
       The University of Alberta Press, 1975, pp. 109-110.
.. [3] A.V. Oppenheim and R.W. Schafer, 'Discrete-Time Signal
       Processing', Prentice-Hall, 1999, pp. 468-471.
.. [4] Wikipedia, 'Window function',
       https://en.wikipedia.org/wiki/Window_function
.. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       'Numerical Recipes', Cambridge University Press, 1986, page 429.

Examples
--------
>>> import matplotlib.pyplot as plt
>>> np.bartlett(12)
array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary
        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,
        0.18181818,  0.        ])

Plot the window and its frequency response (requires SciPy and matplotlib):

>>> from numpy.fft import fft, fftshift
>>> window = np.bartlett(51)
>>> plt.plot(window)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title('Bartlett window')
Text(0.5, 1.0, 'Bartlett window')
>>> plt.ylabel('Amplitude')
Text(0, 0.5, 'Amplitude')
>>> plt.xlabel('Sample')
Text(0.5, 0, 'Sample')
>>> plt.show()

>>> plt.figure()
<Figure size 640x480 with 0 Axes>
>>> A = fft(window, 2048) / 25.5
>>> mag = np.abs(fftshift(A))
>>> freq = np.linspace(-0.5, 0.5, len(A))
>>> with np.errstate(divide='ignore', invalid='ignore'):
...     response = 20 * np.log10(mag)
...
>>> response = np.clip(response, -100, 100)
>>> plt.plot(freq, response)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title('Frequency response of Bartlett window')
Text(0.5, 1.0, 'Frequency response of Bartlett window')
>>> plt.ylabel('Magnitude [dB]')
Text(0, 0.5, 'Magnitude [dB]')
>>> plt.xlabel('Normalized frequency [cycles per sample]')
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
>>> _ = plt.axis('tight')
>>> plt.show()
*)

val base_repr : ?base:int -> ?padding:int -> number:int -> unit -> string
(**
Return a string representation of a number in the given base system.

Parameters
----------
number : int
    The value to convert. Positive and negative values are handled.
base : int, optional
    Convert `number` to the `base` number system. The valid range is 2-36,
    the default value is 2.
padding : int, optional
    Number of zeros padded on the left. Default is 0 (no padding).

Returns
-------
out : str
    String representation of `number` in `base` system.

See Also
--------
binary_repr : Faster version of `base_repr` for base 2.

Examples
--------
>>> np.base_repr(5)
'101'
>>> np.base_repr(6, 5)
'11'
>>> np.base_repr(7, base=5, padding=3)
'00012'

>>> np.base_repr(10, base=16)
'A'
>>> np.base_repr(32, base=16)
'20'
*)

val binary_repr : ?width:int -> num:int -> unit -> string
(**
Return the binary representation of the input number as a string.

For negative numbers, if width is not given, a minus sign is added to the
front. If width is given, the two's complement of the number is
returned, with respect to that width.

In a two's-complement system negative numbers are represented by the two's
complement of the absolute value. This is the most common method of
representing signed integers on computers [1]_. A N-bit two's-complement
system can represent every integer in the range
:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.

Parameters
----------
num : int
    Only an integer decimal number can be used.
width : int, optional
    The length of the returned string if `num` is positive, or the length
    of the two's complement if `num` is negative, provided that `width` is
    at least a sufficient number of bits for `num` to be represented in the
    designated form.

    If the `width` value is insufficient, it will be ignored, and `num` will
    be returned in binary (`num` > 0) or two's complement (`num` < 0) form
    with its width equal to the minimum number of bits needed to represent
    the number in the designated form. This behavior is deprecated and will
    later raise an error.

    .. deprecated:: 1.12.0

Returns
-------
bin : str
    Binary representation of `num` or two's complement of `num`.

See Also
--------
base_repr: Return a string representation of a number in the given base
           system.
bin: Python's built-in binary representation generator of an integer.

Notes
-----
`binary_repr` is equivalent to using `base_repr` with base 2, but about 25x
faster.

References
----------
.. [1] Wikipedia, 'Two's complement',
    https://en.wikipedia.org/wiki/Two's_complement

Examples
--------
>>> np.binary_repr(3)
'11'
>>> np.binary_repr(-3)
'-11'
>>> np.binary_repr(3, width=4)
'0011'

The two's complement is returned when the input number is negative and
width is specified:

>>> np.binary_repr(-3, width=3)
'101'
>>> np.binary_repr(-3, width=5)
'11101'
*)

val bincount : ?weights:[>`Ndarray] Obj.t -> ?minlength:int -> [`Ndarray of [>`Ndarray] Obj.t | `PyObject of Py.Object.t] -> Py.Object.t
(**
bincount(x, weights=None, minlength=0)

Count number of occurrences of each value in array of non-negative ints.

The number of bins (of size 1) is one larger than the largest value in
`x`. If `minlength` is specified, there will be at least this number
of bins in the output array (though it will be longer if necessary,
depending on the contents of `x`).
Each bin gives the number of occurrences of its index value in `x`.
If `weights` is specified the input array is weighted by it, i.e. if a
value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead
of ``out[n] += 1``.

Parameters
----------
x : array_like, 1 dimension, nonnegative ints
    Input array.
weights : array_like, optional
    Weights, array of the same shape as `x`.
minlength : int, optional
    A minimum number of bins for the output array.

    .. versionadded:: 1.6.0

Returns
-------
out : ndarray of ints
    The result of binning the input array.
    The length of `out` is equal to ``np.amax(x)+1``.

Raises
------
ValueError
    If the input is not 1-dimensional, or contains elements with negative
    values, or if `minlength` is negative.
TypeError
    If the type of the input is float or complex.

See Also
--------
histogram, digitize, unique

Examples
--------
>>> np.bincount(np.arange(5))
array([1, 1, 1, 1, 1])
>>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))
array([1, 3, 1, 1, 0, 0, 0, 1])

>>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23])
>>> np.bincount(x).size == np.amax(x)+1
True

The input array needs to be of integer dtype, otherwise a
TypeError is raised:

>>> np.bincount(np.arange(5, dtype=float))
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
TypeError: array cannot be safely cast to required type

A possible use of ``bincount`` is to perform sums over
variable-size chunks of an array, using the ``weights`` keyword.

>>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights
>>> x = np.array([0, 1, 1, 2, 2, 2])
>>> np.bincount(x,  weights=w)
array([ 0.3,  0.7,  1.1])
*)

val bitwise_and : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the bit-wise AND of two arrays element-wise.

Computes the bit-wise AND of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``&``.

Parameters
----------
x1, x2 : array_like
    Only integer and boolean types are handled. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Result.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_and
bitwise_or
bitwise_xor
binary_repr :
    Return the binary representation of the input number as a string.

Examples
--------
The number 13 is represented by ``00001101``.  Likewise, 17 is
represented by ``00010001``.  The bit-wise AND of 13 and 17 is
therefore ``000000001``, or 1:

>>> np.bitwise_and(13, 17)
1

>>> np.bitwise_and(14, 13)
12
>>> np.binary_repr(12)
'1100'
>>> np.bitwise_and([14,3], 13)
array([12,  1])

>>> np.bitwise_and([11,7], [4,25])
array([0, 1])
>>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))
array([ 2,  4, 16])
>>> np.bitwise_and([True, True], [False, True])
array([False,  True])
*)

val bitwise_not : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute bit-wise inversion, or bit-wise NOT, element-wise.

Computes the bit-wise NOT of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``~``.

For signed integer inputs, the two's complement is returned.  In a
two's-complement system negative numbers are represented by the two's
complement of the absolute value. This is the most common method of
representing signed integers on computers [1]_. A N-bit
two's-complement system can represent every integer in the range
:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.

Parameters
----------
x : array_like
    Only integer and boolean types are handled.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Result.
    This is a scalar if `x` is a scalar.

See Also
--------
bitwise_and, bitwise_or, bitwise_xor
logical_not
binary_repr :
    Return the binary representation of the input number as a string.

Notes
-----
`bitwise_not` is an alias for `invert`:

>>> np.bitwise_not is np.invert
True

References
----------
.. [1] Wikipedia, 'Two's complement',
    https://en.wikipedia.org/wiki/Two's_complement

Examples
--------
We've seen that 13 is represented by ``00001101``.
The invert or bit-wise NOT of 13 is then:

>>> x = np.invert(np.array(13, dtype=np.uint8))
>>> x
242
>>> np.binary_repr(x, width=8)
'11110010'

The result depends on the bit-width:

>>> x = np.invert(np.array(13, dtype=np.uint16))
>>> x
65522
>>> np.binary_repr(x, width=16)
'1111111111110010'

When using signed integer types the result is the two's complement of
the result for the unsigned type:

>>> np.invert(np.array([13], dtype=np.int8))
array([-14], dtype=int8)
>>> np.binary_repr(-14, width=8)
'11110010'

Booleans are accepted as well:

>>> np.invert(np.array([True, False]))
array([False,  True])
*)

val bitwise_or : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the bit-wise OR of two arrays element-wise.

Computes the bit-wise OR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``|``.

Parameters
----------
x1, x2 : array_like
    Only integer and boolean types are handled. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Result.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_or
bitwise_and
bitwise_xor
binary_repr :
    Return the binary representation of the input number as a string.

Examples
--------
The number 13 has the binaray representation ``00001101``. Likewise,
16 is represented by ``00010000``.  The bit-wise OR of 13 and 16 is
then ``000111011``, or 29:

>>> np.bitwise_or(13, 16)
29
>>> np.binary_repr(29)
'11101'

>>> np.bitwise_or(32, 2)
34
>>> np.bitwise_or([33, 4], 1)
array([33,  5])
>>> np.bitwise_or([33, 4], [1, 2])
array([33,  6])

>>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))
array([  6,   5, 255])
>>> np.array([2, 5, 255]) | np.array([4, 4, 4])
array([  6,   5, 255])
>>> np.bitwise_or(np.array([2, 5, 255, 2147483647], dtype=np.int32),
...               np.array([4, 4, 4, 2147483647], dtype=np.int32))
array([         6,          5,        255, 2147483647])
>>> np.bitwise_or([True, True], [False, True])
array([ True,  True])
*)

val bitwise_xor : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the bit-wise XOR of two arrays element-wise.

Computes the bit-wise XOR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``^``.

Parameters
----------
x1, x2 : array_like
    Only integer and boolean types are handled. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Result.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_xor
bitwise_and
bitwise_or
binary_repr :
    Return the binary representation of the input number as a string.

Examples
--------
The number 13 is represented by ``00001101``. Likewise, 17 is
represented by ``00010001``.  The bit-wise XOR of 13 and 17 is
therefore ``00011100``, or 28:

>>> np.bitwise_xor(13, 17)
28
>>> np.binary_repr(28)
'11100'

>>> np.bitwise_xor(31, 5)
26
>>> np.bitwise_xor([31,3], 5)
array([26,  6])

>>> np.bitwise_xor([31,3], [5,6])
array([26,  5])
>>> np.bitwise_xor([True, True], [False, True])
array([ True, False])
*)

val blackman : int -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the Blackman window.

The Blackman window is a taper formed by using the first three
terms of a summation of cosines. It was designed to have close to the
minimal leakage possible.  It is close to optimal, only slightly worse
than a Kaiser window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.

Returns
-------
out : ndarray
    The window, with the maximum value normalized to one (the value one
    appears only if the number of samples is odd).

See Also
--------
bartlett, hamming, hanning, kaiser

Notes
-----
The Blackman window is defined as

.. math::  w(n) = 0.42 - 0.5 \cos(2\pi n/M) + 0.08 \cos(4\pi n/M)

Most references to the Blackman window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function. It is known as a
'near optimal' tapering function, almost as good (by some measures)
as the kaiser window.

References
----------
Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,
Dover Publications, New York.

Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.

Examples
--------
>>> import matplotlib.pyplot as plt
>>> np.blackman(12)
array([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary
        4.14397981e-01,   7.36045180e-01,   9.67046769e-01,
        9.67046769e-01,   7.36045180e-01,   4.14397981e-01,
        1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])

Plot the window and the frequency response:

>>> from numpy.fft import fft, fftshift
>>> window = np.blackman(51)
>>> plt.plot(window)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title('Blackman window')
Text(0.5, 1.0, 'Blackman window')
>>> plt.ylabel('Amplitude')
Text(0, 0.5, 'Amplitude')
>>> plt.xlabel('Sample')
Text(0.5, 0, 'Sample')
>>> plt.show()

>>> plt.figure()
<Figure size 640x480 with 0 Axes>
>>> A = fft(window, 2048) / 25.5
>>> mag = np.abs(fftshift(A))
>>> freq = np.linspace(-0.5, 0.5, len(A))
>>> with np.errstate(divide='ignore', invalid='ignore'):
...     response = 20 * np.log10(mag)
...
>>> response = np.clip(response, -100, 100)
>>> plt.plot(freq, response)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title('Frequency response of Blackman window')
Text(0.5, 1.0, 'Frequency response of Blackman window')
>>> plt.ylabel('Magnitude [dB]')
Text(0, 0.5, 'Magnitude [dB]')
>>> plt.xlabel('Normalized frequency [cycles per sample]')
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
>>> _ = plt.axis('tight')
>>> plt.show()
*)

val block : Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Assemble an nd-array from nested lists of blocks.

Blocks in the innermost lists are concatenated (see `concatenate`) along
the last dimension (-1), then these are concatenated along the
second-last dimension (-2), and so on until the outermost list is reached.

Blocks can be of any dimension, but will not be broadcasted using the normal
rules. Instead, leading axes of size 1 are inserted, to make ``block.ndim``
the same for all blocks. This is primarily useful for working with scalars,
and means that code like ``np.block([v, 1])`` is valid, where
``v.ndim == 1``.

When the nested list is two levels deep, this allows block matrices to be
constructed from their components.

.. versionadded:: 1.13.0

Parameters
----------
arrays : nested list of array_like or scalars (but not tuples)
    If passed a single ndarray or scalar (a nested list of depth 0), this
    is returned unmodified (and not copied).

    Elements shapes must match along the appropriate axes (without
    broadcasting), but leading 1s will be prepended to the shape as
    necessary to make the dimensions match.

Returns
-------
block_array : ndarray
    The array assembled from the given blocks.

    The dimensionality of the output is equal to the greatest of:
    * the dimensionality of all the inputs
    * the depth to which the input list is nested

Raises
------
ValueError
    * If list depths are mismatched - for instance, ``[[a, b], c]`` is
      illegal, and should be spelt ``[[a, b], [c]]``
    * If lists are empty - for instance, ``[[a, b], []]``

See Also
--------
concatenate : Join a sequence of arrays together.
stack : Stack arrays in sequence along a new dimension.
hstack : Stack arrays in sequence horizontally (column wise).
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
vsplit : Split array into a list of multiple sub-arrays vertically.

Notes
-----

When called with only scalars, ``np.block`` is equivalent to an ndarray
call. So ``np.block([[1, 2], [3, 4]])`` is equivalent to
``np.array([[1, 2], [3, 4]])``.

This function does not enforce that the blocks lie on a fixed grid.
``np.block([[a, b], [c, d]])`` is not restricted to arrays of the form::

    AAAbb
    AAAbb
    cccDD

But is also allowed to produce, for some ``a, b, c, d``::

    AAAbb
    AAAbb
    cDDDD

Since concatenation happens along the last axis first, `block` is _not_
capable of producing the following directly::

    AAAbb
    cccbb
    cccDD

Matlab's 'square bracket stacking', ``[A, B, ...; p, q, ...]``, is
equivalent to ``np.block([[A, B, ...], [p, q, ...]])``.

Examples
--------
The most common use of this function is to build a block matrix

>>> A = np.eye(2) * 2
>>> B = np.eye(3) * 3
>>> np.block([
...     [A,               np.zeros((2, 3))],
...     [np.ones((3, 2)), B               ]
... ])
array([[2., 0., 0., 0., 0.],
       [0., 2., 0., 0., 0.],
       [1., 1., 3., 0., 0.],
       [1., 1., 0., 3., 0.],
       [1., 1., 0., 0., 3.]])

With a list of depth 1, `block` can be used as `hstack`

>>> np.block([1, 2, 3])              # hstack([1, 2, 3])
array([1, 2, 3])

>>> a = np.array([1, 2, 3])
>>> b = np.array([2, 3, 4])
>>> np.block([a, b, 10])             # hstack([a, b, 10])
array([ 1,  2,  3,  2,  3,  4, 10])

>>> A = np.ones((2, 2), int)
>>> B = 2 * A
>>> np.block([A, B])                 # hstack([A, B])
array([[1, 1, 2, 2],
       [1, 1, 2, 2]])

With a list of depth 2, `block` can be used in place of `vstack`:

>>> a = np.array([1, 2, 3])
>>> b = np.array([2, 3, 4])
>>> np.block([[a], [b]])             # vstack([a, b])
array([[1, 2, 3],
       [2, 3, 4]])

>>> A = np.ones((2, 2), int)
>>> B = 2 * A
>>> np.block([[A], [B]])             # vstack([A, B])
array([[1, 1],
       [1, 1],
       [2, 2],
       [2, 2]])

It can also be used in places of `atleast_1d` and `atleast_2d`

>>> a = np.array(0)
>>> b = np.array([1])
>>> np.block([a])                    # atleast_1d(a)
array([0])
>>> np.block([b])                    # atleast_1d(b)
array([1])

>>> np.block([[a]])                  # atleast_2d(a)
array([[0]])
>>> np.block([[b]])                  # atleast_2d(b)
array([[1]])
*)

val bmat : ?ldict:Py.Object.t -> ?gdict:Py.Object.t -> obj:[`Ndarray of [>`Ndarray] Obj.t | `S of string] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Build a matrix object from a string, nested sequence, or array.

Parameters
----------
obj : str or array_like
    Input data. If a string, variables in the current scope may be
    referenced by name.
ldict : dict, optional
    A dictionary that replaces local operands in current frame.
    Ignored if `obj` is not a string or `gdict` is None.
gdict : dict, optional
    A dictionary that replaces global operands in current frame.
    Ignored if `obj` is not a string.

Returns
-------
out : matrix
    Returns a matrix object, which is a specialized 2-D array.

See Also
--------
block :
    A generalization of this function for N-d arrays, that returns normal
    ndarrays.

Examples
--------
>>> A = np.mat('1 1; 1 1')
>>> B = np.mat('2 2; 2 2')
>>> C = np.mat('3 4; 5 6')
>>> D = np.mat('7 8; 9 0')

All the following expressions construct the same block matrix:

>>> np.bmat([[A, B], [C, D]])
matrix([[1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0]])
>>> np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])
matrix([[1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0]])
>>> np.bmat('A,B; C,D')
matrix([[1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0]])
*)

val broadcast_arrays : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
Broadcast any number of arrays against each other.

Parameters
----------
`*args` : array_likes
    The arrays to broadcast.

subok : bool, optional
    If True, then sub-classes will be passed-through, otherwise
    the returned arrays will be forced to be a base-class array (default).

Returns
-------
broadcasted : list of arrays
    These arrays are views on the original arrays.  They are typically
    not contiguous.  Furthermore, more than one element of a
    broadcasted array may refer to a single memory location. If you need
    to write to the arrays, make copies first. While you can set the
    ``writable`` flag True, writing to a single output value may end up
    changing more than one location in the output array.

    .. deprecated:: 1.17
        The output is currently marked so that if written to, a deprecation
        warning will be emitted. A future version will set the
        ``writable`` flag False so writing to it will raise an error.

Examples
--------
>>> x = np.array([[1,2,3]])
>>> y = np.array([[4],[5]])
>>> np.broadcast_arrays(x, y)
[array([[1, 2, 3],
       [1, 2, 3]]), array([[4, 4, 4],
       [5, 5, 5]])]

Here is a useful idiom for getting contiguous copies instead of
non-contiguous views.

>>> [np.array(a) for a in np.broadcast_arrays(x, y)]
[array([[1, 2, 3],
       [1, 2, 3]]), array([[4, 4, 4],
       [5, 5, 5]])]
*)

val broadcast_to : ?subok:bool -> array:[>`Ndarray] Obj.t -> int list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Broadcast an array to a new shape.

Parameters
----------
array : array_like
    The array to broadcast.
shape : tuple
    The shape of the desired array.
subok : bool, optional
    If True, then sub-classes will be passed-through, otherwise
    the returned array will be forced to be a base-class array (default).

Returns
-------
broadcast : array
    A readonly view on the original array with the given shape. It is
    typically not contiguous. Furthermore, more than one element of a
    broadcasted array may refer to a single memory location.

Raises
------
ValueError
    If the array is not compatible with the new shape according to NumPy's
    broadcasting rules.

Notes
-----
.. versionadded:: 1.10.0

Examples
--------
>>> x = np.array([1, 2, 3])
>>> np.broadcast_to(x, (3, 3))
array([[1, 2, 3],
       [1, 2, 3],
       [1, 2, 3]])
*)

val busday_count : ?weekmask:[`Array_like_of_bool of Py.Object.t | `S of string] -> ?holidays:Py.Object.t -> ?busdaycal:Py.Object.t -> ?out:[>`Ndarray] Obj.t -> begindates:Py.Object.t -> enddates:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
busday_count(begindates, enddates, weekmask='1111100', holidays=[], busdaycal=None, out=None)

Counts the number of valid days between `begindates` and
`enddates`, not including the day of `enddates`.

If ``enddates`` specifies a date value that is earlier than the
corresponding ``begindates`` date value, the count will be negative.

.. versionadded:: 1.7.0

Parameters
----------
begindates : array_like of datetime64[D]
    The array of the first dates for counting.
enddates : array_like of datetime64[D]
    The array of the end dates for counting, which are excluded
    from the count themselves.
weekmask : str or array_like of bool, optional
    A seven-element array indicating which of Monday through Sunday are
    valid days. May be specified as a length-seven list or array, like
    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
    like 'Mon Tue Wed Thu Fri', made up of 3-character abbreviations for
    weekdays, optionally separated by white space. Valid abbreviations
    are: Mon Tue Wed Thu Fri Sat Sun
holidays : array_like of datetime64[D], optional
    An array of dates to consider as invalid dates.  They may be
    specified in any order, and NaT (not-a-time) dates are ignored.
    This list is saved in a normalized form that is suited for
    fast calculations of valid days.
busdaycal : busdaycalendar, optional
    A `busdaycalendar` object which specifies the valid days. If this
    parameter is provided, neither weekmask nor holidays may be
    provided.
out : array of int, optional
    If provided, this array is filled with the result.

Returns
-------
out : array of int
    An array with a shape from broadcasting ``begindates`` and ``enddates``
    together, containing the number of valid days between
    the begin and end dates.

See Also
--------
busdaycalendar: An object that specifies a custom set of valid days.
is_busday : Returns a boolean array indicating valid days.
busday_offset : Applies an offset counted in valid days.

Examples
--------
>>> # Number of weekdays in January 2011
... np.busday_count('2011-01', '2011-02')
21
>>> # Number of weekdays in 2011
>>> np.busday_count('2011', '2012')
260
>>> # Number of Saturdays in 2011
... np.busday_count('2011', '2012', weekmask='Sat')
53
*)

val busday_offset : ?roll:[`Raise | `Nat | `Forward | `Following | `Backward | `Preceding | `Modifiedfollowing | `Modifiedpreceding] -> ?weekmask:[`Array_like_of_bool of Py.Object.t | `S of string] -> ?holidays:Py.Object.t -> ?busdaycal:Py.Object.t -> ?out:Py.Object.t -> dates:Py.Object.t -> offsets:Py.Object.t -> unit -> Py.Object.t
(**
busday_offset(dates, offsets, roll='raise', weekmask='1111100', holidays=None, busdaycal=None, out=None)

First adjusts the date to fall on a valid day according to
the ``roll`` rule, then applies offsets to the given dates
counted in valid days.

.. versionadded:: 1.7.0

Parameters
----------
dates : array_like of datetime64[D]
    The array of dates to process.
offsets : array_like of int
    The array of offsets, which is broadcast with ``dates``.
roll : {'raise', 'nat', 'forward', 'following', 'backward', 'preceding', 'modifiedfollowing', 'modifiedpreceding'}, optional
    How to treat dates that do not fall on a valid day. The default
    is 'raise'.

      * 'raise' means to raise an exception for an invalid day.
      * 'nat' means to return a NaT (not-a-time) for an invalid day.
      * 'forward' and 'following' mean to take the first valid day
        later in time.
      * 'backward' and 'preceding' mean to take the first valid day
        earlier in time.
      * 'modifiedfollowing' means to take the first valid day
        later in time unless it is across a Month boundary, in which
        case to take the first valid day earlier in time.
      * 'modifiedpreceding' means to take the first valid day
        earlier in time unless it is across a Month boundary, in which
        case to take the first valid day later in time.
weekmask : str or array_like of bool, optional
    A seven-element array indicating which of Monday through Sunday are
    valid days. May be specified as a length-seven list or array, like
    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
    like 'Mon Tue Wed Thu Fri', made up of 3-character abbreviations for
    weekdays, optionally separated by white space. Valid abbreviations
    are: Mon Tue Wed Thu Fri Sat Sun
holidays : array_like of datetime64[D], optional
    An array of dates to consider as invalid dates.  They may be
    specified in any order, and NaT (not-a-time) dates are ignored.
    This list is saved in a normalized form that is suited for
    fast calculations of valid days.
busdaycal : busdaycalendar, optional
    A `busdaycalendar` object which specifies the valid days. If this
    parameter is provided, neither weekmask nor holidays may be
    provided.
out : array of datetime64[D], optional
    If provided, this array is filled with the result.

Returns
-------
out : array of datetime64[D]
    An array with a shape from broadcasting ``dates`` and ``offsets``
    together, containing the dates with offsets applied.

See Also
--------
busdaycalendar: An object that specifies a custom set of valid days.
is_busday : Returns a boolean array indicating valid days.
busday_count : Counts how many valid days are in a half-open date range.

Examples
--------
>>> # First business day in October 2011 (not accounting for holidays)
... np.busday_offset('2011-10', 0, roll='forward')
numpy.datetime64('2011-10-03')
>>> # Last business day in February 2012 (not accounting for holidays)
... np.busday_offset('2012-03', -1, roll='forward')
numpy.datetime64('2012-02-29')
>>> # Third Wednesday in January 2011
... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')
numpy.datetime64('2011-01-19')
>>> # 2012 Mother's Day in Canada and the U.S.
... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')
numpy.datetime64('2012-05-13')

>>> # First business day on or after a date
... np.busday_offset('2011-03-20', 0, roll='forward')
numpy.datetime64('2011-03-21')
>>> np.busday_offset('2011-03-22', 0, roll='forward')
numpy.datetime64('2011-03-22')
>>> # First business day after a date
... np.busday_offset('2011-03-20', 1, roll='backward')
numpy.datetime64('2011-03-21')
>>> np.busday_offset('2011-03-22', 1, roll='backward')
numpy.datetime64('2011-03-23')
*)

val byte_bounds : [>`Ndarray] Obj.t -> Py.Object.t
(**
Returns pointers to the end-points of an array.

Parameters
----------
a : ndarray
    Input array. It must conform to the Python-side of the array
    interface.

Returns
-------
(low, high) : tuple of 2 integers
    The first integer is the first byte of the array, the second
    integer is just past the last byte of the array.  If `a` is not
    contiguous it will not use every byte between the (`low`, `high`)
    values.

Examples
--------
>>> I = np.eye(2, dtype='f'); I.dtype
dtype('float32')
>>> low, high = np.byte_bounds(I)
>>> high - low == I.size*I.itemsize
True
>>> I = np.eye(2); I.dtype
dtype('float64')
>>> low, high = np.byte_bounds(I)
>>> high - low == I.size*I.itemsize
True
*)

val can_cast : ?casting:[`No | `Equiv | `Safe | `Same_kind | `Unsafe] -> from_:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `F of float | `Dtype_specifier of Py.Object.t | `Bool of bool | `Dtype of Dtype.t | `S of string] -> to_:[`Dtype_specifier of Py.Object.t | `Dtype of Dtype.t] -> unit -> bool
(**
can_cast(from_, to, casting='safe')

Returns True if cast between data types can occur according to the
casting rule.  If from is a scalar or array scalar, also returns
True if the scalar value can be cast without overflow or truncation
to an integer.

Parameters
----------
from_ : dtype, dtype specifier, scalar, or array
    Data type, scalar, or array to cast from.
to : dtype or dtype specifier
    Data type to cast to.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.

Returns
-------
out : bool
    True if cast can occur according to the casting rule.

Notes
-----
.. versionchanged:: 1.17.0
   Casting between a simple data type and a structured one is possible only
   for 'unsafe' casting.  Casting to multiple fields is allowed, but
   casting from multiple fields is not.

.. versionchanged:: 1.9.0
   Casting from numeric to string types in 'safe' casting mode requires
   that the string dtype length is long enough to store the maximum
   integer/float value converted.

See also
--------
dtype, result_type

Examples
--------
Basic examples

>>> np.can_cast(np.int32, np.int64)
True
>>> np.can_cast(np.float64, complex)
True
>>> np.can_cast(complex, float)
False

>>> np.can_cast('i8', 'f8')
True
>>> np.can_cast('i8', 'f4')
False
>>> np.can_cast('i4', 'S4')
False

Casting scalars

>>> np.can_cast(100, 'i1')
True
>>> np.can_cast(150, 'i1')
False
>>> np.can_cast(150, 'u1')
True

>>> np.can_cast(3.5e100, np.float32)
False
>>> np.can_cast(1000.0, np.float32)
True

Array scalar checks the value, array does not

>>> np.can_cast(np.array(1000.0), np.float32)
True
>>> np.can_cast(np.array([1000.0]), np.float32)
False

Using the casting rules

>>> np.can_cast('i8', 'i8', 'no')
True
>>> np.can_cast('<i8', '>i8', 'no')
False

>>> np.can_cast('<i8', '>i8', 'equiv')
True
>>> np.can_cast('<i4', '>i8', 'equiv')
False

>>> np.can_cast('<i4', '>i8', 'safe')
True
>>> np.can_cast('<i8', '>i4', 'safe')
False

>>> np.can_cast('<i8', '>i4', 'same_kind')
True
>>> np.can_cast('<i8', '>u4', 'same_kind')
False

>>> np.can_cast('<i8', '>u4', 'unsafe')
True
*)

val cbrt : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the cube-root of an array, element-wise.

.. versionadded:: 1.10.0

Parameters
----------
x : array_like
    The values whose cube-roots are required.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    An array of the same shape as `x`, containing the cube
    cube-root of each element in `x`.
    If `out` was provided, `y` is a reference to it.
    This is a scalar if `x` is a scalar.


Examples
--------
>>> np.cbrt([1,8,27])
array([ 1.,  2.,  3.])
*)

val ceil : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the ceiling of the input, element-wise.

The ceil of the scalar `x` is the smallest integer `i`, such that
`i >= x`.  It is often denoted as :math:`\lceil x \rceil`.

Parameters
----------
x : array_like
    Input data.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The ceiling of each element in `x`, with `float` dtype.
    This is a scalar if `x` is a scalar.

See Also
--------
floor, trunc, rint

Examples
--------
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.ceil(a)
array([-1., -1., -0.,  1.,  2.,  2.,  2.])
*)

val choose : ?out:[>`Ndarray] Obj.t -> ?mode:[`Raise | `Wrap | `Clip] -> choices:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Construct an array from an index array and a set of arrays to choose from.

First of all, if confused or uncertain, definitely look at the Examples -
in its full generality, this function is less simple than it might
seem from the following code description (below ndi =
`numpy.lib.index_tricks`):

``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.

But this omits some subtleties.  Here is a fully general summary:

Given an 'index' array (`a`) of integers and a sequence of `n` arrays
(`choices`), `a` and each choice array are first broadcast, as necessary,
to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =
0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``
for each `i`.  Then, a new array with shape ``Ba.shape`` is created as
follows:

* if ``mode=raise`` (the default), then, first of all, each element of
  `a` (and thus `Ba`) must be in the range `[0, n-1]`; now, suppose that
  `i` (in that range) is the value at the `(j0, j1, ..., jm)` position
  in `Ba` - then the value at the same position in the new array is the
  value in `Bchoices[i]` at that same position;

* if ``mode=wrap``, values in `a` (and thus `Ba`) may be any (signed)
  integer; modular arithmetic is used to map integers outside the range
  `[0, n-1]` back into that range; and then the new array is constructed
  as above;

* if ``mode=clip``, values in `a` (and thus `Ba`) may be any (signed)
  integer; negative integers are mapped to 0; values greater than `n-1`
  are mapped to `n-1`; and then the new array is constructed as above.

Parameters
----------
a : int array
    This array must contain integers in `[0, n-1]`, where `n` is the number
    of choices, unless ``mode=wrap`` or ``mode=clip``, in which cases any
    integers are permissible.
choices : sequence of arrays
    Choice arrays. `a` and all of the choices must be broadcastable to the
    same shape.  If `choices` is itself an array (not recommended), then
    its outermost dimension (i.e., the one corresponding to
    ``choices.shape[0]``) is taken as defining the 'sequence'.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and dtype. Note that `out` is always
    buffered if `mode='raise'`; use other modes for better performance.
mode : {'raise' (default), 'wrap', 'clip'}, optional
    Specifies how indices outside `[0, n-1]` will be treated:

      * 'raise' : an exception is raised
      * 'wrap' : value becomes value mod `n`
      * 'clip' : values < 0 are mapped to 0, values > n-1 are mapped to n-1

Returns
-------
merged_array : array
    The merged result.

Raises
------
ValueError: shape mismatch
    If `a` and each choice array are not all broadcastable to the same
    shape.

See Also
--------
ndarray.choose : equivalent method
numpy.take_along_axis : Preferable if `choices` is an array

Notes
-----
To reduce the chance of misinterpretation, even though the following
'abuse' is nominally supported, `choices` should neither be, nor be
thought of as, a single array, i.e., the outermost sequence-like container
should be either a list or a tuple.

Examples
--------

>>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],
...   [20, 21, 22, 23], [30, 31, 32, 33]]
>>> np.choose([2, 3, 1, 0], choices
... # the first element of the result will be the first element of the
... # third (2+1) 'array' in choices, namely, 20; the second element
... # will be the second element of the fourth (3+1) choice array, i.e.,
... # 31, etc.
... )
array([20, 31, 12,  3])
>>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)
array([20, 31, 12,  3])
>>> # because there are 4 choice arrays
>>> np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)
array([20,  1, 12,  3])
>>> # i.e., 0

A couple examples illustrating how choose broadcasts:

>>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]
>>> choices = [-10, 10]
>>> np.choose(a, choices)
array([[ 10, -10,  10],
       [-10,  10, -10],
       [ 10, -10,  10]])

>>> # With thanks to Anne Archibald
>>> a = np.array([0, 1]).reshape((2,1,1))
>>> c1 = np.array([1, 2, 3]).reshape((1,3,1))
>>> c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))
>>> np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2
array([[[ 1,  1,  1,  1,  1],
        [ 2,  2,  2,  2,  2],
        [ 3,  3,  3,  3,  3]],
       [[-1, -2, -3, -4, -5],
        [-1, -2, -3, -4, -5],
        [-1, -2, -3, -4, -5]]])
*)

val clip : ?out:[>`Ndarray] Obj.t -> ?kwargs:(string * Py.Object.t) list -> a_min:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string | `None] -> a_max:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string | `None] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Clip (limit) the values in an array.

Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of ``[0, 1]``
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.

Equivalent to but faster than ``np.maximum(a_min, np.minimum(a, a_max))``.
No check is performed to ensure ``a_min < a_max``.

Parameters
----------
a : array_like
    Array containing elements to clip.
a_min : scalar or array_like or None
    Minimum value. If None, clipping is not performed on lower
    interval edge. Not more than one of `a_min` and `a_max` may be
    None.
a_max : scalar or array_like or None
    Maximum value. If None, clipping is not performed on upper
    interval edge. Not more than one of `a_min` and `a_max` may be
    None. If `a_min` or `a_max` are array_like, then the three
    arrays will be broadcasted to match their shapes.
out : ndarray, optional
    The results will be placed in this array. It may be the input
    array for in-place clipping.  `out` must be of the right shape
    to hold the output.  Its type is preserved.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

    .. versionadded:: 1.17.0

Returns
-------
clipped_array : ndarray
    An array with the elements of `a`, but where values
    < `a_min` are replaced with `a_min`, and those > `a_max`
    with `a_max`.

See Also
--------
ufuncs-output-type

Examples
--------
>>> a = np.arange(10)
>>> np.clip(a, 1, 8)
array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.clip(a, 3, 6, out=a)
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])
*)

val column_stack : Py.Object.t -> Py.Object.t
(**
Stack 1-D arrays as columns into a 2-D array.

Take a sequence of 1-D arrays and stack them as columns
to make a single 2-D array. 2-D arrays are stacked as-is,
just like with `hstack`.  1-D arrays are turned into 2-D columns
first.

Parameters
----------
tup : sequence of 1-D or 2-D arrays.
    Arrays to stack. All of them must have the same first dimension.

Returns
-------
stacked : 2-D array
    The array formed by stacking the given arrays.

See Also
--------
stack, hstack, vstack, concatenate

Examples
--------
>>> a = np.array((1,2,3))
>>> b = np.array((2,3,4))
>>> np.column_stack((a,b))
array([[1, 2],
       [2, 3],
       [3, 4]])
*)

val common_type : Py.Object.t list -> Py.Object.t
(**
Return a scalar type which is common to the input arrays.

The return type will always be an inexact (i.e. floating point) scalar
type, even if all the arrays are integer arrays. If one of the inputs is
an integer array, the minimum precision type that is returned is a
64-bit floating point dtype.

All input arrays except int64 and uint64 can be safely cast to the
returned dtype without loss of information.

Parameters
----------
array1, array2, ... : ndarrays
    Input arrays.

Returns
-------
out : data type code
    Data type code.

See Also
--------
dtype, mintypecode

Examples
--------
>>> np.common_type(np.arange(2, dtype=np.float32))
<class 'numpy.float32'>
>>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))
<class 'numpy.float64'>
>>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))
<class 'numpy.complex128'>
*)

val compare_chararrays : b:Py.Object.t -> cmp_op:[`Lt | `Lte | `Eq | `Gte | `Gt | `Neq] -> rstrip:bool -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
compare_chararrays(a, b, cmp_op, rstrip)

Performs element-wise comparison of two string arrays using the
comparison operator specified by `cmp_op`.

Parameters
----------
a, b : array_like
    Arrays to be compared.
cmp_op : {'<', '<=', '==', '>=', '>', '!='}
    Type of comparison.
rstrip : Boolean
    If True, the spaces at the end of Strings are removed before the comparison.

Returns
-------
out : ndarray
    The output array of type Boolean with the same shape as a and b.

Raises
------
ValueError
    If `cmp_op` is not valid.
TypeError
    If at least one of `a` or `b` is a non-string array

Examples
--------
>>> a = np.array(['a', 'b', 'cde'])
>>> b = np.array(['a', 'a', 'dec'])
>>> np.compare_chararrays(a, b, '>', True)
array([False,  True, False])
*)

val compress : ?axis:int -> ?out:[>`Ndarray] Obj.t -> condition:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return selected slices of an array along given axis.

When working along a given axis, a slice along that axis is returned in
`output` for each index where `condition` evaluates to True. When
working on a 1-D array, `compress` is equivalent to `extract`.

Parameters
----------
condition : 1-D array of bools
    Array that selects which entries to return. If len(condition)
    is less than the size of `a` along the given axis, then output is
    truncated to the length of the condition array.
a : array_like
    Array from which to extract a part.
axis : int, optional
    Axis along which to take slices. If None (default), work on the
    flattened array.
out : ndarray, optional
    Output array.  Its type is preserved and it must be of the right
    shape to hold the output.

Returns
-------
compressed_array : ndarray
    A copy of `a` without the slices along axis for which `condition`
    is false.

See Also
--------
take, choose, diag, diagonal, select
ndarray.compress : Equivalent method in ndarray
np.extract: Equivalent method when working on 1-D arrays
ufuncs-output-type

Examples
--------
>>> a = np.array([[1, 2], [3, 4], [5, 6]])
>>> a
array([[1, 2],
       [3, 4],
       [5, 6]])
>>> np.compress([0, 1], a, axis=0)
array([[3, 4]])
>>> np.compress([False, True, True], a, axis=0)
array([[3, 4],
       [5, 6]])
>>> np.compress([False, True], a, axis=1)
array([[2],
       [4],
       [6]])

Working on the flattened array does not return slices along an axis but
selects elements.

>>> np.compress([False, True], a)
array([2])
*)

val concatenate : ?axis:int -> ?out:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
concatenate((a1, a2, ...), axis=0, out=None)

Join a sequence of arrays along an existing axis.

Parameters
----------
a1, a2, ... : sequence of array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int, optional
    The axis along which the arrays will be joined.  If axis is None,
    arrays are flattened before use.  Default is 0.
out : ndarray, optional
    If provided, the destination to place the result. The shape must be
    correct, matching that of what concatenate would have returned if no
    out argument were specified.

Returns
-------
res : ndarray
    The concatenated array.

See Also
--------
ma.concatenate : Concatenate function that preserves input masks.
array_split : Split an array into multiple sub-arrays of equal or
              near-equal size.
split : Split array into a list of multiple sub-arrays of equal size.
hsplit : Split array into multiple sub-arrays horizontally (column wise)
vsplit : Split array into multiple sub-arrays vertically (row wise)
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
stack : Stack a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise)
vstack : Stack arrays in sequence vertically (row wise)
dstack : Stack arrays in sequence depth wise (along third dimension)
block : Assemble arrays from blocks.

Notes
-----
When one or more of the arrays to be concatenated is a MaskedArray,
this function will return a MaskedArray object instead of an ndarray,
but the input masks are *not* preserved. In cases where a MaskedArray
is expected as input, use the ma.concatenate function from the masked
array module instead.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> b = np.array([[5, 6]])
>>> np.concatenate((a, b), axis=0)
array([[1, 2],
       [3, 4],
       [5, 6]])
>>> np.concatenate((a, b.T), axis=1)
array([[1, 2, 5],
       [3, 4, 6]])
>>> np.concatenate((a, b), axis=None)
array([1, 2, 3, 4, 5, 6])

This function will not preserve masking of MaskedArray inputs.

>>> a = np.ma.arange(3)
>>> a[1] = np.ma.masked
>>> b = np.arange(2, 5)
>>> a
masked_array(data=[0, --, 2],
             mask=[False,  True, False],
       fill_value=999999)
>>> b
array([2, 3, 4])
>>> np.concatenate([a, b])
masked_array(data=[0, 1, 2, 2, 3, 4],
             mask=False,
       fill_value=999999)
>>> np.ma.concatenate([a, b])
masked_array(data=[0, --, 2, 2, 3, 4],
             mask=[False,  True, False, False, False, False],
       fill_value=999999)
*)

val conj : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the complex conjugate, element-wise.

The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.

Parameters
----------
x : array_like
    Input value.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The complex conjugate of `x`, with same dtype as `y`.
    This is a scalar if `x` is a scalar.

Notes
-----
`conj` is an alias for `conjugate`:

>>> np.conj is np.conjugate
True

Examples
--------
>>> np.conjugate(1+2j)
(1-2j)

>>> x = np.eye(2) + 1j * np.eye(2)
>>> np.conjugate(x)
array([[ 1.-1.j,  0.-0.j],
       [ 0.-0.j,  1.-1.j]])
*)

val conjugate : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the complex conjugate, element-wise.

The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.

Parameters
----------
x : array_like
    Input value.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The complex conjugate of `x`, with same dtype as `y`.
    This is a scalar if `x` is a scalar.

Notes
-----
`conj` is an alias for `conjugate`:

>>> np.conj is np.conjugate
True

Examples
--------
>>> np.conjugate(1+2j)
(1-2j)

>>> x = np.eye(2) + 1j * np.eye(2)
>>> np.conjugate(x)
array([[ 1.-1.j,  0.-0.j],
       [ 0.-0.j,  1.-1.j]])
*)

val convolve : ?mode:[`Full | `Valid | `Same] -> v:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Returns the discrete, linear convolution of two one-dimensional sequences.

The convolution operator is often seen in signal processing, where it
models the effect of a linear time-invariant system on a signal [1]_.  In
probability theory, the sum of two independent random variables is
distributed according to the convolution of their individual
distributions.

If `v` is longer than `a`, the arrays are swapped before computation.

Parameters
----------
a : (N,) array_like
    First one-dimensional input array.
v : (M,) array_like
    Second one-dimensional input array.
mode : {'full', 'valid', 'same'}, optional
    'full':
      By default, mode is 'full'.  This returns the convolution
      at each point of overlap, with an output shape of (N+M-1,). At
      the end-points of the convolution, the signals do not overlap
      completely, and boundary effects may be seen.

    'same':
      Mode 'same' returns output of length ``max(M, N)``.  Boundary
      effects are still visible.

    'valid':
      Mode 'valid' returns output of length
      ``max(M, N) - min(M, N) + 1``.  The convolution product is only given
      for points where the signals overlap completely.  Values outside
      the signal boundary have no effect.

Returns
-------
out : ndarray
    Discrete, linear convolution of `a` and `v`.

See Also
--------
scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier
                           Transform.
scipy.linalg.toeplitz : Used to construct the convolution operator.
polymul : Polynomial multiplication. Same output as convolve, but also
          accepts poly1d objects as input.

Notes
-----
The discrete convolution operation is defined as

.. math:: (a * v)[n] = \sum_{m = -\infty}^{\infty} a[m] v[n - m]

It can be shown that a convolution :math:`x(t) * y(t)` in time/space
is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier
domain, after appropriate padding (padding is necessary to prevent
circular convolution).  Since multiplication is more efficient (faster)
than convolution, the function `scipy.signal.fftconvolve` exploits the
FFT to calculate the convolution of large data-sets.

References
----------
.. [1] Wikipedia, 'Convolution',
    https://en.wikipedia.org/wiki/Convolution

Examples
--------
Note how the convolution operator flips the second array
before 'sliding' the two across one another:

>>> np.convolve([1, 2, 3], [0, 1, 0.5])
array([0. , 1. , 2.5, 4. , 1.5])

Only return the middle values of the convolution.
Contains boundary effects, where zeros are taken
into account:

>>> np.convolve([1,2,3],[0,1,0.5], 'same')
array([1. ,  2.5,  4. ])

The two arrays are of the same length, so there
is only one position where they completely overlap:

>>> np.convolve([1,2,3],[0,1,0.5], 'valid')
array([2.5])
*)

val copy : ?order:[`C | `F | `A | `K] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an array copy of the given object.

Parameters
----------
a : array_like
    Input data.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout of the copy. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible. (Note that this function and :meth:`ndarray.copy` are very
    similar, but have different default values for their order=
    arguments.)

Returns
-------
arr : ndarray
    Array interpretation of `a`.

Notes
-----
This is equivalent to:

>>> np.array(a, copy=True)  #doctest: +SKIP

Examples
--------
Create an array x, with a reference y and a copy z:

>>> x = np.array([1, 2, 3])
>>> y = x
>>> z = np.copy(x)

Note that, when we modify x, y changes, but not z:

>>> x[0] = 10
>>> x[0] == y[0]
True
>>> x[0] == z[0]
False
*)

val copysign : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
copysign(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Change the sign of x1 to that of x2, element-wise.

If `x2` is a scalar, its sign will be copied to all elements of `x1`.

Parameters
----------
x1 : array_like
    Values to change the sign of.
x2 : array_like
    The sign of `x2` is copied to `x1`. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    The values of `x1` with the sign of `x2`.
    This is a scalar if both `x1` and `x2` are scalars.

Examples
--------
>>> np.copysign(1.3, -1)
-1.3
>>> 1/np.copysign(0, 1)
inf
>>> 1/np.copysign(0, -1)
-inf

>>> np.copysign([-1, 0, 1], -1.1)
array([-1., -0., -1.])
>>> np.copysign([-1, 0, 1], np.arange(3)-1)
array([-1.,  0.,  1.])
*)

val copyto : ?casting:[`No | `Equiv | `Safe | `Same_kind | `Unsafe] -> ?where:Py.Object.t -> dst:[>`Ndarray] Obj.t -> src:[>`Ndarray] Obj.t -> unit -> Py.Object.t
(**
copyto(dst, src, casting='same_kind', where=True)

Copies values from one array to another, broadcasting as necessary.

Raises a TypeError if the `casting` rule is violated, and if
`where` is provided, it selects which elements to copy.

.. versionadded:: 1.7.0

Parameters
----------
dst : ndarray
    The array into which values are copied.
src : array_like
    The array from which values are copied.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur when copying.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.
where : array_like of bool, optional
    A boolean array which is broadcasted to match the dimensions
    of `dst`, and selects elements to copy from `src` to `dst`
    wherever it contains the value True.
*)

val corrcoef : ?y:[>`Ndarray] Obj.t -> ?rowvar:bool -> ?bias:Py.Object.t -> ?ddof:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return Pearson product-moment correlation coefficients.

Please refer to the documentation for `cov` for more detail.  The
relationship between the correlation coefficient matrix, `R`, and the
covariance matrix, `C`, is

.. math:: R_{ij} = \frac{ C_{ij} } { \sqrt{ C_{ii} * C_{jj} } }

The values of `R` are between -1 and 1, inclusive.

Parameters
----------
x : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `x` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same
    shape as `x`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.10.0
ddof : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.10.0

Returns
-------
R : ndarray
    The correlation coefficient matrix of the variables.

See Also
--------
cov : Covariance matrix

Notes
-----
Due to floating point rounding the resulting array may not be Hermitian,
the diagonal elements may not be 1, and the elements may not satisfy the
inequality abs(a) <= 1. The real and imaginary parts are clipped to the
interval [-1,  1] in an attempt to improve on that situation but is not
much help in the complex case.

This function accepts but discards arguments `bias` and `ddof`.  This is
for backwards compatibility with previous versions of this function.  These
arguments had no effect on the return values of the function and can be
safely ignored in this and previous versions of numpy.
*)

val correlate : ?mode:[`Valid | `Same | `Full] -> v:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Cross-correlation of two 1-dimensional sequences.

This function computes the correlation as generally defined in signal
processing texts::

    c_{av}[k] = sum_n a[n+k] * conj(v[n])

with a and v sequences being zero-padded where necessary and conj being
the conjugate.

Parameters
----------
a, v : array_like
    Input sequences.
mode : {'valid', 'same', 'full'}, optional
    Refer to the `convolve` docstring.  Note that the default
    is 'valid', unlike `convolve`, which uses 'full'.
old_behavior : bool
    `old_behavior` was removed in NumPy 1.10. If you need the old
    behavior, use `multiarray.correlate`.

Returns
-------
out : ndarray
    Discrete cross-correlation of `a` and `v`.

See Also
--------
convolve : Discrete, linear convolution of two one-dimensional sequences.
multiarray.correlate : Old, no conjugate, version of correlate.

Notes
-----
The definition of correlation above is not unique and sometimes correlation
may be defined differently. Another common definition is::

    c'_{av}[k] = sum_n a[n] conj(v[n+k])

which is related to ``c_{av}[k]`` by ``c'_{av}[k] = c_{av}[-k]``.

Examples
--------
>>> np.correlate([1, 2, 3], [0, 1, 0.5])
array([3.5])
>>> np.correlate([1, 2, 3], [0, 1, 0.5], 'same')
array([2. ,  3.5,  3. ])
>>> np.correlate([1, 2, 3], [0, 1, 0.5], 'full')
array([0.5,  2. ,  3.5,  3. ,  0. ])

Using complex sequences:

>>> np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')
array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])

Note that you get the time reversed, complex conjugated result
when the two input sequences change places, i.e.,
``c_{va}[k] = c^{*}_{av}[-k]``:

>>> np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')
array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])
*)

val cos : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Cosine element-wise.

Parameters
----------
x : array_like
    Input array in radians.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding cosine values.
    This is a scalar if `x` is a scalar.

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.

Examples
--------
>>> np.cos(np.array([0, np.pi/2, np.pi]))
array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])
>>>
>>> # Example of providing the optional output parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.cos([0.1], out1)
>>> out2 is out1
True
>>>
>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
*)

val cosh : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Hyperbolic cosine, element-wise.

Equivalent to ``1/2 * (np.exp(x) + np.exp(-x))`` and ``np.cos(1j*x)``.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array of same shape as `x`.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> np.cosh(0)
1.0

The hyperbolic cosine describes the shape of a hanging cable:

>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-4, 4, 1000)
>>> plt.plot(x, np.cosh(x))
>>> plt.show()
*)

val count_nonzero : ?axis:[`Tuple of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Counts the number of non-zero values in the array ``a``.

The word 'non-zero' is in reference to the Python 2.x
built-in method ``__nonzero__()`` (renamed ``__bool__()``
in Python 3.x) of Python objects that tests an object's
'truthfulness'. For example, any number is considered
truthful if it is nonzero, whereas any string is considered
truthful if it is not the empty string. Thus, this function
(recursively) counts how many elements in ``a`` (and in
sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``
method evaluated to ``True``.

Parameters
----------
a : array_like
    The array for which to count non-zeros.
axis : int or tuple, optional
    Axis or tuple of axes along which to count non-zeros.
    Default is None, meaning that non-zeros will be counted
    along a flattened version of ``a``.

    .. versionadded:: 1.12.0

Returns
-------
count : int or array of int
    Number of non-zero values in the array along a given axis.
    Otherwise, the total number of non-zero values in the array
    is returned.

See Also
--------
nonzero : Return the coordinates of all the non-zero values.

Examples
--------
>>> np.count_nonzero(np.eye(4))
4
>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])
5
>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=0)
array([1, 1, 1, 1, 1])
>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=1)
array([2, 3])
*)

val cov : ?y:[>`Ndarray] Obj.t -> ?rowvar:bool -> ?bias:bool -> ?ddof:int -> ?fweights:[`I of int | `Ndarray of [>`Ndarray] Obj.t] -> ?aweights:[>`Ndarray] Obj.t -> m:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Estimate a covariance matrix, given data and weights.

Covariance indicates the level to which two variables vary together.
If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,
then the covariance matrix element :math:`C_{ij}` is the covariance of
:math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance
of :math:`x_i`.

See the notes for an outline of the algorithm.

Parameters
----------
m : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `m` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same form
    as that of `m`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : bool, optional
    Default normalization (False) is by ``(N - 1)``, where ``N`` is the
    number of observations given (unbiased estimate). If `bias` is True,
    then normalization is by ``N``. These values can be overridden by using
    the keyword ``ddof`` in numpy versions >= 1.5.
ddof : int, optional
    If not ``None`` the default value implied by `bias` is overridden.
    Note that ``ddof=1`` will return the unbiased estimate, even if both
    `fweights` and `aweights` are specified, and ``ddof=0`` will return
    the simple average. See the notes for the details. The default value
    is ``None``.

    .. versionadded:: 1.5
fweights : array_like, int, optional
    1-D array of integer frequency weights; the number of times each
    observation vector should be repeated.

    .. versionadded:: 1.10
aweights : array_like, optional
    1-D array of observation vector weights. These relative weights are
    typically large for observations considered 'important' and smaller for
    observations considered less 'important'. If ``ddof=0`` the array of
    weights can be used to assign probabilities to observation vectors.

    .. versionadded:: 1.10

Returns
-------
out : ndarray
    The covariance matrix of the variables.

See Also
--------
corrcoef : Normalized covariance matrix

Notes
-----
Assume that the observations are in the columns of the observation
array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The
steps to compute the weighted covariance are as follows::

    >>> m = np.arange(10, dtype=np.float64)
    >>> f = np.arange(10) * 2
    >>> a = np.arange(10) ** 2.
    >>> ddof = 1
    >>> w = f * a
    >>> v1 = np.sum(w)
    >>> v2 = np.sum(w * a)
    >>> m -= np.sum(m * w, axis=None, keepdims=True) / v1
    >>> cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)

Note that when ``a == 1``, the normalization factor
``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``
as it should.

Examples
--------
Consider two variables, :math:`x_0` and :math:`x_1`, which
correlate perfectly, but in opposite directions:

>>> x = np.array([[0, 2], [1, 1], [2, 0]]).T
>>> x
array([[0, 1, 2],
       [2, 1, 0]])

Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance
matrix shows this clearly:

>>> np.cov(x)
array([[ 1., -1.],
       [-1.,  1.]])

Note that element :math:`C_{0,1}`, which shows the correlation between
:math:`x_0` and :math:`x_1`, is negative.

Further, note how `x` and `y` are combined:

>>> x = [-2.1, -1,  4.3]
>>> y = [3,  1.1,  0.12]
>>> X = np.stack((x, y), axis=0)
>>> np.cov(X)
array([[11.71      , -4.286     ], # may vary
       [-4.286     ,  2.144133]])
>>> np.cov(x, y)
array([[11.71      , -4.286     ], # may vary
       [-4.286     ,  2.144133]])
>>> np.cov(x)
array(11.71)
*)

val cross : ?axisa:int -> ?axisb:int -> ?axisc:int -> ?axis:int -> b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the cross product of two (arrays of) vectors.

The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular
to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors
are defined by the last axis of `a` and `b` by default, and these axes
can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is
2, the third component of the input vector is assumed to be zero and the
cross product calculated accordingly.  In cases where both input vectors
have dimension 2, the z-component of the cross product is returned.

Parameters
----------
a : array_like
    Components of the first vector(s).
b : array_like
    Components of the second vector(s).
axisa : int, optional
    Axis of `a` that defines the vector(s).  By default, the last axis.
axisb : int, optional
    Axis of `b` that defines the vector(s).  By default, the last axis.
axisc : int, optional
    Axis of `c` containing the cross product vector(s).  Ignored if
    both input vectors have dimension 2, as the return is scalar.
    By default, the last axis.
axis : int, optional
    If defined, the axis of `a`, `b` and `c` that defines the vector(s)
    and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.

Returns
-------
c : ndarray
    Vector cross product(s).

Raises
------
ValueError
    When the dimension of the vector(s) in `a` and/or `b` does not
    equal 2 or 3.

See Also
--------
inner : Inner product
outer : Outer product.
ix_ : Construct index arrays.

Notes
-----
.. versionadded:: 1.9.0

Supports full broadcasting of the inputs.

Examples
--------
Vector cross-product.

>>> x = [1, 2, 3]
>>> y = [4, 5, 6]
>>> np.cross(x, y)
array([-3,  6, -3])

One vector with dimension 2.

>>> x = [1, 2]
>>> y = [4, 5, 6]
>>> np.cross(x, y)
array([12, -6, -3])

Equivalently:

>>> x = [1, 2, 0]
>>> y = [4, 5, 6]
>>> np.cross(x, y)
array([12, -6, -3])

Both vectors with dimension 2.

>>> x = [1,2]
>>> y = [4,5]
>>> np.cross(x, y)
array(-3)

Multiple vector cross-products. Note that the direction of the cross
product vector is defined by the `right-hand rule`.

>>> x = np.array([[1,2,3], [4,5,6]])
>>> y = np.array([[4,5,6], [1,2,3]])
>>> np.cross(x, y)
array([[-3,  6, -3],
       [ 3, -6,  3]])

The orientation of `c` can be changed using the `axisc` keyword.

>>> np.cross(x, y, axisc=0)
array([[-3,  3],
       [ 6, -6],
       [-3,  3]])

Change the vector definition of `x` and `y` using `axisa` and `axisb`.

>>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
>>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])
>>> np.cross(x, y)
array([[ -6,  12,  -6],
       [  0,   0,   0],
       [  6, -12,   6]])
>>> np.cross(x, y, axisa=0, axisb=0)
array([[-24,  48, -24],
       [-30,  60, -30],
       [-36,  72, -36]])
*)

val cumprod : ?axis:int -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the cumulative product of elements along a given axis.

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    Axis along which the cumulative product is computed.  By default
    the input is flattened.
dtype : dtype, optional
    Type of the returned array, as well as of the accumulator in which
    the elements are multiplied.  If *dtype* is not specified, it
    defaults to the dtype of `a`, unless `a` has an integer dtype with
    a precision less than that of the default platform integer.  In
    that case, the default platform integer is used instead.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type of the resulting values will be cast if necessary.

Returns
-------
cumprod : ndarray
    A new array holding the result is returned unless `out` is
    specified, in which case a reference to out is returned.

See Also
--------
ufuncs-output-type

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

Examples
--------
>>> a = np.array([1,2,3])
>>> np.cumprod(a) # intermediate results 1, 1*2
...               # total product 1*2*3 = 6
array([1, 2, 6])
>>> a = np.array([[1, 2, 3], [4, 5, 6]])
>>> np.cumprod(a, dtype=float) # specify type of output
array([   1.,    2.,    6.,   24.,  120.,  720.])

The cumulative product for each column (i.e., over the rows) of `a`:

>>> np.cumprod(a, axis=0)
array([[ 1,  2,  3],
       [ 4, 10, 18]])

The cumulative product for each row (i.e. over the columns) of `a`:

>>> np.cumprod(a,axis=1)
array([[  1,   2,   6],
       [  4,  20, 120]])
*)

val cumproduct : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
Return the cumulative product over the given axis.

See Also
--------
cumprod : equivalent function; see for details.
*)

val cumsum : ?axis:int -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the cumulative sum of the elements along a given axis.

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    Axis along which the cumulative sum is computed. The default
    (None) is to compute the cumsum over the flattened array.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed.  If `dtype` is not specified, it defaults
    to the dtype of `a`, unless `a` has an integer dtype with a
    precision less than that of the default platform integer.  In
    that case, the default platform integer is used.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary. See `ufuncs-output-type` for
    more details.

Returns
-------
cumsum_along_axis : ndarray.
    A new array holding the result is returned unless `out` is
    specified, in which case a reference to `out` is returned. The
    result has the same size as `a`, and the same shape as `a` if
    `axis` is not None or `a` is a 1-d array.


See Also
--------
sum : Sum array elements.

trapz : Integration of array values using the composite trapezoidal rule.

diff :  Calculate the n-th discrete difference along given axis.

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

Examples
--------
>>> a = np.array([[1,2,3], [4,5,6]])
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.cumsum(a)
array([ 1,  3,  6, 10, 15, 21])
>>> np.cumsum(a, dtype=float)     # specifies type of output value(s)
array([  1.,   3.,   6.,  10.,  15.,  21.])

>>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns
array([[1, 2, 3],
       [5, 7, 9]])
>>> np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows
array([[ 1,  3,  6],
       [ 4,  9, 15]])
*)

val datetime_as_string : ?unit:string -> ?timezone:[`Naive | `Local | `UTC | `Tzinfo of Py.Object.t] -> ?casting:[`No | `Equiv | `Safe | `Same_kind | `Unsafe] -> arr:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')

Convert an array of datetimes into an array of strings.

Parameters
----------
arr : array_like of datetime64
    The array of UTC timestamps to format.
unit : str
    One of None, 'auto', or a :ref:`datetime unit <arrays.dtypes.dateunits>`.
timezone : {'naive', 'UTC', 'local'} or tzinfo
    Timezone information to use when displaying the datetime. If 'UTC', end
    with a Z to indicate UTC time. If 'local', convert to the local timezone
    first, and suffix with a +-#### timezone offset. If a tzinfo object,
    then do as with 'local', but use the specified timezone.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}
    Casting to allow when changing between datetime units.

Returns
-------
str_arr : ndarray
    An array of strings the same shape as `arr`.

Examples
--------
>>> import pytz
>>> d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')
>>> d
array(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',
       '2002-10-27T07:30'], dtype='datetime64[m]')

Setting the timezone to UTC shows the same information, but with a Z suffix

>>> np.datetime_as_string(d, timezone='UTC')
array(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',
       '2002-10-27T07:30Z'], dtype='<U35')

Note that we picked datetimes that cross a DST boundary. Passing in a
``pytz`` timezone object will print the appropriate offset

>>> np.datetime_as_string(d, timezone=pytz.timezone('US/Eastern'))
array(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',
       '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='<U39')

Passing in a unit will change the precision

>>> np.datetime_as_string(d, unit='h')
array(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],
      dtype='<U32')
>>> np.datetime_as_string(d, unit='s')
array(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',
       '2002-10-27T07:30:00'], dtype='<U38')

'casting' can be used to specify whether precision can be changed

>>> np.datetime_as_string(d, unit='h', casting='safe')
Traceback (most recent call last):
    ...
TypeError: Cannot create a datetime string as units 'h' from a NumPy
datetime with units 'm' according to the rule 'safe'
*)

val datetime_data : Dtype.t -> (string * int)
(**
datetime_data(dtype, /)

Get information about the step size of a date or time type.

The returned tuple can be passed as the second argument of `numpy.datetime64` and
`numpy.timedelta64`.

Parameters
----------
dtype : dtype
    The dtype object, which must be a `datetime64` or `timedelta64` type.

Returns
-------
unit : str
    The :ref:`datetime unit <arrays.dtypes.dateunits>` on which this dtype
    is based.
count : int
    The number of base units in a step.

Examples
--------
>>> dt_25s = np.dtype('timedelta64[25s]')
>>> np.datetime_data(dt_25s)
('s', 25)
>>> np.array(10, dt_25s).astype('timedelta64[s]')
array(250, dtype='timedelta64[s]')

The result can be used to construct a datetime that uses the same units
as a timedelta

>>> np.datetime64('2010', np.datetime_data(dt_25s))
numpy.datetime64('2010-01-01T00:00:00','25s')
*)

val deg2rad : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
deg2rad(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Convert angles from degrees to radians.

Parameters
----------
x : array_like
    Angles in degrees.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding angle in radians.
    This is a scalar if `x` is a scalar.

See Also
--------
rad2deg : Convert angles from radians to degrees.
unwrap : Remove large jumps in angle by wrapping.

Notes
-----
.. versionadded:: 1.3.0

``deg2rad(x)`` is ``x * pi / 180``.

Examples
--------
>>> np.deg2rad(180)
3.1415926535897931
*)

val degrees : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
degrees(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Convert angles from radians to degrees.

Parameters
----------
x : array_like
    Input array in radians.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray of floats
    The corresponding degree values; if `out` was supplied this is a
    reference to it.
    This is a scalar if `x` is a scalar.

See Also
--------
rad2deg : equivalent function

Examples
--------
Convert a radian array to degrees

>>> rad = np.arange(12.)*np.pi/6
>>> np.degrees(rad)
array([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,
        270.,  300.,  330.])

>>> out = np.zeros((rad.shape))
>>> r = np.degrees(rad, out)
>>> np.all(r == out)
True
*)

val delete : ?axis:int -> arr:[>`Ndarray] Obj.t -> obj:[`Slice of Wrap_utils.Slice.t | `Array_of_ints of Py.Object.t | `I of int] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a new array with sub-arrays along an axis deleted. For a one
dimensional array, this returns those entries not returned by
`arr[obj]`.

Parameters
----------
arr : array_like
  Input array.
obj : slice, int or array of ints
  Indicate indices of sub-arrays to remove along the specified axis.
axis : int, optional
  The axis along which to delete the subarray defined by `obj`.
  If `axis` is None, `obj` is applied to the flattened array.

Returns
-------
out : ndarray
    A copy of `arr` with the elements specified by `obj` removed. Note
    that `delete` does not occur in-place. If `axis` is None, `out` is
    a flattened array.

See Also
--------
insert : Insert elements into an array.
append : Append elements at the end of an array.

Notes
-----
Often it is preferable to use a boolean mask. For example:

>>> arr = np.arange(12) + 1
>>> mask = np.ones(len(arr), dtype=bool)
>>> mask[[0,2,4]] = False
>>> result = arr[mask,...]

Is equivalent to `np.delete(arr, [0,2,4], axis=0)`, but allows further
use of `mask`.

Examples
--------
>>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
>>> arr
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
>>> np.delete(arr, 1, 0)
array([[ 1,  2,  3,  4],
       [ 9, 10, 11, 12]])

>>> np.delete(arr, np.s_[::2], 1)
array([[ 2,  4],
       [ 6,  8],
       [10, 12]])
>>> np.delete(arr, [1,3,5], None)
array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])
*)

val deprecate : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
Issues a DeprecationWarning, adds warning to `old_name`'s
docstring, rebinds ``old_name.__name__`` and returns the new
function object.

This function may also be used as a decorator.

Parameters
----------
func : function
    The function to be deprecated.
old_name : str, optional
    The name of the function to be deprecated. Default is None, in
    which case the name of `func` is used.
new_name : str, optional
    The new name for the function. Default is None, in which case the
    deprecation message is that `old_name` is deprecated. If given, the
    deprecation message is that `old_name` is deprecated and `new_name`
    should be used instead.
message : str, optional
    Additional explanation of the deprecation.  Displayed in the
    docstring after the warning.

Returns
-------
old_func : function
    The deprecated function.

Examples
--------
Note that ``olduint`` returns a value after printing Deprecation
Warning:

>>> olduint = np.deprecate(np.uint)
DeprecationWarning: `uint64` is deprecated! # may vary
>>> olduint(6)
6
*)

val deprecate_with_doc : Py.Object.t -> Py.Object.t
(**
None
*)

val diag : ?k:int -> v:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Extract a diagonal or construct a diagonal array.

See the more detailed documentation for ``numpy.diagonal`` if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.

Parameters
----------
v : array_like
    If `v` is a 2-D array, return a copy of its `k`-th diagonal.
    If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th
    diagonal.
k : int, optional
    Diagonal in question. The default is 0. Use `k>0` for diagonals
    above the main diagonal, and `k<0` for diagonals below the main
    diagonal.

Returns
-------
out : ndarray
    The extracted diagonal or constructed diagonal array.

See Also
--------
diagonal : Return specified diagonals.
diagflat : Create a 2-D array with the flattened input as a diagonal.
trace : Sum along diagonals.
triu : Upper triangle of an array.
tril : Lower triangle of an array.

Examples
--------
>>> x = np.arange(9).reshape((3,3))
>>> x
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])

>>> np.diag(x)
array([0, 4, 8])
>>> np.diag(x, k=1)
array([1, 5])
>>> np.diag(x, k=-1)
array([3, 7])

>>> np.diag(np.diag(x))
array([[0, 0, 0],
       [0, 4, 0],
       [0, 0, 8]])
*)

val diag_indices : ?ndim:int -> n:int -> unit -> Py.Object.t
(**
Return the indices to access the main diagonal of an array.

This returns a tuple of indices that can be used to access the main
diagonal of an array `a` with ``a.ndim >= 2`` dimensions and shape
(n, n, ..., n). For ``a.ndim = 2`` this is the usual diagonal, for
``a.ndim > 2`` this is the set of indices to access ``a[i, i, ..., i]``
for ``i = [0..n-1]``.

Parameters
----------
n : int
  The size, along each dimension, of the arrays for which the returned
  indices can be used.

ndim : int, optional
  The number of dimensions.

See also
--------
diag_indices_from

Notes
-----
.. versionadded:: 1.4.0

Examples
--------
Create a set of indices to access the diagonal of a (4, 4) array:

>>> di = np.diag_indices(4)
>>> di
(array([0, 1, 2, 3]), array([0, 1, 2, 3]))
>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
>>> a[di] = 100
>>> a
array([[100,   1,   2,   3],
       [  4, 100,   6,   7],
       [  8,   9, 100,  11],
       [ 12,  13,  14, 100]])

Now, we create indices to manipulate a 3-D array:

>>> d3 = np.diag_indices(2, 3)
>>> d3
(array([0, 1]), array([0, 1]), array([0, 1]))

And use it to set the diagonal of an array of zeros to 1:

>>> a = np.zeros((2, 2, 2), dtype=int)
>>> a[d3] = 1
>>> a
array([[[1, 0],
        [0, 0]],
       [[0, 0],
        [0, 1]]])
*)

val diag_indices_from : [`At_least_2_D of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
Return the indices to access the main diagonal of an n-dimensional array.

See `diag_indices` for full details.

Parameters
----------
arr : array, at least 2-D

See Also
--------
diag_indices

Notes
-----
.. versionadded:: 1.4.0
*)

val diagflat : ?k:int -> v:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Create a two-dimensional array with the flattened input as a diagonal.

Parameters
----------
v : array_like
    Input data, which is flattened and set as the `k`-th
    diagonal of the output.
k : int, optional
    Diagonal to set; 0, the default, corresponds to the 'main' diagonal,
    a positive (negative) `k` giving the number of the diagonal above
    (below) the main.

Returns
-------
out : ndarray
    The 2-D output array.

See Also
--------
diag : MATLAB work-alike for 1-D and 2-D arrays.
diagonal : Return specified diagonals.
trace : Sum along diagonals.

Examples
--------
>>> np.diagflat([[1,2], [3,4]])
array([[1, 0, 0, 0],
       [0, 2, 0, 0],
       [0, 0, 3, 0],
       [0, 0, 0, 4]])

>>> np.diagflat([1,2], 1)
array([[0, 1, 0],
       [0, 0, 2],
       [0, 0, 0]])
*)

val diagonal : ?offset:int -> ?axis1:int -> ?axis2:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return specified diagonals.

If `a` is 2-D, returns the diagonal of `a` with the given offset,
i.e., the collection of elements of the form ``a[i, i+offset]``.  If
`a` has more than two dimensions, then the axes specified by `axis1`
and `axis2` are used to determine the 2-D sub-array whose diagonal is
returned.  The shape of the resulting array can be determined by
removing `axis1` and `axis2` and appending an index to the right equal
to the size of the resulting diagonals.

In versions of NumPy prior to 1.7, this function always returned a new,
independent array containing a copy of the values in the diagonal.

In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,
but depending on this fact is deprecated. Writing to the resulting
array continues to work as it used to, but a FutureWarning is issued.

Starting in NumPy 1.9 it returns a read-only view on the original array.
Attempting to write to the resulting array will produce an error.

In some future release, it will return a read/write view and writing to
the returned array will alter your original array.  The returned array
will have the same type as the input array.

If you don't write to the array returned by this function, then you can
just ignore all of the above.

If you depend on the current behavior, then we suggest copying the
returned array explicitly, i.e., use ``np.diagonal(a).copy()`` instead
of just ``np.diagonal(a)``. This will work with both past and future
versions of NumPy.

Parameters
----------
a : array_like
    Array from which the diagonals are taken.
offset : int, optional
    Offset of the diagonal from the main diagonal.  Can be positive or
    negative.  Defaults to main diagonal (0).
axis1 : int, optional
    Axis to be used as the first axis of the 2-D sub-arrays from which
    the diagonals should be taken.  Defaults to first axis (0).
axis2 : int, optional
    Axis to be used as the second axis of the 2-D sub-arrays from
    which the diagonals should be taken. Defaults to second axis (1).

Returns
-------
array_of_diagonals : ndarray
    If `a` is 2-D, then a 1-D array containing the diagonal and of the
    same type as `a` is returned unless `a` is a `matrix`, in which case
    a 1-D array rather than a (2-D) `matrix` is returned in order to
    maintain backward compatibility.

    If ``a.ndim > 2``, then the dimensions specified by `axis1` and `axis2`
    are removed, and a new axis inserted at the end corresponding to the
    diagonal.

Raises
------
ValueError
    If the dimension of `a` is less than 2.

See Also
--------
diag : MATLAB work-a-like for 1-D and 2-D arrays.
diagflat : Create diagonal arrays.
trace : Sum along diagonals.

Examples
--------
>>> a = np.arange(4).reshape(2,2)
>>> a
array([[0, 1],
       [2, 3]])
>>> a.diagonal()
array([0, 3])
>>> a.diagonal(1)
array([1])

A 3-D example:

>>> a = np.arange(8).reshape(2,2,2); a
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
>>> a.diagonal(0,  # Main diagonals of two arrays created by skipping
...            0,  # across the outer(left)-most axis last and
...            1)  # the 'middle' (row) axis first.
array([[0, 6],
       [1, 7]])

The sub-arrays whose main diagonals we just obtained; note that each
corresponds to fixing the right-most (column) axis, and that the
diagonals are 'packed' in rows.

>>> a[:,:,0]  # main diagonal is [0 6]
array([[0, 2],
       [4, 6]])
>>> a[:,:,1]  # main diagonal is [1 7]
array([[1, 3],
       [5, 7]])

The anti-diagonal can be obtained by reversing the order of elements
using either `numpy.flipud` or `numpy.fliplr`.

>>> a = np.arange(9).reshape(3, 3)
>>> a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> np.fliplr(a).diagonal()  # Horizontal flip
array([2, 4, 6])
>>> np.flipud(a).diagonal()  # Vertical flip
array([6, 4, 2])

Note that the order in which the diagonal is retrieved varies depending
on the flip function.
*)

val diff : ?n:int -> ?axis:int -> ?prepend:Py.Object.t -> ?append:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Calculate the n-th discrete difference along the given axis.

The first difference is given by ``out[i] = a[i+1] - a[i]`` along
the given axis, higher differences are calculated by using `diff`
recursively.

Parameters
----------
a : array_like
    Input array
n : int, optional
    The number of times values are differenced. If zero, the input
    is returned as-is.
axis : int, optional
    The axis along which the difference is taken, default is the
    last axis.
prepend, append : array_like, optional
    Values to prepend or append to `a` along axis prior to
    performing the difference.  Scalar values are expanded to
    arrays with length 1 in the direction of axis and the shape
    of the input array in along all other axes.  Otherwise the
    dimension and shape must match `a` except along axis.

    .. versionadded:: 1.16.0

Returns
-------
diff : ndarray
    The n-th differences. The shape of the output is the same as `a`
    except along `axis` where the dimension is smaller by `n`. The
    type of the output is the same as the type of the difference
    between any two elements of `a`. This is the same as the type of
    `a` in most cases. A notable exception is `datetime64`, which
    results in a `timedelta64` output array.

See Also
--------
gradient, ediff1d, cumsum

Notes
-----
Type is preserved for boolean arrays, so the result will contain
`False` when consecutive elements are the same and `True` when they
differ.

For unsigned integer arrays, the results will also be unsigned. This
should not be surprising, as the result is consistent with
calculating the difference directly:

>>> u8_arr = np.array([1, 0], dtype=np.uint8)
>>> np.diff(u8_arr)
array([255], dtype=uint8)
>>> u8_arr[1,...] - u8_arr[0,...]
255

If this is not desirable, then the array should be cast to a larger
integer type first:

>>> i16_arr = u8_arr.astype(np.int16)
>>> np.diff(i16_arr)
array([-1], dtype=int16)

Examples
--------
>>> x = np.array([1, 2, 4, 7, 0])
>>> np.diff(x)
array([ 1,  2,  3, -7])
>>> np.diff(x, n=2)
array([  1,   1, -10])

>>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
>>> np.diff(x)
array([[2, 3, 4],
       [5, 1, 2]])
>>> np.diff(x, axis=0)
array([[-1,  2,  0, -2]])

>>> x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)
>>> np.diff(x)
array([1, 1], dtype='timedelta64[D]')
*)

val digitize : ?right:bool -> bins:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the indices of the bins to which each value in input array belongs.

=========  =============  ============================
`right`    order of bins  returned index `i` satisfies
=========  =============  ============================
``False``  increasing     ``bins[i-1] <= x < bins[i]``
``True``   increasing     ``bins[i-1] < x <= bins[i]``
``False``  decreasing     ``bins[i-1] > x >= bins[i]``
``True``   decreasing     ``bins[i-1] >= x > bins[i]``
=========  =============  ============================

If values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is
returned as appropriate.

Parameters
----------
x : array_like
    Input array to be binned. Prior to NumPy 1.10.0, this array had to
    be 1-dimensional, but can now have any shape.
bins : array_like
    Array of bins. It has to be 1-dimensional and monotonic.
right : bool, optional
    Indicating whether the intervals include the right or the left bin
    edge. Default behavior is (right==False) indicating that the interval
    does not include the right edge. The left bin end is open in this
    case, i.e., bins[i-1] <= x < bins[i] is the default behavior for
    monotonically increasing bins.

Returns
-------
indices : ndarray of ints
    Output array of indices, of same shape as `x`.

Raises
------
ValueError
    If `bins` is not monotonic.
TypeError
    If the type of the input is complex.

See Also
--------
bincount, histogram, unique, searchsorted

Notes
-----
If values in `x` are such that they fall outside the bin range,
attempting to index `bins` with the indices that `digitize` returns
will result in an IndexError.

.. versionadded:: 1.10.0

`np.digitize` is  implemented in terms of `np.searchsorted`. This means
that a binary search is used to bin the values, which scales much better
for larger number of bins than the previous linear search. It also removes
the requirement for the input array to be 1-dimensional.

For monotonically _increasing_ `bins`, the following are equivalent::

    np.digitize(x, bins, right=True)
    np.searchsorted(bins, x, side='left')

Note that as the order of the arguments are reversed, the side must be too.
The `searchsorted` call is marginally faster, as it does not do any
monotonicity checks. Perhaps more importantly, it supports all dtypes.

Examples
--------
>>> x = np.array([0.2, 6.4, 3.0, 1.6])
>>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])
>>> inds = np.digitize(x, bins)
>>> inds
array([1, 4, 3, 2])
>>> for n in range(x.size):
...   print(bins[inds[n]-1], '<=', x[n], '<', bins[inds[n]])
...
0.0 <= 0.2 < 1.0
4.0 <= 6.4 < 10.0
2.5 <= 3.0 < 4.0
1.0 <= 1.6 < 2.5

>>> x = np.array([1.2, 10.0, 12.4, 15.5, 20.])
>>> bins = np.array([0, 5, 10, 15, 20])
>>> np.digitize(x,bins,right=True)
array([1, 2, 3, 4, 4])
>>> np.digitize(x,bins,right=False)
array([1, 3, 3, 4, 5])
*)

val disp : ?device:Py.Object.t -> ?linefeed:bool -> mesg:string -> unit -> Py.Object.t
(**
Display a message on a device.

Parameters
----------
mesg : str
    Message to display.
device : object
    Device to write message. If None, defaults to ``sys.stdout`` which is
    very similar to ``print``. `device` needs to have ``write()`` and
    ``flush()`` methods.
linefeed : bool, optional
    Option whether to print a line feed or not. Defaults to True.

Raises
------
AttributeError
    If `device` does not have a ``write()`` or ``flush()`` method.

Examples
--------
Besides ``sys.stdout``, a file-like object can also be used as it has
both required methods:

>>> from io import StringIO
>>> buf = StringIO()
>>> np.disp(u''Display' in a file', device=buf)
>>> buf.getvalue()
''Display' in a file\n'
*)

val divide : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Returns a true division of the inputs, element-wise.

Instead of the Python traditional 'floor division', this returns a true
division.  True division adjusts the output type to present the best
answer, regardless of input types.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
The floor division operator ``//`` was added in Python 2.2 making
``//`` and ``/`` equivalent operators.  The default floor division
operation of ``/`` can be replaced by true division with ``from
__future__ import division``.

In Python 3.0, ``//`` is the floor division operator and ``/`` the
true division operator.  The ``true_divide(x1, x2)`` function is
equivalent to true division in Python.

Examples
--------
>>> x = np.arange(5)
>>> np.true_divide(x, 4)
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])

>>> x//4
array([0, 0, 0, 0, 1])

>>> from __future__ import division
>>> x/4
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
>>> x//4
array([0, 0, 0, 0, 1])
*)

val divmod : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
divmod(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return element-wise quotient and remainder simultaneously.

.. versionadded:: 1.13.0

``np.divmod(x, y)`` is equivalent to ``(x // y, x % y)``, but faster
because it avoids redundant work. It is used to implement the Python
built-in function ``divmod`` on NumPy arrays.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out1 : ndarray
    Element-wise quotient resulting from floor division.
    This is a scalar if both `x1` and `x2` are scalars.
out2 : ndarray
    Element-wise remainder from floor division.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
floor_divide : Equivalent to Python's ``//`` operator.
remainder : Equivalent to Python's ``%`` operator.
modf : Equivalent to ``divmod(x, 1)`` for positive ``x`` with the return
       values switched.

Examples
--------
>>> np.divmod(np.arange(5), 3)
(array([0, 0, 0, 1, 1]), array([0, 1, 2, 0, 1]))
*)

val dot : ?out:[>`Ndarray] Obj.t -> b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
dot(a, b, out=None)

Dot product of two arrays. Specifically,

- If both `a` and `b` are 1-D arrays, it is inner product of vectors
  (without complex conjugation).

- If both `a` and `b` are 2-D arrays, it is matrix multiplication,
  but using :func:`matmul` or ``a @ b`` is preferred.

- If either `a` or `b` is 0-D (scalar), it is equivalent to :func:`multiply`
  and using ``numpy.multiply(a, b)`` or ``a * b`` is preferred.

- If `a` is an N-D array and `b` is a 1-D array, it is a sum product over
  the last axis of `a` and `b`.

- If `a` is an N-D array and `b` is an M-D array (where ``M>=2``), it is a
  sum product over the last axis of `a` and the second-to-last axis of `b`::

    dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])

Parameters
----------
a : array_like
    First argument.
b : array_like
    Second argument.
out : ndarray, optional
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for `dot(a,b)`. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.

Returns
-------
output : ndarray
    Returns the dot product of `a` and `b`.  If `a` and `b` are both
    scalars or both 1-D arrays then a scalar is returned; otherwise
    an array is returned.
    If `out` is given, then it is returned.

Raises
------
ValueError
    If the last dimension of `a` is not the same size as
    the second-to-last dimension of `b`.

See Also
--------
vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : '@' operator as method with out parameter.

Examples
--------
>>> np.dot(3, 4)
12

Neither argument is complex-conjugated:

>>> np.dot([2j, 3j], [2j, 3j])
(-13+0j)

For 2-D arrays it is the matrix product:

>>> a = [[1, 0], [0, 1]]
>>> b = [[4, 1], [2, 2]]
>>> np.dot(a, b)
array([[4, 1],
       [2, 2]])

>>> a = np.arange(3*4*5*6).reshape((3,4,5,6))
>>> b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
>>> np.dot(a, b)[2,3,2,1,2,2]
499128
>>> sum(a[2,3,2,:] * b[1,2,:,2])
499128
*)

val dsplit : ary:Py.Object.t -> indices_or_sections:Py.Object.t -> unit -> Py.Object.t
(**
Split array into multiple sub-arrays along the 3rd axis (depth).

Please refer to the `split` documentation.  `dsplit` is equivalent
to `split` with ``axis=2``, the array is always split along the third
axis provided the array dimension is greater than or equal to 3.

See Also
--------
split : Split an array into multiple sub-arrays of equal size.

Examples
--------
>>> x = np.arange(16.0).reshape(2, 2, 4)
>>> x
array([[[ 0.,   1.,   2.,   3.],
        [ 4.,   5.,   6.,   7.]],
       [[ 8.,   9.,  10.,  11.],
        [12.,  13.,  14.,  15.]]])
>>> np.dsplit(x, 2)
[array([[[ 0.,  1.],
        [ 4.,  5.]],
       [[ 8.,  9.],
        [12., 13.]]]), array([[[ 2.,  3.],
        [ 6.,  7.]],
       [[10., 11.],
        [14., 15.]]])]
>>> np.dsplit(x, np.array([3, 6]))
[array([[[ 0.,   1.,   2.],
        [ 4.,   5.,   6.]],
       [[ 8.,   9.,  10.],
        [12.,  13.,  14.]]]),
 array([[[ 3.],
        [ 7.]],
       [[11.],
        [15.]]]),
array([], shape=(2, 2, 0), dtype=float64)]
*)

val dstack : Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Stack arrays in sequence depth wise (along third axis).

This is equivalent to concatenation along the third axis after 2-D arrays
of shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape
`(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by
`dsplit`.

This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions `concatenate`, `stack` and
`block` provide more general stacking and concatenation operations.

Parameters
----------
tup : sequence of arrays
    The arrays must have the same shape along all but the third axis.
    1-D or 2-D arrays must have the same shape.

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays, will be at least 3-D.

See Also
--------
stack : Join a sequence of arrays along a new axis.
vstack : Stack along first axis.
hstack : Stack along second axis.
concatenate : Join a sequence of arrays along an existing axis.
dsplit : Split array along third axis.

Examples
--------
>>> a = np.array((1,2,3))
>>> b = np.array((2,3,4))
>>> np.dstack((a,b))
array([[[1, 2],
        [2, 3],
        [3, 4]]])

>>> a = np.array([[1],[2],[3]])
>>> b = np.array([[2],[3],[4]])
>>> np.dstack((a,b))
array([[[1, 2]],
       [[2, 3]],
       [[3, 4]]])
*)

val ediff1d : ?to_end:[>`Ndarray] Obj.t -> ?to_begin:[>`Ndarray] Obj.t -> ary:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
The differences between consecutive elements of an array.

Parameters
----------
ary : array_like
    If necessary, will be flattened before the differences are taken.
to_end : array_like, optional
    Number(s) to append at the end of the returned differences.
to_begin : array_like, optional
    Number(s) to prepend at the beginning of the returned differences.

Returns
-------
ediff1d : ndarray
    The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``.

See Also
--------
diff, gradient

Notes
-----
When applied to masked arrays, this function drops the mask information
if the `to_begin` and/or `to_end` parameters are used.

Examples
--------
>>> x = np.array([1, 2, 4, 7, 0])
>>> np.ediff1d(x)
array([ 1,  2,  3, -7])

>>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))
array([-99,   1,   2, ...,  -7,  88,  99])

The returned array is always 1D.

>>> y = [[1, 2, 4], [1, 6, 24]]
>>> np.ediff1d(y)
array([ 1,  2, -3,  5, 18])
*)

val einsum : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
einsum(subscripts, *operands, out=None, dtype=None, order='K',
       casting='safe', optimize=False)

Evaluates the Einstein summation convention on the operands.

Using the Einstein summation convention, many common multi-dimensional,
linear algebraic array operations can be represented in a simple fashion.
In *implicit* mode `einsum` computes these values.

In *explicit* mode, `einsum` provides further flexibility to compute
other array operations that might not be considered classical Einstein
summation operations, by disabling, or forcing summation over specified
subscript labels.

See the notes and examples for clarification.

Parameters
----------
subscripts : str
    Specifies the subscripts for summation as comma separated list of
    subscript labels. An implicit (classical Einstein summation)
    calculation is performed unless the explicit indicator '->' is
    included as well as subscript labels of the precise output form.
operands : list of array_like
    These are the arrays for the operation.
out : ndarray, optional
    If provided, the calculation is done into this array.
dtype : {data-type, None}, optional
    If provided, forces the calculation to use the data type specified.
    Note that you may have to also give a more liberal `casting`
    parameter to allow the conversions. Default is None.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout of the output. 'C' means it should
    be C contiguous. 'F' means it should be Fortran contiguous,
    'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.
    'K' means it should be as close to the layout as the inputs as
    is possible, including arbitrarily permuted axes.
    Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur.  Setting this to
    'unsafe' is not recommended, as it can adversely affect accumulations.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.

    Default is 'safe'.
optimize : {False, True, 'greedy', 'optimal'}, optional
    Controls if intermediate optimization should occur. No optimization
    will occur if False and True will default to the 'greedy' algorithm.
    Also accepts an explicit contraction list from the ``np.einsum_path``
    function. See ``np.einsum_path`` for more details. Defaults to False.

Returns
-------
output : ndarray
    The calculation based on the Einstein summation convention.

See Also
--------
einsum_path, dot, inner, outer, tensordot, linalg.multi_dot

Notes
-----
.. versionadded:: 1.6.0

The Einstein summation convention can be used to compute
many multi-dimensional, linear algebraic array operations. `einsum`
provides a succinct way of representing these.

A non-exhaustive list of these operations,
which can be computed by `einsum`, is shown below along with examples:

* Trace of an array, :py:func:`numpy.trace`.
* Return a diagonal, :py:func:`numpy.diag`.
* Array axis summations, :py:func:`numpy.sum`.
* Transpositions and permutations, :py:func:`numpy.transpose`.
* Matrix multiplication and dot product, :py:func:`numpy.matmul` :py:func:`numpy.dot`.
* Vector inner and outer products, :py:func:`numpy.inner` :py:func:`numpy.outer`.
* Broadcasting, element-wise and scalar multiplication, :py:func:`numpy.multiply`.
* Tensor contractions, :py:func:`numpy.tensordot`.
* Chained array operations, in efficient calculation order, :py:func:`numpy.einsum_path`.

The subscripts string is a comma-separated list of subscript labels,
where each label refers to a dimension of the corresponding operand.
Whenever a label is repeated it is summed, so ``np.einsum('i,i', a, b)``
is equivalent to :py:func:`np.inner(a,b) <numpy.inner>`. If a label
appears only once, it is not summed, so ``np.einsum('i', a)`` produces a
view of ``a`` with no changes. A further example ``np.einsum('ij,jk', a, b)``
describes traditional matrix multiplication and is equivalent to
:py:func:`np.matmul(a,b) <numpy.matmul>`. Repeated subscript labels in one
operand take the diagonal. For example, ``np.einsum('ii', a)`` is equivalent
to :py:func:`np.trace(a) <numpy.trace>`.

In *implicit mode*, the chosen subscripts are important
since the axes of the output are reordered alphabetically.  This
means that ``np.einsum('ij', a)`` doesn't affect a 2D array, while
``np.einsum('ji', a)`` takes its transpose. Additionally,
``np.einsum('ij,jk', a, b)`` returns a matrix multiplication, while,
``np.einsum('ij,jh', a, b)`` returns the transpose of the
multiplication since subscript 'h' precedes subscript 'i'.

In *explicit mode* the output can be directly controlled by
specifying output subscript labels.  This requires the
identifier '->' as well as the list of output subscript labels.
This feature increases the flexibility of the function since
summing can be disabled or forced when required. The call
``np.einsum('i->', a)`` is like :py:func:`np.sum(a, axis=-1) <numpy.sum>`,
and ``np.einsum('ii->i', a)`` is like :py:func:`np.diag(a) <numpy.diag>`.
The difference is that `einsum` does not allow broadcasting by default.
Additionally ``np.einsum('ij,jh->ih', a, b)`` directly specifies the
order of the output subscript labels and therefore returns matrix
multiplication, unlike the example above in implicit mode.

To enable and control broadcasting, use an ellipsis.  Default
NumPy-style broadcasting is done by adding an ellipsis
to the left of each term, like ``np.einsum('...ii->...i', a)``.
To take the trace along the first and last axes,
you can do ``np.einsum('i...i', a)``, or to do a matrix-matrix
product with the left-most indices instead of rightmost, one can do
``np.einsum('ij...,jk...->ik...', a, b)``.

When there is only one operand, no axes are summed, and no output
parameter is provided, a view into the operand is returned instead
of a new array.  Thus, taking the diagonal as ``np.einsum('ii->i', a)``
produces a view (changed in version 1.10.0).

`einsum` also provides an alternative way to provide the subscripts
and operands as ``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``.
If the output shape is not provided in this format `einsum` will be
calculated in implicit mode, otherwise it will be performed explicitly.
The examples below have corresponding `einsum` calls with the two
parameter methods.

.. versionadded:: 1.10.0

Views returned from einsum are now writeable whenever the input array
is writeable. For example, ``np.einsum('ijk...->kji...', a)`` will now
have the same effect as :py:func:`np.swapaxes(a, 0, 2) <numpy.swapaxes>`
and ``np.einsum('ii->i', a)`` will return a writeable view of the diagonal
of a 2D array.

.. versionadded:: 1.12.0

Added the ``optimize`` argument which will optimize the contraction order
of an einsum expression. For a contraction with three or more operands this
can greatly increase the computational efficiency at the cost of a larger
memory footprint during computation.

Typically a 'greedy' algorithm is applied which empirical tests have shown
returns the optimal path in the majority of cases. In some cases 'optimal'
will return the superlative path through a more expensive, exhaustive search.
For iterative calculations it may be advisable to calculate the optimal path
once and reuse that path by supplying it as an argument. An example is given
below.

See :py:func:`numpy.einsum_path` for more details.

Examples
--------
>>> a = np.arange(25).reshape(5,5)
>>> b = np.arange(5)
>>> c = np.arange(6).reshape(2,3)

Trace of a matrix:

>>> np.einsum('ii', a)
60
>>> np.einsum(a, [0,0])
60
>>> np.trace(a)
60

Extract the diagonal (requires explicit form):

>>> np.einsum('ii->i', a)
array([ 0,  6, 12, 18, 24])
>>> np.einsum(a, [0,0], [0])
array([ 0,  6, 12, 18, 24])
>>> np.diag(a)
array([ 0,  6, 12, 18, 24])

Sum over an axis (requires explicit form):

>>> np.einsum('ij->i', a)
array([ 10,  35,  60,  85, 110])
>>> np.einsum(a, [0,1], [0])
array([ 10,  35,  60,  85, 110])
>>> np.sum(a, axis=1)
array([ 10,  35,  60,  85, 110])

For higher dimensional arrays summing a single axis can be done with ellipsis:

>>> np.einsum('...j->...', a)
array([ 10,  35,  60,  85, 110])
>>> np.einsum(a, [Ellipsis,1], [Ellipsis])
array([ 10,  35,  60,  85, 110])

Compute a matrix transpose, or reorder any number of axes:

>>> np.einsum('ji', c)
array([[0, 3],
       [1, 4],
       [2, 5]])
>>> np.einsum('ij->ji', c)
array([[0, 3],
       [1, 4],
       [2, 5]])
>>> np.einsum(c, [1,0])
array([[0, 3],
       [1, 4],
       [2, 5]])
>>> np.transpose(c)
array([[0, 3],
       [1, 4],
       [2, 5]])

Vector inner products:

>>> np.einsum('i,i', b, b)
30
>>> np.einsum(b, [0], b, [0])
30
>>> np.inner(b,b)
30

Matrix vector multiplication:

>>> np.einsum('ij,j', a, b)
array([ 30,  80, 130, 180, 230])
>>> np.einsum(a, [0,1], b, [1])
array([ 30,  80, 130, 180, 230])
>>> np.dot(a, b)
array([ 30,  80, 130, 180, 230])
>>> np.einsum('...j,j', a, b)
array([ 30,  80, 130, 180, 230])

Broadcasting and scalar multiplication:

>>> np.einsum('..., ...', 3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])
>>> np.einsum(',ij', 3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])
>>> np.einsum(3, [Ellipsis], c, [Ellipsis])
array([[ 0,  3,  6],
       [ 9, 12, 15]])
>>> np.multiply(3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])

Vector outer product:

>>> np.einsum('i,j', np.arange(2)+1, b)
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])
>>> np.einsum(np.arange(2)+1, [0], b, [1])
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])
>>> np.outer(np.arange(2)+1, b)
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])

Tensor contraction:

>>> a = np.arange(60.).reshape(3,4,5)
>>> b = np.arange(24.).reshape(4,3,2)
>>> np.einsum('ijk,jil->kl', a, b)
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
>>> np.einsum(a, [0,1,2], b, [1,0,3], [2,3])
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
>>> np.tensordot(a,b, axes=([1,0],[0,1]))
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])

Writeable returned arrays (since version 1.10.0):

>>> a = np.zeros((3, 3))
>>> np.einsum('ii->i', a)[:] = 1
>>> a
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])

Example of ellipsis use:

>>> a = np.arange(6).reshape((3,2))
>>> b = np.arange(12).reshape((4,3))
>>> np.einsum('ki,jk->ij', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])
>>> np.einsum('ki,...k->i...', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])
>>> np.einsum('k...,jk', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])

Chained array operations. For more complicated contractions, speed ups
might be achieved by repeatedly computing a 'greedy' path or pre-computing the
'optimal' path and repeatedly applying it, using an
`einsum_path` insertion (since version 1.12.0). Performance improvements can be
particularly significant with larger arrays:

>>> a = np.ones(64).reshape(2,4,8)

Basic `einsum`: ~1520ms  (benchmarked on 3.1GHz Intel i5.)

>>> for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a)

Sub-optimal `einsum` (due to repeated path calculation time): ~330ms

>>> for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')

Greedy `einsum` (faster optimal path approximation): ~160ms

>>> for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='greedy')

Optimal `einsum` (best usage pattern in some use cases): ~110ms

>>> path = np.einsum_path('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')[0]
>>> for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize=path)
*)

val einsum_path : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> (Py.Object.t * string)
(**
einsum_path(subscripts, *operands, optimize='greedy')

Evaluates the lowest cost contraction order for an einsum expression by
considering the creation of intermediate arrays.

Parameters
----------
subscripts : str
    Specifies the subscripts for summation.
*operands : list of array_like
    These are the arrays for the operation.
optimize : {bool, list, tuple, 'greedy', 'optimal'}
    Choose the type of path. If a tuple is provided, the second argument is
    assumed to be the maximum intermediate size created. If only a single
    argument is provided the largest input or output array size is used
    as a maximum intermediate size.

    * if a list is given that starts with ``einsum_path``, uses this as the
      contraction path
    * if False no optimization is taken
    * if True defaults to the 'greedy' algorithm
    * 'optimal' An algorithm that combinatorially explores all possible
      ways of contracting the listed tensors and choosest the least costly
      path. Scales exponentially with the number of terms in the
      contraction.
    * 'greedy' An algorithm that chooses the best pair contraction
      at each step. Effectively, this algorithm searches the largest inner,
      Hadamard, and then outer products at each step. Scales cubically with
      the number of terms in the contraction. Equivalent to the 'optimal'
      path for most contractions.

    Default is 'greedy'.

Returns
-------
path : list of tuples
    A list representation of the einsum path.
string_repr : str
    A printable representation of the einsum path.

Notes
-----
The resulting path indicates which terms of the input contraction should be
contracted first, the result of this contraction is then appended to the
end of the contraction list. This list can then be iterated over until all
intermediate contractions are complete.

See Also
--------
einsum, linalg.multi_dot

Examples
--------

We can begin with a chain dot example. In this case, it is optimal to
contract the ``b`` and ``c`` tensors first as represented by the first
element of the path ``(1, 2)``. The resulting tensor is added to the end
of the contraction and the remaining contraction ``(0, 1)`` is then
completed.

>>> np.random.seed(123)
>>> a = np.random.rand(2, 2)
>>> b = np.random.rand(2, 5)
>>> c = np.random.rand(5, 2)
>>> path_info = np.einsum_path('ij,jk,kl->il', a, b, c, optimize='greedy')
>>> print(path_info[0])
['einsum_path', (1, 2), (0, 1)]
>>> print(path_info[1])
  Complete contraction:  ij,jk,kl->il # may vary
         Naive scaling:  4
     Optimized scaling:  3
      Naive FLOP count:  1.600e+02
  Optimized FLOP count:  5.600e+01
   Theoretical speedup:  2.857
  Largest intermediate:  4.000e+00 elements
-------------------------------------------------------------------------
scaling                  current                                remaining
-------------------------------------------------------------------------
   3                   kl,jk->jl                                ij,jl->il
   3                   jl,ij->il                                   il->il


A more complex index transformation example.

>>> I = np.random.rand(10, 10, 10, 10)
>>> C = np.random.rand(10, 10)
>>> path_info = np.einsum_path('ea,fb,abcd,gc,hd->efgh', C, C, I, C, C,
...                            optimize='greedy')

>>> print(path_info[0])
['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)]
>>> print(path_info[1]) 
  Complete contraction:  ea,fb,abcd,gc,hd->efgh # may vary
         Naive scaling:  8
     Optimized scaling:  5
      Naive FLOP count:  8.000e+08
  Optimized FLOP count:  8.000e+05
   Theoretical speedup:  1000.000
  Largest intermediate:  1.000e+04 elements
--------------------------------------------------------------------------
scaling                  current                                remaining
--------------------------------------------------------------------------
   5               abcd,ea->bcde                      fb,gc,hd,bcde->efgh
   5               bcde,fb->cdef                         gc,hd,cdef->efgh
   5               cdef,gc->defg                            hd,defg->efgh
   5               defg,hd->efgh                               efgh->efgh
*)

val empty : ?dtype:Dtype.t -> ?order:[`C | `F] -> int list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
empty(shape, dtype=float, order='C')

Return a new array of given shape and type, without initializing entries.

Parameters
----------
shape : int or tuple of int
    Shape of the empty array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    Desired output data-type for the array, e.g, `numpy.int8`. Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: 'C'
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data of the given shape, dtype, and
    order.  Object arrays will be initialized to None.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Notes
-----
`empty`, unlike `zeros`, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.

Examples
--------
>>> np.empty([2, 2])
array([[ -9.74499359e+001,   6.69583040e-309],
       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized

>>> np.empty([2, 2], dtype=int)
array([[-1073741821, -1067949133],
       [  496041986,    19249760]])                     #uninitialized
*)

val empty_like : ?dtype:Dtype.t -> ?order:[`F | `A | `PyObject of Py.Object.t] -> ?subok:bool -> ?shape:int list -> prototype:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
empty_like(prototype, dtype=None, order='K', subok=True, shape=None)

Return a new array with the same shape and type as a given array.

Parameters
----------
prototype : array_like
    The shape and data-type of `prototype` define these same attributes
    of the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if ``prototype`` is Fortran
    contiguous, 'C' otherwise. 'K' means match the layout of ``prototype``
    as closely as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of 'a', otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data with the same
    shape and type as `prototype`.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.

Notes
-----
This function does *not* initialize the returned array; to do that use
`zeros_like` or `ones_like` instead.  It may be marginally faster than
the functions that do set the array values.

Examples
--------
>>> a = ([1,2,3], [4,5,6])                         # a is array-like
>>> np.empty_like(a)
array([[-1073741821, -1073741821,           3],    # uninitialized
       [          0,           0, -1073741821]])
>>> a = np.array([[1., 2., 3.],[4.,5.,6.]])
>>> np.empty_like(a)
array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized
       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])
*)

val equal : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return (x1 == x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
not_equal, greater_equal, less_equal, greater, less

Examples
--------
>>> np.equal([0, 1, 3], np.arange(3))
array([ True,  True, False])

What is compared are values, not types. So an int (1) and an array of
length one can evaluate as True:

>>> np.equal(1, np.ones(1))
array([ True])
*)

val exp : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Calculate the exponential of all elements in the input array.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise exponential of `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
expm1 : Calculate ``exp(x) - 1`` for all elements in the array.
exp2  : Calculate ``2**x`` for all elements in the array.

Notes
-----
The irrational number ``e`` is also known as Euler's number.  It is
approximately 2.718281, and is the base of the natural logarithm,
``ln`` (this means that, if :math:`x = \ln y = \log_e y`,
then :math:`e^x = y`. For real input, ``exp(x)`` is always positive.

For complex arguments, ``x = a + ib``, we can write
:math:`e^x = e^a e^{ib}`.  The first term, :math:`e^a`, is already
known (it is the real argument, described above).  The second term,
:math:`e^{ib}`, is :math:`\cos b + i \sin b`, a function with
magnitude 1 and a periodic phase.

References
----------
.. [1] Wikipedia, 'Exponential function',
       https://en.wikipedia.org/wiki/Exponential_function
.. [2] M. Abramovitz and I. A. Stegun, 'Handbook of Mathematical Functions
       with Formulas, Graphs, and Mathematical Tables,' Dover, 1964, p. 69,
       http://www.math.sfu.ca/~cbm/aands/page_69.htm

Examples
--------
Plot the magnitude and phase of ``exp(x)`` in the complex plane:

>>> import matplotlib.pyplot as plt

>>> x = np.linspace(-2*np.pi, 2*np.pi, 100)
>>> xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
>>> out = np.exp(xx)

>>> plt.subplot(121)
>>> plt.imshow(np.abs(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')
>>> plt.title('Magnitude of exp(x)')

>>> plt.subplot(122)
>>> plt.imshow(np.angle(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')
>>> plt.title('Phase (angle) of exp(x)')
>>> plt.show()
*)

val exp2 : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Calculate `2**p` for all `p` in the input array.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Element-wise 2 to the power `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
power

Notes
-----
.. versionadded:: 1.3.0



Examples
--------
>>> np.exp2([2, 3])
array([ 4.,  8.])
*)

val expand_dims : axis:int list -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Expand the shape of an array.

Insert a new axis that will appear at the `axis` position in the expanded
array shape.

Parameters
----------
a : array_like
    Input array.
axis : int or tuple of ints
    Position in the expanded axes where the new axis (or axes) is placed.

    .. deprecated:: 1.13.0
        Passing an axis where ``axis > a.ndim`` will be treated as
        ``axis == a.ndim``, and passing ``axis < -a.ndim - 1`` will
        be treated as ``axis == 0``. This behavior is deprecated.

    .. versionchanged:: 1.18.0
        A tuple of axes is now supported.  Out of range axes as
        described above are now forbidden and raise an `AxisError`.

Returns
-------
result : ndarray
    View of `a` with the number of dimensions increased.

See Also
--------
squeeze : The inverse operation, removing singleton dimensions
reshape : Insert, remove, and combine dimensions, and resize existing ones
doc.indexing, atleast_1d, atleast_2d, atleast_3d

Examples
--------
>>> x = np.array([1, 2])
>>> x.shape
(2,)

The following is equivalent to ``x[np.newaxis, :]`` or ``x[np.newaxis]``:

>>> y = np.expand_dims(x, axis=0)
>>> y
array([[1, 2]])
>>> y.shape
(1, 2)

The following is equivalent to ``x[:, np.newaxis]``:

>>> y = np.expand_dims(x, axis=1)
>>> y
array([[1],
       [2]])
>>> y.shape
(2, 1)

``axis`` may also be a tuple:

>>> y = np.expand_dims(x, axis=(0, 1))
>>> y
array([[[1, 2]]])

>>> y = np.expand_dims(x, axis=(2, 0))
>>> y
array([[[1],
        [2]]])

Note that some examples may use ``None`` instead of ``np.newaxis``.  These
are the same objects:

>>> np.newaxis is None
True
*)

val expm1 : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Calculate ``exp(x) - 1`` for all elements in the array.

Parameters
----------
x : array_like
   Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Element-wise exponential minus one: ``out = exp(x) - 1``.
    This is a scalar if `x` is a scalar.

See Also
--------
log1p : ``log(1 + x)``, the inverse of expm1.


Notes
-----
This function provides greater precision than ``exp(x) - 1``
for small values of ``x``.

Examples
--------
The true value of ``exp(1e-10) - 1`` is ``1.00000000005e-10`` to
about 32 significant digits. This example shows the superiority of
expm1 in this case.

>>> np.expm1(1e-10)
1.00000000005e-10
>>> np.exp(1e-10) - 1
1.000000082740371e-10
*)

val extract : condition:[>`Ndarray] Obj.t -> arr:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the elements of an array that satisfy some condition.

This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If
`condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.

Note that `place` does the exact opposite of `extract`.

Parameters
----------
condition : array_like
    An array whose nonzero or True entries indicate the elements of `arr`
    to extract.
arr : array_like
    Input array of the same size as `condition`.

Returns
-------
extract : ndarray
    Rank 1 array of values from `arr` where `condition` is True.

See Also
--------
take, put, copyto, compress, place

Examples
--------
>>> arr = np.arange(12).reshape((3, 4))
>>> arr
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> condition = np.mod(arr, 3)==0
>>> condition
array([[ True, False, False,  True],
       [False, False,  True, False],
       [False,  True, False, False]])
>>> np.extract(condition, arr)
array([0, 3, 6, 9])


If `condition` is boolean:

>>> arr[condition]
array([0, 3, 6, 9])
*)

val eye : ?m:int -> ?k:int -> ?dtype:Dtype.t -> ?order:[`C | `F] -> n:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a 2-D array with ones on the diagonal and zeros elsewhere.

Parameters
----------
N : int
  Number of rows in the output.
M : int, optional
  Number of columns in the output. If None, defaults to `N`.
k : int, optional
  Index of the diagonal: 0 (the default) refers to the main diagonal,
  a positive value refers to an upper diagonal, and a negative value
  to a lower diagonal.
dtype : data-type, optional
  Data-type of the returned array.
order : {'C', 'F'}, optional
    Whether the output should be stored in row-major (C-style) or
    column-major (Fortran-style) order in memory.

    .. versionadded:: 1.14.0

Returns
-------
I : ndarray of shape (N,M)
  An array where all elements are equal to zero, except for the `k`-th
  diagonal, whose values are equal to one.

See Also
--------
identity : (almost) equivalent function
diag : diagonal 2-D array from a 1-D array specified by the user.

Examples
--------
>>> np.eye(2, dtype=int)
array([[1, 0],
       [0, 1]])
>>> np.eye(3, k=1)
array([[0.,  1.,  0.],
       [0.,  0.,  1.],
       [0.,  0.,  0.]])
*)

val fabs : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the absolute values element-wise.

This function returns the absolute values (positive magnitude) of the
data in `x`. Complex values are not handled, use `absolute` to find the
absolute values of complex data.

Parameters
----------
x : array_like
    The array of numbers for which the absolute values are required. If
    `x` is a scalar, the result `y` will also be a scalar.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The absolute values of `x`, the returned values are always floats.
    This is a scalar if `x` is a scalar.

See Also
--------
absolute : Absolute values including `complex` types.

Examples
--------
>>> np.fabs(-1)
1.0
>>> np.fabs([-1.2, 1.2])
array([ 1.2,  1.2])
*)

val fastCopyAndTranspose : Py.Object.t -> Py.Object.t
(**
_fastCopyAndTranspose(a)
*)

val fill_diagonal : ?wrap:bool -> val_:[`F of float | `I of int | `Bool of bool | `S of string] -> [`At_least_2_D of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
Fill the main diagonal of the given array of any dimensionality.

For an array `a` with ``a.ndim >= 2``, the diagonal is the list of
locations with indices ``a[i, ..., i]`` all identical. This function
modifies the input array in-place, it does not return a value.

Parameters
----------
a : array, at least 2-D.
  Array whose diagonal is to be filled, it gets modified in-place.

val : scalar
  Value to be written on the diagonal, its type must be compatible with
  that of the array a.

wrap : bool
  For tall matrices in NumPy version up to 1.6.2, the
  diagonal 'wrapped' after N columns. You can have this behavior
  with this option. This affects only tall matrices.

See also
--------
diag_indices, diag_indices_from

Notes
-----
.. versionadded:: 1.4.0

This functionality can be obtained via `diag_indices`, but internally
this version uses a much faster implementation that never constructs the
indices and uses simple slicing.

Examples
--------
>>> a = np.zeros((3, 3), int)
>>> np.fill_diagonal(a, 5)
>>> a
array([[5, 0, 0],
       [0, 5, 0],
       [0, 0, 5]])

The same function can operate on a 4-D array:

>>> a = np.zeros((3, 3, 3, 3), int)
>>> np.fill_diagonal(a, 4)

We only show a few blocks for clarity:

>>> a[0, 0]
array([[4, 0, 0],
       [0, 0, 0],
       [0, 0, 0]])
>>> a[1, 1]
array([[0, 0, 0],
       [0, 4, 0],
       [0, 0, 0]])
>>> a[2, 2]
array([[0, 0, 0],
       [0, 0, 0],
       [0, 0, 4]])

The wrap option affects only tall matrices:

>>> # tall matrices no wrap
>>> a = np.zeros((5, 3), int)
>>> np.fill_diagonal(a, 4)
>>> a
array([[4, 0, 0],
       [0, 4, 0],
       [0, 0, 4],
       [0, 0, 0],
       [0, 0, 0]])

>>> # tall matrices wrap
>>> a = np.zeros((5, 3), int)
>>> np.fill_diagonal(a, 4, wrap=True)
>>> a
array([[4, 0, 0],
       [0, 4, 0],
       [0, 0, 4],
       [0, 0, 0],
       [4, 0, 0]])

>>> # wide matrices
>>> a = np.zeros((3, 5), int)
>>> np.fill_diagonal(a, 4, wrap=True)
>>> a
array([[4, 0, 0, 0, 0],
       [0, 4, 0, 0, 0],
       [0, 0, 4, 0, 0]])

The anti-diagonal can be filled by reversing the order of elements
using either `numpy.flipud` or `numpy.fliplr`.

>>> a = np.zeros((3, 3), int);
>>> np.fill_diagonal(np.fliplr(a), [1,2,3])  # Horizontal flip
>>> a
array([[0, 0, 1],
       [0, 2, 0],
       [3, 0, 0]])
>>> np.fill_diagonal(np.flipud(a), [1,2,3])  # Vertical flip
>>> a
array([[0, 0, 3],
       [0, 2, 0],
       [1, 0, 0]])

Note that the order in which the diagonal is filled varies depending
on the flip function.
*)

val find_common_type : array_types:Py.Object.t -> scalar_types:Py.Object.t -> unit -> Dtype.t
(**
Determine common type following standard coercion rules.

Parameters
----------
array_types : sequence
    A list of dtypes or dtype convertible objects representing arrays.
scalar_types : sequence
    A list of dtypes or dtype convertible objects representing scalars.

Returns
-------
datatype : dtype
    The common data type, which is the maximum of `array_types` ignoring
    `scalar_types`, unless the maximum of `scalar_types` is of a
    different kind (`dtype.kind`). If the kind is not understood, then
    None is returned.

See Also
--------
dtype, common_type, can_cast, mintypecode

Examples
--------
>>> np.find_common_type([], [np.int64, np.float32, complex])
dtype('complex128')
>>> np.find_common_type([np.int64, np.float32], [])
dtype('float64')

The standard casting rules ensure that a scalar cannot up-cast an
array unless the scalar is of a fundamentally different kind of data
(i.e. under a different hierarchy in the data type hierarchy) then
the array:

>>> np.find_common_type([np.float32], [np.int64, np.float64])
dtype('float32')

Complex is of a different type, so it up-casts the float in the
`array_types` argument:

>>> np.find_common_type([np.float32], [complex])
dtype('complex128')

Type specifier strings are convertible to dtypes and can therefore
be used instead of dtypes:

>>> np.find_common_type(['f4', 'f4', 'i4'], ['c8'])
dtype('complex128')
*)

val fix : ?out:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Round to nearest integer towards zero.

Round an array of floats element-wise to nearest integer towards zero.
The rounded values are returned as floats.

Parameters
----------
x : array_like
    An array of floats to be rounded
y : ndarray, optional
    Output array

Returns
-------
out : ndarray of floats
    The array of rounded numbers

See Also
--------
trunc, floor, ceil
around : Round to given number of decimals

Examples
--------
>>> np.fix(3.14)
3.0
>>> np.fix(3)
3.0
>>> np.fix([2.1, 2.9, -2.1, -2.9])
array([ 2.,  2., -2., -2.])
*)

val flatnonzero : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return indices that are non-zero in the flattened version of a.

This is equivalent to np.nonzero(np.ravel(a))[0].

Parameters
----------
a : array_like
    Input data.

Returns
-------
res : ndarray
    Output array, containing the indices of the elements of `a.ravel()`
    that are non-zero.

See Also
--------
nonzero : Return the indices of the non-zero elements of the input array.
ravel : Return a 1-D array containing the elements of the input array.

Examples
--------
>>> x = np.arange(-2, 3)
>>> x
array([-2, -1,  0,  1,  2])
>>> np.flatnonzero(x)
array([0, 1, 3, 4])

Use the indices of the non-zero elements as an index array to extract
these elements:

>>> x.ravel()[np.flatnonzero(x)]
array([-2, -1,  1,  2])
*)

val flip : ?axis:int list -> m:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Reverse the order of elements in an array along the given axis.

The shape of the array is preserved, but the elements are reordered.

.. versionadded:: 1.12.0

Parameters
----------
m : array_like
    Input array.
axis : None or int or tuple of ints, optional
     Axis or axes along which to flip over. The default,
     axis=None, will flip over all of the axes of the input array.
     If axis is negative it counts from the last to the first axis.

     If axis is a tuple of ints, flipping is performed on all of the axes
     specified in the tuple.

     .. versionchanged:: 1.15.0
        None and tuples of axes are supported

Returns
-------
out : array_like
    A view of `m` with the entries of axis reversed.  Since a view is
    returned, this operation is done in constant time.

See Also
--------
flipud : Flip an array vertically (axis=0).
fliplr : Flip an array horizontally (axis=1).

Notes
-----
flip(m, 0) is equivalent to flipud(m).

flip(m, 1) is equivalent to fliplr(m).

flip(m, n) corresponds to ``m[...,::-1,...]`` with ``::-1`` at position n.

flip(m) corresponds to ``m[::-1,::-1,...,::-1]`` with ``::-1`` at all
positions.

flip(m, (0, 1)) corresponds to ``m[::-1,::-1,...]`` with ``::-1`` at
position 0 and position 1.

Examples
--------
>>> A = np.arange(8).reshape((2,2,2))
>>> A
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
>>> np.flip(A, 0)
array([[[4, 5],
        [6, 7]],
       [[0, 1],
        [2, 3]]])
>>> np.flip(A, 1)
array([[[2, 3],
        [0, 1]],
       [[6, 7],
        [4, 5]]])
>>> np.flip(A)
array([[[7, 6],
        [5, 4]],
       [[3, 2],
        [1, 0]]])
>>> np.flip(A, (0, 2))
array([[[5, 4],
        [7, 6]],
       [[1, 0],
        [3, 2]]])
>>> A = np.random.randn(3,4,5)
>>> np.all(np.flip(A,2) == A[:,:,::-1,...])
True
*)

val fliplr : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Flip array in the left/right direction.

Flip the entries in each row in the left/right direction.
Columns are preserved, but appear in a different order than before.

Parameters
----------
m : array_like
    Input array, must be at least 2-D.

Returns
-------
f : ndarray
    A view of `m` with the columns reversed.  Since a view
    is returned, this operation is :math:`\mathcal O(1)`.

See Also
--------
flipud : Flip array in the up/down direction.
rot90 : Rotate array counterclockwise.

Notes
-----
Equivalent to m[:,::-1]. Requires the array to be at least 2-D.

Examples
--------
>>> A = np.diag([1.,2.,3.])
>>> A
array([[1.,  0.,  0.],
       [0.,  2.,  0.],
       [0.,  0.,  3.]])
>>> np.fliplr(A)
array([[0.,  0.,  1.],
       [0.,  2.,  0.],
       [3.,  0.,  0.]])

>>> A = np.random.randn(2,3,5)
>>> np.all(np.fliplr(A) == A[:,::-1,...])
True
*)

val flipud : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Flip array in the up/down direction.

Flip the entries in each column in the up/down direction.
Rows are preserved, but appear in a different order than before.

Parameters
----------
m : array_like
    Input array.

Returns
-------
out : array_like
    A view of `m` with the rows reversed.  Since a view is
    returned, this operation is :math:`\mathcal O(1)`.

See Also
--------
fliplr : Flip array in the left/right direction.
rot90 : Rotate array counterclockwise.

Notes
-----
Equivalent to ``m[::-1,...]``.
Does not require the array to be two-dimensional.

Examples
--------
>>> A = np.diag([1.0, 2, 3])
>>> A
array([[1.,  0.,  0.],
       [0.,  2.,  0.],
       [0.,  0.,  3.]])
>>> np.flipud(A)
array([[0.,  0.,  3.],
       [0.,  2.,  0.],
       [1.,  0.,  0.]])

>>> A = np.random.randn(2,3,5)
>>> np.all(np.flipud(A) == A[::-1,...])
True

>>> np.flipud([1,2])
array([2, 1])
*)

val float_power : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
float_power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

First array elements raised to powers from second array, element-wise.

Raise each base in `x1` to the positionally-corresponding power in `x2`.
`x1` and `x2` must be broadcastable to the same shape. This differs from
the power function in that integers, float16, and float32  are promoted to
floats with a minimum precision of float64 so that the result is always
inexact.  The intent is that the function will return a usable result for
negative powers and seldom overflow for positive powers.

.. versionadded:: 1.12.0

Parameters
----------
x1 : array_like
    The bases.
x2 : array_like
    The exponents. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The bases in `x1` raised to the exponents in `x2`.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
power : power function that preserves type

Examples
--------
Cube each element in a list.

>>> x1 = range(6)
>>> x1
[0, 1, 2, 3, 4, 5]
>>> np.float_power(x1, 3)
array([   0.,    1.,    8.,   27.,   64.,  125.])

Raise the bases to different exponents.

>>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]
>>> np.float_power(x1, x2)
array([  0.,   1.,   8.,  27.,  16.,   5.])

The effect of broadcasting.

>>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])
>>> x2
array([[1, 2, 3, 3, 2, 1],
       [1, 2, 3, 3, 2, 1]])
>>> np.float_power(x1, x2)
array([[  0.,   1.,   8.,  27.,  16.,   5.],
       [  0.,   1.,   8.,  27.,  16.,   5.]])
*)

val floor : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the floor of the input, element-wise.

The floor of the scalar `x` is the largest integer `i`, such that
`i <= x`.  It is often denoted as :math:`\lfloor x \rfloor`.

Parameters
----------
x : array_like
    Input data.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The floor of each element in `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
ceil, trunc, rint

Notes
-----
Some spreadsheet programs calculate the 'floor-towards-zero', in other
words ``floor(-2.5) == -2``.  NumPy instead uses the definition of
`floor` where `floor(-2.5) == -3`.

Examples
--------
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.floor(a)
array([-2., -2., -1.,  0.,  1.,  1.,  2.])
*)

val floor_divide : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the largest integer smaller or equal to the division of the inputs.
It is equivalent to the Python ``//`` operator and pairs with the
Python ``%`` (`remainder`), function so that ``a = a % b + b * (a // b)``
up to roundoff.

Parameters
----------
x1 : array_like
    Numerator.
x2 : array_like
    Denominator. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    y = floor(`x1`/`x2`)
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
remainder : Remainder complementary to floor_divide.
divmod : Simultaneous floor division and remainder.
divide : Standard division.
floor : Round a number to the nearest integer toward minus infinity.
ceil : Round a number to the nearest integer toward infinity.

Examples
--------
>>> np.floor_divide(7,3)
2
>>> np.floor_divide([1., 2., 3., 4.], 2.5)
array([ 0.,  0.,  1.,  1.])
*)

val fmax : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
fmax(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Element-wise maximum of array elements.

Compare two arrays and returns a new array containing the element-wise
maxima. If one of the elements being compared is a NaN, then the
non-nan element is returned. If both elements are NaNs then the first
is returned.  The latter distinction is important for complex NaNs,
which are defined as at least one of the real or imaginary parts being
a NaN. The net effect is that NaNs are ignored when possible.

Parameters
----------
x1, x2 : array_like
    The arrays holding the elements to be compared. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The maximum of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
fmin :
    Element-wise minimum of two arrays, ignores NaNs.
maximum :
    Element-wise maximum of two arrays, propagates NaNs.
amax :
    The maximum value of an array along a given axis, propagates NaNs.
nanmax :
    The maximum value of an array along a given axis, ignores NaNs.

minimum, amin, nanmin

Notes
-----
.. versionadded:: 1.3.0

The fmax is equivalent to ``np.where(x1 >= x2, x1, x2)`` when neither
x1 nor x2 are NaNs, but it is faster and does proper broadcasting.

Examples
--------
>>> np.fmax([2, 3, 4], [1, 5, 2])
array([ 2.,  5.,  4.])

>>> np.fmax(np.eye(2), [0.5, 2])
array([[ 1. ,  2. ],
       [ 0.5,  2. ]])

>>> np.fmax([np.nan, 0, np.nan],[0, np.nan, np.nan])
array([ 0.,  0., nan])
*)

val fmin : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
fmin(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Element-wise minimum of array elements.

Compare two arrays and returns a new array containing the element-wise
minima. If one of the elements being compared is a NaN, then the
non-nan element is returned. If both elements are NaNs then the first
is returned.  The latter distinction is important for complex NaNs,
which are defined as at least one of the real or imaginary parts being
a NaN. The net effect is that NaNs are ignored when possible.

Parameters
----------
x1, x2 : array_like
    The arrays holding the elements to be compared. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The minimum of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
fmax :
    Element-wise maximum of two arrays, ignores NaNs.
minimum :
    Element-wise minimum of two arrays, propagates NaNs.
amin :
    The minimum value of an array along a given axis, propagates NaNs.
nanmin :
    The minimum value of an array along a given axis, ignores NaNs.

maximum, amax, nanmax

Notes
-----
.. versionadded:: 1.3.0

The fmin is equivalent to ``np.where(x1 <= x2, x1, x2)`` when neither
x1 nor x2 are NaNs, but it is faster and does proper broadcasting.

Examples
--------
>>> np.fmin([2, 3, 4], [1, 5, 2])
array([1, 3, 2])

>>> np.fmin(np.eye(2), [0.5, 2])
array([[ 0.5,  0. ],
       [ 0. ,  1. ]])

>>> np.fmin([np.nan, 0, np.nan],[0, np.nan, np.nan])
array([ 0.,  0., nan])
*)

val fmod : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the element-wise remainder of division.

This is the NumPy implementation of the C library function fmod, the
remainder has the same sign as the dividend `x1`. It is equivalent to
the Matlab(TM) ``rem`` function and should not be confused with the
Python modulus operator ``x1 % x2``.

Parameters
----------
x1 : array_like
    Dividend.
x2 : array_like
    Divisor. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : array_like
    The remainder of the division of `x1` by `x2`.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
remainder : Equivalent to the Python ``%`` operator.
divide

Notes
-----
The result of the modulo operation for negative dividend and divisors
is bound by conventions. For `fmod`, the sign of result is the sign of
the dividend, while for `remainder` the sign of the result is the sign
of the divisor. The `fmod` function is equivalent to the Matlab(TM)
``rem`` function.

Examples
--------
>>> np.fmod([-3, -2, -1, 1, 2, 3], 2)
array([-1,  0, -1,  1,  0,  1])
>>> np.remainder([-3, -2, -1, 1, 2, 3], 2)
array([1, 0, 1, 1, 0, 1])

>>> np.fmod([5, 3], [2, 2.])
array([ 1.,  1.])
>>> a = np.arange(-3, 3).reshape(3, 2)
>>> a
array([[-3, -2],
       [-1,  0],
       [ 1,  2]])
>>> np.fmod(a, [2,2])
array([[-1,  0],
       [-1,  0],
       [ 1,  0]])
*)

val format_float_positional : ?precision:Py.Object.t -> ?unique:bool -> ?fractional:bool -> ?trim:[`One_of_k_ of Py.Object.t | `T0 | `Minus | `T_] -> ?sign:Py.Object.t -> ?pad_left:Py.Object.t -> ?pad_right:Py.Object.t -> Py.Object.t -> string
(**
Format a floating-point scalar as a decimal string in positional notation.

Provides control over rounding, trimming and padding. Uses and assumes
IEEE unbiased rounding. Uses the 'Dragon4' algorithm.

Parameters
----------
x : python float or numpy floating scalar
    Value to format.
precision : non-negative integer or None, optional
    Maximum number of digits to print. May be None if `unique` is
    `True`, but must be an integer if unique is `False`.
unique : boolean, optional
    If `True`, use a digit-generation strategy which gives the shortest
    representation which uniquely identifies the floating-point number from
    other values of the same type, by judicious rounding. If `precision`
    was omitted, print out all necessary digits, otherwise digit generation
    is cut off after `precision` digits and the remaining value is rounded.
    If `False`, digits are generated as if printing an infinite-precision
    value and stopping after `precision` digits, rounding the remaining
    value.
fractional : boolean, optional
    If `True`, the cutoff of `precision` digits refers to the total number
    of digits after the decimal point, including leading zeros.
    If `False`, `precision` refers to the total number of significant
    digits, before or after the decimal point, ignoring leading zeros.
trim : one of 'k', '.', '0', '-', optional
    Controls post-processing trimming of trailing digits, as follows:

    * 'k' : keep trailing zeros, keep decimal point (no trimming)
    * '.' : trim all trailing zeros, leave decimal point
    * '0' : trim all but the zero before the decimal point. Insert the
      zero if it is missing.
    * '-' : trim trailing zeros and any trailing decimal point
sign : boolean, optional
    Whether to show the sign for positive values.
pad_left : non-negative integer, optional
    Pad the left side of the string with whitespace until at least that
    many characters are to the left of the decimal point.
pad_right : non-negative integer, optional
    Pad the right side of the string with whitespace until at least that
    many characters are to the right of the decimal point.

Returns
-------
rep : string
    The string representation of the floating point value

See Also
--------
format_float_scientific

Examples
--------
>>> np.format_float_positional(np.float32(np.pi))
'3.1415927'
>>> np.format_float_positional(np.float16(np.pi))
'3.14'
>>> np.format_float_positional(np.float16(0.3))
'0.3'
>>> np.format_float_positional(np.float16(0.3), unique=False, precision=10)
'0.3000488281'
*)

val format_float_scientific : ?precision:Py.Object.t -> ?unique:bool -> ?trim:[`One_of_k_ of Py.Object.t | `T0 | `Minus | `T_] -> ?sign:Py.Object.t -> ?pad_left:Py.Object.t -> ?exp_digits:Py.Object.t -> Py.Object.t -> string
(**
Format a floating-point scalar as a decimal string in scientific notation.

Provides control over rounding, trimming and padding. Uses and assumes
IEEE unbiased rounding. Uses the 'Dragon4' algorithm.

Parameters
----------
x : python float or numpy floating scalar
    Value to format.
precision : non-negative integer or None, optional
    Maximum number of digits to print. May be None if `unique` is
    `True`, but must be an integer if unique is `False`.
unique : boolean, optional
    If `True`, use a digit-generation strategy which gives the shortest
    representation which uniquely identifies the floating-point number from
    other values of the same type, by judicious rounding. If `precision`
    was omitted, print all necessary digits, otherwise digit generation is
    cut off after `precision` digits and the remaining value is rounded.
    If `False`, digits are generated as if printing an infinite-precision
    value and stopping after `precision` digits, rounding the remaining
    value.
trim : one of 'k', '.', '0', '-', optional
    Controls post-processing trimming of trailing digits, as follows:

    * 'k' : keep trailing zeros, keep decimal point (no trimming)
    * '.' : trim all trailing zeros, leave decimal point
    * '0' : trim all but the zero before the decimal point. Insert the
      zero if it is missing.
    * '-' : trim trailing zeros and any trailing decimal point
sign : boolean, optional
    Whether to show the sign for positive values.
pad_left : non-negative integer, optional
    Pad the left side of the string with whitespace until at least that
    many characters are to the left of the decimal point.
exp_digits : non-negative integer, optional
    Pad the exponent with zeros until it contains at least this many digits.
    If omitted, the exponent will be at least 2 digits.

Returns
-------
rep : string
    The string representation of the floating point value

See Also
--------
format_float_positional

Examples
--------
>>> np.format_float_scientific(np.float32(np.pi))
'3.1415927e+00'
>>> s = np.float32(1.23e24)
>>> np.format_float_scientific(s, unique=False, precision=15)
'1.230000071797338e+24'
>>> np.format_float_scientific(s, exp_digits=4)
'1.23e+0024'
*)

val frexp : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
frexp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Decompose the elements of x into mantissa and twos exponent.

Returns (`mantissa`, `exponent`), where `x = mantissa * 2**exponent``.
The mantissa is lies in the open interval(-1, 1), while the twos
exponent is a signed integer.

Parameters
----------
x : array_like
    Array of numbers to be decomposed.
out1 : ndarray, optional
    Output array for the mantissa. Must have the same shape as `x`.
out2 : ndarray, optional
    Output array for the exponent. Must have the same shape as `x`.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
mantissa : ndarray
    Floating values between -1 and 1.
    This is a scalar if `x` is a scalar.
exponent : ndarray
    Integer exponents of 2.
    This is a scalar if `x` is a scalar.

See Also
--------
ldexp : Compute ``y = x1 * 2**x2``, the inverse of `frexp`.

Notes
-----
Complex dtypes are not supported, they will raise a TypeError.

Examples
--------
>>> x = np.arange(9)
>>> y1, y2 = np.frexp(x)
>>> y1
array([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,
        0.5  ])
>>> y2
array([0, 1, 2, 2, 3, 3, 3, 3, 4])
>>> y1 * 2**y2
array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])
*)

val frombuffer : ?dtype:Dtype.t -> ?count:int -> ?offset:int -> buffer:Py.Object.t -> unit -> Py.Object.t
(**
frombuffer(buffer, dtype=float, count=-1, offset=0)

Interpret a buffer as a 1-dimensional array.

Parameters
----------
buffer : buffer_like
    An object that exposes the buffer interface.
dtype : data-type, optional
    Data-type of the returned array; default: float.
count : int, optional
    Number of items to read. ``-1`` means all data in the buffer.
offset : int, optional
    Start reading the buffer from this offset (in bytes); default: 0.

Notes
-----
If the buffer has data that is not in machine byte-order, this should
be specified as part of the data-type, e.g.::

  >>> dt = np.dtype(int)
  >>> dt = dt.newbyteorder('>')
  >>> np.frombuffer(buf, dtype=dt) # doctest: +SKIP

The data of the resulting array will not be byteswapped, but will be
interpreted correctly.

Examples
--------
>>> s = b'hello world'
>>> np.frombuffer(s, dtype='S1', count=5, offset=6)
array([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')

>>> np.frombuffer(b'\x01\x02', dtype=np.uint8)
array([1, 2], dtype=uint8)
>>> np.frombuffer(b'\x01\x02\x03\x04\x05', dtype=np.uint8, count=3)
array([1, 2, 3], dtype=uint8)
*)

val fromfile : ?dtype:Dtype.t -> ?count:int -> ?sep:string -> ?offset:int -> file:[`S of string | `PyObject of Py.Object.t] -> unit -> Py.Object.t
(**
fromfile(file, dtype=float, count=-1, sep='', offset=0)

Construct an array from data in a text or binary file.

A highly efficient way of reading binary data with a known data-type,
as well as parsing simply formatted text files.  Data written using the
`tofile` method can be read using this function.

Parameters
----------
file : file or str or Path
    Open file object or filename.

    .. versionchanged:: 1.17.0
        `pathlib.Path` objects are now accepted.

dtype : data-type
    Data type of the returned array.
    For binary files, it is used to determine the size and byte-order
    of the items in the file.
    Most builtin numeric types are supported and extension types may be supported.

    .. versionadded:: 1.18.0
        Complex dtypes.

count : int
    Number of items to read. ``-1`` means all items (i.e., the complete
    file).
sep : str
    Separator between items if file is a text file.
    Empty ('') separator means the file should be treated as binary.
    Spaces (' ') in the separator match zero or more whitespace characters.
    A separator consisting only of spaces must match at least one
    whitespace.
offset : int
    The offset (in bytes) from the file's current position. Defaults to 0.
    Only permitted for binary files.

    .. versionadded:: 1.17.0

See also
--------
load, save
ndarray.tofile
loadtxt : More flexible way of loading data from a text file.

Notes
-----
Do not rely on the combination of `tofile` and `fromfile` for
data storage, as the binary files generated are not platform
independent.  In particular, no byte-order or data-type information is
saved.  Data can be stored in the platform independent ``.npy`` format
using `save` and `load` instead.

Examples
--------
Construct an ndarray:

>>> dt = np.dtype([('time', [('min', np.int64), ('sec', np.int64)]),
...                ('temp', float)])
>>> x = np.zeros((1,), dtype=dt)
>>> x['time']['min'] = 10; x['temp'] = 98.25
>>> x
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])

Save the raw data to disk:

>>> import tempfile
>>> fname = tempfile.mkstemp()[1]
>>> x.tofile(fname)

Read the raw data from disk:

>>> np.fromfile(fname, dtype=dt)
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])

The recommended way to store and load data:

>>> np.save(fname, x)
>>> np.load(fname + '.npy')
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])
*)

val fromfunction : ?kwargs:(string * Py.Object.t) list -> function_:Py.Object.t -> int list -> Py.Object.t
(**
Construct an array by executing a function over each coordinate.

The resulting array therefore has a value ``fn(x, y, z)`` at
coordinate ``(x, y, z)``.

Parameters
----------
function : callable
    The function is called with N parameters, where N is the rank of
    `shape`.  Each parameter represents the coordinates of the array
    varying along a specific axis.  For example, if `shape`
    were ``(2, 2)``, then the parameters would be
    ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``
shape : (N,) tuple of ints
    Shape of the output array, which also determines the shape of
    the coordinate arrays passed to `function`.
dtype : data-type, optional
    Data-type of the coordinate arrays passed to `function`.
    By default, `dtype` is float.

Returns
-------
fromfunction : any
    The result of the call to `function` is passed back directly.
    Therefore the shape of `fromfunction` is completely determined by
    `function`.  If `function` returns a scalar value, the shape of
    `fromfunction` would not match the `shape` parameter.

See Also
--------
indices, meshgrid

Notes
-----
Keywords other than `dtype` are passed to `function`.

Examples
--------
>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
array([[ True, False, False],
       [False,  True, False],
       [False, False,  True]])

>>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)
array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])
*)

val fromiter : ?count:int -> iterable:Py.Object.t -> dtype:Dtype.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
fromiter(iterable, dtype, count=-1)

Create a new 1-dimensional array from an iterable object.

Parameters
----------
iterable : iterable object
    An iterable object providing data for the array.
dtype : data-type
    The data-type of the returned array.
count : int, optional
    The number of items to read from *iterable*.  The default is -1,
    which means all data is read.

Returns
-------
out : ndarray
    The output array.

Notes
-----
Specify `count` to improve performance.  It allows ``fromiter`` to
pre-allocate the output array, instead of resizing it on demand.

Examples
--------
>>> iterable = (x*x for x in range(5))
>>> np.fromiter(iterable, float)
array([  0.,   1.,   4.,   9.,  16.])
*)

val frompyfunc : func:Py.Object.t -> nin:int -> nout:int -> unit -> Py.Object.t
(**
frompyfunc(func, nin, nout)

Takes an arbitrary Python function and returns a NumPy ufunc.

Can be used, for example, to add broadcasting to a built-in Python
function (see Examples section).

Parameters
----------
func : Python function object
    An arbitrary Python function.
nin : int
    The number of input arguments.
nout : int
    The number of objects returned by `func`.

Returns
-------
out : ufunc
    Returns a NumPy universal function (``ufunc``) object.

See Also
--------
vectorize : Evaluates pyfunc over input arrays using broadcasting rules of numpy.

Notes
-----
The returned ufunc always returns PyObject arrays.

Examples
--------
Use frompyfunc to add broadcasting to the Python function ``oct``:

>>> oct_array = np.frompyfunc(oct, 1, 1)
>>> oct_array(np.array((10, 30, 100)))
array(['0o12', '0o36', '0o144'], dtype=object)
>>> np.array((oct(10), oct(30), oct(100))) # for comparison
array(['0o12', '0o36', '0o144'], dtype='<U5')
*)

val fromregex : ?encoding:string -> file:[`File of Py.Object.t | `S of string] -> regexp:[`Regexp of Py.Object.t | `S of string] -> dtype:[`List_of_dtypes of Py.Object.t | `Dtype of Dtype.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Construct an array from a text file, using regular expression parsing.

The returned array is always a structured array, and is constructed from
all matches of the regular expression in the file. Groups in the regular
expression are converted to fields of the structured array.

Parameters
----------
file : str or file
    Filename or file object to read.
regexp : str or regexp
    Regular expression used to parse the file.
    Groups in the regular expression correspond to fields in the dtype.
dtype : dtype or list of dtypes
    Dtype for the structured array.
encoding : str, optional
    Encoding used to decode the inputfile. Does not apply to input streams.

    .. versionadded:: 1.14.0

Returns
-------
output : ndarray
    The output array, containing the part of the content of `file` that
    was matched by `regexp`. `output` is always a structured array.

Raises
------
TypeError
    When `dtype` is not a valid dtype for a structured array.

See Also
--------
fromstring, loadtxt

Notes
-----
Dtypes for structured arrays can be specified in several forms, but all
forms specify at least the data type and field name. For details see
`doc.structured_arrays`.

Examples
--------
>>> f = open('test.dat', 'w')
>>> _ = f.write('1312 foo\n1534  bar\n444   qux')
>>> f.close()

>>> regexp = r'(\d+)\s+(...)'  # match [digits, whitespace, anything]
>>> output = np.fromregex('test.dat', regexp,
...                       [('num', np.int64), ('key', 'S3')])
>>> output
array([(1312, b'foo'), (1534, b'bar'), ( 444, b'qux')],
      dtype=[('num', '<i8'), ('key', 'S3')])
>>> output['num']
array([1312, 1534,  444])
*)

val fromstring : ?dtype:Dtype.t -> ?count:int -> ?sep:string -> string:string -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
fromstring(string, dtype=float, count=-1, sep='')

A new 1-D array initialized from text data in a string.

Parameters
----------
string : str
    A string containing the data.
dtype : data-type, optional
    The data type of the array; default: float.  For binary input data,
    the data must be in exactly this format. Most builtin numeric types are 
    supported and extension types may be supported.

    .. versionadded:: 1.18.0
        Complex dtypes.

count : int, optional
    Read this number of `dtype` elements from the data.  If this is
    negative (the default), the count will be determined from the
    length of the data.
sep : str, optional
    The string separating numbers in the data; extra whitespace between
    elements is also ignored.

    .. deprecated:: 1.14
        Passing ``sep=''``, the default, is deprecated since it will
        trigger the deprecated binary mode of this function. This mode
        interprets `string` as binary bytes, rather than ASCII text with
        decimal numbers, an operation which is better spelt
        ``frombuffer(string, dtype, count)``. If `string` contains unicode
        text, the binary mode of `fromstring` will first encode it into
        bytes using either utf-8 (python 3) or the default encoding
        (python 2), neither of which produce sane results.

Returns
-------
arr : ndarray
    The constructed array.

Raises
------
ValueError
    If the string is not the correct size to satisfy the requested
    `dtype` and `count`.

See Also
--------
frombuffer, fromfile, fromiter

Examples
--------
>>> np.fromstring('1 2', dtype=int, sep=' ')
array([1, 2])
>>> np.fromstring('1, 2', dtype=int, sep=',')
array([1, 2])
*)

val full : ?dtype:Dtype.t -> ?order:[`C | `F] -> fill_value:[`F of float | `I of int | `Bool of bool | `S of string] -> int list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a new array of given shape and type, filled with `fill_value`.

Parameters
----------
shape : int or sequence of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
fill_value : scalar
    Fill value.
dtype : data-type, optional
    The desired data-type for the array  The default, None, means
     `np.array(fill_value).dtype`.
order : {'C', 'F'}, optional
    Whether to store multidimensional data in C- or Fortran-contiguous
    (row- or column-wise) order in memory.

Returns
-------
out : ndarray
    Array of `fill_value` with the given shape, dtype, and order.

See Also
--------
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.

Examples
--------
>>> np.full((2, 2), np.inf)
array([[inf, inf],
       [inf, inf]])
>>> np.full((2, 2), 10)
array([[10, 10],
       [10, 10]])
*)

val full_like : ?dtype:Dtype.t -> ?order:[`F | `A | `PyObject of Py.Object.t] -> ?subok:bool -> ?shape:int list -> fill_value:[`F of float | `I of int | `Bool of bool | `S of string] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a full array with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
fill_value : scalar
    Fill value.
dtype : data-type, optional
    Overrides the data type of the result.
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of 'a', otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of `fill_value` with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full : Return a new array of given shape filled with value.

Examples
--------
>>> x = np.arange(6, dtype=int)
>>> np.full_like(x, 1)
array([1, 1, 1, 1, 1, 1])
>>> np.full_like(x, 0.1)
array([0, 0, 0, 0, 0, 0])
>>> np.full_like(x, 0.1, dtype=np.double)
array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
>>> np.full_like(x, np.nan, dtype=np.double)
array([nan, nan, nan, nan, nan, nan])

>>> y = np.arange(6, dtype=np.double)
>>> np.full_like(y, 0.1)
array([0.1,  0.1,  0.1,  0.1,  0.1,  0.1])
*)

val fv : ?when_:[`Begin | `I of int | `PyObject of Py.Object.t] -> rate:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> nper:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> pmt:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> pv:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the future value.

.. deprecated:: 1.18

   `fv` is deprecated; for details, see NEP 32 [1]_.
   Use the corresponding function in the numpy-financial library,
   https://pypi.org/project/numpy-financial.

Given:
 * a present value, `pv`
 * an interest `rate` compounded once per period, of which
   there are
 * `nper` total
 * a (fixed) payment, `pmt`, paid either
 * at the beginning (`when` = {'begin', 1}) or the end
   (`when` = {'end', 0}) of each period

Return:
   the value at the end of the `nper` periods

Parameters
----------
rate : scalar or array_like of shape(M, )
    Rate of interest as decimal (not per cent) per period
nper : scalar or array_like of shape(M, )
    Number of compounding periods
pmt : scalar or array_like of shape(M, )
    Payment
pv : scalar or array_like of shape(M, )
    Present value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0)).
    Defaults to {'end', 0}.

Returns
-------
out : ndarray
    Future values.  If all input is scalar, returns a scalar float.  If
    any input is array_like, returns future values for each input element.
    If multiple inputs are array_like, they all must have the same shape.

Notes
-----
The future value is computed by solving the equation::

 fv +
 pv*(1+rate)**nper +
 pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0

or, when ``rate == 0``::

 fv + pv + pmt * nper == 0

References
----------
.. [1] NumPy Enhancement Proposal (NEP) 32,
   https://numpy.org/neps/nep-0032-remove-financial-functions.html
.. [2] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).
   Open Document Format for Office Applications (OpenDocument)v1.2,
   Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,
   Pre-Draft 12. Organization for the Advancement of Structured Information
   Standards (OASIS). Billerica, MA, USA. [ODT Document].
   Available:
   http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula
   OpenDocument-formula-20090508.odt


Examples
--------
What is the future value after 10 years of saving $100 now, with
an additional monthly savings of $100.  Assume the interest rate is
5% (annually) compounded monthly?

>>> np.fv(0.05/12, 10*12, -100, -100)
15692.928894335748

By convention, the negative sign represents cash flow out (i.e. money not
available today).  Thus, saving $100 a month at 5% annual interest leads
to $15,692.93 available to spend in 10 years.

If any input is array_like, returns an array of equal shape.  Let's
compare different interest rates from the example above.

>>> a = np.array((0.05, 0.06, 0.07))/12
>>> np.fv(a, 10*12, -100, -100)
array([ 15692.92889434,  16569.87435405,  17509.44688102]) # may vary
*)

val gcd : ?out:Py.Object.t -> ?where:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
gcd(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Returns the greatest common divisor of ``|x1|`` and ``|x2|``

Parameters
----------
x1, x2 : array_like, int
    Arrays of values. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).

Returns
-------
y : ndarray or scalar
    The greatest common divisor of the absolute value of the inputs
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
lcm : The lowest common multiple

Examples
--------
>>> np.gcd(12, 20)
4
>>> np.gcd.reduce([15, 25, 35])
5
>>> np.gcd(np.arange(6), 20)
array([20,  1,  2,  1,  4,  5])
*)

val genfromtxt : ?dtype:Dtype.t -> ?comments:string -> ?delimiter:[`Sequence of Py.Object.t | `I of int | `S of string] -> ?skip_header:int -> ?skip_footer:int -> ?converters:Py.Object.t -> ?missing_values:Py.Object.t -> ?filling_values:Py.Object.t -> ?usecols:Py.Object.t -> ?names:[`Sequence of Py.Object.t | `True | `S of string] -> ?excludelist:Py.Object.t -> ?deletechars:string -> ?replace_space:Py.Object.t -> ?autostrip:bool -> ?case_sensitive:[`Upper | `Bool of bool | `Lower] -> ?defaultfmt:string -> ?unpack:bool -> ?usemask:bool -> ?loose:bool -> ?invalid_raise:bool -> ?max_rows:int -> ?encoding:string -> fname:[`StringList of string list | `S of string | `PyObject of Py.Object.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Load data from a text file, with missing values handled as specified.

Each line past the first `skip_header` lines is split at the `delimiter`
character, and characters following the `comments` character are discarded.

Parameters
----------
fname : file, str, pathlib.Path, list of str, generator
    File, filename, list, or generator to read.  If the filename
    extension is `.gz` or `.bz2`, the file is first decompressed. Note
    that generators must return byte strings. The strings
    in a list or produced by a generator are treated as lines.
dtype : dtype, optional
    Data type of the resulting array.
    If None, the dtypes will be determined by the contents of each
    column, individually.
comments : str, optional
    The character used to indicate the start of a comment.
    All the characters occurring on a line after a comment are discarded
delimiter : str, int, or sequence, optional
    The string used to separate values.  By default, any consecutive
    whitespaces act as delimiter.  An integer or sequence of integers
    can also be provided as width(s) of each field.
skiprows : int, optional
    `skiprows` was removed in numpy 1.10. Please use `skip_header` instead.
skip_header : int, optional
    The number of lines to skip at the beginning of the file.
skip_footer : int, optional
    The number of lines to skip at the end of the file.
converters : variable, optional
    The set of functions that convert the data of a column to a value.
    The converters can also be used to provide a default value
    for missing data: ``converters = {3: lambda s: float(s or 0)}``.
missing : variable, optional
    `missing` was removed in numpy 1.10. Please use `missing_values`
    instead.
missing_values : variable, optional
    The set of strings corresponding to missing data.
filling_values : variable, optional
    The set of values to be used as default when the data are missing.
usecols : sequence, optional
    Which columns to read, with 0 being the first.  For example,
    ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.
names : {None, True, str, sequence}, optional
    If `names` is True, the field names are read from the first line after
    the first `skip_header` lines.  This line can optionally be proceeded
    by a comment delimiter. If `names` is a sequence or a single-string of
    comma-separated names, the names will be used to define the field names
    in a structured dtype. If `names` is None, the names of the dtype
    fields will be used, if any.
excludelist : sequence, optional
    A list of names to exclude. This list is appended to the default list
    ['return','file','print']. Excluded names are appended an underscore:
    for example, `file` would become `file_`.
deletechars : str, optional
    A string combining invalid characters that must be deleted from the
    names.
defaultfmt : str, optional
    A format used to define default field names, such as 'f%i' or 'f_%02i'.
autostrip : bool, optional
    Whether to automatically strip white spaces from the variables.
replace_space : char, optional
    Character(s) used in replacement of white spaces in the variables
    names. By default, use a '_'.
case_sensitive : {True, False, 'upper', 'lower'}, optional
    If True, field names are case sensitive.
    If False or 'upper', field names are converted to upper case.
    If 'lower', field names are converted to lower case.
unpack : bool, optional
    If True, the returned array is transposed, so that arguments may be
    unpacked using ``x, y, z = loadtxt(...)``
usemask : bool, optional
    If True, return a masked array.
    If False, return a regular array.
loose : bool, optional
    If True, do not raise errors for invalid values.
invalid_raise : bool, optional
    If True, an exception is raised if an inconsistency is detected in the
    number of columns.
    If False, a warning is emitted and the offending lines are skipped.
max_rows : int,  optional
    The maximum number of rows to read. Must not be used with skip_footer
    at the same time.  If given, the value must be at least 1. Default is
    to read the entire file.

    .. versionadded:: 1.10.0
encoding : str, optional
    Encoding used to decode the inputfile. Does not apply when `fname` is
    a file object.  The special value 'bytes' enables backward compatibility
    workarounds that ensure that you receive byte arrays when possible
    and passes latin1 encoded strings to converters. Override this value to
    receive unicode arrays and pass strings as input to converters.  If set
    to None the system default is used. The default value is 'bytes'.

    .. versionadded:: 1.14.0

Returns
-------
out : ndarray
    Data read from the text file. If `usemask` is True, this is a
    masked array.

See Also
--------
numpy.loadtxt : equivalent function when no data is missing.

Notes
-----
* When spaces are used as delimiters, or when no delimiter has been given
  as input, there should not be any missing data between two fields.
* When the variables are named (either by a flexible dtype or with `names`,
  there must not be any header in the file (else a ValueError
  exception is raised).
* Individual values are not stripped of spaces by default.
  When using a custom converter, make sure the function does remove spaces.

References
----------
.. [1] NumPy User Guide, section `I/O with NumPy
       <https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html>`_.

Examples
---------
>>> from io import StringIO
>>> import numpy as np

Comma delimited file with mixed dtype

>>> s = StringIO(u'1,1.3,abcde')
>>> data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),
... ('mystring','S5')], delimiter=',')
>>> data
array((1, 1.3, b'abcde'),
      dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', 'S5')])

Using dtype = None

>>> _ = s.seek(0) # needed for StringIO example only
>>> data = np.genfromtxt(s, dtype=None,
... names = ['myint','myfloat','mystring'], delimiter=',')
>>> data
array((1, 1.3, b'abcde'),
      dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', 'S5')])

Specifying dtype and names

>>> _ = s.seek(0)
>>> data = np.genfromtxt(s, dtype='i8,f8,S5',
... names=['myint','myfloat','mystring'], delimiter=',')
>>> data
array((1, 1.3, b'abcde'),
      dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', 'S5')])

An example with fixed-width columns

>>> s = StringIO(u'11.3abcde')
>>> data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],
...     delimiter=[1,3,5])
>>> data
array((1, 1.3, b'abcde'),
      dtype=[('intvar', '<i8'), ('fltvar', '<f8'), ('strvar', 'S5')])

An example to show comments

>>> f = StringIO('''
... text,# of chars
... hello world,11
... numpy,5''')
>>> np.genfromtxt(f, dtype='S12,S12', delimiter=',')
array([(b'text', b''), (b'hello world', b'11'), (b'numpy', b'5')],
  dtype=[('f0', 'S12'), ('f1', 'S12')])
*)

val geomspace : ?num:int -> ?endpoint:bool -> ?dtype:Dtype.t -> ?axis:int -> start:[>`Ndarray] Obj.t -> stop:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return numbers spaced evenly on a log scale (a geometric progression).

This is similar to `logspace`, but with endpoints specified directly.
Each output sample is a constant multiple of the previous.

.. versionchanged:: 1.16.0
    Non-scalar `start` and `stop` are now supported.

Parameters
----------
start : array_like
    The starting value of the sequence.
stop : array_like
    The final value of the sequence, unless `endpoint` is False.
    In that case, ``num + 1`` values are spaced over the
    interval in log-space, of which all but the last (a sequence of
    length `num`) are returned.
num : integer, optional
    Number of samples to generate.  Default is 50.
endpoint : boolean, optional
    If true, `stop` is the last sample. Otherwise, it is not included.
    Default is True.
dtype : dtype
    The type of the output array.  If `dtype` is not given, infer the data
    type from the other input arguments.
axis : int, optional
    The axis in the result to store the samples.  Relevant only if start
    or stop are array-like.  By default (0), the samples will be along a
    new axis inserted at the beginning. Use -1 to get an axis at the end.

    .. versionadded:: 1.16.0

Returns
-------
samples : ndarray
    `num` samples, equally spaced on a log scale.

See Also
--------
logspace : Similar to geomspace, but with endpoints specified using log
           and base.
linspace : Similar to geomspace, but with arithmetic instead of geometric
           progression.
arange : Similar to linspace, with the step size specified instead of the
         number of samples.

Notes
-----
If the inputs or dtype are complex, the output will follow a logarithmic
spiral in the complex plane.  (There are an infinite number of spirals
passing through two points; the output will follow the shortest such path.)

Examples
--------
>>> np.geomspace(1, 1000, num=4)
array([    1.,    10.,   100.,  1000.])
>>> np.geomspace(1, 1000, num=3, endpoint=False)
array([   1.,   10.,  100.])
>>> np.geomspace(1, 1000, num=4, endpoint=False)
array([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])
>>> np.geomspace(1, 256, num=9)
array([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])

Note that the above may not produce exact integers:

>>> np.geomspace(1, 256, num=9, dtype=int)
array([  1,   2,   4,   7,  16,  32,  63, 127, 256])
>>> np.around(np.geomspace(1, 256, num=9)).astype(int)
array([  1,   2,   4,   8,  16,  32,  64, 128, 256])

Negative, decreasing, and complex inputs are allowed:

>>> np.geomspace(1000, 1, num=4)
array([1000.,  100.,   10.,    1.])
>>> np.geomspace(-1000, -1, num=4)
array([-1000.,  -100.,   -10.,    -1.])
>>> np.geomspace(1j, 1000j, num=4)  # Straight line
array([0.   +1.j, 0.  +10.j, 0. +100.j, 0.+1000.j])
>>> np.geomspace(-1+0j, 1+0j, num=5)  # Circle
array([-1.00000000e+00+1.22464680e-16j, -7.07106781e-01+7.07106781e-01j,
        6.12323400e-17+1.00000000e+00j,  7.07106781e-01+7.07106781e-01j,
        1.00000000e+00+0.00000000e+00j])

Graphical illustration of ``endpoint`` parameter:

>>> import matplotlib.pyplot as plt
>>> N = 10
>>> y = np.zeros(N)
>>> plt.semilogx(np.geomspace(1, 1000, N, endpoint=True), y + 1, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.semilogx(np.geomspace(1, 1000, N, endpoint=False), y + 2, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.axis([0.5, 2000, 0, 3])
[0.5, 2000, 0, 3]
>>> plt.grid(True, color='0.7', linestyle='-', which='both', axis='both')
>>> plt.show()
*)

val get_array_wrap : Py.Object.t list -> Py.Object.t
(**
Find the wrapper for the array with the highest priority.

In case of ties, leftmost wins. If no wrapper is found, return None
*)

val get_include : unit -> Py.Object.t
(**
Return the directory that contains the NumPy \*.h header files.

Extension modules that need to compile against NumPy should use this
function to locate the appropriate include directory.

Notes
-----
When using ``distutils``, for example in ``setup.py``.
::

    import numpy as np
    ...
    Extension('extension_name', ...
            include_dirs=[np.get_include()])
    ...
*)

val get_printoptions : unit -> Py.Object.t
(**
Return the current print options.

Returns
-------
print_opts : dict
    Dictionary of current print options with keys

      - precision : int
      - threshold : int
      - edgeitems : int
      - linewidth : int
      - suppress : bool
      - nanstr : str
      - infstr : str
      - formatter : dict of callables
      - sign : str

    For a full description of these options, see `set_printoptions`.

See Also
--------
set_printoptions, printoptions, set_string_function
*)

val getbufsize : unit -> int
(**
Return the size of the buffer used in ufuncs.

Returns
-------
getbufsize : int
    Size of ufunc buffer in bytes.
*)

val geterr : unit -> Py.Object.t
(**
Get the current way of handling floating-point errors.

Returns
-------
res : dict
    A dictionary with keys 'divide', 'over', 'under', and 'invalid',
    whose values are from the strings 'ignore', 'print', 'log', 'warn',
    'raise', and 'call'. The keys represent possible floating-point
    exceptions, and the values define how these exceptions are handled.

See Also
--------
geterrcall, seterr, seterrcall

Notes
-----
For complete documentation of the types of floating-point exceptions and
treatment options, see `seterr`.

Examples
--------
>>> from collections import OrderedDict
>>> sorted(np.geterr().items())
[('divide', 'warn'), ('invalid', 'warn'), ('over', 'warn'), ('under', 'ignore')]
>>> np.arange(3.) / np.arange(3.)
array([nan,  1.,  1.])

>>> oldsettings = np.seterr(all='warn', over='raise')
>>> OrderedDict(sorted(np.geterr().items()))
OrderedDict([('divide', 'warn'), ('invalid', 'warn'), ('over', 'raise'), ('under', 'warn')])
>>> np.arange(3.) / np.arange(3.)
array([nan,  1.,  1.])
*)

val geterrcall : unit -> Py.Object.t option
(**
Return the current callback function used on floating-point errors.

When the error handling for a floating-point error (one of 'divide',
'over', 'under', or 'invalid') is set to 'call' or 'log', the function
that is called or the log instance that is written to is returned by
`geterrcall`. This function or log instance has been set with
`seterrcall`.

Returns
-------
errobj : callable, log instance or None
    The current error handler. If no handler was set through `seterrcall`,
    ``None`` is returned.

See Also
--------
seterrcall, seterr, geterr

Notes
-----
For complete documentation of the types of floating-point exceptions and
treatment options, see `seterr`.

Examples
--------
>>> np.geterrcall()  # we did not yet set a handler, returns None

>>> oldsettings = np.seterr(all='call')
>>> def err_handler(type, flag):
...     print('Floating point error (%s), with flag %s' % (type, flag))
>>> oldhandler = np.seterrcall(err_handler)
>>> np.array([1, 2, 3]) / 0.0
Floating point error (divide by zero), with flag 1
array([inf, inf, inf])

>>> cur_handler = np.geterrcall()
>>> cur_handler is err_handler
True
*)

val gradient : ?kwargs:(string * Py.Object.t) list -> f:[>`Ndarray] Obj.t -> Py.Object.t list -> Py.Object.t
(**
Return the gradient of an N-dimensional array.

The gradient is computed using second order accurate central differences
in the interior points and either first or second order accurate one-sides
(forward or backwards) differences at the boundaries.
The returned gradient hence has the same shape as the input array.

Parameters
----------
f : array_like
    An N-dimensional array containing samples of a scalar function.
varargs : list of scalar or array, optional
    Spacing between f values. Default unitary spacing for all dimensions.
    Spacing can be specified using:

    1. single scalar to specify a sample distance for all dimensions.
    2. N scalars to specify a constant sample distance for each dimension.
       i.e. `dx`, `dy`, `dz`, ...
    3. N arrays to specify the coordinates of the values along each
       dimension of F. The length of the array must match the size of
       the corresponding dimension
    4. Any combination of N scalars/arrays with the meaning of 2. and 3.

    If `axis` is given, the number of varargs must equal the number of axes.
    Default: 1.

edge_order : {1, 2}, optional
    Gradient is calculated using N-th order accurate differences
    at the boundaries. Default: 1.

    .. versionadded:: 1.9.1

axis : None or int or tuple of ints, optional
    Gradient is calculated only along the given axis or axes
    The default (axis = None) is to calculate the gradient for all the axes
    of the input array. axis may be negative, in which case it counts from
    the last to the first axis.

    .. versionadded:: 1.11.0

Returns
-------
gradient : ndarray or list of ndarray
    A set of ndarrays (or a single ndarray if there is only one dimension)
    corresponding to the derivatives of f with respect to each dimension.
    Each derivative has the same shape as f.

Examples
--------
>>> f = np.array([1, 2, 4, 7, 11, 16], dtype=float)
>>> np.gradient(f)
array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])
>>> np.gradient(f, 2)
array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])

Spacing can be also specified with an array that represents the coordinates
of the values F along the dimensions.
For instance a uniform spacing:

>>> x = np.arange(f.size)
>>> np.gradient(f, x)
array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])

Or a non uniform one:

>>> x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)
>>> np.gradient(f, x)
array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])

For two dimensional arrays, the return will be two arrays ordered by
axis. In this example the first array stands for the gradient in
rows and the second one in columns direction:

>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))
[array([[ 2.,  2., -1.],
       [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],
       [1. , 1. , 1. ]])]

In this example the spacing is also specified:
uniform for axis=0 and non uniform for axis=1

>>> dx = 2.
>>> y = [1., 1.5, 3.5]
>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)
[array([[ 1. ,  1. , -0.5],
       [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],
       [2. , 1.7, 0.5]])]

It is possible to specify how boundaries are treated using `edge_order`

>>> x = np.array([0, 1, 2, 3, 4])
>>> f = x**2
>>> np.gradient(f, edge_order=1)
array([1.,  2.,  4.,  6.,  7.])
>>> np.gradient(f, edge_order=2)
array([0., 2., 4., 6., 8.])

The `axis` keyword can be used to specify a subset of axes of which the
gradient is calculated

>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)
array([[ 2.,  2., -1.],
       [ 2.,  2., -1.]])

Notes
-----
Assuming that :math:`f\in C^{3}` (i.e., :math:`f` has at least 3 continuous
derivatives) and let :math:`h_{*}` be a non-homogeneous stepsize, we
minimize the 'consistency error' :math:`\eta_{i}` between the true gradient
and its estimate from a linear combination of the neighboring grid-points:

.. math::

    \eta_{i} = f_{i}^{\left(1\right)} -
                \left[ \alpha f\left(x_{i}\right) +
                        \beta f\left(x_{i} + h_{d}\right) +
                        \gamma f\left(x_{i}-h_{s}\right)
                \right]

By substituting :math:`f(x_{i} + h_{d})` and :math:`f(x_{i} - h_{s})`
with their Taylor series expansion, this translates into solving
the following the linear system:

.. math::

    \left\{
        \begin{array}{r}
            \alpha+\beta+\gamma=0 \\
            \beta h_{d}-\gamma h_{s}=1 \\
            \beta h_{d}^{2}+\gamma h_{s}^{2}=0
        \end{array}
    \right.

The resulting approximation of :math:`f_{i}^{(1)}` is the following:

.. math::

    \hat f_{i}^{(1)} =
        \frac{
            h_{s}^{2}f\left(x_{i} + h_{d}\right)
            + \left(h_{d}^{2} - h_{s}^{2}\right)f\left(x_{i}\right)
            - h_{d}^{2}f\left(x_{i}-h_{s}\right)}
            { h_{s}h_{d}\left(h_{d} + h_{s}\right)}
        + \mathcal{O}\left(\frac{h_{d}h_{s}^{2}
                            + h_{s}h_{d}^{2}}{h_{d}
                            + h_{s}}\right)

It is worth noting that if :math:`h_{s}=h_{d}`
(i.e., data are evenly spaced)
we find the standard second order approximation:

.. math::

    \hat f_{i}^{(1)}=
        \frac{f\left(x_{i+1}\right) - f\left(x_{i-1}\right)}{2h}
        + \mathcal{O}\left(h^{2}\right)

With a similar procedure the forward/backward approximations used for
boundaries can be derived.

References
----------
.. [1]  Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics
        (Texts in Applied Mathematics). New York: Springer.
.. [2]  Durran D. R. (1999) Numerical Methods for Wave Equations
        in Geophysical Fluid Dynamics. New York: Springer.
.. [3]  Fornberg B. (1988) Generation of Finite Difference Formulas on
        Arbitrarily Spaced Grids,
        Mathematics of Computation 51, no. 184 : 699-706.
        `PDF <http://www.ams.org/journals/mcom/1988-51-184/
        S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_.
*)

val greater : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the truth value of (x1 > x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.


See Also
--------
greater_equal, less, less_equal, equal, not_equal

Examples
--------
>>> np.greater([4,2],[2,2])
array([ True, False])

If the inputs are ndarrays, then np.greater is equivalent to '>'.

>>> a = np.array([4,2])
>>> b = np.array([2,2])
>>> a > b
array([ True, False])
*)

val greater_equal : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the truth value of (x1 >= x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : bool or ndarray of bool
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
greater, less, less_equal, equal, not_equal

Examples
--------
>>> np.greater_equal([4, 2, 1], [2, 2, 2])
array([ True, True, False])
*)

val hamming : int -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the Hamming window.

The Hamming window is a taper formed by using a weighted cosine.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : ndarray
    The window, with the maximum value normalized to one (the value
    one appears only if the number of samples is odd).

See Also
--------
bartlett, blackman, hanning, kaiser

Notes
-----
The Hamming window is defined as

.. math::  w(n) = 0.54 - 0.46cos\left(\frac{2\pi{n}}{M-1}\right)
           \qquad 0 \leq n \leq M-1

The Hamming was named for R. W. Hamming, an associate of J. W. Tukey
and is described in Blackman and Tukey. It was recommended for
smoothing the truncated autocovariance function in the time domain.
Most references to the Hamming window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
       spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics', The
       University of Alberta Press, 1975, pp. 109-110.
.. [3] Wikipedia, 'Window function',
       https://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       'Numerical Recipes', Cambridge University Press, 1986, page 425.

Examples
--------
>>> np.hamming(12)
array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary
        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,
        0.15302337,  0.08      ])

Plot the window and the frequency response:

>>> import matplotlib.pyplot as plt
>>> from numpy.fft import fft, fftshift
>>> window = np.hamming(51)
>>> plt.plot(window)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title('Hamming window')
Text(0.5, 1.0, 'Hamming window')
>>> plt.ylabel('Amplitude')
Text(0, 0.5, 'Amplitude')
>>> plt.xlabel('Sample')
Text(0.5, 0, 'Sample')
>>> plt.show()

>>> plt.figure()
<Figure size 640x480 with 0 Axes>
>>> A = fft(window, 2048) / 25.5
>>> mag = np.abs(fftshift(A))
>>> freq = np.linspace(-0.5, 0.5, len(A))
>>> response = 20 * np.log10(mag)
>>> response = np.clip(response, -100, 100)
>>> plt.plot(freq, response)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title('Frequency response of Hamming window')
Text(0.5, 1.0, 'Frequency response of Hamming window')
>>> plt.ylabel('Magnitude [dB]')
Text(0, 0.5, 'Magnitude [dB]')
>>> plt.xlabel('Normalized frequency [cycles per sample]')
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
>>> plt.axis('tight')
...
>>> plt.show()
*)

val hanning : int -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the Hanning window.

The Hanning window is a taper formed by using a weighted cosine.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : ndarray, shape(M,)
    The window, with the maximum value normalized to one (the value
    one appears only if `M` is odd).

See Also
--------
bartlett, blackman, hamming, kaiser

Notes
-----
The Hanning window is defined as

.. math::  w(n) = 0.5 - 0.5cos\left(\frac{2\pi{n}}{M-1}\right)
           \qquad 0 \leq n \leq M-1

The Hanning was named for Julius von Hann, an Austrian meteorologist.
It is also known as the Cosine Bell. Some authors prefer that it be
called a Hann window, to help avoid confusion with the very similar
Hamming window.

Most references to the Hanning window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
       spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics',
       The University of Alberta Press, 1975, pp. 106-108.
.. [3] Wikipedia, 'Window function',
       https://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       'Numerical Recipes', Cambridge University Press, 1986, page 425.

Examples
--------
>>> np.hanning(12)
array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,
       0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,
       0.07937323, 0.        ])

Plot the window and its frequency response:

>>> import matplotlib.pyplot as plt
>>> from numpy.fft import fft, fftshift
>>> window = np.hanning(51)
>>> plt.plot(window)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title('Hann window')
Text(0.5, 1.0, 'Hann window')
>>> plt.ylabel('Amplitude')
Text(0, 0.5, 'Amplitude')
>>> plt.xlabel('Sample')
Text(0.5, 0, 'Sample')
>>> plt.show()

>>> plt.figure()
<Figure size 640x480 with 0 Axes>
>>> A = fft(window, 2048) / 25.5
>>> mag = np.abs(fftshift(A))
>>> freq = np.linspace(-0.5, 0.5, len(A))
>>> with np.errstate(divide='ignore', invalid='ignore'):
...     response = 20 * np.log10(mag)
...
>>> response = np.clip(response, -100, 100)
>>> plt.plot(freq, response)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title('Frequency response of the Hann window')
Text(0.5, 1.0, 'Frequency response of the Hann window')
>>> plt.ylabel('Magnitude [dB]')
Text(0, 0.5, 'Magnitude [dB]')
>>> plt.xlabel('Normalized frequency [cycles per sample]')
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
>>> plt.axis('tight')
...
>>> plt.show()
*)

val heaviside : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
heaviside(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the Heaviside step function.

The Heaviside step function is defined as::

                          0   if x1 < 0
    heaviside(x1, x2) =  x2   if x1 == 0
                          1   if x1 > 0

where `x2` is often taken to be 0.5, but 0 and 1 are also sometimes used.

Parameters
----------
x1 : array_like
    Input values.
x2 : array_like
    The value of the function when x1 is 0. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    The output array, element-wise Heaviside step function of `x1`.
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
.. versionadded:: 1.13.0

References
----------
.. Wikipedia, 'Heaviside step function',
   https://en.wikipedia.org/wiki/Heaviside_step_function

Examples
--------
>>> np.heaviside([-1.5, 0, 2.0], 0.5)
array([ 0. ,  0.5,  1. ])
>>> np.heaviside([-1.5, 0, 2.0], 1)
array([ 0.,  1.,  1.])
*)

val histogram : ?bins:[`I of int | `S of string | `Sequence_of_scalars of Py.Object.t] -> ?range:(float * float) -> ?normed:bool -> ?weights:[>`Ndarray] Obj.t -> ?density:bool -> [>`Ndarray] Obj.t -> ([`ArrayLike|`Ndarray|`Object] Obj.t * Py.Object.t)
(**
Compute the histogram of a set of data.

Parameters
----------
a : array_like
    Input data. The histogram is computed over the flattened array.
bins : int or sequence of scalars or str, optional
    If `bins` is an int, it defines the number of equal-width
    bins in the given range (10, by default). If `bins` is a
    sequence, it defines a monotonically increasing array of bin edges,
    including the rightmost edge, allowing for non-uniform bin widths.

    .. versionadded:: 1.11.0

    If `bins` is a string, it defines the method used to calculate the
    optimal bin width, as defined by `histogram_bin_edges`.

range : (float, float), optional
    The lower and upper range of the bins.  If not provided, range
    is simply ``(a.min(), a.max())``.  Values outside the range are
    ignored. The first element of the range must be less than or
    equal to the second. `range` affects the automatic bin
    computation as well. While bin width is computed to be optimal
    based on the actual data within `range`, the bin count will fill
    the entire range including portions containing no data.
normed : bool, optional

    .. deprecated:: 1.6.0

    This is equivalent to the `density` argument, but produces incorrect
    results for unequal bin widths. It should not be used.

    .. versionchanged:: 1.15.0
        DeprecationWarnings are actually emitted.

weights : array_like, optional
    An array of weights, of the same shape as `a`.  Each value in
    `a` only contributes its associated weight towards the bin count
    (instead of 1). If `density` is True, the weights are
    normalized, so that the integral of the density over the range
    remains 1.
density : bool, optional
    If ``False``, the result will contain the number of samples in
    each bin. If ``True``, the result is the value of the
    probability *density* function at the bin, normalized such that
    the *integral* over the range is 1. Note that the sum of the
    histogram values will not be equal to 1 unless bins of unity
    width are chosen; it is not a probability *mass* function.

    Overrides the ``normed`` keyword if given.

Returns
-------
hist : array
    The values of the histogram. See `density` and `weights` for a
    description of the possible semantics.
bin_edges : array of dtype float
    Return the bin edges ``(length(hist)+1)``.


See Also
--------
histogramdd, bincount, searchsorted, digitize, histogram_bin_edges

Notes
-----
All but the last (righthand-most) bin is half-open.  In other words,
if `bins` is::

  [1, 2, 3, 4]

then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
*includes* 4.


Examples
--------
>>> np.histogram([1, 2, 1], bins=[0, 1, 2, 3])
(array([0, 2, 1]), array([0, 1, 2, 3]))
>>> np.histogram(np.arange(4), bins=np.arange(5), density=True)
(array([0.25, 0.25, 0.25, 0.25]), array([0, 1, 2, 3, 4]))
>>> np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])
(array([1, 4, 1]), array([0, 1, 2, 3]))

>>> a = np.arange(5)
>>> hist, bin_edges = np.histogram(a, density=True)
>>> hist
array([0.5, 0. , 0.5, 0. , 0. , 0.5, 0. , 0.5, 0. , 0.5])
>>> hist.sum()
2.4999999999999996
>>> np.sum(hist * np.diff(bin_edges))
1.0

.. versionadded:: 1.11.0

Automated Bin Selection Methods example, using 2 peak random data
with 2000 points:

>>> import matplotlib.pyplot as plt
>>> rng = np.random.RandomState(10)  # deterministic random data
>>> a = np.hstack((rng.normal(size=1000),
...                rng.normal(loc=5, scale=2, size=1000)))
>>> _ = plt.hist(a, bins='auto')  # arguments are passed to np.histogram
>>> plt.title('Histogram with 'auto' bins')
Text(0.5, 1.0, 'Histogram with 'auto' bins')
>>> plt.show()
*)

val histogram2d : ?bins:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `PyObject of Py.Object.t] -> ?range:[>`Ndarray] Obj.t -> ?normed:bool -> ?weights:[>`Ndarray] Obj.t -> ?density:bool -> y:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Compute the bi-dimensional histogram of two data samples.

Parameters
----------
x : array_like, shape (N,)
    An array containing the x coordinates of the points to be
    histogrammed.
y : array_like, shape (N,)
    An array containing the y coordinates of the points to be
    histogrammed.
bins : int or array_like or [int, int] or [array, array], optional
    The bin specification:

      * If int, the number of bins for the two dimensions (nx=ny=bins).
      * If array_like, the bin edges for the two dimensions
        (x_edges=y_edges=bins).
      * If [int, int], the number of bins in each dimension
        (nx, ny = bins).
      * If [array, array], the bin edges in each dimension
        (x_edges, y_edges = bins).
      * A combination [int, array] or [array, int], where int
        is the number of bins and array is the bin edges.

range : array_like, shape(2,2), optional
    The leftmost and rightmost edges of the bins along each dimension
    (if not specified explicitly in the `bins` parameters):
    ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range
    will be considered outliers and not tallied in the histogram.
density : bool, optional
    If False, the default, returns the number of samples in each bin.
    If True, returns the probability *density* function at the bin,
    ``bin_count / sample_count / bin_area``.
normed : bool, optional
    An alias for the density argument that behaves identically. To avoid
    confusion with the broken normed argument to `histogram`, `density`
    should be preferred.
weights : array_like, shape(N,), optional
    An array of values ``w_i`` weighing each sample ``(x_i, y_i)``.
    Weights are normalized to 1 if `normed` is True. If `normed` is
    False, the values of the returned histogram are equal to the sum of
    the weights belonging to the samples falling into each bin.

Returns
-------
H : ndarray, shape(nx, ny)
    The bi-dimensional histogram of samples `x` and `y`. Values in `x`
    are histogrammed along the first dimension and values in `y` are
    histogrammed along the second dimension.
xedges : ndarray, shape(nx+1,)
    The bin edges along the first dimension.
yedges : ndarray, shape(ny+1,)
    The bin edges along the second dimension.

See Also
--------
histogram : 1D histogram
histogramdd : Multidimensional histogram

Notes
-----
When `normed` is True, then the returned histogram is the sample
density, defined such that the sum over bins of the product
``bin_value * bin_area`` is 1.

Please note that the histogram does not follow the Cartesian convention
where `x` values are on the abscissa and `y` values on the ordinate
axis.  Rather, `x` is histogrammed along the first dimension of the
array (vertical), and `y` along the second dimension of the array
(horizontal).  This ensures compatibility with `histogramdd`.

Examples
--------
>>> from matplotlib.image import NonUniformImage
>>> import matplotlib.pyplot as plt

Construct a 2-D histogram with variable bin width. First define the bin
edges:

>>> xedges = [0, 1, 3, 5]
>>> yedges = [0, 2, 3, 4, 6]

Next we create a histogram H with random bin content:

>>> x = np.random.normal(2, 1, 100)
>>> y = np.random.normal(1, 1, 100)
>>> H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))
>>> H = H.T  # Let each row list bins with common y range.

:func:`imshow <matplotlib.pyplot.imshow>` can only display square bins:

>>> fig = plt.figure(figsize=(7, 3))
>>> ax = fig.add_subplot(131, title='imshow: square bins')
>>> plt.imshow(H, interpolation='nearest', origin='low',
...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])
<matplotlib.image.AxesImage object at 0x...>

:func:`pcolormesh <matplotlib.pyplot.pcolormesh>` can display actual edges:

>>> ax = fig.add_subplot(132, title='pcolormesh: actual edges',
...         aspect='equal')
>>> X, Y = np.meshgrid(xedges, yedges)
>>> ax.pcolormesh(X, Y, H)
<matplotlib.collections.QuadMesh object at 0x...>

:class:`NonUniformImage <matplotlib.image.NonUniformImage>` can be used to
display actual bin edges with interpolation:

>>> ax = fig.add_subplot(133, title='NonUniformImage: interpolated',
...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])
>>> im = NonUniformImage(ax, interpolation='bilinear')
>>> xcenters = (xedges[:-1] + xedges[1:]) / 2
>>> ycenters = (yedges[:-1] + yedges[1:]) / 2
>>> im.set_data(xcenters, ycenters, H)
>>> ax.images.append(im)
>>> plt.show()
*)

val histogram_bin_edges : ?bins:[`I of int | `S of string | `Sequence_of_scalars of Py.Object.t] -> ?range:(float * float) -> ?weights:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Function to calculate only the edges of the bins used by the `histogram`
function.

Parameters
----------
a : array_like
    Input data. The histogram is computed over the flattened array.
bins : int or sequence of scalars or str, optional
    If `bins` is an int, it defines the number of equal-width
    bins in the given range (10, by default). If `bins` is a
    sequence, it defines the bin edges, including the rightmost
    edge, allowing for non-uniform bin widths.

    If `bins` is a string from the list below, `histogram_bin_edges` will use
    the method chosen to calculate the optimal bin width and
    consequently the number of bins (see `Notes` for more detail on
    the estimators) from the data that falls within the requested
    range. While the bin width will be optimal for the actual data
    in the range, the number of bins will be computed to fill the
    entire range, including the empty portions. For visualisation,
    using the 'auto' option is suggested. Weighted data is not
    supported for automated bin size selection.

    'auto'
        Maximum of the 'sturges' and 'fd' estimators. Provides good
        all around performance.

    'fd' (Freedman Diaconis Estimator)
        Robust (resilient to outliers) estimator that takes into
        account data variability and data size.

    'doane'
        An improved version of Sturges' estimator that works better
        with non-normal datasets.

    'scott'
        Less robust estimator that that takes into account data
        variability and data size.

    'stone'
        Estimator based on leave-one-out cross-validation estimate of
        the integrated squared error. Can be regarded as a generalization
        of Scott's rule.

    'rice'
        Estimator does not take variability into account, only data
        size. Commonly overestimates number of bins required.

    'sturges'
        R's default method, only accounts for data size. Only
        optimal for gaussian data and underestimates number of bins
        for large non-gaussian datasets.

    'sqrt'
        Square root (of data size) estimator, used by Excel and
        other programs for its speed and simplicity.

range : (float, float), optional
    The lower and upper range of the bins.  If not provided, range
    is simply ``(a.min(), a.max())``.  Values outside the range are
    ignored. The first element of the range must be less than or
    equal to the second. `range` affects the automatic bin
    computation as well. While bin width is computed to be optimal
    based on the actual data within `range`, the bin count will fill
    the entire range including portions containing no data.

weights : array_like, optional
    An array of weights, of the same shape as `a`.  Each value in
    `a` only contributes its associated weight towards the bin count
    (instead of 1). This is currently not used by any of the bin estimators,
    but may be in the future.

Returns
-------
bin_edges : array of dtype float
    The edges to pass into `histogram`

See Also
--------
histogram

Notes
-----
The methods to estimate the optimal number of bins are well founded
in literature, and are inspired by the choices R provides for
histogram visualisation. Note that having the number of bins
proportional to :math:`n^{1/3}` is asymptotically optimal, which is
why it appears in most estimators. These are simply plug-in methods
that give good starting points for number of bins. In the equations
below, :math:`h` is the binwidth and :math:`n_h` is the number of
bins. All estimators that compute bin counts are recast to bin width
using the `ptp` of the data. The final bin count is obtained from
``np.round(np.ceil(range / h))``.

'auto' (maximum of the 'sturges' and 'fd' estimators)
    A compromise to get a good value. For small datasets the Sturges
    value will usually be chosen, while larger datasets will usually
    default to FD.  Avoids the overly conservative behaviour of FD
    and Sturges for small and large datasets respectively.
    Switchover point is usually :math:`a.size \approx 1000`.

'fd' (Freedman Diaconis Estimator)
    .. math:: h = 2 \frac{IQR}{n^{1/3}}

    The binwidth is proportional to the interquartile range (IQR)
    and inversely proportional to cube root of a.size. Can be too
    conservative for small datasets, but is quite good for large
    datasets. The IQR is very robust to outliers.

'scott'
    .. math:: h = \sigma \sqrt[3]{\frac{24 * \sqrt{\pi}}{n}}

    The binwidth is proportional to the standard deviation of the
    data and inversely proportional to cube root of ``x.size``. Can
    be too conservative for small datasets, but is quite good for
    large datasets. The standard deviation is not very robust to
    outliers. Values are very similar to the Freedman-Diaconis
    estimator in the absence of outliers.

'rice'
    .. math:: n_h = 2n^{1/3}

    The number of bins is only proportional to cube root of
    ``a.size``. It tends to overestimate the number of bins and it
    does not take into account data variability.

'sturges'
    .. math:: n_h = \log _{2}n+1

    The number of bins is the base 2 log of ``a.size``.  This
    estimator assumes normality of data and is too conservative for
    larger, non-normal datasets. This is the default method in R's
    ``hist`` method.

'doane'
    .. math:: n_h = 1 + \log_{2}(n) +
                    \log_{2}(1 + \frac{ |g_1| }{\sigma_{g_1}})

        g_1 = mean[(\frac{x - \mu}{\sigma})^3]

        \sigma_{g_1} = \sqrt{\frac{6(n - 2)}{(n + 1)(n + 3)}}

    An improved version of Sturges' formula that produces better
    estimates for non-normal datasets. This estimator attempts to
    account for the skew of the data.

'sqrt'
    .. math:: n_h = \sqrt n

    The simplest and fastest estimator. Only takes into account the
    data size.

Examples
--------
>>> arr = np.array([0, 0, 0, 1, 2, 3, 3, 4, 5])
>>> np.histogram_bin_edges(arr, bins='auto', range=(0, 1))
array([0.  , 0.25, 0.5 , 0.75, 1.  ])
>>> np.histogram_bin_edges(arr, bins=2)
array([0. , 2.5, 5. ])

For consistency with histogram, an array of pre-computed bins is
passed through unmodified:

>>> np.histogram_bin_edges(arr, [1, 2])
array([1, 2])

This function allows one set of bins to be computed, and reused across
multiple histograms:

>>> shared_bins = np.histogram_bin_edges(arr, bins='auto')
>>> shared_bins
array([0., 1., 2., 3., 4., 5.])

>>> group_id = np.array([0, 1, 1, 0, 1, 1, 0, 1, 1])
>>> hist_0, _ = np.histogram(arr[group_id == 0], bins=shared_bins)
>>> hist_1, _ = np.histogram(arr[group_id == 1], bins=shared_bins)

>>> hist_0; hist_1
array([1, 1, 0, 1, 0])
array([2, 0, 1, 1, 2])

Which gives more easily comparable results than using separate bins for
each histogram:

>>> hist_0, bins_0 = np.histogram(arr[group_id == 0], bins='auto')
>>> hist_1, bins_1 = np.histogram(arr[group_id == 1], bins='auto')
>>> hist_0; hist_1
array([1, 1, 1])
array([2, 1, 1, 2])
>>> bins_0; bins_1
array([0., 1., 2., 3.])
array([0.  , 1.25, 2.5 , 3.75, 5.  ])
*)

val histogramdd : ?bins:[`Sequence of Py.Object.t | `I of int] -> ?range:Py.Object.t -> ?normed:bool -> ?weights:[>`Ndarray] Obj.t -> ?density:bool -> sample:Py.Object.t -> unit -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Compute the multidimensional histogram of some data.

Parameters
----------
sample : (N, D) array, or (D, N) array_like
    The data to be histogrammed.

    Note the unusual interpretation of sample when an array_like:

    * When an array, each row is a coordinate in a D-dimensional space -
      such as ``histogramgramdd(np.array([p1, p2, p3]))``.
    * When an array_like, each element is the list of values for single
      coordinate - such as ``histogramgramdd((X, Y, Z))``.

    The first form should be preferred.

bins : sequence or int, optional
    The bin specification:

    * A sequence of arrays describing the monotonically increasing bin
      edges along each dimension.
    * The number of bins for each dimension (nx, ny, ... =bins)
    * The number of bins for all dimensions (nx=ny=...=bins).

range : sequence, optional
    A sequence of length D, each an optional (lower, upper) tuple giving
    the outer bin edges to be used if the edges are not given explicitly in
    `bins`.
    An entry of None in the sequence results in the minimum and maximum
    values being used for the corresponding dimension.
    The default, None, is equivalent to passing a tuple of D None values.
density : bool, optional
    If False, the default, returns the number of samples in each bin.
    If True, returns the probability *density* function at the bin,
    ``bin_count / sample_count / bin_volume``.
normed : bool, optional
    An alias for the density argument that behaves identically. To avoid
    confusion with the broken normed argument to `histogram`, `density`
    should be preferred.
weights : (N,) array_like, optional
    An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.
    Weights are normalized to 1 if normed is True. If normed is False,
    the values of the returned histogram are equal to the sum of the
    weights belonging to the samples falling into each bin.

Returns
-------
H : ndarray
    The multidimensional histogram of sample x. See normed and weights
    for the different possible semantics.
edges : list
    A list of D arrays describing the bin edges for each dimension.

See Also
--------
histogram: 1-D histogram
histogram2d: 2-D histogram

Examples
--------
>>> r = np.random.randn(100,3)
>>> H, edges = np.histogramdd(r, bins = (5, 8, 4))
>>> H.shape, edges[0].size, edges[1].size, edges[2].size
((5, 8, 4), 6, 9, 5)
*)

val hsplit : ary:Py.Object.t -> indices_or_sections:Py.Object.t -> unit -> Py.Object.t
(**
Split an array into multiple sub-arrays horizontally (column-wise).

Please refer to the `split` documentation.  `hsplit` is equivalent
to `split` with ``axis=1``, the array is always split along the second
axis regardless of the array dimension.

See Also
--------
split : Split an array into multiple sub-arrays of equal size.

Examples
--------
>>> x = np.arange(16.0).reshape(4, 4)
>>> x
array([[ 0.,   1.,   2.,   3.],
       [ 4.,   5.,   6.,   7.],
       [ 8.,   9.,  10.,  11.],
       [12.,  13.,  14.,  15.]])
>>> np.hsplit(x, 2)
[array([[  0.,   1.],
       [  4.,   5.],
       [  8.,   9.],
       [12.,  13.]]),
 array([[  2.,   3.],
       [  6.,   7.],
       [10.,  11.],
       [14.,  15.]])]
>>> np.hsplit(x, np.array([3, 6]))
[array([[ 0.,   1.,   2.],
       [ 4.,   5.,   6.],
       [ 8.,   9.,  10.],
       [12.,  13.,  14.]]),
 array([[ 3.],
       [ 7.],
       [11.],
       [15.]]),
 array([], shape=(4, 0), dtype=float64)]

With a higher dimensional array the split is still along the second axis.

>>> x = np.arange(8.0).reshape(2, 2, 2)
>>> x
array([[[0.,  1.],
        [2.,  3.]],
       [[4.,  5.],
        [6.,  7.]]])
>>> np.hsplit(x, 2)
[array([[[0.,  1.]],
       [[4.,  5.]]]),
 array([[[2.,  3.]],
       [[6.,  7.]]])]
*)

val hstack : [>`Ndarray] Obj.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Stack arrays in sequence horizontally (column wise).

This is equivalent to concatenation along the second axis, except for 1-D
arrays where it concatenates along the first axis. Rebuilds arrays divided
by `hsplit`.

This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions `concatenate`, `stack` and
`block` provide more general stacking and concatenation operations.

Parameters
----------
tup : sequence of ndarrays
    The arrays must have the same shape along all but the second axis,
    except 1-D arrays which can be any length.

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays.

See Also
--------
stack : Join a sequence of arrays along a new axis.
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third axis).
concatenate : Join a sequence of arrays along an existing axis.
hsplit : Split array along second axis.
block : Assemble arrays from blocks.

Examples
--------
>>> a = np.array((1,2,3))
>>> b = np.array((2,3,4))
>>> np.hstack((a,b))
array([1, 2, 3, 2, 3, 4])
>>> a = np.array([[1],[2],[3]])
>>> b = np.array([[2],[3],[4]])
>>> np.hstack((a,b))
array([[1, 2],
       [2, 3],
       [3, 4]])
*)

val hypot : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Given the 'legs' of a right triangle, return its hypotenuse.

Equivalent to ``sqrt(x1**2 + x2**2)``, element-wise.  If `x1` or
`x2` is scalar_like (i.e., unambiguously cast-able to a scalar type),
it is broadcast for use with each element of the other argument.
(See Examples)

Parameters
----------
x1, x2 : array_like
    Leg of the triangle(s). If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
z : ndarray
    The hypotenuse of the triangle(s).
    This is a scalar if both `x1` and `x2` are scalars.

Examples
--------
>>> np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])

Example showing broadcast of scalar_like argument:

>>> np.hypot(3*np.ones((3, 3)), [4])
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])
*)

val i0 : [`Ndarray of [>`Ndarray] Obj.t | `PyObject of Py.Object.t] -> Py.Object.t
(**
Modified Bessel function of the first kind, order 0.

Usually denoted :math:`I_0`.  This function does broadcast, but will *not*
'up-cast' int dtype arguments unless accompanied by at least one float or
complex dtype argument (see Raises below).

Parameters
----------
x : array_like, dtype float or complex
    Argument of the Bessel function.

Returns
-------
out : ndarray, shape = x.shape, dtype = x.dtype
    The modified Bessel function evaluated at each of the elements of `x`.

Raises
------
TypeError: array cannot be safely cast to required type
    If argument consists exclusively of int dtypes.

See Also
--------
scipy.special.i0, scipy.special.iv, scipy.special.ive

Notes
-----
The scipy implementation is recommended over this function: it is a
proper ufunc written in C, and more than an order of magnitude faster.

We use the algorithm published by Clenshaw [1]_ and referenced by
Abramowitz and Stegun [2]_, for which the function domain is
partitioned into the two intervals [0,8] and (8,inf), and Chebyshev
polynomial expansions are employed in each interval. Relative error on
the domain [0,30] using IEEE arithmetic is documented [3]_ as having a
peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).

References
----------
.. [1] C. W. Clenshaw, 'Chebyshev series for mathematical functions', in
       *National Physical Laboratory Mathematical Tables*, vol. 5, London:
       Her Majesty's Stationery Office, 1962.
.. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical
       Functions*, 10th printing, New York: Dover, 1964, pp. 379.
       http://www.math.sfu.ca/~cbm/aands/page_379.htm
.. [3] http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html

Examples
--------
>>> np.i0(0.)
array(1.0)  # may vary
>>> np.i0([0., 1. + 2j])
array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])  # may vary
*)

val identity : ?dtype:Dtype.t -> n:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the identity array.

The identity array is a square array with ones on
the main diagonal.

Parameters
----------
n : int
    Number of rows (and columns) in `n` x `n` output.
dtype : data-type, optional
    Data-type of the output.  Defaults to ``float``.

Returns
-------
out : ndarray
    `n` x `n` array with its main diagonal set to one,
    and all other elements 0.

Examples
--------
>>> np.identity(3)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
*)

val imag : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the imaginary part of the complex argument.

Parameters
----------
val : array_like
    Input array.

Returns
-------
out : ndarray or scalar
    The imaginary component of the complex argument. If `val` is real,
    the type of `val` is used for the output.  If `val` has complex
    elements, the returned type is float.

See Also
--------
real, angle, real_if_close

Examples
--------
>>> a = np.array([1+2j, 3+4j, 5+6j])
>>> a.imag
array([2.,  4.,  6.])
>>> a.imag = np.array([8, 10, 12])
>>> a
array([1. +8.j,  3.+10.j,  5.+12.j])
>>> np.imag(1 + 1j)
1.0
*)

val in1d : ?assume_unique:bool -> ?invert:bool -> ar1:[>`Ndarray] Obj.t -> ar2:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Test whether each element of a 1-D array is also present in a second array.

Returns a boolean array the same length as `ar1` that is True
where an element of `ar1` is in `ar2` and False otherwise.

We recommend using :func:`isin` instead of `in1d` for new code.

Parameters
----------
ar1 : (M,) array_like
    Input array.
ar2 : array_like
    The values against which to test each value of `ar1`.
assume_unique : bool, optional
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.
invert : bool, optional
    If True, the values in the returned array are inverted (that is,
    False where an element of `ar1` is in `ar2` and True otherwise).
    Default is False. ``np.in1d(a, b, invert=True)`` is equivalent
    to (but is faster than) ``np.invert(in1d(a, b))``.

    .. versionadded:: 1.8.0

Returns
-------
in1d : (M,) ndarray, bool
    The values `ar1[in1d]` are in `ar2`.

See Also
--------
isin                  : Version of this function that preserves the
                        shape of ar1.
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Notes
-----
`in1d` can be considered as an element-wise function version of the
python keyword `in`, for 1-D sequences. ``in1d(a, b)`` is roughly
equivalent to ``np.array([item in b for item in a])``.
However, this idea fails if `ar2` is a set, or similar (non-sequence)
container:  As ``ar2`` is converted to an array, in those cases
``asarray(ar2)`` is an object array rather than the expected array of
contained values.

.. versionadded:: 1.4.0

Examples
--------
>>> test = np.array([0, 1, 2, 5, 0])
>>> states = [0, 2]
>>> mask = np.in1d(test, states)
>>> mask
array([ True, False,  True, False,  True])
>>> test[mask]
array([0, 2, 0])
>>> mask = np.in1d(test, states, invert=True)
>>> mask
array([False,  True, False,  True, False])
>>> test[mask]
array([1, 5])
*)

val indices : ?dtype:Dtype.t -> ?sparse:bool -> dimensions:int list -> unit -> Py.Object.t
(**
Return an array representing the indices of a grid.

Compute an array where the subarrays contain index values 0, 1, ...
varying only along the corresponding axis.

Parameters
----------
dimensions : sequence of ints
    The shape of the grid.
dtype : dtype, optional
    Data type of the result.
sparse : boolean, optional
    Return a sparse representation of the grid instead of a dense
    representation. Default is False.

    .. versionadded:: 1.17

Returns
-------
grid : one ndarray or tuple of ndarrays
    If sparse is False:
        Returns one array of grid indices,
        ``grid.shape = (len(dimensions),) + tuple(dimensions)``.
    If sparse is True:
        Returns a tuple of arrays, with
        ``grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)`` with
        dimensions[i] in the ith place

See Also
--------
mgrid, ogrid, meshgrid

Notes
-----
The output shape in the dense case is obtained by prepending the number
of dimensions in front of the tuple of dimensions, i.e. if `dimensions`
is a tuple ``(r0, ..., rN-1)`` of length ``N``, the output shape is
``(N, r0, ..., rN-1)``.

The subarrays ``grid[k]`` contains the N-D array of indices along the
``k-th`` axis. Explicitly::

    grid[k, i0, i1, ..., iN-1] = ik

Examples
--------
>>> grid = np.indices((2, 3))
>>> grid.shape
(2, 2, 3)
>>> grid[0]        # row indices
array([[0, 0, 0],
       [1, 1, 1]])
>>> grid[1]        # column indices
array([[0, 1, 2],
       [0, 1, 2]])

The indices can be used as an index into an array.

>>> x = np.arange(20).reshape(5, 4)
>>> row, col = np.indices((2, 3))
>>> x[row, col]
array([[0, 1, 2],
       [4, 5, 6]])

Note that it would be more straightforward in the above example to
extract the required elements directly with ``x[:2, :3]``.

If sparse is set to true, the grid will be returned in a sparse
representation.

>>> i, j = np.indices((2, 3), sparse=True)
>>> i.shape
(2, 1)
>>> j.shape
(1, 3)
>>> i        # row indices
array([[0],
       [1]])
>>> j        # column indices
array([[0, 1, 2]])
*)

val info : ?object_:[`PyObject of Py.Object.t | `S of string] -> ?maxwidth:int -> ?output:Py.Object.t -> ?toplevel:string -> unit -> Py.Object.t
(**
Get help information for a function, class, or module.

Parameters
----------
object : object or str, optional
    Input object or name to get information about. If `object` is a
    numpy object, its docstring is given. If it is a string, available
    modules are searched for matching objects.  If None, information
    about `info` itself is returned.
maxwidth : int, optional
    Printing width.
output : file like object, optional
    File like object that the output is written to, default is
    ``stdout``.  The object has to be opened in 'w' or 'a' mode.
toplevel : str, optional
    Start search at this level.

See Also
--------
source, lookfor

Notes
-----
When used interactively with an object, ``np.info(obj)`` is equivalent
to ``help(obj)`` on the Python prompt or ``obj?`` on the IPython
prompt.

Examples
--------
>>> np.info(np.polyval) # doctest: +SKIP
   polyval(p, x)
     Evaluate the polynomial p at x.
     ...

When using a string for `object` it is possible to get multiple results.

>>> np.info('fft') # doctest: +SKIP
     *** Found in numpy ***
Core FFT routines
...
     *** Found in numpy.fft ***
 fft(a, n=None, axis=-1)
...
     *** Repeat reference found in numpy.fft.fftpack ***
     *** Total of 3 references found. ***
*)

val inner : b:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
inner(a, b)

Inner product of two arrays.

Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.

Parameters
----------
a, b : array_like
    If `a` and `b` are nonscalar, their last dimensions must match.

Returns
-------
out : ndarray
    `out.shape = a.shape[:-1] + b.shape[:-1]`

Raises
------
ValueError
    If the last dimension of `a` and `b` has different size.

See Also
--------
tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of `b`.
einsum : Einstein summation convention.

Notes
-----
For vectors (1-D arrays) it computes the ordinary inner-product::

    np.inner(a, b) = sum(a[:]*b[:])

More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::

    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))

or explicitly::

    np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
         = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])

In addition `a` or `b` may be scalars, in which case::

   np.inner(a,b) = a*b

Examples
--------
Ordinary inner product for vectors:

>>> a = np.array([1,2,3])
>>> b = np.array([0,1,0])
>>> np.inner(a, b)
2

A multidimensional example:

>>> a = np.arange(24).reshape((2,3,4))
>>> b = np.arange(4)
>>> np.inner(a, b)
array([[ 14,  38,  62],
       [ 86, 110, 134]])

An example where `b` is a scalar:

>>> np.inner(np.eye(2), 7)
array([[7., 0.],
       [0., 7.]])
*)

val insert : ?axis:int -> arr:[>`Ndarray] Obj.t -> obj:[`Slice of Wrap_utils.Slice.t | `I of int | `Is of int list] -> values:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Insert values along the given axis before the given indices.

Parameters
----------
arr : array_like
    Input array.
obj : int, slice or sequence of ints
    Object that defines the index or indices before which `values` is
    inserted.

    .. versionadded:: 1.8.0

    Support for multiple insertions when `obj` is a single scalar or a
    sequence with one element (similar to calling insert multiple
    times).
values : array_like
    Values to insert into `arr`. If the type of `values` is different
    from that of `arr`, `values` is converted to the type of `arr`.
    `values` should be shaped so that ``arr[...,obj,...] = values``
    is legal.
axis : int, optional
    Axis along which to insert `values`.  If `axis` is None then `arr`
    is flattened first.

Returns
-------
out : ndarray
    A copy of `arr` with `values` inserted.  Note that `insert`
    does not occur in-place: a new array is returned. If
    `axis` is None, `out` is a flattened array.

See Also
--------
append : Append elements at the end of an array.
concatenate : Join a sequence of arrays along an existing axis.
delete : Delete elements from an array.

Notes
-----
Note that for higher dimensional inserts `obj=0` behaves very different
from `obj=[0]` just like `arr[:,0,:] = values` is different from
`arr[:,[0],:] = values`.

Examples
--------
>>> a = np.array([[1, 1], [2, 2], [3, 3]])
>>> a
array([[1, 1],
       [2, 2],
       [3, 3]])
>>> np.insert(a, 1, 5)
array([1, 5, 1, ..., 2, 3, 3])
>>> np.insert(a, 1, 5, axis=1)
array([[1, 5, 1],
       [2, 5, 2],
       [3, 5, 3]])

Difference between sequence and scalars:

>>> np.insert(a, [1], [[1],[2],[3]], axis=1)
array([[1, 1, 1],
       [2, 2, 2],
       [3, 3, 3]])
>>> np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),
...                np.insert(a, [1], [[1],[2],[3]], axis=1))
True

>>> b = a.flatten()
>>> b
array([1, 1, 2, 2, 3, 3])
>>> np.insert(b, [2, 2], [5, 6])
array([1, 1, 5, ..., 2, 3, 3])

>>> np.insert(b, slice(2, 4), [5, 6])
array([1, 1, 5, ..., 2, 3, 3])

>>> np.insert(b, [2, 2], [7.13, False]) # type casting
array([1, 1, 7, ..., 2, 3, 3])

>>> x = np.arange(8).reshape(2, 4)
>>> idx = (1, 3)
>>> np.insert(x, idx, 999, axis=1)
array([[  0, 999,   1,   2, 999,   3],
       [  4, 999,   5,   6, 999,   7]])
*)

val interp : ?left:[`Complex_corresponding_to_fp of Py.Object.t | `F of float] -> ?right:[`Complex_corresponding_to_fp of Py.Object.t | `F of float] -> ?period:float -> xp:Py.Object.t -> fp:Py.Object.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
One-dimensional linear interpolation.

Returns the one-dimensional piecewise linear interpolant to a function
with given discrete data points (`xp`, `fp`), evaluated at `x`.

Parameters
----------
x : array_like
    The x-coordinates at which to evaluate the interpolated values.

xp : 1-D sequence of floats
    The x-coordinates of the data points, must be increasing if argument
    `period` is not specified. Otherwise, `xp` is internally sorted after
    normalizing the periodic boundaries with ``xp = xp % period``.

fp : 1-D sequence of float or complex
    The y-coordinates of the data points, same length as `xp`.

left : optional float or complex corresponding to fp
    Value to return for `x < xp[0]`, default is `fp[0]`.

right : optional float or complex corresponding to fp
    Value to return for `x > xp[-1]`, default is `fp[-1]`.

period : None or float, optional
    A period for the x-coordinates. This parameter allows the proper
    interpolation of angular x-coordinates. Parameters `left` and `right`
    are ignored if `period` is specified.

    .. versionadded:: 1.10.0

Returns
-------
y : float or complex (corresponding to fp) or ndarray
    The interpolated values, same shape as `x`.

Raises
------
ValueError
    If `xp` and `fp` have different length
    If `xp` or `fp` are not 1-D sequences
    If `period == 0`

Notes
-----
The x-coordinate sequence is expected to be increasing, but this is not
explicitly enforced.  However, if the sequence `xp` is non-increasing,
interpolation results are meaningless.

Note that, since NaN is unsortable, `xp` also cannot contain NaNs.

A simple check for `xp` being strictly increasing is::

    np.all(np.diff(xp) > 0)

Examples
--------
>>> xp = [1, 2, 3]
>>> fp = [3, 2, 0]
>>> np.interp(2.5, xp, fp)
1.0
>>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)
array([3.  , 3.  , 2.5 , 0.56, 0.  ])
>>> UNDEF = -99.0
>>> np.interp(3.14, xp, fp, right=UNDEF)
-99.0

Plot an interpolant to the sine function:

>>> x = np.linspace(0, 2*np.pi, 10)
>>> y = np.sin(x)
>>> xvals = np.linspace(0, 2*np.pi, 50)
>>> yinterp = np.interp(xvals, x, y)
>>> import matplotlib.pyplot as plt
>>> plt.plot(x, y, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.plot(xvals, yinterp, '-x')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.show()

Interpolation with periodic x-coordinates:

>>> x = [-180, -170, -185, 185, -10, -5, 0, 365]
>>> xp = [190, -190, 350, -350]
>>> fp = [5, 10, 3, 4]
>>> np.interp(x, xp, fp, period=360)
array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])

Complex interpolation:

>>> x = [1.5, 4.0]
>>> xp = [2,3,5]
>>> fp = [1.0j, 0, 2+3j]
>>> np.interp(x, xp, fp)
array([0.+1.j , 1.+1.5j])
*)

val intersect1d : ?assume_unique:bool -> ?return_indices:bool -> ar1:Py.Object.t -> ar2:Py.Object.t -> unit -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Find the intersection of two arrays.

Return the sorted, unique values that are in both of the input arrays.

Parameters
----------
ar1, ar2 : array_like
    Input arrays. Will be flattened if not already 1D.
assume_unique : bool
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.
return_indices : bool
    If True, the indices which correspond to the intersection of the two
    arrays are returned. The first instance of a value is used if there are
    multiple. Default is False.

    .. versionadded:: 1.15.0

Returns
-------
intersect1d : ndarray
    Sorted 1D array of common and unique elements.
comm1 : ndarray
    The indices of the first occurrences of the common values in `ar1`.
    Only provided if `return_indices` is True.
comm2 : ndarray
    The indices of the first occurrences of the common values in `ar2`.
    Only provided if `return_indices` is True.


See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Examples
--------
>>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])
array([1, 3])

To intersect more than two arrays, use functools.reduce:

>>> from functools import reduce
>>> reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
array([3])

To return the indices of the values common to the input arrays
along with the intersected values:

>>> x = np.array([1, 1, 2, 3, 4])
>>> y = np.array([2, 1, 4, 6])
>>> xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)
>>> x_ind, y_ind
(array([0, 2, 4]), array([1, 0, 2]))
>>> xy, x[x_ind], y[y_ind]
(array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))
*)

val invert : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute bit-wise inversion, or bit-wise NOT, element-wise.

Computes the bit-wise NOT of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ``~``.

For signed integer inputs, the two's complement is returned.  In a
two's-complement system negative numbers are represented by the two's
complement of the absolute value. This is the most common method of
representing signed integers on computers [1]_. A N-bit
two's-complement system can represent every integer in the range
:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.

Parameters
----------
x : array_like
    Only integer and boolean types are handled.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Result.
    This is a scalar if `x` is a scalar.

See Also
--------
bitwise_and, bitwise_or, bitwise_xor
logical_not
binary_repr :
    Return the binary representation of the input number as a string.

Notes
-----
`bitwise_not` is an alias for `invert`:

>>> np.bitwise_not is np.invert
True

References
----------
.. [1] Wikipedia, 'Two's complement',
    https://en.wikipedia.org/wiki/Two's_complement

Examples
--------
We've seen that 13 is represented by ``00001101``.
The invert or bit-wise NOT of 13 is then:

>>> x = np.invert(np.array(13, dtype=np.uint8))
>>> x
242
>>> np.binary_repr(x, width=8)
'11110010'

The result depends on the bit-width:

>>> x = np.invert(np.array(13, dtype=np.uint16))
>>> x
65522
>>> np.binary_repr(x, width=16)
'1111111111110010'

When using signed integer types the result is the two's complement of
the result for the unsigned type:

>>> np.invert(np.array([13], dtype=np.int8))
array([-14], dtype=int8)
>>> np.binary_repr(-14, width=8)
'11110010'

Booleans are accepted as well:

>>> np.invert(np.array([True, False]))
array([False,  True])
*)

val ipmt : ?fv:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> ?when_:[`Begin | `I of int | `PyObject of Py.Object.t] -> rate:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> per:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> nper:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> pv:[`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the interest portion of a payment.

.. deprecated:: 1.18

   `ipmt` is deprecated; for details, see NEP 32 [1]_.
   Use the corresponding function in the numpy-financial library,
   https://pypi.org/project/numpy-financial.

Parameters
----------
rate : scalar or array_like of shape(M, )
    Rate of interest as decimal (not per cent) per period
per : scalar or array_like of shape(M, )
    Interest paid against the loan changes during the life or the loan.
    The `per` is the payment period to calculate the interest amount.
nper : scalar or array_like of shape(M, )
    Number of compounding periods
pv : scalar or array_like of shape(M, )
    Present value
fv : scalar or array_like of shape(M, ), optional
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0)).
    Defaults to {'end', 0}.

Returns
-------
out : ndarray
    Interest portion of payment.  If all input is scalar, returns a scalar
    float.  If any input is array_like, returns interest payment for each
    input element. If multiple inputs are array_like, they all must have
    the same shape.

See Also
--------
ppmt, pmt, pv

Notes
-----
The total payment is made up of payment against principal plus interest.

``pmt = ppmt + ipmt``

References
----------
.. [1] NumPy Enhancement Proposal (NEP) 32,
   https://numpy.org/neps/nep-0032-remove-financial-functions.html

Examples
--------
What is the amortization schedule for a 1 year loan of $2500 at
8.24% interest per year compounded monthly?

>>> principal = 2500.00

The 'per' variable represents the periods of the loan.  Remember that
financial equations start the period count at 1!

>>> per = np.arange(1*12) + 1
>>> ipmt = np.ipmt(0.0824/12, per, 1*12, principal)
>>> ppmt = np.ppmt(0.0824/12, per, 1*12, principal)

Each element of the sum of the 'ipmt' and 'ppmt' arrays should equal
'pmt'.

>>> pmt = np.pmt(0.0824/12, 1*12, principal)
>>> np.allclose(ipmt + ppmt, pmt)
True

>>> fmt = '{0:2d} {1:8.2f} {2:8.2f} {3:8.2f}'
>>> for payment in per:
...     index = payment - 1
...     principal = principal + ppmt[index]
...     print(fmt.format(payment, ppmt[index], ipmt[index], principal))
 1  -200.58   -17.17  2299.42
 2  -201.96   -15.79  2097.46
 3  -203.35   -14.40  1894.11
 4  -204.74   -13.01  1689.37
 5  -206.15   -11.60  1483.22
 6  -207.56   -10.18  1275.66
 7  -208.99    -8.76  1066.67
 8  -210.42    -7.32   856.25
 9  -211.87    -5.88   644.38
10  -213.32    -4.42   431.05
11  -214.79    -2.96   216.26
12  -216.26    -1.49    -0.00

>>> interestpd = np.sum(ipmt)
>>> np.round(interestpd, 2)
-112.98
*)

val irr : [>`Ndarray] Obj.t -> float
(**
Return the Internal Rate of Return (IRR).

.. deprecated:: 1.18

   `irr` is deprecated; for details, see NEP 32 [1]_.
   Use the corresponding function in the numpy-financial library,
   https://pypi.org/project/numpy-financial.

This is the 'average' periodically compounded rate of return
that gives a net present value of 0.0; for a more complete explanation,
see Notes below.

:class:`decimal.Decimal` type is not supported.

Parameters
----------
values : array_like, shape(N,)
    Input cash flows per time period.  By convention, net 'deposits'
    are negative and net 'withdrawals' are positive.  Thus, for
    example, at least the first element of `values`, which represents
    the initial investment, will typically be negative.

Returns
-------
out : float
    Internal Rate of Return for periodic input values.

Notes
-----
The IRR is perhaps best understood through an example (illustrated
using np.irr in the Examples section below).  Suppose one invests 100
units and then makes the following withdrawals at regular (fixed)
intervals: 39, 59, 55, 20.  Assuming the ending value is 0, one's 100
unit investment yields 173 units; however, due to the combination of
compounding and the periodic withdrawals, the 'average' rate of return
is neither simply 0.73/4 nor (1.73)^0.25-1.  Rather, it is the solution
(for :math:`r`) of the equation:

.. math:: -100 + \frac{39}{1+r} + \frac{59}{(1+r)^2}
 + \frac{55}{(1+r)^3} + \frac{20}{(1+r)^4} = 0

In general, for `values` :math:`= [v_0, v_1, ... v_M]`,
irr is the solution of the equation: [2]_

.. math:: \sum_{t=0}^M{\frac{v_t}{(1+irr)^{t}}} = 0

References
----------
.. [1] NumPy Enhancement Proposal (NEP) 32,
   https://numpy.org/neps/nep-0032-remove-financial-functions.html
.. [2] L. J. Gitman, 'Principles of Managerial Finance, Brief,' 3rd ed.,
   Addison-Wesley, 2003, pg. 348.

Examples
--------
>>> round(np.irr([-100, 39, 59, 55, 20]), 5)
0.28095
>>> round(np.irr([-100, 0, 0, 74]), 5)
-0.0955
>>> round(np.irr([-100, 100, 0, -7]), 5)
-0.0833
>>> round(np.irr([-100, 100, 0, 7]), 5)
0.06206
>>> round(np.irr([-5, 10.5, 1, -8, 1]), 5)
0.0886
*)

val is_busday : ?weekmask:[`Array_like_of_bool of Py.Object.t | `S of string] -> ?holidays:Py.Object.t -> ?busdaycal:Py.Object.t -> ?out:Py.Object.t -> dates:Py.Object.t -> unit -> Py.Object.t
(**
is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None)

Calculates which of the given dates are valid days, and which are not.

.. versionadded:: 1.7.0

Parameters
----------
dates : array_like of datetime64[D]
    The array of dates to process.
weekmask : str or array_like of bool, optional
    A seven-element array indicating which of Monday through Sunday are
    valid days. May be specified as a length-seven list or array, like
    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
    like 'Mon Tue Wed Thu Fri', made up of 3-character abbreviations for
    weekdays, optionally separated by white space. Valid abbreviations
    are: Mon Tue Wed Thu Fri Sat Sun
holidays : array_like of datetime64[D], optional
    An array of dates to consider as invalid dates.  They may be
    specified in any order, and NaT (not-a-time) dates are ignored.
    This list is saved in a normalized form that is suited for
    fast calculations of valid days.
busdaycal : busdaycalendar, optional
    A `busdaycalendar` object which specifies the valid days. If this
    parameter is provided, neither weekmask nor holidays may be
    provided.
out : array of bool, optional
    If provided, this array is filled with the result.

Returns
-------
out : array of bool
    An array with the same shape as ``dates``, containing True for
    each valid day, and False for each invalid day.

See Also
--------
busdaycalendar: An object that specifies a custom set of valid days.
busday_offset : Applies an offset counted in valid days.
busday_count : Counts how many valid days are in a half-open date range.

Examples
--------
>>> # The weekdays are Friday, Saturday, and Monday
... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],
...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])
array([False, False,  True])
*)

val isclose : ?rtol:float -> ?atol:float -> ?equal_nan:bool -> b:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Returns a boolean array where two arrays are element-wise equal within a
tolerance.

The tolerance values are positive, typically very small numbers.  The
relative difference (`rtol` * abs(`b`)) and the absolute difference
`atol` are added together to compare against the absolute difference
between `a` and `b`.

.. warning:: The default `atol` is not appropriate for comparing numbers
             that are much smaller than one (see Notes).

Parameters
----------
a, b : array_like
    Input arrays to compare.
rtol : float
    The relative tolerance parameter (see Notes).
atol : float
    The absolute tolerance parameter (see Notes).
equal_nan : bool
    Whether to compare NaN's as equal.  If True, NaN's in `a` will be
    considered equal to NaN's in `b` in the output array.

Returns
-------
y : array_like
    Returns a boolean array of where `a` and `b` are equal within the
    given tolerance. If both `a` and `b` are scalars, returns a single
    boolean value.

See Also
--------
allclose

Notes
-----
.. versionadded:: 1.7.0

For finite values, isclose uses the following equation to test whether
two floating point values are equivalent.

 absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))

Unlike the built-in `math.isclose`, the above equation is not symmetric
in `a` and `b` -- it assumes `b` is the reference value -- so that
`isclose(a, b)` might be different from `isclose(b, a)`. Furthermore,
the default value of atol is not zero, and is used to determine what
small values should be considered close to zero. The default value is
appropriate for expected values of order unity: if the expected values
are significantly smaller than one, it can result in false positives.
`atol` should be carefully selected for the use case at hand. A zero value
for `atol` will result in `False` if either `a` or `b` is zero.

Examples
--------
>>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
array([ True, False])
>>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
array([ True, True])
>>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
array([False,  True])
>>> np.isclose([1.0, np.nan], [1.0, np.nan])
array([ True, False])
>>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
array([ True, True])
>>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
array([ True, False])
>>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
array([False, False])
>>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
array([ True,  True])
>>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
array([False,  True])
*)

val iscomplex : [>`Ndarray] Obj.t -> Py.Object.t
(**
Returns a bool array, where True if input element is complex.

What is tested is whether the input has a non-zero imaginary part, not if
the input type is complex.

Parameters
----------
x : array_like
    Input array.

Returns
-------
out : ndarray of bools
    Output array.

See Also
--------
isreal
iscomplexobj : Return True if x is a complex type or an array of complex
               numbers.

Examples
--------
>>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])
array([ True, False, False, False, False,  True])
*)

val iscomplexobj : Py.Object.t -> bool
(**
Check for a complex type or an array of complex numbers.

The type of the input is checked, not the value. Even if the input
has an imaginary part equal to zero, `iscomplexobj` evaluates to True.

Parameters
----------
x : any
    The input can be of any type and shape.

Returns
-------
iscomplexobj : bool
    The return value, True if `x` is of a complex type or has at least
    one complex element.

See Also
--------
isrealobj, iscomplex

Examples
--------
>>> np.iscomplexobj(1)
False
>>> np.iscomplexobj(1+0j)
True
>>> np.iscomplexobj([3, 1+0j, True])
True
*)

val isfinite : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Test element-wise for finiteness (not infinity or not Not a Number).

The result is returned as a boolean array.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray, bool
    True where ``x`` is not positive infinity, negative infinity,
    or NaN; false otherwise.
    This is a scalar if `x` is a scalar.

See Also
--------
isinf, isneginf, isposinf, isnan

Notes
-----
Not a Number, positive infinity and negative infinity are considered
to be non-finite.

NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Also that positive infinity is not equivalent to negative infinity. But
infinity is equivalent to positive infinity.  Errors result if the
second argument is also supplied when `x` is a scalar input, or if
first and second arguments have different shapes.

Examples
--------
>>> np.isfinite(1)
True
>>> np.isfinite(0)
True
>>> np.isfinite(np.nan)
False
>>> np.isfinite(np.inf)
False
>>> np.isfinite(np.NINF)
False
>>> np.isfinite([np.log(-1.),1.,np.log(0)])
array([False,  True, False])

>>> x = np.array([-np.inf, 0., np.inf])
>>> y = np.array([2, 2, 2])
>>> np.isfinite(x, y)
array([0, 1, 0])
>>> y
array([0, 1, 0])
*)

val isfortran : [>`Ndarray] Obj.t -> bool
(**
Check if the array is Fortran contiguous but *not* C contiguous.

This function is obsolete and, because of changes due to relaxed stride
checking, its return value for the same array may differ for versions
of NumPy >= 1.10.0 and previous versions. If you only want to check if an
array is Fortran contiguous use ``a.flags.f_contiguous`` instead.

Parameters
----------
a : ndarray
    Input array.

Returns
-------
isfortran : bool
    Returns True if the array is Fortran contiguous but *not* C contiguous.


Examples
--------

np.array allows to specify whether the array is written in C-contiguous
order (last index varies the fastest), or FORTRAN-contiguous order in
memory (first index varies the fastest).

>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.isfortran(a)
False

>>> b = np.array([[1, 2, 3], [4, 5, 6]], order='F')
>>> b
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.isfortran(b)
True


The transpose of a C-ordered array is a FORTRAN-ordered array.

>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.isfortran(a)
False
>>> b = a.T
>>> b
array([[1, 4],
       [2, 5],
       [3, 6]])
>>> np.isfortran(b)
True

C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.

>>> np.isfortran(np.array([1, 2], order='F'))
False
*)

val isin : ?assume_unique:bool -> ?invert:bool -> element:[>`Ndarray] Obj.t -> test_elements:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Calculates `element in test_elements`, broadcasting over `element` only.
Returns a boolean array of the same shape as `element` that is True
where an element of `element` is in `test_elements` and False otherwise.

Parameters
----------
element : array_like
    Input array.
test_elements : array_like
    The values against which to test each value of `element`.
    This argument is flattened if it is an array or array_like.
    See notes for behavior with non-array-like parameters.
assume_unique : bool, optional
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.
invert : bool, optional
    If True, the values in the returned array are inverted, as if
    calculating `element not in test_elements`. Default is False.
    ``np.isin(a, b, invert=True)`` is equivalent to (but faster
    than) ``np.invert(np.isin(a, b))``.

Returns
-------
isin : ndarray, bool
    Has the same shape as `element`. The values `element[isin]`
    are in `test_elements`.

See Also
--------
in1d                  : Flattened version of this function.
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Notes
-----

`isin` is an element-wise function version of the python keyword `in`.
``isin(a, b)`` is roughly equivalent to
``np.array([item in b for item in a])`` if `a` and `b` are 1-D sequences.

`element` and `test_elements` are converted to arrays if they are not
already. If `test_elements` is a set (or other non-sequence collection)
it will be converted to an object array with one element, rather than an
array of the values contained in `test_elements`. This is a consequence
of the `array` constructor's way of handling non-sequence collections.
Converting the set to a list usually gives the desired behavior.

.. versionadded:: 1.13.0

Examples
--------
>>> element = 2*np.arange(4).reshape((2, 2))
>>> element
array([[0, 2],
       [4, 6]])
>>> test_elements = [1, 2, 4, 8]
>>> mask = np.isin(element, test_elements)
>>> mask
array([[False,  True],
       [ True, False]])
>>> element[mask]
array([2, 4])

The indices of the matched values can be obtained with `nonzero`:

>>> np.nonzero(mask)
(array([0, 1]), array([1, 0]))

The test can also be inverted:

>>> mask = np.isin(element, test_elements, invert=True)
>>> mask
array([[ True, False],
       [False,  True]])
>>> element[mask]
array([0, 6])

Because of how `array` handles sets, the following does not
work as expected:

>>> test_set = {1, 2, 4, 8}
>>> np.isin(element, test_set)
array([[False, False],
       [False, False]])

Casting the set to a list gives the expected result:

>>> np.isin(element, list(test_set))
array([[False,  True],
       [ True, False]])
*)

val isinf : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
isinf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Test element-wise for positive or negative infinity.

Returns a boolean array of the same shape as `x`, True where ``x ==
+/-inf``, otherwise False.

Parameters
----------
x : array_like
    Input values
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : bool (scalar) or boolean ndarray
    True where ``x`` is positive or negative infinity, false otherwise.
    This is a scalar if `x` is a scalar.

See Also
--------
isneginf, isposinf, isnan, isfinite

Notes
-----
NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).

Errors result if the second argument is supplied when the first
argument is a scalar, or if the first and second arguments have
different shapes.

Examples
--------
>>> np.isinf(np.inf)
True
>>> np.isinf(np.nan)
False
>>> np.isinf(np.NINF)
True
>>> np.isinf([np.inf, -np.inf, 1.0, np.nan])
array([ True,  True, False, False])

>>> x = np.array([-np.inf, 0., np.inf])
>>> y = np.array([2, 2, 2])
>>> np.isinf(x, y)
array([1, 0, 1])
>>> y
array([1, 0, 1])
*)

val isnan : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
isnan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Test element-wise for NaN and return result as a boolean array.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or bool
    True where ``x`` is NaN, false otherwise.
    This is a scalar if `x` is a scalar.

See Also
--------
isinf, isneginf, isposinf, isfinite, isnat

Notes
-----
NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.

Examples
--------
>>> np.isnan(np.nan)
True
>>> np.isnan(np.inf)
False
>>> np.isnan([np.log(-1.),1.,np.log(0)])
array([ True, False, False])
*)

val isnat : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
isnat(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Test element-wise for NaT (not a time) and return result as a boolean array.

.. versionadded:: 1.13.0

Parameters
----------
x : array_like
    Input array with datetime or timedelta data type.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or bool
    True where ``x`` is NaT, false otherwise.
    This is a scalar if `x` is a scalar.

See Also
--------
isnan, isinf, isneginf, isposinf, isfinite

Examples
--------
>>> np.isnat(np.datetime64('NaT'))
True
>>> np.isnat(np.datetime64('2016-01-01'))
False
>>> np.isnat(np.array(['NaT', '2016-01-01'], dtype='datetime64[ns]'))
array([ True, False])
*)

val isneginf : ?out:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Test element-wise for negative infinity, return result as bool array.

Parameters
----------
x : array_like
    The input array.
out : array_like, optional
    A boolean array with the same shape and type as `x` to store the
    result.

Returns
-------
out : ndarray
    A boolean array with the same dimensions as the input.
    If second argument is not supplied then a numpy boolean array is
    returned with values True where the corresponding element of the
    input is negative infinity and values False where the element of
    the input is not negative infinity.

    If a second argument is supplied the result is stored there. If the
    type of that array is a numeric type the result is represented as
    zeros and ones, if the type is boolean then as False and True. The
    return value `out` is then a reference to that array.

See Also
--------
isinf, isposinf, isnan, isfinite

Notes
-----
NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).

Errors result if the second argument is also supplied when x is a scalar
input, if first and second arguments have different shapes, or if the
first argument has complex values.

Examples
--------
>>> np.isneginf(np.NINF)
True
>>> np.isneginf(np.inf)
False
>>> np.isneginf(np.PINF)
False
>>> np.isneginf([-np.inf, 0., np.inf])
array([ True, False, False])

>>> x = np.array([-np.inf, 0., np.inf])
>>> y = np.array([2, 2, 2])
>>> np.isneginf(x, y)
array([1, 0, 0])
>>> y
array([1, 0, 0])
*)

val isposinf : ?out:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Test element-wise for positive infinity, return result as bool array.

Parameters
----------
x : array_like
    The input array.
y : array_like, optional
    A boolean array with the same shape as `x` to store the result.

Returns
-------
out : ndarray
    A boolean array with the same dimensions as the input.
    If second argument is not supplied then a boolean array is returned
    with values True where the corresponding element of the input is
    positive infinity and values False where the element of the input is
    not positive infinity.

    If a second argument is supplied the result is stored there. If the
    type of that array is a numeric type the result is represented as zeros
    and ones, if the type is boolean then as False and True.
    The return value `out` is then a reference to that array.

See Also
--------
isinf, isneginf, isfinite, isnan

Notes
-----
NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).

Errors result if the second argument is also supplied when x is a scalar
input, if first and second arguments have different shapes, or if the
first argument has complex values

Examples
--------
>>> np.isposinf(np.PINF)
True
>>> np.isposinf(np.inf)
True
>>> np.isposinf(np.NINF)
False
>>> np.isposinf([-np.inf, 0., np.inf])
array([False, False,  True])

>>> x = np.array([-np.inf, 0., np.inf])
>>> y = np.array([2, 2, 2])
>>> np.isposinf(x, y)
array([0, 0, 1])
>>> y
array([0, 0, 1])
*)

val isreal : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Returns a bool array, where True if input element is real.

If element has complex type with zero complex part, the return value
for that element is True.

Parameters
----------
x : array_like
    Input array.

Returns
-------
out : ndarray, bool
    Boolean array of same shape as `x`.

See Also
--------
iscomplex
isrealobj : Return True if x is not a complex type.

Examples
--------
>>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])
array([False,  True,  True,  True,  True, False])
*)

val isrealobj : Py.Object.t -> bool
(**
Return True if x is a not complex type or an array of complex numbers.

The type of the input is checked, not the value. So even if the input
has an imaginary part equal to zero, `isrealobj` evaluates to False
if the data type is complex.

Parameters
----------
x : any
    The input can be of any type and shape.

Returns
-------
y : bool
    The return value, False if `x` is of a complex type.

See Also
--------
iscomplexobj, isreal

Examples
--------
>>> np.isrealobj(1)
True
>>> np.isrealobj(1+0j)
False
>>> np.isrealobj([3, 1+0j, True])
False
*)

val isscalar : Py.Object.t -> bool
(**
Returns True if the type of `element` is a scalar type.

Parameters
----------
element : any
    Input argument, can be of any type and shape.

Returns
-------
val : bool
    True if `element` is a scalar type, False if it is not.

See Also
--------
ndim : Get the number of dimensions of an array

Notes
-----
If you need a stricter way to identify a *numerical* scalar, use
``isinstance(x, numbers.Number)``, as that returns ``False`` for most
non-numerical elements such as strings.

In most cases ``np.ndim(x) == 0`` should be used instead of this function,
as that will also return true for 0d arrays. This is how numpy overloads
functions in the style of the ``dx`` arguments to `gradient` and the ``bins``
argument to `histogram`. Some key differences:

+--------------------------------------+---------------+-------------------+
| x                                    |``isscalar(x)``|``np.ndim(x) == 0``|
+======================================+===============+===================+
| PEP 3141 numeric objects (including  | ``True``      | ``True``          |
| builtins)                            |               |                   |
+--------------------------------------+---------------+-------------------+
| builtin string and buffer objects    | ``True``      | ``True``          |
+--------------------------------------+---------------+-------------------+
| other builtin objects, like          | ``False``     | ``True``          |
| `pathlib.Path`, `Exception`,         |               |                   |
| the result of `re.compile`           |               |                   |
+--------------------------------------+---------------+-------------------+
| third-party objects like             | ``False``     | ``True``          |
| `matplotlib.figure.Figure`           |               |                   |
+--------------------------------------+---------------+-------------------+
| zero-dimensional numpy arrays        | ``False``     | ``True``          |
+--------------------------------------+---------------+-------------------+
| other numpy arrays                   | ``False``     | ``False``         |
+--------------------------------------+---------------+-------------------+
| `list`, `tuple`, and other sequence  | ``False``     | ``False``         |
| objects                              |               |                   |
+--------------------------------------+---------------+-------------------+

Examples
--------
>>> np.isscalar(3.1)
True
>>> np.isscalar(np.array(3.1))
False
>>> np.isscalar([3.1])
False
>>> np.isscalar(False)
True
>>> np.isscalar('numpy')
True

NumPy supports PEP 3141 numbers:

>>> from fractions import Fraction
>>> np.isscalar(Fraction(5, 17))
True
>>> from numbers import Number
>>> np.isscalar(Number())
True
*)

val issctype : Py.Object.t -> bool
(**
Determines whether the given object represents a scalar data-type.

Parameters
----------
rep : any
    If `rep` is an instance of a scalar dtype, True is returned. If not,
    False is returned.

Returns
-------
out : bool
    Boolean result of check whether `rep` is a scalar dtype.

See Also
--------
issubsctype, issubdtype, obj2sctype, sctype2char

Examples
--------
>>> np.issctype(np.int32)
True
>>> np.issctype(list)
False
>>> np.issctype(1.1)
False

Strings are also a scalar type:

>>> np.issctype(np.dtype('str'))
True
*)

val issubdtype : arg1:Py.Object.t -> arg2:Py.Object.t -> unit -> bool
(**
Returns True if first argument is a typecode lower/equal in type hierarchy.

Parameters
----------
arg1, arg2 : dtype_like
    dtype or string representing a typecode.

Returns
-------
out : bool

See Also
--------
issubsctype, issubclass_
numpy.core.numerictypes : Overview of numpy type hierarchy.

Examples
--------
>>> np.issubdtype('S1', np.string_)
True
>>> np.issubdtype(np.float64, np.float32)
False
*)

val issubsctype : arg1:Py.Object.t -> arg2:Py.Object.t -> unit -> bool
(**
Determine if the first argument is a subclass of the second argument.

Parameters
----------
arg1, arg2 : dtype or dtype specifier
    Data-types.

Returns
-------
out : bool
    The result.

See Also
--------
issctype, issubdtype, obj2sctype

Examples
--------
>>> np.issubsctype('S8', str)
False
>>> np.issubsctype(np.array([1]), int)
True
>>> np.issubsctype(np.array([1]), float)
False
*)

val iterable : Py.Object.t -> bool
(**
Check whether or not an object can be iterated over.

Parameters
----------
y : object
  Input object.

Returns
-------
b : bool
  Return ``True`` if the object has an iterator method or is a
  sequence and ``False`` otherwise.


Examples
--------
>>> np.iterable([1, 2, 3])
True
>>> np.iterable(2)
False
*)

val kaiser : m:int -> beta:float -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the Kaiser window.

The Kaiser window is a taper formed by using a Bessel function.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.
beta : float
    Shape parameter for window.

Returns
-------
out : array
    The window, with the maximum value normalized to one (the value
    one appears only if the number of samples is odd).

See Also
--------
bartlett, blackman, hamming, hanning

Notes
-----
The Kaiser window is defined as

.. math::  w(n) = I_0\left( \beta \sqrt{1-\frac{4n^2}{(M-1)^2}}
           \right)/I_0(\beta)

with

.. math:: \quad -\frac{M-1}{2} \leq n \leq \frac{M-1}{2},

where :math:`I_0` is the modified zeroth-order Bessel function.

The Kaiser was named for Jim Kaiser, who discovered a simple
approximation to the DPSS window based on Bessel functions.  The Kaiser
window is a very good approximation to the Digital Prolate Spheroidal
Sequence, or Slepian window, which is the transform which maximizes the
energy in the main lobe of the window relative to total energy.

The Kaiser can approximate many other windows by varying the beta
parameter.

====  =======================
beta  Window shape
====  =======================
0     Rectangular
5     Similar to a Hamming
6     Similar to a Hanning
8.6   Similar to a Blackman
====  =======================

A beta value of 14 is probably a good starting point. Note that as beta
gets large, the window narrows, and so the number of samples needs to be
large enough to sample the increasingly narrow spike, otherwise NaNs will
get returned.

Most references to the Kaiser window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] J. F. Kaiser, 'Digital Filters' - Ch 7 in 'Systems analysis by
       digital computer', Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
       John Wiley and Sons, New York, (1966).
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics', The
       University of Alberta Press, 1975, pp. 177-178.
.. [3] Wikipedia, 'Window function',
       https://en.wikipedia.org/wiki/Window_function

Examples
--------
>>> import matplotlib.pyplot as plt
>>> np.kaiser(12, 14)
 array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary
        2.29737120e-01, 5.99885316e-01, 9.45674898e-01,
        9.45674898e-01, 5.99885316e-01, 2.29737120e-01,
        4.65200189e-02, 3.46009194e-03, 7.72686684e-06])


Plot the window and the frequency response:

>>> from numpy.fft import fft, fftshift
>>> window = np.kaiser(51, 14)
>>> plt.plot(window)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title('Kaiser window')
Text(0.5, 1.0, 'Kaiser window')
>>> plt.ylabel('Amplitude')
Text(0, 0.5, 'Amplitude')
>>> plt.xlabel('Sample')
Text(0.5, 0, 'Sample')
>>> plt.show()

>>> plt.figure()
<Figure size 640x480 with 0 Axes>
>>> A = fft(window, 2048) / 25.5
>>> mag = np.abs(fftshift(A))
>>> freq = np.linspace(-0.5, 0.5, len(A))
>>> response = 20 * np.log10(mag)
>>> response = np.clip(response, -100, 100)
>>> plt.plot(freq, response)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title('Frequency response of Kaiser window')
Text(0.5, 1.0, 'Frequency response of Kaiser window')
>>> plt.ylabel('Magnitude [dB]')
Text(0, 0.5, 'Magnitude [dB]')
>>> plt.xlabel('Normalized frequency [cycles per sample]')
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
>>> plt.axis('tight')
(-0.5, 0.5, -100.0, ...) # may vary
>>> plt.show()
*)

val kron : b:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Kronecker product of two arrays.

Computes the Kronecker product, a composite array made of blocks of the
second array scaled by the first.

Parameters
----------
a, b : array_like

Returns
-------
out : ndarray

See Also
--------
outer : The outer product

Notes
-----
The function assumes that the number of dimensions of `a` and `b`
are the same, if necessary prepending the smallest with ones.
If `a.shape = (r0,r1,..,rN)` and `b.shape = (s0,s1,...,sN)`,
the Kronecker product has shape `(r0*s0, r1*s1, ..., rN*SN)`.
The elements are products of elements from `a` and `b`, organized
explicitly by::

    kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]

where::

    kt = it * st + jt,  t = 0,...,N

In the common 2-D case (N=1), the block structure can be visualized::

    [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],
     [  ...                              ...   ],
     [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]


Examples
--------
>>> np.kron([1,10,100], [5,6,7])
array([  5,   6,   7, ..., 500, 600, 700])
>>> np.kron([5,6,7], [1,10,100])
array([  5,  50, 500, ...,   7,  70, 700])

>>> np.kron(np.eye(2), np.ones((2,2)))
array([[1.,  1.,  0.,  0.],
       [1.,  1.,  0.,  0.],
       [0.,  0.,  1.,  1.],
       [0.,  0.,  1.,  1.]])

>>> a = np.arange(100).reshape((2,5,2,5))
>>> b = np.arange(24).reshape((2,3,4))
>>> c = np.kron(a,b)
>>> c.shape
(2, 10, 6, 20)
>>> I = (1,3,0,2)
>>> J = (0,2,1)
>>> J1 = (0,) + J             # extend to ndim=4
>>> S1 = (1,) + b.shape
>>> K = tuple(np.array(I) * np.array(S1) + np.array(J1))
>>> c[K] == a[I]*b[J]
True
*)

val lcm : ?out:Py.Object.t -> ?where:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
lcm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Returns the lowest common multiple of ``|x1|`` and ``|x2|``

Parameters
----------
x1, x2 : array_like, int
    Arrays of values. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).

Returns
-------
y : ndarray or scalar
    The lowest common multiple of the absolute value of the inputs
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
gcd : The greatest common divisor

Examples
--------
>>> np.lcm(12, 20)
60
>>> np.lcm.reduce([3, 12, 20])
60
>>> np.lcm.reduce([40, 12, 20])
120
>>> np.lcm(np.arange(6), 20)
array([ 0, 20, 20, 60, 20, 20])
*)

val ldexp : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
ldexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Returns x1 * 2**x2, element-wise.

The mantissas `x1` and twos exponents `x2` are used to construct
floating point numbers ``x1 * 2**x2``.

Parameters
----------
x1 : array_like
    Array of multipliers.
x2 : array_like, int
    Array of twos exponents. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The result of ``x1 * 2**x2``.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
frexp : Return (y1, y2) from ``x = y1 * 2**y2``, inverse to `ldexp`.

Notes
-----
Complex dtypes are not supported, they will raise a TypeError.

`ldexp` is useful as the inverse of `frexp`, if used by itself it is
more clear to simply use the expression ``x1 * 2**x2``.

Examples
--------
>>> np.ldexp(5, np.arange(4))
array([ 5., 10., 20., 40.], dtype=float16)

>>> x = np.arange(6)
>>> np.ldexp( *np.frexp(x))
array([ 0.,  1.,  2.,  3.,  4.,  5.])
*)

val left_shift : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Shift the bits of an integer to the left.

Bits are shifted to the left by appending `x2` 0s at the right of `x1`.
Since the internal representation of numbers is in binary format, this
operation is equivalent to multiplying `x1` by ``2**x2``.

Parameters
----------
x1 : array_like of integer type
    Input values.
x2 : array_like of integer type
    Number of zeros to append to `x1`. Has to be non-negative.
    If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : array of integer type
    Return `x1` with bits shifted `x2` times to the left.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
right_shift : Shift the bits of an integer to the right.
binary_repr : Return the binary representation of the input number
    as a string.

Examples
--------
>>> np.binary_repr(5)
'101'
>>> np.left_shift(5, 2)
20
>>> np.binary_repr(20)
'10100'

>>> np.left_shift(5, [1,2,3])
array([10, 20, 40])
*)

val less : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the truth value of (x1 < x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
greater, less_equal, greater_equal, equal, not_equal

Examples
--------
>>> np.less([1, 2], [2, 2])
array([ True, False])
*)

val less_equal : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the truth value of (x1 =< x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
greater, less, greater_equal, equal, not_equal

Examples
--------
>>> np.less_equal([4, 2, 1], [2, 2, 2])
array([False,  True,  True])
*)

val lexsort : ?axis:int -> keys:Py.Object.t -> unit -> Py.Object.t
(**
lexsort(keys, axis=-1)

Perform an indirect stable sort using a sequence of keys.

Given multiple sorting keys, which can be interpreted as columns in a
spreadsheet, lexsort returns an array of integer indices that describes
the sort order by multiple columns. The last key in the sequence is used
for the primary sort order, the second-to-last key for the secondary sort
order, and so on. The keys argument must be a sequence of objects that
can be converted to arrays of the same shape. If a 2D array is provided
for the keys argument, it's rows are interpreted as the sorting keys and
sorting is according to the last row, second last row etc.

Parameters
----------
keys : (k, N) array or tuple containing k (N,)-shaped sequences
    The `k` different 'columns' to be sorted.  The last column (or row if
    `keys` is a 2D array) is the primary sort key.
axis : int, optional
    Axis to be indirectly sorted.  By default, sort over the last axis.

Returns
-------
indices : (N,) ndarray of ints
    Array of indices that sort the keys along the specified axis.

See Also
--------
argsort : Indirect sort.
ndarray.sort : In-place sort.
sort : Return a sorted copy of an array.

Examples
--------
Sort names: first by surname, then by name.

>>> surnames =    ('Hertz',    'Galilei', 'Hertz')
>>> first_names = ('Heinrich', 'Galileo', 'Gustav')
>>> ind = np.lexsort((first_names, surnames))
>>> ind
array([1, 2, 0])

>>> [surnames[i] + ', ' + first_names[i] for i in ind]
['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']

Sort two columns of numbers:

>>> a = [1,5,1,4,3,4,4] # First column
>>> b = [9,4,0,4,0,2,1] # Second column
>>> ind = np.lexsort((b,a)) # Sort by a, then by b
>>> ind
array([2, 0, 4, 6, 5, 3, 1])

>>> [(a[i],b[i]) for i in ind]
[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]

Note that sorting is first according to the elements of ``a``.
Secondary sorting is according to the elements of ``b``.

A normal ``argsort`` would have yielded:

>>> [(a[i],b[i]) for i in np.argsort(a)]
[(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]

Structured arrays are sorted lexically by ``argsort``:

>>> x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],
...              dtype=np.dtype([('x', int), ('y', int)]))

>>> np.argsort(x) # or np.argsort(x, order=('x', 'y'))
array([2, 0, 4, 6, 5, 3, 1])
*)

val linspace : ?num:int -> ?endpoint:bool -> ?retstep:bool -> ?dtype:Dtype.t -> ?axis:int -> start:[>`Ndarray] Obj.t -> stop:[>`Ndarray] Obj.t -> unit -> ([`ArrayLike|`Ndarray|`Object] Obj.t * float)
(**
Return evenly spaced numbers over a specified interval.

Returns `num` evenly spaced samples, calculated over the
interval [`start`, `stop`].

The endpoint of the interval can optionally be excluded.

.. versionchanged:: 1.16.0
    Non-scalar `start` and `stop` are now supported.

Parameters
----------
start : array_like
    The starting value of the sequence.
stop : array_like
    The end value of the sequence, unless `endpoint` is set to False.
    In that case, the sequence consists of all but the last of ``num + 1``
    evenly spaced samples, so that `stop` is excluded.  Note that the step
    size changes when `endpoint` is False.
num : int, optional
    Number of samples to generate. Default is 50. Must be non-negative.
endpoint : bool, optional
    If True, `stop` is the last sample. Otherwise, it is not included.
    Default is True.
retstep : bool, optional
    If True, return (`samples`, `step`), where `step` is the spacing
    between samples.
dtype : dtype, optional
    The type of the output array.  If `dtype` is not given, infer the data
    type from the other input arguments.

    .. versionadded:: 1.9.0

axis : int, optional
    The axis in the result to store the samples.  Relevant only if start
    or stop are array-like.  By default (0), the samples will be along a
    new axis inserted at the beginning. Use -1 to get an axis at the end.

    .. versionadded:: 1.16.0

Returns
-------
samples : ndarray
    There are `num` equally spaced samples in the closed interval
    ``[start, stop]`` or the half-open interval ``[start, stop)``
    (depending on whether `endpoint` is True or False).
step : float, optional
    Only returned if `retstep` is True

    Size of spacing between samples.


See Also
--------
arange : Similar to `linspace`, but uses a step size (instead of the
         number of samples).
geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
            scale (a geometric progression).
logspace : Similar to `geomspace`, but with the end points specified as
           logarithms.

Examples
--------
>>> np.linspace(2.0, 3.0, num=5)
array([2.  , 2.25, 2.5 , 2.75, 3.  ])
>>> np.linspace(2.0, 3.0, num=5, endpoint=False)
array([2. ,  2.2,  2.4,  2.6,  2.8])
>>> np.linspace(2.0, 3.0, num=5, retstep=True)
(array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)

Graphical illustration:

>>> import matplotlib.pyplot as plt
>>> N = 8
>>> y = np.zeros(N)
>>> x1 = np.linspace(0, 10, N, endpoint=True)
>>> x2 = np.linspace(0, 10, N, endpoint=False)
>>> plt.plot(x1, y, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.plot(x2, y + 0.5, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.ylim([-0.5, 1])
(-0.5, 1)
>>> plt.show()
*)

val load : ?mmap_mode:[`C | `R | `R_plus | `W_plus] -> ?allow_pickle:bool -> ?fix_imports:bool -> ?encoding:string -> file:[`S of string | `PyObject of Py.Object.t] -> unit -> Py.Object.t
(**
Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.

.. warning:: Loading files that contain object arrays uses the ``pickle``
             module, which is not secure against erroneous or maliciously
             constructed data. Consider passing ``allow_pickle=False`` to
             load data that is known not to contain object arrays for the
             safer handling of untrusted sources.

Parameters
----------
file : file-like object, string, or pathlib.Path
    The file to read. File-like objects must support the
    ``seek()`` and ``read()`` methods. Pickled files require that the
    file-like object support the ``readline()`` method as well.
mmap_mode : {None, 'r+', 'r', 'w+', 'c'}, optional
    If not None, then memory-map the file, using the given mode (see
    `numpy.memmap` for a detailed description of the modes).  A
    memory-mapped array is kept on disk. However, it can be accessed
    and sliced like any ndarray.  Memory mapping is especially useful
    for accessing small fragments of large files without reading the
    entire file into memory.
allow_pickle : bool, optional
    Allow loading pickled object arrays stored in npy files. Reasons for
    disallowing pickles include security, as loading pickled data can
    execute arbitrary code. If pickles are disallowed, loading object
    arrays will fail. Default: False

    .. versionchanged:: 1.16.3
        Made default False in response to CVE-2019-6446.

fix_imports : bool, optional
    Only useful when loading Python 2 generated pickled files on Python 3,
    which includes npy/npz files containing object arrays. If `fix_imports`
    is True, pickle will try to map the old Python 2 names to the new names
    used in Python 3.
encoding : str, optional
    What encoding to use when reading Python 2 strings. Only useful when
    loading Python 2 generated pickled files in Python 3, which includes
    npy/npz files containing object arrays. Values other than 'latin1',
    'ASCII', and 'bytes' are not allowed, as they can corrupt numerical
    data. Default: 'ASCII'

Returns
-------
result : array, tuple, dict, etc.
    Data stored in the file. For ``.npz`` files, the returned instance
    of NpzFile class must be closed to avoid leaking file descriptors.

Raises
------
IOError
    If the input file does not exist or cannot be read.
ValueError
    The file contains an object array, but allow_pickle=False given.

See Also
--------
save, savez, savez_compressed, loadtxt
memmap : Create a memory-map to an array stored in a file on disk.
lib.format.open_memmap : Create or load a memory-mapped ``.npy`` file.

Notes
-----
- If the file contains pickle data, then whatever object is stored
  in the pickle is returned.
- If the file is a ``.npy`` file, then a single array is returned.
- If the file is a ``.npz`` file, then a dictionary-like object is
  returned, containing ``{filename: array}`` key-value pairs, one for
  each file in the archive.
- If the file is a ``.npz`` file, the returned value supports the
  context manager protocol in a similar fashion to the open function::

    with load('foo.npz') as data:
        a = data['a']

  The underlying file descriptor is closed when exiting the 'with'
  block.

Examples
--------
Store data to disk, and load it again:

>>> np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))
>>> np.load('/tmp/123.npy')
array([[1, 2, 3],
       [4, 5, 6]])

Store compressed data to disk, and load it again:

>>> a=np.array([[1, 2, 3], [4, 5, 6]])
>>> b=np.array([1, 2])
>>> np.savez('/tmp/123.npz', a=a, b=b)
>>> data = np.load('/tmp/123.npz')
>>> data['a']
array([[1, 2, 3],
       [4, 5, 6]])
>>> data['b']
array([1, 2])
>>> data.close()

Mem-map the stored array, and then access the second row
directly from disk:

>>> X = np.load('/tmp/123.npy', mmap_mode='r')
>>> X[1, :]
memmap([4, 5, 6])
*)

val loads : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
None
*)

val loadtxt : ?dtype:Dtype.t -> ?comments:[`Sequence_of_str of Py.Object.t | `S of string] -> ?delimiter:string -> ?converters:Py.Object.t -> ?skiprows:int -> ?usecols:[`Sequence of Py.Object.t | `I of int] -> ?unpack:bool -> ?ndmin:int -> ?encoding:string -> ?max_rows:int -> fname:[`S of string | `PyObject of Py.Object.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Load data from a text file.

Each row in the text file must have the same number of values.

Parameters
----------
fname : file, str, or pathlib.Path
    File, filename, or generator to read.  If the filename extension is
    ``.gz`` or ``.bz2``, the file is first decompressed. Note that
    generators should return byte strings.
dtype : data-type, optional
    Data-type of the resulting array; default: float.  If this is a
    structured data-type, the resulting array will be 1-dimensional, and
    each row will be interpreted as an element of the array.  In this
    case, the number of columns used must match the number of fields in
    the data-type.
comments : str or sequence of str, optional
    The characters or list of characters used to indicate the start of a
    comment. None implies no comments. For backwards compatibility, byte
    strings will be decoded as 'latin1'. The default is '#'.
delimiter : str, optional
    The string used to separate values. For backwards compatibility, byte
    strings will be decoded as 'latin1'. The default is whitespace.
converters : dict, optional
    A dictionary mapping column number to a function that will parse the
    column string into the desired value.  E.g., if column 0 is a date
    string: ``converters = {0: datestr2num}``.  Converters can also be
    used to provide a default value for missing data (but see also
    `genfromtxt`): ``converters = {3: lambda s: float(s.strip() or 0)}``.
    Default: None.
skiprows : int, optional
    Skip the first `skiprows` lines, including comments; default: 0.
usecols : int or sequence, optional
    Which columns to read, with 0 being the first. For example,
    ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.
    The default, None, results in all columns being read.

    .. versionchanged:: 1.11.0
        When a single column has to be read it is possible to use
        an integer instead of a tuple. E.g ``usecols = 3`` reads the
        fourth column the same way as ``usecols = (3,)`` would.
unpack : bool, optional
    If True, the returned array is transposed, so that arguments may be
    unpacked using ``x, y, z = loadtxt(...)``.  When used with a structured
    data-type, arrays are returned for each field.  Default is False.
ndmin : int, optional
    The returned array will have at least `ndmin` dimensions.
    Otherwise mono-dimensional axes will be squeezed.
    Legal values: 0 (default), 1 or 2.

    .. versionadded:: 1.6.0
encoding : str, optional
    Encoding used to decode the inputfile. Does not apply to input streams.
    The special value 'bytes' enables backward compatibility workarounds
    that ensures you receive byte arrays as results if possible and passes
    'latin1' encoded strings to converters. Override this value to receive
    unicode arrays and pass strings as input to converters.  If set to None
    the system default is used. The default value is 'bytes'.

    .. versionadded:: 1.14.0
max_rows : int, optional
    Read `max_rows` lines of content after `skiprows` lines. The default
    is to read all the lines.

    .. versionadded:: 1.16.0

Returns
-------
out : ndarray
    Data read from the text file.

See Also
--------
load, fromstring, fromregex
genfromtxt : Load data with missing values handled as specified.
scipy.io.loadmat : reads MATLAB data files

Notes
-----
This function aims to be a fast reader for simply formatted files.  The
`genfromtxt` function provides more sophisticated handling of, e.g.,
lines with missing values.

.. versionadded:: 1.10.0

The strings produced by the Python float.hex method can be used as
input for floats.

Examples
--------
>>> from io import StringIO   # StringIO behaves like a file object
>>> c = StringIO(u'0 1\n2 3')
>>> np.loadtxt(c)
array([[0., 1.],
       [2., 3.]])

>>> d = StringIO(u'M 21 72\nF 35 58')
>>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),
...                      'formats': ('S1', 'i4', 'f4')})
array([(b'M', 21, 72.), (b'F', 35, 58.)],
      dtype=[('gender', 'S1'), ('age', '<i4'), ('weight', '<f4')])

>>> c = StringIO(u'1,0,2\n3,0,4')
>>> x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)
>>> x
array([1., 3.])
>>> y
array([2., 4.])
*)

val log : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Natural logarithm, element-wise.

The natural logarithm `log` is the inverse of the exponential function,
so that `log(exp(x)) = x`. The natural logarithm is logarithm in base
`e`.

Parameters
----------
x : array_like
    Input value.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The natural logarithm of `x`, element-wise.
    This is a scalar if `x` is a scalar.

See Also
--------
log10, log2, log1p, emath.log

Notes
-----
Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `exp(z) = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log` always returns real output. For
each value that cannot be expressed as a real number or infinity, it
yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it. `log`
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Logarithm'. https://en.wikipedia.org/wiki/Logarithm

Examples
--------
>>> np.log([1, np.e, np.e**2, 0])
array([  0.,   1.,   2., -Inf])
*)

val log10 : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the base 10 logarithm of the input array, element-wise.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The logarithm to the base 10 of `x`, element-wise. NaNs are
    returned where x is negative.
    This is a scalar if `x` is a scalar.

See Also
--------
emath.log10

Notes
-----
Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `10**z = x`. The convention is to return the
`z` whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log10` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log10` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it.
`log10` handles the floating-point negative zero as an infinitesimal
negative number, conforming to the C99 standard.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Logarithm'. https://en.wikipedia.org/wiki/Logarithm

Examples
--------
>>> np.log10([1e-15, -3.])
array([-15.,  nan])
*)

val log1p : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
log1p(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the natural logarithm of one plus the input array, element-wise.

Calculates ``log(1 + x)``.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    Natural logarithm of `1 + x`, element-wise.
    This is a scalar if `x` is a scalar.

See Also
--------
expm1 : ``exp(x) - 1``, the inverse of `log1p`.

Notes
-----
For real-valued input, `log1p` is accurate also for `x` so small
that `1 + x == 1` in floating-point accuracy.

Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `exp(z) = 1 + x`. The convention is to return
the `z` whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log1p` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log1p` is a complex analytical function that
has a branch cut `[-inf, -1]` and is continuous from above on it.
`log1p` handles the floating-point negative zero as an infinitesimal
negative number, conforming to the C99 standard.

References
----------
.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Logarithm'. https://en.wikipedia.org/wiki/Logarithm

Examples
--------
>>> np.log1p(1e-99)
1e-99
>>> np.log(1 + 1e-99)
0.0
*)

val log2 : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Base-2 logarithm of `x`.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    Base-2 logarithm of `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
log, log10, log1p, emath.log2

Notes
-----
.. versionadded:: 1.3.0

Logarithm is a multivalued function: for each `x` there is an infinite
number of `z` such that `2**z = x`. The convention is to return the `z`
whose imaginary part lies in `[-pi, pi]`.

For real-valued input data types, `log2` always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields ``nan`` and sets the `invalid` floating point error flag.

For complex-valued input, `log2` is a complex analytical function that
has a branch cut `[-inf, 0]` and is continuous from above on it. `log2`
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.

Examples
--------
>>> x = np.array([0, 1, 2, 2**4])
>>> np.log2(x)
array([-Inf,   0.,   1.,   4.])

>>> xi = np.array([0+1.j, 1, 2+0.j, 4.j])
>>> np.log2(xi)
array([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])
*)

val logaddexp : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
logaddexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Logarithm of the sum of exponentiations of the inputs.

Calculates ``log(exp(x1) + exp(x2))``. This function is useful in
statistics where the calculated probabilities of events may be so small
as to exceed the range of normal floating point numbers.  In such cases
the logarithm of the calculated probability is stored. This function
allows adding probabilities stored in such a fashion.

Parameters
----------
x1, x2 : array_like
    Input values. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
result : ndarray
    Logarithm of ``exp(x1) + exp(x2)``.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logaddexp2: Logarithm of the sum of exponentiations of inputs in base 2.

Notes
-----
.. versionadded:: 1.3.0

Examples
--------
>>> prob1 = np.log(1e-50)
>>> prob2 = np.log(2.5e-50)
>>> prob12 = np.logaddexp(prob1, prob2)
>>> prob12
-113.87649168120691
>>> np.exp(prob12)
3.5000000000000057e-50
*)

val logaddexp2 : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
logaddexp2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Logarithm of the sum of exponentiations of the inputs in base-2.

Calculates ``log2(2**x1 + 2**x2)``. This function is useful in machine
learning when the calculated probabilities of events may be so small as
to exceed the range of normal floating point numbers.  In such cases
the base-2 logarithm of the calculated probability can be used instead.
This function allows adding probabilities stored in such a fashion.

Parameters
----------
x1, x2 : array_like
    Input values. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
result : ndarray
    Base-2 logarithm of ``2**x1 + 2**x2``.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logaddexp: Logarithm of the sum of exponentiations of the inputs.

Notes
-----
.. versionadded:: 1.3.0

Examples
--------
>>> prob1 = np.log2(1e-50)
>>> prob2 = np.log2(2.5e-50)
>>> prob12 = np.logaddexp2(prob1, prob2)
>>> prob1, prob2, prob12
(-166.09640474436813, -164.77447664948076, -164.28904982231052)
>>> 2**prob12
3.4999999999999914e-50
*)

val logical_and : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the truth value of x1 AND x2 element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or bool
    Boolean result of the logical AND operation applied to the elements
    of `x1` and `x2`; the shape is determined by broadcasting.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_or, logical_not, logical_xor
bitwise_and

Examples
--------
>>> np.logical_and(True, False)
False
>>> np.logical_and([True, False], [False, False])
array([False, False])

>>> x = np.arange(5)
>>> np.logical_and(x>1, x<4)
array([False, False,  True,  True, False])
*)

val logical_not : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the truth value of NOT x element-wise.

Parameters
----------
x : array_like
    Logical NOT is applied to the elements of `x`.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : bool or ndarray of bool
    Boolean result with the same shape as `x` of the NOT operation
    on elements of `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
logical_and, logical_or, logical_xor

Examples
--------
>>> np.logical_not(3)
False
>>> np.logical_not([True, False, 0, 1])
array([False,  True,  True, False])

>>> x = np.arange(5)
>>> np.logical_not(x<3)
array([False, False, False,  True,  True])
*)

val logical_or : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the truth value of x1 OR x2 element-wise.

Parameters
----------
x1, x2 : array_like
    Logical OR is applied to the elements of `x1` and `x2`.
    If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or bool
    Boolean result of the logical OR operation applied to the elements
    of `x1` and `x2`; the shape is determined by broadcasting.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_and, logical_not, logical_xor
bitwise_or

Examples
--------
>>> np.logical_or(True, False)
True
>>> np.logical_or([True, False], [False, False])
array([ True, False])

>>> x = np.arange(5)
>>> np.logical_or(x < 1, x > 3)
array([ True, False, False, False,  True])
*)

val logical_xor : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute the truth value of x1 XOR x2, element-wise.

Parameters
----------
x1, x2 : array_like
    Logical XOR is applied to the elements of `x1` and `x2`. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : bool or ndarray of bool
    Boolean result of the logical XOR operation applied to the elements
    of `x1` and `x2`; the shape is determined by broadcasting.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
logical_and, logical_or, logical_not, bitwise_xor

Examples
--------
>>> np.logical_xor(True, False)
True
>>> np.logical_xor([True, True, False, False], [True, False, True, False])
array([False,  True,  True, False])

>>> x = np.arange(5)
>>> np.logical_xor(x < 1, x > 3)
array([ True, False, False, False,  True])

Simple example showing support of broadcasting

>>> np.logical_xor(0, np.eye(2))
array([[ True, False],
       [False,  True]])
*)

val logspace : ?num:int -> ?endpoint:bool -> ?base:float -> ?dtype:Dtype.t -> ?axis:int -> start:[>`Ndarray] Obj.t -> stop:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return numbers spaced evenly on a log scale.

In linear space, the sequence starts at ``base ** start``
(`base` to the power of `start`) and ends with ``base ** stop``
(see `endpoint` below).

.. versionchanged:: 1.16.0
    Non-scalar `start` and `stop` are now supported.

Parameters
----------
start : array_like
    ``base ** start`` is the starting value of the sequence.
stop : array_like
    ``base ** stop`` is the final value of the sequence, unless `endpoint`
    is False.  In that case, ``num + 1`` values are spaced over the
    interval in log-space, of which all but the last (a sequence of
    length `num`) are returned.
num : integer, optional
    Number of samples to generate.  Default is 50.
endpoint : boolean, optional
    If true, `stop` is the last sample. Otherwise, it is not included.
    Default is True.
base : float, optional
    The base of the log space. The step size between the elements in
    ``ln(samples) / ln(base)`` (or ``log_base(samples)``) is uniform.
    Default is 10.0.
dtype : dtype
    The type of the output array.  If `dtype` is not given, infer the data
    type from the other input arguments.
axis : int, optional
    The axis in the result to store the samples.  Relevant only if start
    or stop are array-like.  By default (0), the samples will be along a
    new axis inserted at the beginning. Use -1 to get an axis at the end.

    .. versionadded:: 1.16.0


Returns
-------
samples : ndarray
    `num` samples, equally spaced on a log scale.

See Also
--------
arange : Similar to linspace, with the step size specified instead of the
         number of samples. Note that, when used with a float endpoint, the
         endpoint may or may not be included.
linspace : Similar to logspace, but with the samples uniformly distributed
           in linear space, instead of log space.
geomspace : Similar to logspace, but with endpoints specified directly.

Notes
-----
Logspace is equivalent to the code

>>> y = np.linspace(start, stop, num=num, endpoint=endpoint)
... # doctest: +SKIP
>>> power(base, y).astype(dtype)
... # doctest: +SKIP

Examples
--------
>>> np.logspace(2.0, 3.0, num=4)
array([ 100.        ,  215.443469  ,  464.15888336, 1000.        ])
>>> np.logspace(2.0, 3.0, num=4, endpoint=False)
array([100.        ,  177.827941  ,  316.22776602,  562.34132519])
>>> np.logspace(2.0, 3.0, num=4, base=2.0)
array([4.        ,  5.0396842 ,  6.34960421,  8.        ])

Graphical illustration:

>>> import matplotlib.pyplot as plt
>>> N = 10
>>> x1 = np.logspace(0.1, 1, N, endpoint=True)
>>> x2 = np.logspace(0.1, 1, N, endpoint=False)
>>> y = np.zeros(N)
>>> plt.plot(x1, y, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.plot(x2, y + 0.5, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.ylim([-0.5, 1])
(-0.5, 1)
>>> plt.show()
*)

val lookfor : ?module_:[`Ndarray of [>`Ndarray] Obj.t | `S of string] -> ?import_modules:bool -> ?regenerate:bool -> ?output:Py.Object.t -> what:string -> unit -> Py.Object.t
(**
Do a keyword search on docstrings.

A list of objects that matched the search is displayed,
sorted by relevance. All given keywords need to be found in the
docstring for it to be returned as a result, but the order does
not matter.

Parameters
----------
what : str
    String containing words to look for.
module : str or list, optional
    Name of module(s) whose docstrings to go through.
import_modules : bool, optional
    Whether to import sub-modules in packages. Default is True.
regenerate : bool, optional
    Whether to re-generate the docstring cache. Default is False.
output : file-like, optional
    File-like object to write the output to. If omitted, use a pager.

See Also
--------
source, info

Notes
-----
Relevance is determined only roughly, by checking if the keywords occur
in the function name, at the start of a docstring, etc.

Examples
--------
>>> np.lookfor('binary representation') # doctest: +SKIP
Search results for 'binary representation'
------------------------------------------
numpy.binary_repr
    Return the binary representation of the input number as a string.
numpy.core.setup_common.long_double_representation
    Given a binary dump as given by GNU od -b, look for long double
numpy.base_repr
    Return a string representation of a number in the given base system.
...
*)

val mafromtxt : ?kwargs:(string * Py.Object.t) list -> fname:Py.Object.t -> unit -> Py.Object.t
(**
Load ASCII data stored in a text file and return a masked array.

.. deprecated:: 1.17
    np.mafromtxt is a deprecated alias of `genfromtxt` which
    overwrites the ``usemask`` argument with `True` even when
    explicitly called as ``mafromtxt(..., usemask=False)``.
    Use `genfromtxt` instead.

Parameters
----------
fname, kwargs : For a description of input parameters, see `genfromtxt`.

See Also
--------
numpy.genfromtxt : generic function to load ASCII data.
*)

val mask_indices : ?k:[`F of float | `I of int | `Bool of bool | `S of string] -> n:int -> mask_func:Py.Object.t -> unit -> Py.Object.t
(**
Return the indices to access (n, n) arrays, given a masking function.

Assume `mask_func` is a function that, for a square array a of size
``(n, n)`` with a possible offset argument `k`, when called as
``mask_func(a, k)`` returns a new array with zeros in certain locations
(functions like `triu` or `tril` do precisely this). Then this function
returns the indices where the non-zero values would be located.

Parameters
----------
n : int
    The returned indices will be valid to access arrays of shape (n, n).
mask_func : callable
    A function whose call signature is similar to that of `triu`, `tril`.
    That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.
    `k` is an optional argument to the function.
k : scalar
    An optional argument which is passed through to `mask_func`. Functions
    like `triu`, `tril` take a second argument that is interpreted as an
    offset.

Returns
-------
indices : tuple of arrays.
    The `n` arrays of indices corresponding to the locations where
    ``mask_func(np.ones((n, n)), k)`` is True.

See Also
--------
triu, tril, triu_indices, tril_indices

Notes
-----
.. versionadded:: 1.4.0

Examples
--------
These are the indices that would allow you to access the upper triangular
part of any 3x3 array:

>>> iu = np.mask_indices(3, np.triu)

For example, if `a` is a 3x3 array:

>>> a = np.arange(9).reshape(3, 3)
>>> a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> a[iu]
array([0, 1, 2, 4, 5, 8])

An offset can be passed also to the masking function.  This gets us the
indices starting on the first diagonal right of the main one:

>>> iu1 = np.mask_indices(3, np.triu, 1)

with which we now extract only three elements:

>>> a[iu1]
array([1, 2, 5])
*)

val mat : ?dtype:Dtype.t -> data:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Interpret the input as a matrix.

Unlike `matrix`, `asmatrix` does not make a copy if the input is already
a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.

Parameters
----------
data : array_like
    Input data.
dtype : data-type
   Data-type of the output matrix.

Returns
-------
mat : matrix
    `data` interpreted as a matrix.

Examples
--------
>>> x = np.array([[1, 2], [3, 4]])

>>> m = np.asmatrix(x)

>>> x[0,0] = 5

>>> m
matrix([[5, 2],
        [3, 4]])
*)

val matmul : ?out:[>`Ndarray] Obj.t -> ?where:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
matmul(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Matrix product of two arrays.

Parameters
----------
x1, x2 : array_like
    Input arrays, scalars not allowed.
out : ndarray, optional
    A location into which the result is stored. If provided, it must have
    a shape that matches the signature `(n,k),(k,m)->(n,m)`. If not
    provided or None, a freshly-allocated array is returned.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

    .. versionadded:: 1.16
       Now handles ufunc kwargs

Returns
-------
y : ndarray
    The matrix product of the inputs.
    This is a scalar only when both x1, x2 are 1-d vectors.

Raises
------
ValueError
    If the last dimension of `a` is not the same size as
    the second-to-last dimension of `b`.

    If a scalar value is passed in.

See Also
--------
vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
dot : alternative matrix product with different broadcasting rules.

Notes
-----

The behavior depends on the arguments in the following way.

- If both arguments are 2-D they are multiplied like conventional
  matrices.
- If either argument is N-D, N > 2, it is treated as a stack of
  matrices residing in the last two indexes and broadcast accordingly.
- If the first argument is 1-D, it is promoted to a matrix by
  prepending a 1 to its dimensions. After matrix multiplication
  the prepended 1 is removed.
- If the second argument is 1-D, it is promoted to a matrix by
  appending a 1 to its dimensions. After matrix multiplication
  the appended 1 is removed.

``matmul`` differs from ``dot`` in two important ways:

- Multiplication by scalars is not allowed, use ``*`` instead.
- Stacks of matrices are broadcast together as if the matrices
  were elements, respecting the signature ``(n,k),(k,m)->(n,m)``:

  >>> a = np.ones([9, 5, 7, 4])
  >>> c = np.ones([9, 5, 4, 3])
  >>> np.dot(a, c).shape
  (9, 5, 7, 9, 5, 3)
  >>> np.matmul(a, c).shape
  (9, 5, 7, 3)
  >>> # n is 7, k is 4, m is 3

The matmul function implements the semantics of the `@` operator introduced
in Python 3.5 following PEP465.

Examples
--------
For 2-D arrays it is the matrix product:

>>> a = np.array([[1, 0],
...               [0, 1]])
>>> b = np.array([[4, 1],
...               [2, 2]])
>>> np.matmul(a, b)
array([[4, 1],
       [2, 2]])

For 2-D mixed with 1-D, the result is the usual.

>>> a = np.array([[1, 0],
...               [0, 1]])
>>> b = np.array([1, 2])
>>> np.matmul(a, b)
array([1, 2])
>>> np.matmul(b, a)
array([1, 2])


Broadcasting is conventional for stacks of arrays

>>> a = np.arange(2 * 2 * 4).reshape((2, 2, 4))
>>> b = np.arange(2 * 2 * 4).reshape((2, 4, 2))
>>> np.matmul(a,b).shape
(2, 2, 2)
>>> np.matmul(a, b)[0, 1, 1]
98
>>> sum(a[0, 1, :] * b[0 , :, 1])
98

Vector, vector returns the scalar inner product, but neither argument
is complex-conjugated:

>>> np.matmul([2j, 3j], [2j, 3j])
(-13+0j)

Scalar multiplication raises an error.

>>> np.matmul([1,2], 3)
Traceback (most recent call last):
...
ValueError: matmul: Input operand 1 does not have enough dimensions ...

.. versionadded:: 1.10.0
*)

val max : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> ?initial:[`F of float | `I of int | `Bool of bool | `S of string] -> ?where:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the maximum of an array or maximum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, the maximum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `amax` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

initial : scalar, optional
    The minimum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to compare for the maximum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.17.0

Returns
-------
amax : ndarray or scalar
    Maximum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amin :
    The minimum value of an array along a given axis, propagating any NaNs.
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
argmax :
    Return the indices of the maximum values.

nanmin, minimum, fmin

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.

Don't use `amax` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
``amax(a, axis=0)``.

Examples
--------
>>> a = np.arange(4).reshape((2,2))
>>> a
array([[0, 1],
       [2, 3]])
>>> np.amax(a)           # Maximum of the flattened array
3
>>> np.amax(a, axis=0)   # Maxima along the first axis
array([2, 3])
>>> np.amax(a, axis=1)   # Maxima along the second axis
array([1, 3])
>>> np.amax(a, where=[False, True], initial=-1, axis=0)
array([-1,  3])
>>> b = np.arange(5, dtype=float)
>>> b[2] = np.NaN
>>> np.amax(b)
nan
>>> np.amax(b, where=~np.isnan(b), initial=-1)
4.0
>>> np.nanmax(b)
4.0

You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:

>>> np.max([[-50], [10]], axis=-1, initial=0)
array([ 0, 10])

Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.

>>> np.max([5], initial=6)
6
>>> max([5], default=6)
5
*)

val maximum : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Element-wise maximum of array elements.

Compare two arrays and returns a new array containing the element-wise
maxima. If one of the elements being compared is a NaN, then that
element is returned. If both elements are NaNs then the first is
returned. The latter distinction is important for complex NaNs, which
are defined as at least one of the real or imaginary parts being a NaN.
The net effect is that NaNs are propagated.

Parameters
----------
x1, x2 : array_like
    The arrays holding the elements to be compared. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The maximum of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
minimum :
    Element-wise minimum of two arrays, propagates NaNs.
fmax :
    Element-wise maximum of two arrays, ignores NaNs.
amax :
    The maximum value of an array along a given axis, propagates NaNs.
nanmax :
    The maximum value of an array along a given axis, ignores NaNs.

fmin, amin, nanmin

Notes
-----
The maximum is equivalent to ``np.where(x1 >= x2, x1, x2)`` when
neither x1 nor x2 are nans, but it is faster and does proper
broadcasting.

Examples
--------
>>> np.maximum([2, 3, 4], [1, 5, 2])
array([2, 5, 4])

>>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting
array([[ 1. ,  2. ],
       [ 0.5,  2. ]])

>>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])
array([nan, nan, nan])
>>> np.maximum(np.Inf, 1)
inf
*)

val maximum_sctype : [`Dtype_specifier of Py.Object.t | `Dtype of Dtype.t] -> Dtype.t
(**
Return the scalar type of highest precision of the same kind as the input.

Parameters
----------
t : dtype or dtype specifier
    The input data type. This can be a `dtype` object or an object that
    is convertible to a `dtype`.

Returns
-------
out : dtype
    The highest precision data type of the same kind (`dtype.kind`) as `t`.

See Also
--------
obj2sctype, mintypecode, sctype2char
dtype

Examples
--------
>>> np.maximum_sctype(int)
<class 'numpy.int64'>
>>> np.maximum_sctype(np.uint8)
<class 'numpy.uint64'>
>>> np.maximum_sctype(complex)
<class 'numpy.complex256'> # may vary

>>> np.maximum_sctype(str)
<class 'numpy.str_'>

>>> np.maximum_sctype('i2')
<class 'numpy.int64'>
>>> np.maximum_sctype('f4')
<class 'numpy.float128'> # may vary
*)

val may_share_memory : ?max_work:int -> b:Py.Object.t -> Py.Object.t -> bool
(**
may_share_memory(a, b, max_work=None)

Determine if two arrays might share memory

A return of True does not necessarily mean that the two arrays
share any element.  It just means that they *might*.

Only the memory bounds of a and b are checked by default.

Parameters
----------
a, b : ndarray
    Input arrays
max_work : int, optional
    Effort to spend on solving the overlap problem.  See
    `shares_memory` for details.  Default for ``may_share_memory``
    is to do a bounds check.

Returns
-------
out : bool

See Also
--------
shares_memory

Examples
--------
>>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))
False
>>> x = np.zeros([3, 4])
>>> np.may_share_memory(x[:,0], x[:,1])
True
*)

val mean : ?axis:int list -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the arithmetic mean along the specified axis.

Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
`float64` intermediate and return values are used for integer inputs.

Parameters
----------
a : array_like
    Array containing numbers whose mean is desired. If `a` is not an
    array, a conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which the means are computed. The default is to
    compute the mean of the flattened array.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a mean is performed over multiple axes,
    instead of a single axis or all the axes as before.
dtype : data-type, optional
    Type to use in computing the mean.  For integer inputs, the default
    is `float64`; for floating point inputs, it is the same as the
    input dtype.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary.
    See `ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `mean` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
m : ndarray, see dtype parameter above
    If `out=None`, returns a new array containing the mean values,
    otherwise a reference to the output array is returned.

See Also
--------
average : Weighted average
std, var, nanmean, nanstd, nanvar

Notes
-----
The arithmetic mean is the sum of the elements along the axis divided
by the number of elements.

Note that for floating-point input, the mean is computed using the
same precision the input has.  Depending on the input data, this can
cause the results to be inaccurate, especially for `float32` (see
example below).  Specifying a higher-precision accumulator using the
`dtype` keyword can alleviate this issue.

By default, `float16` results are computed using `float32` intermediates
for extra precision.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> np.mean(a)
2.5
>>> np.mean(a, axis=0)
array([2., 3.])
>>> np.mean(a, axis=1)
array([1.5, 3.5])

In single precision, `mean` can be inaccurate:

>>> a = np.zeros((2, 512*512), dtype=np.float32)
>>> a[0, :] = 1.0
>>> a[1, :] = 0.1
>>> np.mean(a)
0.54999924

Computing the mean in float64 is more accurate:

>>> np.mean(a, dtype=np.float64)
0.55000000074505806 # may vary
*)

val median : ?axis:[`I of int | `Sequence_of_int of Py.Object.t] -> ?out:[>`Ndarray] Obj.t -> ?overwrite_input:bool -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the median along the specified axis.

Returns the median of the array elements.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : {int, sequence of int, None}, optional
    Axis or axes along which the medians are computed. The default
    is to compute the median along a flattened version of the array.
    A sequence of axes is supported since version 1.9.0.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
   If True, then allow use of memory of input array `a` for
   calculations. The input array will be modified by the call to
   `median`. This will save memory when you do not need to preserve
   the contents of the input array. Treat the input as undefined,
   but it will probably be fully or partially sorted. Default is
   False. If `overwrite_input` is ``True`` and `a` is not already an
   `ndarray`, an error will be raised.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

    .. versionadded:: 1.9.0

Returns
-------
median : ndarray
    A new array holding the result. If the input contains integers
    or floats smaller than ``float64``, then the output data-type is
    ``np.float64``.  Otherwise, the data-type of the output is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
mean, percentile

Notes
-----
Given a vector ``V`` of length ``N``, the median of ``V`` is the
middle value of a sorted copy of ``V``, ``V_sorted`` - i
e., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the
two middle values of ``V_sorted`` when ``N`` is even.

Examples
--------
>>> a = np.array([[10, 7, 4], [3, 2, 1]])
>>> a
array([[10,  7,  4],
       [ 3,  2,  1]])
>>> np.median(a)
3.5
>>> np.median(a, axis=0)
array([6.5, 4.5, 2.5])
>>> np.median(a, axis=1)
array([7.,  2.])
>>> m = np.median(a, axis=0)
>>> out = np.zeros_like(m)
>>> np.median(a, axis=0, out=m)
array([6.5,  4.5,  2.5])
>>> m
array([6.5,  4.5,  2.5])
>>> b = a.copy()
>>> np.median(b, axis=1, overwrite_input=True)
array([7.,  2.])
>>> assert not np.all(a==b)
>>> b = a.copy()
>>> np.median(b, axis=None, overwrite_input=True)
3.5
>>> assert not np.all(a==b)
*)

val meshgrid : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
Return coordinate matrices from coordinate vectors.

Make N-D coordinate arrays for vectorized evaluations of
N-D scalar/vector fields over N-D grids, given
one-dimensional coordinate arrays x1, x2,..., xn.

.. versionchanged:: 1.9
   1-D and 0-D cases are allowed.

Parameters
----------
x1, x2,..., xn : array_like
    1-D arrays representing the coordinates of a grid.
indexing : {'xy', 'ij'}, optional
    Cartesian ('xy', default) or matrix ('ij') indexing of output.
    See Notes for more details.

    .. versionadded:: 1.7.0
sparse : bool, optional
    If True a sparse grid is returned in order to conserve memory.
    Default is False.

    .. versionadded:: 1.7.0
copy : bool, optional
    If False, a view into the original arrays are returned in order to
    conserve memory.  Default is True.  Please note that
    ``sparse=False, copy=False`` will likely return non-contiguous
    arrays.  Furthermore, more than one element of a broadcast array
    may refer to a single memory location.  If you need to write to the
    arrays, make copies first.

    .. versionadded:: 1.7.0

Returns
-------
X1, X2,..., XN : ndarray
    For vectors `x1`, `x2`,..., 'xn' with lengths ``Ni=len(xi)`` ,
    return ``(N1, N2, N3,...Nn)`` shaped arrays if indexing='ij'
    or ``(N2, N1, N3,...Nn)`` shaped arrays if indexing='xy'
    with the elements of `xi` repeated to fill the matrix along
    the first dimension for `x1`, the second for `x2` and so on.

Notes
-----
This function supports both indexing conventions through the indexing
keyword argument.  Giving the string 'ij' returns a meshgrid with
matrix indexing, while 'xy' returns a meshgrid with Cartesian indexing.
In the 2-D case with inputs of length M and N, the outputs are of shape
(N, M) for 'xy' indexing and (M, N) for 'ij' indexing.  In the 3-D case
with inputs of length M, N and P, outputs are of shape (N, M, P) for
'xy' indexing and (M, N, P) for 'ij' indexing.  The difference is
illustrated by the following code snippet::

    xv, yv = np.meshgrid(x, y, sparse=False, indexing='ij')
    for i in range(nx):
        for j in range(ny):
            # treat xv[i,j], yv[i,j]

    xv, yv = np.meshgrid(x, y, sparse=False, indexing='xy')
    for i in range(nx):
        for j in range(ny):
            # treat xv[j,i], yv[j,i]

In the 1-D and 0-D case, the indexing and sparse keywords have no effect.

See Also
--------
index_tricks.mgrid : Construct a multi-dimensional 'meshgrid'
                 using indexing notation.
index_tricks.ogrid : Construct an open multi-dimensional 'meshgrid'
                 using indexing notation.

Examples
--------
>>> nx, ny = (3, 2)
>>> x = np.linspace(0, 1, nx)
>>> y = np.linspace(0, 1, ny)
>>> xv, yv = np.meshgrid(x, y)
>>> xv
array([[0. , 0.5, 1. ],
       [0. , 0.5, 1. ]])
>>> yv
array([[0.,  0.,  0.],
       [1.,  1.,  1.]])
>>> xv, yv = np.meshgrid(x, y, sparse=True)  # make sparse output arrays
>>> xv
array([[0. ,  0.5,  1. ]])
>>> yv
array([[0.],
       [1.]])

`meshgrid` is very useful to evaluate functions on a grid.

>>> import matplotlib.pyplot as plt
>>> x = np.arange(-5, 5, 0.1)
>>> y = np.arange(-5, 5, 0.1)
>>> xx, yy = np.meshgrid(x, y, sparse=True)
>>> z = np.sin(xx**2 + yy**2) / (xx**2 + yy**2)
>>> h = plt.contourf(x,y,z)
>>> plt.show()
*)

val min : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> ?initial:[`F of float | `I of int | `Bool of bool | `S of string] -> ?where:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the minimum of an array or minimum along an axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which to operate.  By default, flattened input is
    used.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, the minimum is selected over multiple axes,
    instead of a single axis or all the axes as before.
out : ndarray, optional
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See `ufuncs-output-type` for more details.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `amin` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

initial : scalar, optional
    The maximum value of an output element. Must be present to allow
    computation on empty slice. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to compare for the minimum. See `~numpy.ufunc.reduce`
    for details.

    .. versionadded:: 1.17.0

Returns
-------
amin : ndarray or scalar
    Minimum of `a`. If `axis` is None, the result is a scalar value.
    If `axis` is given, the result is an array of dimension
    ``a.ndim - 1``.

See Also
--------
amax :
    The maximum value of an array along a given axis, propagating any NaNs.
nanmin :
    The minimum value of an array along a given axis, ignoring any NaNs.
minimum :
    Element-wise minimum of two arrays, propagating any NaNs.
fmin :
    Element-wise minimum of two arrays, ignoring any NaNs.
argmin :
    Return the indices of the minimum values.

nanmax, maximum, fmax

Notes
-----
NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.

Don't use `amin` for element-wise comparison of 2 arrays; when
``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
``amin(a, axis=0)``.

Examples
--------
>>> a = np.arange(4).reshape((2,2))
>>> a
array([[0, 1],
       [2, 3]])
>>> np.amin(a)           # Minimum of the flattened array
0
>>> np.amin(a, axis=0)   # Minima along the first axis
array([0, 1])
>>> np.amin(a, axis=1)   # Minima along the second axis
array([0, 2])
>>> np.amin(a, where=[False, True], initial=10, axis=0)
array([10,  1])

>>> b = np.arange(5, dtype=float)
>>> b[2] = np.NaN
>>> np.amin(b)
nan
>>> np.amin(b, where=~np.isnan(b), initial=10)
0.0
>>> np.nanmin(b)
0.0

>>> np.min([[-50], [10]], axis=-1, initial=0)
array([-50,   0])

Notice that the initial value is used as one of the elements for which the
minimum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.

Notice that this isn't the same as Python's ``default`` argument.

>>> np.min([6], initial=5)
5
>>> min([6], default=5)
6
*)

val min_scalar_type : [`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> Dtype.t
(**
min_scalar_type(a)

For scalar ``a``, returns the data type with the smallest size
and smallest scalar kind which can hold its value.  For non-scalar
array ``a``, returns the vector's dtype unmodified.

Floating point values are not demoted to integers,
and complex values are not demoted to floats.

Parameters
----------
a : scalar or array_like
    The value whose minimal data type is to be found.

Returns
-------
out : dtype
    The minimal data type.

Notes
-----
.. versionadded:: 1.6.0

See Also
--------
result_type, promote_types, dtype, can_cast

Examples
--------
>>> np.min_scalar_type(10)
dtype('uint8')

>>> np.min_scalar_type(-260)
dtype('int16')

>>> np.min_scalar_type(3.1)
dtype('float16')

>>> np.min_scalar_type(1e50)
dtype('float64')

>>> np.min_scalar_type(np.arange(4,dtype='f8'))
dtype('float64')
*)

val minimum : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Element-wise minimum of array elements.

Compare two arrays and returns a new array containing the element-wise
minima. If one of the elements being compared is a NaN, then that
element is returned. If both elements are NaNs then the first is
returned. The latter distinction is important for complex NaNs, which
are defined as at least one of the real or imaginary parts being a NaN.
The net effect is that NaNs are propagated.

Parameters
----------
x1, x2 : array_like
    The arrays holding the elements to be compared. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The minimum of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
maximum :
    Element-wise maximum of two arrays, propagates NaNs.
fmin :
    Element-wise minimum of two arrays, ignores NaNs.
amin :
    The minimum value of an array along a given axis, propagates NaNs.
nanmin :
    The minimum value of an array along a given axis, ignores NaNs.

fmax, amax, nanmax

Notes
-----
The minimum is equivalent to ``np.where(x1 <= x2, x1, x2)`` when
neither x1 nor x2 are NaNs, but it is faster and does proper
broadcasting.

Examples
--------
>>> np.minimum([2, 3, 4], [1, 5, 2])
array([1, 3, 2])

>>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting
array([[ 0.5,  0. ],
       [ 0. ,  1. ]])

>>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])
array([nan, nan, nan])
>>> np.minimum(-np.Inf, 1)
-inf
*)

val mintypecode : ?typeset:[`StringList of string list | `S of string] -> ?default:string -> typechars:[`StringList of string list | `Ndarray of [>`Ndarray] Obj.t] -> unit -> string
(**
Return the character for the minimum-size type to which given types can
be safely cast.

The returned type character must represent the smallest size dtype such
that an array of the returned type can handle the data from an array of
all types in `typechars` (or if `typechars` is an array, then its
dtype.char).

Parameters
----------
typechars : list of str or array_like
    If a list of strings, each string should represent a dtype.
    If array_like, the character representation of the array dtype is used.
typeset : str or list of str, optional
    The set of characters that the returned character is chosen from.
    The default set is 'GDFgdf'.
default : str, optional
    The default character, this is returned if none of the characters in
    `typechars` matches a character in `typeset`.

Returns
-------
typechar : str
    The character representing the minimum-size type that was found.

See Also
--------
dtype, sctype2char, maximum_sctype

Examples
--------
>>> np.mintypecode(['d', 'f', 'S'])
'd'
>>> x = np.array([1.1, 2-3.j])
>>> np.mintypecode(x)
'D'

>>> np.mintypecode('abceh', default='G')
'G'
*)

val mirr : values:[>`Ndarray] Obj.t -> finance_rate:[`F of float | `I of int | `Bool of bool | `S of string] -> reinvest_rate:[`F of float | `I of int | `Bool of bool | `S of string] -> unit -> float
(**
Modified internal rate of return.

.. deprecated:: 1.18

   `mirr` is deprecated; for details, see NEP 32 [1]_.
   Use the corresponding function in the numpy-financial library,
   https://pypi.org/project/numpy-financial.

Parameters
----------
values : array_like
    Cash flows (must contain at least one positive and one negative
    value) or nan is returned.  The first value is considered a sunk
    cost at time zero.
finance_rate : scalar
    Interest rate paid on the cash flows
reinvest_rate : scalar
    Interest rate received on the cash flows upon reinvestment

Returns
-------
out : float
    Modified internal rate of return

References
----------
.. [1] NumPy Enhancement Proposal (NEP) 32,
   https://numpy.org/neps/nep-0032-remove-financial-functions.html
*)

val mod_ : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return element-wise remainder of division.

Computes the remainder complementary to the `floor_divide` function.  It is
equivalent to the Python modulus operator``x1 % x2`` and has the same sign
as the divisor `x2`. The MATLAB function equivalent to ``np.remainder``
is ``mod``.

.. warning::

    This should not be confused with:

    * Python 3.7's `math.remainder` and C's ``remainder``, which
      computes the IEEE remainder, which are the complement to
      ``round(x1 / x2)``.
    * The MATLAB ``rem`` function and or the C ``%`` operator which is the
      complement to ``int(x1 / x2)``.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
floor_divide : Equivalent of Python ``//`` operator.
divmod : Simultaneous floor division and remainder.
fmod : Equivalent of the MATLAB ``rem`` function.
divide, floor

Notes
-----
Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)
integers.
``mod`` is an alias of ``remainder``.

Examples
--------
>>> np.remainder([4, 7], [2, 3])
array([0, 1])
>>> np.remainder(np.arange(7), 5)
array([0, 1, 2, 3, 4, 0, 1])
*)

val modf : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
modf(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the fractional and integral parts of an array, element-wise.

The fractional and integral parts are negative if the given number is
negative.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y1 : ndarray
    Fractional part of `x`.
    This is a scalar if `x` is a scalar.
y2 : ndarray
    Integral part of `x`.
    This is a scalar if `x` is a scalar.

Notes
-----
For integer input the return values are floats.

See Also
--------
divmod : ``divmod(x, 1)`` is equivalent to ``modf`` with the return values
         switched, except it always has a positive remainder.

Examples
--------
>>> np.modf([0, 3.5])
(array([ 0. ,  0.5]), array([ 0.,  3.]))
>>> np.modf(-0.5)
(-0.5, -0)
*)

val moveaxis : source:[`I of int | `Sequence_of_int of Py.Object.t] -> destination:[`I of int | `Sequence_of_int of Py.Object.t] -> Py.Object.t -> Py.Object.t
(**
Move axes of an array to new positions.

Other axes remain in their original order.

.. versionadded:: 1.11.0

Parameters
----------
a : np.ndarray
    The array whose axes should be reordered.
source : int or sequence of int
    Original positions of the axes to move. These must be unique.
destination : int or sequence of int
    Destination positions for each of the original axes. These must also be
    unique.

Returns
-------
result : np.ndarray
    Array with moved axes. This array is a view of the input array.

See Also
--------
transpose: Permute the dimensions of an array.
swapaxes: Interchange two axes of an array.

Examples
--------

>>> x = np.zeros((3, 4, 5))
>>> np.moveaxis(x, 0, -1).shape
(4, 5, 3)
>>> np.moveaxis(x, -1, 0).shape
(5, 3, 4)

These all achieve the same result:

>>> np.transpose(x).shape
(5, 4, 3)
>>> np.swapaxes(x, 0, -1).shape
(5, 4, 3)
>>> np.moveaxis(x, [0, 1], [-1, -2]).shape
(5, 4, 3)
>>> np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape
(5, 4, 3)
*)

val msort : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a copy of an array sorted along the first axis.

Parameters
----------
a : array_like
    Array to be sorted.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
sort

Notes
-----
``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.
*)

val multiply : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Multiply arguments element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays to be multiplied. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The product of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
Equivalent to `x1` * `x2` in terms of array broadcasting.

Examples
--------
>>> np.multiply(2.0, 4.0)
8.0

>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.multiply(x1, x2)
array([[  0.,   1.,   4.],
       [  0.,   4.,  10.],
       [  0.,   7.,  16.]])
*)

val nan_to_num : ?copy:bool -> ?nan:[`I of int | `F of float] -> ?posinf:[`I of int | `F of float] -> ?neginf:[`I of int | `F of float] -> [`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Replace NaN with zero and infinity with large finite numbers (default
behaviour) or with the numbers defined by the user using the `nan`, 
`posinf` and/or `neginf` keywords.

If `x` is inexact, NaN is replaced by zero or by the user defined value in
`nan` keyword, infinity is replaced by the largest finite floating point 
values representable by ``x.dtype`` or by the user defined value in 
`posinf` keyword and -infinity is replaced by the most negative finite 
floating point values representable by ``x.dtype`` or by the user defined 
value in `neginf` keyword.

For complex dtypes, the above is applied to each of the real and
imaginary components of `x` separately.

If `x` is not inexact, then no replacements are made.

Parameters
----------
x : scalar or array_like
    Input data.
copy : bool, optional
    Whether to create a copy of `x` (True) or to replace values
    in-place (False). The in-place operation only occurs if
    casting to an array does not require a copy.
    Default is True.
    
    .. versionadded:: 1.13
nan : int, float, optional
    Value to be used to fill NaN values. If no value is passed 
    then NaN values will be replaced with 0.0.
    
    .. versionadded:: 1.17
posinf : int, float, optional
    Value to be used to fill positive infinity values. If no value is 
    passed then positive infinity values will be replaced with a very
    large number.
    
    .. versionadded:: 1.17
neginf : int, float, optional
    Value to be used to fill negative infinity values. If no value is 
    passed then negative infinity values will be replaced with a very
    small (or negative) number.
    
    .. versionadded:: 1.17

    

Returns
-------
out : ndarray
    `x`, with the non-finite values replaced. If `copy` is False, this may
    be `x` itself.

See Also
--------
isinf : Shows which elements are positive or negative infinity.
isneginf : Shows which elements are negative infinity.
isposinf : Shows which elements are positive infinity.
isnan : Shows which elements are Not a Number (NaN).
isfinite : Shows which elements are finite (not NaN, not infinity)

Notes
-----
NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.

Examples
--------
>>> np.nan_to_num(np.inf)
1.7976931348623157e+308
>>> np.nan_to_num(-np.inf)
-1.7976931348623157e+308
>>> np.nan_to_num(np.nan)
0.0
>>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])
>>> np.nan_to_num(x)
array([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary
       -1.28000000e+002,  1.28000000e+002])
>>> np.nan_to_num(x, nan=-9999, posinf=33333333, neginf=33333333)
array([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03, 
       -1.2800000e+02,  1.2800000e+02])
>>> y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])
array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary
     -1.28000000e+002,   1.28000000e+002])
>>> np.nan_to_num(y)
array([  1.79769313e+308 +0.00000000e+000j, # may vary
         0.00000000e+000 +0.00000000e+000j,
         0.00000000e+000 +1.79769313e+308j])
>>> np.nan_to_num(y, nan=111111, posinf=222222)
array([222222.+111111.j, 111111.     +0.j, 111111.+222222.j])
*)

val nanargmax : ?axis:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the indices of the maximum values in the specified axis ignoring
NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the
results cannot be trusted if a slice contains only NaNs and -Infs.


Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which to operate.  By default flattened input is used.

Returns
-------
index_array : ndarray
    An array of indices or a single index value.

See Also
--------
argmax, nanargmin

Examples
--------
>>> a = np.array([[np.nan, 4], [2, 3]])
>>> np.argmax(a)
0
>>> np.nanargmax(a)
1
>>> np.nanargmax(a, axis=0)
array([1, 0])
>>> np.nanargmax(a, axis=1)
array([1, 1])
*)

val nanargmin : ?axis:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the indices of the minimum values in the specified axis ignoring
NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results
cannot be trusted if a slice contains only NaNs and Infs.

Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which to operate.  By default flattened input is used.

Returns
-------
index_array : ndarray
    An array of indices or a single index value.

See Also
--------
argmin, nanargmax

Examples
--------
>>> a = np.array([[np.nan, 4], [2, 3]])
>>> np.argmin(a)
0
>>> np.nanargmin(a)
2
>>> np.nanargmin(a, axis=0)
array([1, 1])
>>> np.nanargmin(a, axis=1)
array([1, 0])
*)

val nancumprod : ?axis:int -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the cumulative product of array elements over a given axis treating Not a
Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
encountered and leading NaNs are replaced by ones.

Ones are returned for slices that are all-NaN or empty.

.. versionadded:: 1.12.0

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    Axis along which the cumulative product is computed.  By default
    the input is flattened.
dtype : dtype, optional
    Type of the returned array, as well as of the accumulator in which
    the elements are multiplied.  If *dtype* is not specified, it
    defaults to the dtype of `a`, unless `a` has an integer dtype with
    a precision less than that of the default platform integer.  In
    that case, the default platform integer is used instead.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type of the resulting values will be cast if necessary.

Returns
-------
nancumprod : ndarray
    A new array holding the result is returned unless `out` is
    specified, in which case it is returned.

See Also
--------
numpy.cumprod : Cumulative product across array propagating NaNs.
isnan : Show which elements are NaN.

Examples
--------
>>> np.nancumprod(1)
array([1])
>>> np.nancumprod([1])
array([1])
>>> np.nancumprod([1, np.nan])
array([1.,  1.])
>>> a = np.array([[1, 2], [3, np.nan]])
>>> np.nancumprod(a)
array([1.,  2.,  6.,  6.])
>>> np.nancumprod(a, axis=0)
array([[1.,  2.],
       [3.,  2.]])
>>> np.nancumprod(a, axis=1)
array([[1.,  2.],
       [3.,  3.]])
*)

val nancumsum : ?axis:int -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the cumulative sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
encountered and leading NaNs are replaced by zeros.

Zeros are returned for slices that are all-NaN or empty.

.. versionadded:: 1.12.0

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    Axis along which the cumulative sum is computed. The default
    (None) is to compute the cumsum over the flattened array.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed.  If `dtype` is not specified, it defaults
    to the dtype of `a`, unless `a` has an integer dtype with a
    precision less than that of the default platform integer.  In
    that case, the default platform integer is used.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary. See `ufuncs-output-type` for
    more details.

Returns
-------
nancumsum : ndarray.
    A new array holding the result is returned unless `out` is
    specified, in which it is returned. The result has the same
    size as `a`, and the same shape as `a` if `axis` is not None
    or `a` is a 1-d array.

See Also
--------
numpy.cumsum : Cumulative sum across array propagating NaNs.
isnan : Show which elements are NaN.

Examples
--------
>>> np.nancumsum(1)
array([1])
>>> np.nancumsum([1])
array([1])
>>> np.nancumsum([1, np.nan])
array([1.,  1.])
>>> a = np.array([[1, 2], [3, np.nan]])
>>> np.nancumsum(a)
array([1.,  3.,  6.,  6.])
>>> np.nancumsum(a, axis=0)
array([[1.,  2.],
       [4.,  2.]])
>>> np.nancumsum(a, axis=1)
array([[1.,  3.],
       [3.,  3.]])
*)

val nanmax : ?axis:[`I of int | `Tuple_of_int of Py.Object.t] -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the maximum of an array or maximum along an axis, ignoring any
NaNs.  When all-NaN slices are encountered a ``RuntimeWarning`` is
raised and NaN is returned for that slice.

Parameters
----------
a : array_like
    Array containing numbers whose maximum is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the maximum is computed. The default is to compute
    the maximum of the flattened array.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary. See
    `ufuncs-output-type` for more details.

    .. versionadded:: 1.8.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If the value is anything but the default, then
    `keepdims` will be passed through to the `max` method
    of sub-classes of `ndarray`.  If the sub-classes methods
    does not implement `keepdims` any exceptions will be raised.

    .. versionadded:: 1.8.0

Returns
-------
nanmax : ndarray
    An array with the same shape as `a`, with the specified axis removed.
    If `a` is a 0-d array, or if axis is None, an ndarray scalar is
    returned.  The same dtype as `a` is returned.

See Also
--------
nanmin :
    The minimum value of an array along a given axis, ignoring any NaNs.
amax :
    The maximum value of an array along a given axis, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
isnan :
    Shows which elements are Not a Number (NaN).
isfinite:
    Shows which elements are neither NaN nor infinity.

amin, fmin, minimum

Notes
-----
NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.

If the input has a integer type the function is equivalent to np.max.

Examples
--------
>>> a = np.array([[1, 2], [3, np.nan]])
>>> np.nanmax(a)
3.0
>>> np.nanmax(a, axis=0)
array([3.,  2.])
>>> np.nanmax(a, axis=1)
array([2.,  3.])

When positive infinity and negative infinity are present:

>>> np.nanmax([1, 2, np.nan, np.NINF])
2.0
>>> np.nanmax([1, 2, np.nan, np.inf])
inf
*)

val nanmean : ?axis:[`I of int | `Tuple_of_int of Py.Object.t] -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the arithmetic mean along the specified axis, ignoring NaNs.

Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
`float64` intermediate and return values are used for integer inputs.

For all-NaN slices, NaN is returned and a `RuntimeWarning` is raised.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array containing numbers whose mean is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the means are computed. The default is to compute
    the mean of the flattened array.
dtype : data-type, optional
    Type to use in computing the mean.  For integer inputs, the default
    is `float64`; for inexact inputs, it is the same as the input
    dtype.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary. See
    `ufuncs-output-type` for more details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If the value is anything but the default, then
    `keepdims` will be passed through to the `mean` or `sum` methods
    of sub-classes of `ndarray`.  If the sub-classes methods
    does not implement `keepdims` any exceptions will be raised.

Returns
-------
m : ndarray, see dtype parameter above
    If `out=None`, returns a new array containing the mean values,
    otherwise a reference to the output array is returned. Nan is
    returned for slices that contain only NaNs.

See Also
--------
average : Weighted average
mean : Arithmetic mean taken while not ignoring NaNs
var, nanvar

Notes
-----
The arithmetic mean is the sum of the non-NaN elements along the axis
divided by the number of non-NaN elements.

Note that for floating-point input, the mean is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32`.  Specifying a
higher-precision accumulator using the `dtype` keyword can alleviate
this issue.

Examples
--------
>>> a = np.array([[1, np.nan], [3, 4]])
>>> np.nanmean(a)
2.6666666666666665
>>> np.nanmean(a, axis=0)
array([2.,  4.])
>>> np.nanmean(a, axis=1)
array([1.,  3.5]) # may vary
*)

val nanmedian : ?axis:[`I of int | `Sequence_of_int of Py.Object.t] -> ?out:[>`Ndarray] Obj.t -> ?overwrite_input:bool -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the median along the specified axis, while ignoring NaNs.

Returns the median of the array elements.

.. versionadded:: 1.9.0

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : {int, sequence of int, None}, optional
    Axis or axes along which the medians are computed. The default
    is to compute the median along a flattened version of the array.
    A sequence of axes is supported since version 1.9.0.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
   If True, then allow use of memory of input array `a` for
   calculations. The input array will be modified by the call to
   `median`. This will save memory when you do not need to preserve
   the contents of the input array. Treat the input as undefined,
   but it will probably be fully or partially sorted. Default is
   False. If `overwrite_input` is ``True`` and `a` is not already an
   `ndarray`, an error will be raised.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If this is anything but the default value it will be passed
    through (in the special case of an empty array) to the
    `mean` function of the underlying array.  If the array is
    a sub-class and `mean` does not have the kwarg `keepdims` this
    will raise a RuntimeError.

Returns
-------
median : ndarray
    A new array holding the result. If the input contains integers
    or floats smaller than ``float64``, then the output data-type is
    ``np.float64``.  Otherwise, the data-type of the output is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
mean, median, percentile

Notes
-----
Given a vector ``V`` of length ``N``, the median of ``V`` is the
middle value of a sorted copy of ``V``, ``V_sorted`` - i.e.,
``V_sorted[(N-1)/2]``, when ``N`` is odd and the average of the two
middle values of ``V_sorted`` when ``N`` is even.

Examples
--------
>>> a = np.array([[10.0, 7, 4], [3, 2, 1]])
>>> a[0, 1] = np.nan
>>> a
array([[10., nan,  4.],
       [ 3.,  2.,  1.]])
>>> np.median(a)
nan
>>> np.nanmedian(a)
3.0
>>> np.nanmedian(a, axis=0)
array([6.5, 2. , 2.5])
>>> np.median(a, axis=1)
array([nan,  2.])
>>> b = a.copy()
>>> np.nanmedian(b, axis=1, overwrite_input=True)
array([7.,  2.])
>>> assert not np.all(a==b)
>>> b = a.copy()
>>> np.nanmedian(b, axis=None, overwrite_input=True)
3.0
>>> assert not np.all(a==b)
*)

val nanmin : ?axis:[`I of int | `Tuple_of_int of Py.Object.t] -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return minimum of an array or minimum along an axis, ignoring any NaNs.
When all-NaN slices are encountered a ``RuntimeWarning`` is raised and
Nan is returned for that slice.

Parameters
----------
a : array_like
    Array containing numbers whose minimum is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the minimum is computed. The default is to compute
    the minimum of the flattened array.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary. See
    `ufuncs-output-type` for more details.

    .. versionadded:: 1.8.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If the value is anything but the default, then
    `keepdims` will be passed through to the `min` method
    of sub-classes of `ndarray`.  If the sub-classes methods
    does not implement `keepdims` any exceptions will be raised.

    .. versionadded:: 1.8.0

Returns
-------
nanmin : ndarray
    An array with the same shape as `a`, with the specified axis
    removed.  If `a` is a 0-d array, or if axis is None, an ndarray
    scalar is returned.  The same dtype as `a` is returned.

See Also
--------
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
amin :
    The minimum value of an array along a given axis, propagating any NaNs.
fmin :
    Element-wise minimum of two arrays, ignoring any NaNs.
minimum :
    Element-wise minimum of two arrays, propagating any NaNs.
isnan :
    Shows which elements are Not a Number (NaN).
isfinite:
    Shows which elements are neither NaN nor infinity.

amax, fmax, maximum

Notes
-----
NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.

If the input has a integer type the function is equivalent to np.min.

Examples
--------
>>> a = np.array([[1, 2], [3, np.nan]])
>>> np.nanmin(a)
1.0
>>> np.nanmin(a, axis=0)
array([1.,  2.])
>>> np.nanmin(a, axis=1)
array([1.,  3.])

When positive infinity and negative infinity are present:

>>> np.nanmin([1, 2, np.nan, np.inf])
1.0
>>> np.nanmin([1, 2, np.nan, np.NINF])
-inf
*)

val nanpercentile : ?axis:[`I of int | `Tuple_of_int of Py.Object.t] -> ?out:[>`Ndarray] Obj.t -> ?overwrite_input:bool -> ?interpolation:[`Linear | `Lower | `Higher | `Midpoint | `Nearest] -> ?keepdims:bool -> q:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the qth percentile of the data along the specified axis,
while ignoring nan values.

Returns the qth percentile(s) of the array elements.

.. versionadded:: 1.9.0

Parameters
----------
a : array_like
    Input array or object that can be converted to an array, containing
    nan values to be ignored.
q : array_like of float
    Percentile or sequence of percentiles to compute, which must be between
    0 and 100 inclusive.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the percentiles are computed. The
    default is to compute the percentile(s) along a flattened
    version of the array.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow the input array `a` to be modified by intermediate
    calculations, to save memory. In this case, the contents of the input
    `a` after this function completes is undefined.
interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
    This optional parameter specifies the interpolation method to
    use when the desired percentile lies between two data points
    ``i < j``:

    * 'linear': ``i + (j - i) * fraction``, where ``fraction``
      is the fractional part of the index surrounded by ``i``
      and ``j``.
    * 'lower': ``i``.
    * 'higher': ``j``.
    * 'nearest': ``i`` or ``j``, whichever is nearest.
    * 'midpoint': ``(i + j) / 2``.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in
    the result as dimensions with size one. With this option, the
    result will broadcast correctly against the original array `a`.

    If this is anything but the default value it will be passed
    through (in the special case of an empty array) to the
    `mean` function of the underlying array.  If the array is
    a sub-class and `mean` does not have the kwarg `keepdims` this
    will raise a RuntimeError.

Returns
-------
percentile : scalar or ndarray
    If `q` is a single percentile and `axis=None`, then the result
    is a scalar. If multiple percentiles are given, first axis of
    the result corresponds to the percentiles. The other axes are
    the axes that remain after the reduction of `a`. If the input
    contains integers or floats smaller than ``float64``, the output
    data-type is ``float64``. Otherwise, the output data-type is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
nanmean
nanmedian : equivalent to ``nanpercentile(..., 50)``
percentile, median, mean
nanquantile : equivalent to nanpercentile, but with q in the range [0, 1].

Notes
-----
Given a vector ``V`` of length ``N``, the ``q``-th percentile of
``V`` is the value ``q/100`` of the way from the minimum to the
maximum in a sorted copy of ``V``. The values and distances of
the two nearest neighbors as well as the `interpolation` parameter
will determine the percentile if the normalized ranking does not
match the location of ``q`` exactly. This function is the same as
the median if ``q=50``, the same as the minimum if ``q=0`` and the
same as the maximum if ``q=100``.

Examples
--------
>>> a = np.array([[10., 7., 4.], [3., 2., 1.]])
>>> a[0][1] = np.nan
>>> a
array([[10.,  nan,   4.],
      [ 3.,   2.,   1.]])
>>> np.percentile(a, 50)
nan
>>> np.nanpercentile(a, 50)
3.0
>>> np.nanpercentile(a, 50, axis=0)
array([6.5, 2. , 2.5])
>>> np.nanpercentile(a, 50, axis=1, keepdims=True)
array([[7.],
       [2.]])
>>> m = np.nanpercentile(a, 50, axis=0)
>>> out = np.zeros_like(m)
>>> np.nanpercentile(a, 50, axis=0, out=out)
array([6.5, 2. , 2.5])
>>> m
array([6.5,  2. ,  2.5])

>>> b = a.copy()
>>> np.nanpercentile(b, 50, axis=1, overwrite_input=True)
array([7., 2.])
>>> assert not np.all(a==b)
*)

val nanprod : ?axis:[`I of int | `Tuple_of_int of Py.Object.t] -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the product of array elements over a given axis treating Not a
Numbers (NaNs) as ones.

One is returned for slices that are all-NaN or empty.

.. versionadded:: 1.10.0

Parameters
----------
a : array_like
    Array containing numbers whose product is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the product is computed. The default is to compute
    the product of the flattened array.
dtype : data-type, optional
    The type of the returned array and of the accumulator in which the
    elements are summed.  By default, the dtype of `a` is used.  An
    exception is when `a` has an integer type with less precision than
    the platform (u)intp. In that case, the default will be either
    (u)int32 or (u)int64 depending on whether the platform is 32 or 64
    bits. For inexact inputs, dtype must be inexact.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``. If provided, it must have the same shape as the
    expected output, but the type will be cast if necessary. See
    `ufuncs-output-type` for more details. The casting of NaN to integer
    can yield unexpected results.
keepdims : bool, optional
    If True, the axes which are reduced are left in the result as
    dimensions with size one. With this option, the result will
    broadcast correctly against the original `arr`.

Returns
-------
nanprod : ndarray
    A new array holding the result is returned unless `out` is
    specified, in which case it is returned.

See Also
--------
numpy.prod : Product across array propagating NaNs.
isnan : Show which elements are NaN.

Examples
--------
>>> np.nanprod(1)
1
>>> np.nanprod([1])
1
>>> np.nanprod([1, np.nan])
1.0
>>> a = np.array([[1, 2], [3, np.nan]])
>>> np.nanprod(a)
6.0
>>> np.nanprod(a, axis=0)
array([3., 2.])
*)

val nanquantile : ?axis:[`I of int | `Tuple_of_int of Py.Object.t] -> ?out:[>`Ndarray] Obj.t -> ?overwrite_input:bool -> ?interpolation:[`Linear | `Lower | `Higher | `Midpoint | `Nearest] -> ?keepdims:bool -> q:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the qth quantile of the data along the specified axis,
while ignoring nan values.
Returns the qth quantile(s) of the array elements.

.. versionadded:: 1.15.0

Parameters
----------
a : array_like
    Input array or object that can be converted to an array, containing
    nan values to be ignored
q : array_like of float
    Quantile or sequence of quantiles to compute, which must be between
    0 and 1 inclusive.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the quantiles are computed. The
    default is to compute the quantile(s) along a flattened
    version of the array.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow the input array `a` to be modified by intermediate
    calculations, to save memory. In this case, the contents of the input
    `a` after this function completes is undefined.
interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
    This optional parameter specifies the interpolation method to
    use when the desired quantile lies between two data points
    ``i < j``:

    * linear: ``i + (j - i) * fraction``, where ``fraction``
      is the fractional part of the index surrounded by ``i``
      and ``j``.
    * lower: ``i``.
    * higher: ``j``.
    * nearest: ``i`` or ``j``, whichever is nearest.
    * midpoint: ``(i + j) / 2``.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in
    the result as dimensions with size one. With this option, the
    result will broadcast correctly against the original array `a`.

    If this is anything but the default value it will be passed
    through (in the special case of an empty array) to the
    `mean` function of the underlying array.  If the array is
    a sub-class and `mean` does not have the kwarg `keepdims` this
    will raise a RuntimeError.

Returns
-------
quantile : scalar or ndarray
    If `q` is a single percentile and `axis=None`, then the result
    is a scalar. If multiple quantiles are given, first axis of
    the result corresponds to the quantiles. The other axes are
    the axes that remain after the reduction of `a`. If the input
    contains integers or floats smaller than ``float64``, the output
    data-type is ``float64``. Otherwise, the output data-type is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
quantile
nanmean, nanmedian
nanmedian : equivalent to ``nanquantile(..., 0.5)``
nanpercentile : same as nanquantile, but with q in the range [0, 100].

Examples
--------
>>> a = np.array([[10., 7., 4.], [3., 2., 1.]])
>>> a[0][1] = np.nan
>>> a
array([[10.,  nan,   4.],
      [ 3.,   2.,   1.]])
>>> np.quantile(a, 0.5)
nan
>>> np.nanquantile(a, 0.5)
3.0
>>> np.nanquantile(a, 0.5, axis=0)
array([6.5, 2. , 2.5])
>>> np.nanquantile(a, 0.5, axis=1, keepdims=True)
array([[7.],
       [2.]])
>>> m = np.nanquantile(a, 0.5, axis=0)
>>> out = np.zeros_like(m)
>>> np.nanquantile(a, 0.5, axis=0, out=out)
array([6.5, 2. , 2.5])
>>> m
array([6.5,  2. ,  2.5])
>>> b = a.copy()
>>> np.nanquantile(b, 0.5, axis=1, overwrite_input=True)
array([7., 2.])
>>> assert not np.all(a==b)
*)

val nanstd : ?axis:[`I of int | `Tuple_of_int of Py.Object.t] -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?ddof:int -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the standard deviation along the specified axis, while
ignoring NaNs.

Returns the standard deviation, a measure of the spread of a
distribution, of the non-NaN array elements. The standard deviation is
computed for the flattened array by default, otherwise over the
specified axis.

For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a `RuntimeWarning` is raised.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Calculate the standard deviation of the non-NaN values.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the standard deviation is computed. The default is
    to compute the standard deviation of the flattened array.
dtype : dtype, optional
    Type to use in computing the standard deviation. For arrays of
    integer type the default is float64, for arrays of float types it
    is the same as the array type.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type (of the
    calculated values) will be cast if necessary.
ddof : int, optional
    Means Delta Degrees of Freedom.  The divisor used in calculations
    is ``N - ddof``, where ``N`` represents the number of non-NaN
    elements.  By default `ddof` is zero.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If this value is anything but the default it is passed through
    as-is to the relevant functions of the sub-classes.  If these
    functions do not have a `keepdims` kwarg, a RuntimeError will
    be raised.

Returns
-------
standard_deviation : ndarray, see dtype parameter above.
    If `out` is None, return a new array containing the standard
    deviation, otherwise return a reference to the output array. If
    ddof is >= the number of non-NaN elements in a slice or the slice
    contains only NaNs, then the result for that slice is NaN.

See Also
--------
var, mean, std
nanvar, nanmean
ufuncs-output-type

Notes
-----
The standard deviation is the square root of the average of the squared
deviations from the mean: ``std = sqrt(mean(abs(x - x.mean())**2))``.

The average squared deviation is normally calculated as
``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is
specified, the divisor ``N - ddof`` is used instead. In standard
statistical practice, ``ddof=1`` provides an unbiased estimator of the
variance of the infinite population. ``ddof=0`` provides a maximum
likelihood estimate of the variance for normally distributed variables.
The standard deviation computed in this function is the square root of
the estimated variance, so even with ``ddof=1``, it will not be an
unbiased estimate of the standard deviation per se.

Note that, for complex numbers, `std` takes the absolute value before
squaring, so that the result is always real and nonnegative.

For floating-point input, the *std* is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example
below).  Specifying a higher-accuracy accumulator using the `dtype`
keyword can alleviate this issue.

Examples
--------
>>> a = np.array([[1, np.nan], [3, 4]])
>>> np.nanstd(a)
1.247219128924647
>>> np.nanstd(a, axis=0)
array([1., 0.])
>>> np.nanstd(a, axis=1)
array([0.,  0.5]) # may vary
*)

val nansum : ?axis:[`I of int | `Tuple_of_int of Py.Object.t] -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.

In NumPy versions <= 1.9.0 Nan is returned for slices that are all-NaN or
empty. In later versions zero is returned.

Parameters
----------
a : array_like
    Array containing numbers whose sum is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the sum is computed. The default is to compute the
    sum of the flattened array.
dtype : data-type, optional
    The type of the returned array and of the accumulator in which the
    elements are summed.  By default, the dtype of `a` is used.  An
    exception is when `a` has an integer type with less precision than
    the platform (u)intp. In that case, the default will be either
    (u)int32 or (u)int64 depending on whether the platform is 32 or 64
    bits. For inexact inputs, dtype must be inexact.

    .. versionadded:: 1.8.0
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``. If provided, it must have the same shape as the
    expected output, but the type will be cast if necessary.  See
    `ufuncs-output-type` for more details. The casting of NaN to integer
    can yield unexpected results.

    .. versionadded:: 1.8.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.


    If the value is anything but the default, then
    `keepdims` will be passed through to the `mean` or `sum` methods
    of sub-classes of `ndarray`.  If the sub-classes methods
    does not implement `keepdims` any exceptions will be raised.

    .. versionadded:: 1.8.0

Returns
-------
nansum : ndarray.
    A new array holding the result is returned unless `out` is
    specified, in which it is returned. The result has the same
    size as `a`, and the same shape as `a` if `axis` is not None
    or `a` is a 1-d array.

See Also
--------
numpy.sum : Sum across array propagating NaNs.
isnan : Show which elements are NaN.
isfinite: Show which elements are not NaN or +/-inf.

Notes
-----
If both positive and negative infinity are present, the sum will be Not
A Number (NaN).

Examples
--------
>>> np.nansum(1)
1
>>> np.nansum([1])
1
>>> np.nansum([1, np.nan])
1.0
>>> a = np.array([[1, 1], [1, np.nan]])
>>> np.nansum(a)
3.0
>>> np.nansum(a, axis=0)
array([2.,  1.])
>>> np.nansum([1, np.nan, np.inf])
inf
>>> np.nansum([1, np.nan, np.NINF])
-inf
>>> from numpy.testing import suppress_warnings
>>> with suppress_warnings() as sup:
...     sup.filter(RuntimeWarning)
...     np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present
nan
*)

val nanvar : ?axis:[`I of int | `Tuple_of_int of Py.Object.t] -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?ddof:int -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the variance along the specified axis, while ignoring NaNs.

Returns the variance of the array elements, a measure of the spread of
a distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.

For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a `RuntimeWarning` is raised.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array containing numbers whose variance is desired.  If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the variance is computed.  The default is to compute
    the variance of the flattened array.
dtype : data-type, optional
    Type to use in computing the variance.  For arrays of integer type
    the default is `float64`; for arrays of float types it is the same as
    the array type.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output, but the type is cast if
    necessary.
ddof : int, optional
    'Delta Degrees of Freedom': the divisor used in the calculation is
    ``N - ddof``, where ``N`` represents the number of non-NaN
    elements. By default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.


Returns
-------
variance : ndarray, see dtype parameter above
    If `out` is None, return a new array containing the variance,
    otherwise return a reference to the output array. If ddof is >= the
    number of non-NaN elements in a slice or the slice contains only
    NaNs, then the result for that slice is NaN.

See Also
--------
std : Standard deviation
mean : Average
var : Variance while not ignoring NaNs
nanstd, nanmean
ufuncs-output-type

Notes
-----
The variance is the average of the squared deviations from the mean,
i.e.,  ``var = mean(abs(x - x.mean())**2)``.

The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
If, however, `ddof` is specified, the divisor ``N - ddof`` is used
instead.  In standard statistical practice, ``ddof=1`` provides an
unbiased estimator of the variance of a hypothetical infinite
population.  ``ddof=0`` provides a maximum likelihood estimate of the
variance for normally distributed variables.

Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.

For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32` (see example
below).  Specifying a higher-accuracy accumulator using the ``dtype``
keyword can alleviate this issue.

For this function to work on sub-classes of ndarray, they must define
`sum` with the kwarg `keepdims`

Examples
--------
>>> a = np.array([[1, np.nan], [3, 4]])
>>> np.nanvar(a)
1.5555555555555554
>>> np.nanvar(a, axis=0)
array([1.,  0.])
>>> np.nanvar(a, axis=1)
array([0.,  0.25])  # may vary
*)

val ndfromtxt : ?kwargs:(string * Py.Object.t) list -> fname:Py.Object.t -> unit -> Py.Object.t
(**
Load ASCII data stored in a file and return it as a single array.

.. deprecated:: 1.17
    ndfromtxt` is a deprecated alias of `genfromtxt` which
    overwrites the ``usemask`` argument with `False` even when
    explicitly called as ``ndfromtxt(..., usemask=True)``.
    Use `genfromtxt` instead.

Parameters
----------
fname, kwargs : For a description of input parameters, see `genfromtxt`.

See Also
--------
numpy.genfromtxt : generic function.
*)

val ndim : [>`Ndarray] Obj.t -> int
(**
Return the number of dimensions of an array.

Parameters
----------
a : array_like
    Input array.  If it is not already an ndarray, a conversion is
    attempted.

Returns
-------
number_of_dimensions : int
    The number of dimensions in `a`.  Scalars are zero-dimensional.

See Also
--------
ndarray.ndim : equivalent method
shape : dimensions of array
ndarray.shape : dimensions of array

Examples
--------
>>> np.ndim([[1,2,3],[4,5,6]])
2
>>> np.ndim(np.array([[1,2,3],[4,5,6]]))
2
>>> np.ndim(1)
0
*)

val negative : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Numerical negative, element-wise.

Parameters
----------
x : array_like or scalar
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    Returned array or scalar: `y = -x`.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> np.negative([1.,-1.])
array([-1.,  1.])
*)

val nextafter : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
nextafter(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the next floating-point value after x1 towards x2, element-wise.

Parameters
----------
x1 : array_like
    Values to find the next representable value of.
x2 : array_like
    The direction where to look for the next representable value of `x1`.
    If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    The next representable values of `x1` in the direction of `x2`.
    This is a scalar if both `x1` and `x2` are scalars.

Examples
--------
>>> eps = np.finfo(np.float64).eps
>>> np.nextafter(1, 2) == eps + 1
True
>>> np.nextafter([1, 2], [2, 1]) == [eps + 1, 2 - eps]
array([ True,  True])
*)

val nonzero : [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the indices of the elements that are non-zero.

Returns a tuple of arrays, one for each dimension of `a`,
containing the indices of the non-zero elements in that
dimension. The values in `a` are always tested and returned in
row-major, C-style order.

To group the indices by element, rather than dimension, use `argwhere`,
which returns a row for each non-zero element.

.. note::

   When called on a zero-d array or scalar, ``nonzero(a)`` is treated
   as ``nonzero(atleast1d(a))``.

   .. deprecated:: 1.17.0

      Use `atleast1d` explicitly if this behavior is deliberate.

Parameters
----------
a : array_like
    Input array.

Returns
-------
tuple_of_arrays : tuple
    Indices of elements that are non-zero.

See Also
--------
flatnonzero :
    Return indices that are non-zero in the flattened version of the input
    array.
ndarray.nonzero :
    Equivalent ndarray method.
count_nonzero :
    Counts the number of non-zero elements in the input array.

Notes
-----
While the nonzero values can be obtained with ``a[nonzero(a)]``, it is
recommended to use ``x[x.astype(bool)]`` or ``x[x != 0]`` instead, which
will correctly handle 0-d arrays.

Examples
--------
>>> x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])
>>> x
array([[3, 0, 0],
       [0, 4, 0],
       [5, 6, 0]])
>>> np.nonzero(x)
(array([0, 1, 2, 2]), array([0, 1, 0, 1]))

>>> x[np.nonzero(x)]
array([3, 4, 5, 6])
>>> np.transpose(np.nonzero(x))
array([[0, 0],
       [1, 1],
       [2, 0],
       [2, 1]])

A common use for ``nonzero`` is to find the indices of an array, where
a condition is True.  Given an array `a`, the condition `a` > 3 is a
boolean array and since False is interpreted as 0, np.nonzero(a > 3)
yields the indices of the `a` where the condition is true.

>>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> a > 3
array([[False, False, False],
       [ True,  True,  True],
       [ True,  True,  True]])
>>> np.nonzero(a > 3)
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))

Using this result to index `a` is equivalent to using the mask directly:

>>> a[np.nonzero(a > 3)]
array([4, 5, 6, 7, 8, 9])
>>> a[a > 3]  # prefer this spelling
array([4, 5, 6, 7, 8, 9])

``nonzero`` can also be called as a method of the array.

>>> (a > 3).nonzero()
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
*)

val not_equal : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return (x1 != x2) element-wise.

Parameters
----------
x1, x2 : array_like
    Input arrays.  If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array, element-wise comparison of `x1` and `x2`.
    Typically of type bool, unless ``dtype=object`` is passed.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
equal, greater, greater_equal, less, less_equal

Examples
--------
>>> np.not_equal([1.,2.], [1., 3.])
array([False,  True])
>>> np.not_equal([1, 2], [[1, 3],[1, 4]])
array([[False,  True],
       [False,  True]])
*)

val nper : ?fv:[>`Ndarray] Obj.t -> ?when_:[`Begin | `I of int | `PyObject of Py.Object.t] -> rate:[>`Ndarray] Obj.t -> pmt:[>`Ndarray] Obj.t -> pv:[>`Ndarray] Obj.t -> unit -> Py.Object.t
(**
Compute the number of periodic payments.

.. deprecated:: 1.18

   `nper` is deprecated; for details, see NEP 32 [1]_.
   Use the corresponding function in the numpy-financial library,
   https://pypi.org/project/numpy-financial.

:class:`decimal.Decimal` type is not supported.

Parameters
----------
rate : array_like
    Rate of interest (per period)
pmt : array_like
    Payment
pv : array_like
    Present value
fv : array_like, optional
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0))

Notes
-----
The number of periods ``nper`` is computed by solving the equation::

 fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate*((1+rate)**nper-1) = 0

but if ``rate = 0`` then::

 fv + pv + pmt*nper = 0

References
----------
.. [1] NumPy Enhancement Proposal (NEP) 32,
   https://numpy.org/neps/nep-0032-remove-financial-functions.html

Examples
--------
If you only had $150/month to pay towards the loan, how long would it take
to pay-off a loan of $8,000 at 7% annual interest?

>>> print(np.round(np.nper(0.07/12, -150, 8000), 5))
64.07335

So, over 64 months would be required to pay off the loan.

The same analysis could be done with several different interest rates
and/or payments and/or total amounts to produce an entire table.

>>> np.nper( *(np.ogrid[0.07/12: 0.08/12: 0.01/12,
...                    -150   : -99     : 50    ,
...                    8000   : 9001    : 1000]))
array([[[ 64.07334877,  74.06368256],
        [108.07548412, 127.99022654]],
       [[ 66.12443902,  76.87897353],
        [114.70165583, 137.90124779]]])
*)

val npv : rate:[`F of float | `I of int | `Bool of bool | `S of string] -> values:[>`Ndarray] Obj.t -> unit -> float
(**
Returns the NPV (Net Present Value) of a cash flow series.

.. deprecated:: 1.18

   `npv` is deprecated; for details, see NEP 32 [1]_.
   Use the corresponding function in the numpy-financial library,
   https://pypi.org/project/numpy-financial.

Parameters
----------
rate : scalar
    The discount rate.
values : array_like, shape(M, )
    The values of the time series of cash flows.  The (fixed) time
    interval between cash flow 'events' must be the same as that for
    which `rate` is given (i.e., if `rate` is per year, then precisely
    a year is understood to elapse between each cash flow event).  By
    convention, investments or 'deposits' are negative, income or
    'withdrawals' are positive; `values` must begin with the initial
    investment, thus `values[0]` will typically be negative.

Returns
-------
out : float
    The NPV of the input cash flow series `values` at the discount
    `rate`.

Warnings
--------
``npv`` considers a series of cashflows starting in the present (t = 0).
NPV can also be defined with a series of future cashflows, paid at the
end, rather than the start, of each period. If future cashflows are used,
the first cashflow `values[0]` must be zeroed and added to the net
present value of the future cashflows. This is demonstrated in the
examples.

Notes
-----
Returns the result of: [2]_

.. math :: \sum_{t=0}^{M-1}{\frac{values_t}{(1+rate)^{t}}}

References
----------
.. [1] NumPy Enhancement Proposal (NEP) 32,
   https://numpy.org/neps/nep-0032-remove-financial-functions.html
.. [2] L. J. Gitman, 'Principles of Managerial Finance, Brief,' 3rd ed.,
   Addison-Wesley, 2003, pg. 346.

Examples
--------
Consider a potential project with an initial investment of $40 000 and
projected cashflows of $5 000, $8 000, $12 000 and $30 000 at the end of
each period discounted at a rate of 8% per period. To find the project's
net present value:

>>> rate, cashflows = 0.08, [-40_000, 5_000, 8_000, 12_000, 30_000]
>>> np.npv(rate, cashflows).round(5)
3065.22267

It may be preferable to split the projected cashflow into an initial
investment and expected future cashflows. In this case, the value of
the initial cashflow is zero and the initial investment is later added
to the future cashflows net present value:

>>> initial_cashflow = cashflows[0]
>>> cashflows[0] = 0
>>> np.round(np.npv(rate, cashflows) + initial_cashflow, 5)
3065.22267
*)

val obj2sctype : ?default:Py.Object.t -> rep:Py.Object.t -> unit -> Py.Object.t
(**
Return the scalar dtype or NumPy equivalent of Python type of an object.

Parameters
----------
rep : any
    The object of which the type is returned.
default : any, optional
    If given, this is returned for objects whose types can not be
    determined. If not given, None is returned for those objects.

Returns
-------
dtype : dtype or Python type
    The data type of `rep`.

See Also
--------
sctype2char, issctype, issubsctype, issubdtype, maximum_sctype

Examples
--------
>>> np.obj2sctype(np.int32)
<class 'numpy.int32'>
>>> np.obj2sctype(np.array([1., 2.]))
<class 'numpy.float64'>
>>> np.obj2sctype(np.array([1.j]))
<class 'numpy.complex128'>

>>> np.obj2sctype(dict)
<class 'numpy.object_'>
>>> np.obj2sctype('string')

>>> np.obj2sctype(1, default=list)
<class 'list'>
*)

val ones : ?dtype:Dtype.t -> ?order:[`C | `F] -> int list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a new array of given shape and type, filled with ones.

Parameters
----------
shape : int or sequence of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: C
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of ones with the given shape, dtype, and order.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
empty : Return a new uninitialized array.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Examples
--------
>>> np.ones(5)
array([1., 1., 1., 1., 1.])

>>> np.ones((5,), dtype=int)
array([1, 1, 1, 1, 1])

>>> np.ones((2, 1))
array([[1.],
       [1.]])

>>> s = (2,2)
>>> np.ones(s)
array([[1.,  1.],
       [1.,  1.]])
*)

val ones_like : ?dtype:Dtype.t -> ?order:[`F | `A | `PyObject of Py.Object.t] -> ?subok:bool -> ?shape:int list -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an array of ones with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of 'a', otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of ones with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
ones : Return a new array setting values to one.

Examples
--------
>>> x = np.arange(6)
>>> x = x.reshape((2, 3))
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.ones_like(x)
array([[1, 1, 1],
       [1, 1, 1]])

>>> y = np.arange(3, dtype=float)
>>> y
array([0., 1., 2.])
>>> np.ones_like(y)
array([1.,  1.,  1.])
*)

val outer : ?out:[>`Ndarray] Obj.t -> b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the outer product of two vectors.

Given two vectors, ``a = [a0, a1, ..., aM]`` and
``b = [b0, b1, ..., bN]``,
the outer product [1]_ is::

  [[a0*b0  a0*b1 ... a0*bN ]
   [a1*b0    .
   [ ...          .
   [aM*b0            aM*bN ]]

Parameters
----------
a : (M,) array_like
    First input vector.  Input is flattened if
    not already 1-dimensional.
b : (N,) array_like
    Second input vector.  Input is flattened if
    not already 1-dimensional.
out : (M, N) ndarray, optional
    A location where the result is stored

    .. versionadded:: 1.9.0

Returns
-------
out : (M, N) ndarray
    ``out[i, j] = a[i] * b[j]``

See also
--------
inner
einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.
ufunc.outer : A generalization to N dimensions and other operations.
              ``np.multiply.outer(a.ravel(), b.ravel())`` is the equivalent.

References
----------
.. [1] : G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd
         ed., Baltimore, MD, Johns Hopkins University Press, 1996,
         pg. 8.

Examples
--------
Make a ( *very* coarse) grid for computing a Mandelbrot set:

>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
>>> rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
>>> im
array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
>>> grid = rl + im
>>> grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])

An example using a 'vector' of letters:

>>> x = np.array(['a', 'b', 'c'], dtype=object)
>>> np.outer(x, [1, 2, 3])
array([['a', 'aa', 'aaa'],
       ['b', 'bb', 'bbb'],
       ['c', 'cc', 'ccc']], dtype=object)
*)

val packbits : ?axis:int -> ?bitorder:[`Big | `Little] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
packbits(a, axis=None, bitorder='big')

Packs the elements of a binary-valued array into bits in a uint8 array.

The result is padded to full bytes by inserting zero bits at the end.

Parameters
----------
a : array_like
    An array of integers or booleans whose elements should be packed to
    bits.
axis : int, optional
    The dimension over which bit-packing is done.
    ``None`` implies packing the flattened array.
bitorder : {'big', 'little'}, optional
    The order of the input bits. 'big' will mimic bin(val),
    ``[0, 0, 0, 0, 0, 0, 1, 1] => 3 = 0b00000011 => ``, 'little' will
    reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] => 3``.
    Defaults to 'big'.

    .. versionadded:: 1.17.0

Returns
-------
packed : ndarray
    Array of type uint8 whose elements represent bits corresponding to the
    logical (0 or nonzero) value of the input elements. The shape of
    `packed` has the same number of dimensions as the input (unless `axis`
    is None, in which case the output is 1-D).

See Also
--------
unpackbits: Unpacks elements of a uint8 array into a binary-valued output
            array.

Examples
--------
>>> a = np.array([[[1,0,1],
...                [0,1,0]],
...               [[1,1,0],
...                [0,0,1]]])
>>> b = np.packbits(a, axis=-1)
>>> b
array([[[160],
        [ 64]],
       [[192],
        [ 32]]], dtype=uint8)

Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,
and 32 = 0010 0000.
*)

val pad : ?mode:[`Callable of Py.Object.t | `S of string] -> ?kwargs:(string * Py.Object.t) list -> array:Py.Object.t -> pad_width:[`Sequence of Py.Object.t | `I of int | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Pad an array.

Parameters
----------
array : array_like of rank N
    The array to pad.
pad_width : {sequence, array_like, int}
    Number of values padded to the edges of each axis.
    ((before_1, after_1), ... (before_N, after_N)) unique pad widths
    for each axis.
    ((before, after),) yields same before and after pad for each axis.
    (pad,) or int is a shortcut for before = after = pad width for all
    axes.
mode : str or function, optional
    One of the following string values or a user supplied function.

    'constant' (default)
        Pads with a constant value.
    'edge'
        Pads with the edge values of array.
    'linear_ramp'
        Pads with the linear ramp between end_value and the
        array edge value.
    'maximum'
        Pads with the maximum value of all or part of the
        vector along each axis.
    'mean'
        Pads with the mean value of all or part of the
        vector along each axis.
    'median'
        Pads with the median value of all or part of the
        vector along each axis.
    'minimum'
        Pads with the minimum value of all or part of the
        vector along each axis.
    'reflect'
        Pads with the reflection of the vector mirrored on
        the first and last values of the vector along each
        axis.
    'symmetric'
        Pads with the reflection of the vector mirrored
        along the edge of the array.
    'wrap'
        Pads with the wrap of the vector along the axis.
        The first values are used to pad the end and the
        end values are used to pad the beginning.
    'empty'
        Pads with undefined values.

        .. versionadded:: 1.17

    <function>
        Padding function, see Notes.
stat_length : sequence or int, optional
    Used in 'maximum', 'mean', 'median', and 'minimum'.  Number of
    values at edge of each axis used to calculate the statistic value.

    ((before_1, after_1), ... (before_N, after_N)) unique statistic
    lengths for each axis.

    ((before, after),) yields same before and after statistic lengths
    for each axis.

    (stat_length,) or int is a shortcut for before = after = statistic
    length for all axes.

    Default is ``None``, to use the entire axis.
constant_values : sequence or scalar, optional
    Used in 'constant'.  The values to set the padded values for each
    axis.

    ``((before_1, after_1), ... (before_N, after_N))`` unique pad constants
    for each axis.

    ``((before, after),)`` yields same before and after constants for each
    axis.

    ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for
    all axes.

    Default is 0.
end_values : sequence or scalar, optional
    Used in 'linear_ramp'.  The values used for the ending value of the
    linear_ramp and that will form the edge of the padded array.

    ``((before_1, after_1), ... (before_N, after_N))`` unique end values
    for each axis.

    ``((before, after),)`` yields same before and after end values for each
    axis.

    ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for
    all axes.

    Default is 0.
reflect_type : {'even', 'odd'}, optional
    Used in 'reflect', and 'symmetric'.  The 'even' style is the
    default with an unaltered reflection around the edge value.  For
    the 'odd' style, the extended part of the array is created by
    subtracting the reflected values from two times the edge value.

Returns
-------
pad : ndarray
    Padded array of rank equal to `array` with shape increased
    according to `pad_width`.

Notes
-----
.. versionadded:: 1.7.0

For an array with rank greater than 1, some of the padding of later
axes is calculated from padding of previous axes.  This is easiest to
think about with a rank 2 array where the corners of the padded array
are calculated by using padded values from the first axis.

The padding function, if used, should modify a rank 1 array in-place. It
has the following signature::

    padding_func(vector, iaxis_pad_width, iaxis, kwargs)

where

    vector : ndarray
        A rank 1 array already padded with zeros.  Padded values are
        vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].
    iaxis_pad_width : tuple
        A 2-tuple of ints, iaxis_pad_width[0] represents the number of
        values padded at the beginning of vector where
        iaxis_pad_width[1] represents the number of values padded at
        the end of vector.
    iaxis : int
        The axis currently being calculated.
    kwargs : dict
        Any keyword arguments the function requires.

Examples
--------
>>> a = [1, 2, 3, 4, 5]
>>> np.pad(a, (2, 3), 'constant', constant_values=(4, 6))
array([4, 4, 1, ..., 6, 6, 6])

>>> np.pad(a, (2, 3), 'edge')
array([1, 1, 1, ..., 5, 5, 5])

>>> np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4))
array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])

>>> np.pad(a, (2,), 'maximum')
array([5, 5, 1, 2, 3, 4, 5, 5, 5])

>>> np.pad(a, (2,), 'mean')
array([3, 3, 1, 2, 3, 4, 5, 3, 3])

>>> np.pad(a, (2,), 'median')
array([3, 3, 1, 2, 3, 4, 5, 3, 3])

>>> a = [[1, 2], [3, 4]]
>>> np.pad(a, ((3, 2), (2, 3)), 'minimum')
array([[1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [3, 3, 3, 4, 3, 3, 3],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1]])

>>> a = [1, 2, 3, 4, 5]
>>> np.pad(a, (2, 3), 'reflect')
array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])

>>> np.pad(a, (2, 3), 'reflect', reflect_type='odd')
array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])

>>> np.pad(a, (2, 3), 'symmetric')
array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])

>>> np.pad(a, (2, 3), 'symmetric', reflect_type='odd')
array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])

>>> np.pad(a, (2, 3), 'wrap')
array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])

>>> def pad_with(vector, pad_width, iaxis, kwargs):
...     pad_value = kwargs.get('padder', 10)
...     vector[:pad_width[0]] = pad_value
...     vector[-pad_width[1]:] = pad_value
>>> a = np.arange(6)
>>> a = a.reshape((2, 3))
>>> np.pad(a, 2, pad_with)
array([[10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10,  0,  1,  2, 10, 10],
       [10, 10,  3,  4,  5, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10]])
>>> np.pad(a, 2, pad_with, padder=100)
array([[100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100,   0,   1,   2, 100, 100],
       [100, 100,   3,   4,   5, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100]])
*)

val partition : ?axis:[`I of int | `None] -> ?kind:[`Introselect] -> ?order:[`StringList of string list | `S of string] -> kth:[`Is of int list | `I of int] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a partitioned copy of an array.

Creates a copy of the array with its elements rearranged in such a
way that the value of the element in k-th position is in the
position it would be in a sorted array. All elements smaller than
the k-th element are moved before this element and all equal or
greater are moved behind it. The ordering of the elements in the two
partitions is undefined.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array to be sorted.
kth : int or sequence of ints
    Element index to partition by. The k-th value of the element
    will be in its final sorted position and all smaller elements
    will be moved before it and all equal or greater elements behind
    it. The order of all elements in the partitions is undefined. If
    provided with a sequence of k-th it will partition all elements
    indexed by k-th  of them into their sorted position at once.
axis : int or None, optional
    Axis along which to sort. If None, the array is flattened before
    sorting. The default is -1, which sorts along the last axis.
kind : {'introselect'}, optional
    Selection algorithm. Default is 'introselect'.
order : str or list of str, optional
    When `a` is an array with fields defined, this argument
    specifies which fields to compare first, second, etc.  A single
    field can be specified as a string.  Not all fields need be
    specified, but unspecified fields will still be used, in the
    order in which they come up in the dtype, to break ties.

Returns
-------
partitioned_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
ndarray.partition : Method to sort an array in-place.
argpartition : Indirect partition.
sort : Full sorting

Notes
-----
The various selection algorithms are characterized by their average
speed, worst case performance, work space size, and whether they are
stable. A stable sort keeps items with the same key in the same
relative order. The available algorithms have the following
properties:

================= ======= ============= ============ =======
   kind            speed   worst case    work space  stable
================= ======= ============= ============ =======
'introselect'        1        O(n)           0         no
================= ======= ============= ============ =======

All the partition algorithms make temporary copies of the data when
partitioning along any but the last axis.  Consequently,
partitioning along the last axis is faster and uses less space than
partitioning along any other axis.

The sort order for complex numbers is lexicographic. If both the
real and imaginary parts are non-nan then the order is determined by
the real parts except when they are equal, in which case the order
is determined by the imaginary parts.

Examples
--------
>>> a = np.array([3, 4, 2, 1])
>>> np.partition(a, 3)
array([2, 1, 3, 4])

>>> np.partition(a, (1, 3))
array([1, 2, 3, 4])
*)

val percentile : ?axis:[`I of int | `Tuple_of_int of Py.Object.t] -> ?out:[>`Ndarray] Obj.t -> ?overwrite_input:bool -> ?interpolation:[`Linear | `Lower | `Higher | `Midpoint | `Nearest] -> ?keepdims:bool -> q:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the q-th percentile of the data along the specified axis.

Returns the q-th percentile(s) of the array elements.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
q : array_like of float
    Percentile or sequence of percentiles to compute, which must be between
    0 and 100 inclusive.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the percentiles are computed. The
    default is to compute the percentile(s) along a flattened
    version of the array.

    .. versionchanged:: 1.9.0
        A tuple of axes is supported
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow the input array `a` to be modified by intermediate
    calculations, to save memory. In this case, the contents of the input
    `a` after this function completes is undefined.

interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
    This optional parameter specifies the interpolation method to
    use when the desired percentile lies between two data points
    ``i < j``:

    * 'linear': ``i + (j - i) * fraction``, where ``fraction``
      is the fractional part of the index surrounded by ``i``
      and ``j``.
    * 'lower': ``i``.
    * 'higher': ``j``.
    * 'nearest': ``i`` or ``j``, whichever is nearest.
    * 'midpoint': ``(i + j) / 2``.

    .. versionadded:: 1.9.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in
    the result as dimensions with size one. With this option, the
    result will broadcast correctly against the original array `a`.

    .. versionadded:: 1.9.0

Returns
-------
percentile : scalar or ndarray
    If `q` is a single percentile and `axis=None`, then the result
    is a scalar. If multiple percentiles are given, first axis of
    the result corresponds to the percentiles. The other axes are
    the axes that remain after the reduction of `a`. If the input
    contains integers or floats smaller than ``float64``, the output
    data-type is ``float64``. Otherwise, the output data-type is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
mean
median : equivalent to ``percentile(..., 50)``
nanpercentile
quantile : equivalent to percentile, except with q in the range [0, 1].

Notes
-----
Given a vector ``V`` of length ``N``, the q-th percentile of
``V`` is the value ``q/100`` of the way from the minimum to the
maximum in a sorted copy of ``V``. The values and distances of
the two nearest neighbors as well as the `interpolation` parameter
will determine the percentile if the normalized ranking does not
match the location of ``q`` exactly. This function is the same as
the median if ``q=50``, the same as the minimum if ``q=0`` and the
same as the maximum if ``q=100``.

Examples
--------
>>> a = np.array([[10, 7, 4], [3, 2, 1]])
>>> a
array([[10,  7,  4],
       [ 3,  2,  1]])
>>> np.percentile(a, 50)
3.5
>>> np.percentile(a, 50, axis=0)
array([6.5, 4.5, 2.5])
>>> np.percentile(a, 50, axis=1)
array([7.,  2.])
>>> np.percentile(a, 50, axis=1, keepdims=True)
array([[7.],
       [2.]])

>>> m = np.percentile(a, 50, axis=0)
>>> out = np.zeros_like(m)
>>> np.percentile(a, 50, axis=0, out=out)
array([6.5, 4.5, 2.5])
>>> m
array([6.5, 4.5, 2.5])

>>> b = a.copy()
>>> np.percentile(b, 50, axis=1, overwrite_input=True)
array([7.,  2.])
>>> assert not np.all(a == b)

The different types of interpolation can be visualized graphically:

.. plot::

    import matplotlib.pyplot as plt

    a = np.arange(4)
    p = np.linspace(0, 100, 6001)
    ax = plt.gca()
    lines = [
        ('linear', None),
        ('higher', '--'),
        ('lower', '--'),
        ('nearest', '-.'),
        ('midpoint', '-.'),
    ]
    for interpolation, style in lines:
        ax.plot(
            p, np.percentile(a, p, interpolation=interpolation),
            label=interpolation, linestyle=style)
    ax.set(
        title='Interpolation methods for list: ' + str(a),
        xlabel='Percentile',
        ylabel='List item returned',
        yticks=a)
    ax.legend()
    plt.show()
*)

val piecewise : ?kw:(string * Py.Object.t) list -> condlist:Py.Object.t -> funclist:Py.Object.t -> [>`Ndarray] Obj.t -> Py.Object.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Evaluate a piecewise-defined function.

Given a set of conditions and corresponding functions, evaluate each
function on the input data wherever its condition is true.

Parameters
----------
x : ndarray or scalar
    The input domain.
condlist : list of bool arrays or bool scalars
    Each boolean array corresponds to a function in `funclist`.  Wherever
    `condlist[i]` is True, `funclist[i](x)` is used as the output value.

    Each boolean array in `condlist` selects a piece of `x`,
    and should therefore be of the same shape as `x`.

    The length of `condlist` must correspond to that of `funclist`.
    If one extra function is given, i.e. if
    ``len(funclist) == len(condlist) + 1``, then that extra function
    is the default value, used wherever all conditions are false.
funclist : list of callables, f(x,*args,**kw), or scalars
    Each function is evaluated over `x` wherever its corresponding
    condition is True.  It should take a 1d array as input and give an 1d
    array or a scalar value as output.  If, instead of a callable,
    a scalar is provided then a constant function (``lambda x: scalar``) is
    assumed.
args : tuple, optional
    Any further arguments given to `piecewise` are passed to the functions
    upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then
    each function is called as ``f(x, 1, 'a')``.
kw : dict, optional
    Keyword arguments used in calling `piecewise` are passed to the
    functions upon execution, i.e., if called
    ``piecewise(..., ..., alpha=1)``, then each function is called as
    ``f(x, alpha=1)``.

Returns
-------
out : ndarray
    The output is the same shape and type as x and is found by
    calling the functions in `funclist` on the appropriate portions of `x`,
    as defined by the boolean arrays in `condlist`.  Portions not covered
    by any condition have a default value of 0.


See Also
--------
choose, select, where

Notes
-----
This is similar to choose or select, except that functions are
evaluated on elements of `x` that satisfy the corresponding condition from
`condlist`.

The result is::

        |--
        |funclist[0](x[condlist[0]])
  out = |funclist[1](x[condlist[1]])
        |...
        |funclist[n2](x[condlist[n2]])
        |--

Examples
--------
Define the sigma function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.

>>> x = np.linspace(-2.5, 2.5, 6)
>>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])
array([-1., -1., -1.,  1.,  1.,  1.])

Define the absolute value, which is ``-x`` for ``x <0`` and ``x`` for
``x >= 0``.

>>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])
array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])

Apply the same function to a scalar value.

>>> y = -2
>>> np.piecewise(y, [y < 0, y >= 0], [lambda x: -x, lambda x: x])
array(2)
*)

val place : arr:[>`Ndarray] Obj.t -> mask:[>`Ndarray] Obj.t -> vals:Py.Object.t -> unit -> Py.Object.t
(**
Change elements of an array based on conditional and input values.

Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that
`place` uses the first N elements of `vals`, where N is the number of
True values in `mask`, while `copyto` uses the elements where `mask`
is True.

Note that `extract` does the exact opposite of `place`.

Parameters
----------
arr : ndarray
    Array to put data into.
mask : array_like
    Boolean mask array. Must have the same size as `a`.
vals : 1-D sequence
    Values to put into `a`. Only the first N elements are used, where
    N is the number of True values in `mask`. If `vals` is smaller
    than N, it will be repeated, and if elements of `a` are to be masked,
    this sequence must be non-empty.

See Also
--------
copyto, put, take, extract

Examples
--------
>>> arr = np.arange(6).reshape(2, 3)
>>> np.place(arr, arr>2, [44, 55])
>>> arr
array([[ 0,  1,  2],
       [44, 55, 44]])
*)

val pmt : ?fv:[>`Ndarray] Obj.t -> ?when_:[`Begin | `I of int | `PyObject of Py.Object.t] -> rate:[>`Ndarray] Obj.t -> nper:[>`Ndarray] Obj.t -> pv:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the payment against loan principal plus interest.

.. deprecated:: 1.18

   `pmt` is deprecated; for details, see NEP 32 [1]_.
   Use the corresponding function in the numpy-financial library,
   https://pypi.org/project/numpy-financial.

Given:
 * a present value, `pv` (e.g., an amount borrowed)
 * a future value, `fv` (e.g., 0)
 * an interest `rate` compounded once per period, of which
   there are
 * `nper` total
 * and (optional) specification of whether payment is made
   at the beginning (`when` = {'begin', 1}) or the end
   (`when` = {'end', 0}) of each period

Return:
   the (fixed) periodic payment.

Parameters
----------
rate : array_like
    Rate of interest (per period)
nper : array_like
    Number of compounding periods
pv : array_like
    Present value
fv : array_like,  optional
    Future value (default = 0)
when : {{'begin', 1}, {'end', 0}}, {string, int}
    When payments are due ('begin' (1) or 'end' (0))

Returns
-------
out : ndarray
    Payment against loan plus interest.  If all input is scalar, returns a
    scalar float.  If any input is array_like, returns payment for each
    input element. If multiple inputs are array_like, they all must have
    the same shape.

Notes
-----
The payment is computed by solving the equation::

 fv +
 pv*(1 + rate)**nper +
 pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0

or, when ``rate == 0``::

  fv + pv + pmt * nper == 0

for ``pmt``.

Note that computing a monthly mortgage payment is only
one use for this function.  For example, pmt returns the
periodic deposit one must make to achieve a specified
future balance given an initial deposit, a fixed,
periodically compounded interest rate, and the total
number of periods.

References
----------
.. [1] NumPy Enhancement Proposal (NEP) 32,
   https://numpy.org/neps/nep-0032-remove-financial-functions.html
.. [2] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).
   Open Document Format for Office Applications (OpenDocument)v1.2,
   Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,
   Pre-Draft 12. Organization for the Advancement of Structured Information
   Standards (OASIS). Billerica, MA, USA. [ODT Document].
   Available:
   http://www.oasis-open.org/committees/documents.php
   ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt

Examples
--------
What is the monthly payment needed to pay off a $200,000 loan in 15
years at an annual interest rate of 7.5%?

>>> np.pmt(0.075/12, 12*15, 200000)
-1854.0247200054619

In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained
today, a monthly payment of $1,854.02 would be required.  Note that this
example illustrates usage of `fv` having a default value of 0.
*)

val poly : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Find the coefficients of a polynomial with the given sequence of roots.

Returns the coefficients of the polynomial whose leading coefficient
is one for the given sequence of zeros (multiple roots must be included
in the sequence as many times as their multiplicity; see Examples).
A square matrix (or array, which will be treated as a matrix) can also
be given, in which case the coefficients of the characteristic polynomial
of the matrix are returned.

Parameters
----------
seq_of_zeros : array_like, shape (N,) or (N, N)
    A sequence of polynomial roots, or a square array or matrix object.

Returns
-------
c : ndarray
    1D array of polynomial coefficients from highest to lowest degree:

    ``c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]``
    where c[0] always equals 1.

Raises
------
ValueError
    If input is the wrong shape (the input must be a 1-D or square
    2-D array).

See Also
--------
polyval : Compute polynomial values.
roots : Return the roots of a polynomial.
polyfit : Least squares polynomial fit.
poly1d : A one-dimensional polynomial class.

Notes
-----
Specifying the roots of a polynomial still leaves one degree of
freedom, typically represented by an undetermined leading
coefficient. [1]_ In the case of this function, that coefficient -
the first one in the returned array - is always taken as one. (If
for some reason you have one other point, the only automatic way
presently to leverage that information is to use ``polyfit``.)

The characteristic polynomial, :math:`p_a(t)`, of an `n`-by-`n`
matrix **A** is given by

    :math:`p_a(t) = \mathrm{det}(t\, \mathbf{I} - \mathbf{A})`,

where **I** is the `n`-by-`n` identity matrix. [2]_

References
----------
.. [1] M. Sullivan and M. Sullivan, III, 'Algebra and Trignometry,
   Enhanced With Graphing Utilities,' Prentice-Hall, pg. 318, 1996.

.. [2] G. Strang, 'Linear Algebra and Its Applications, 2nd Edition,'
   Academic Press, pg. 182, 1980.

Examples
--------
Given a sequence of a polynomial's zeros:

>>> np.poly((0, 0, 0)) # Multiple root example
array([1., 0., 0., 0.])

The line above represents z**3 + 0*z**2 + 0*z + 0.

>>> np.poly((-1./2, 0, 1./2))
array([ 1.  ,  0.  , -0.25,  0.  ])

The line above represents z**3 - z/4

>>> np.poly((np.random.random(1)[0], 0, np.random.random(1)[0]))
array([ 1.        , -0.77086955,  0.08618131,  0.        ]) # random

Given a square array object:

>>> P = np.array([[0, 1./3], [-1./2, 0]])
>>> np.poly(P)
array([1.        , 0.        , 0.16666667])

Note how in all cases the leading coefficient is always 1.
*)

val polyadd : a1:Py.Object.t -> a2:Py.Object.t -> unit -> Py.Object.t
(**
Find the sum of two polynomials.

Returns the polynomial resulting from the sum of two input polynomials.
Each input must be either a poly1d object or a 1D sequence of polynomial
coefficients, from highest to lowest degree.

Parameters
----------
a1, a2 : array_like or poly1d object
    Input polynomials.

Returns
-------
out : ndarray or poly1d object
    The sum of the inputs. If either input is a poly1d object, then the
    output is also a poly1d object. Otherwise, it is a 1D array of
    polynomial coefficients from highest to lowest degree.

See Also
--------
poly1d : A one-dimensional polynomial class.
poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval

Examples
--------
>>> np.polyadd([1, 2], [9, 5, 4])
array([9, 6, 6])

Using poly1d objects:

>>> p1 = np.poly1d([1, 2])
>>> p2 = np.poly1d([9, 5, 4])
>>> print(p1)
1 x + 2
>>> print(p2)
   2
9 x + 5 x + 4
>>> print(np.polyadd(p1, p2))
   2
9 x + 6 x + 6
*)

val polyder : ?m:int -> p:Py.Object.t -> unit -> Py.Object.t
(**
Return the derivative of the specified order of a polynomial.

Parameters
----------
p : poly1d or sequence
    Polynomial to differentiate.
    A sequence is interpreted as polynomial coefficients, see `poly1d`.
m : int, optional
    Order of differentiation (default: 1)

Returns
-------
der : poly1d
    A new polynomial representing the derivative.

See Also
--------
polyint : Anti-derivative of a polynomial.
poly1d : Class for one-dimensional polynomials.

Examples
--------
The derivative of the polynomial :math:`x^3 + x^2 + x^1 + 1` is:

>>> p = np.poly1d([1,1,1,1])
>>> p2 = np.polyder(p)
>>> p2
poly1d([3, 2, 1])

which evaluates to:

>>> p2(2.)
17.0

We can verify this, approximating the derivative with
``(f(x + h) - f(x))/h``:

>>> (p(2. + 0.001) - p(2.)) / 0.001
17.007000999997857

The fourth-order derivative of a 3rd-order polynomial is zero:

>>> np.polyder(p, 2)
poly1d([6, 2])
>>> np.polyder(p, 3)
poly1d([6])
>>> np.polyder(p, 4)
poly1d([0.])
*)

val polydiv : u:[`Poly1d of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> v:[`Poly1d of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> unit -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Returns the quotient and remainder of polynomial division.

The input arrays are the coefficients (including any coefficients
equal to zero) of the 'numerator' (dividend) and 'denominator'
(divisor) polynomials, respectively.

Parameters
----------
u : array_like or poly1d
    Dividend polynomial's coefficients.

v : array_like or poly1d
    Divisor polynomial's coefficients.

Returns
-------
q : ndarray
    Coefficients, including those equal to zero, of the quotient.
r : ndarray
    Coefficients, including those equal to zero, of the remainder.

See Also
--------
poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub
polyval

Notes
-----
Both `u` and `v` must be 0-d or 1-d (ndim = 0 or 1), but `u.ndim` need
not equal `v.ndim`. In other words, all four possible combinations -
``u.ndim = v.ndim = 0``, ``u.ndim = v.ndim = 1``,
``u.ndim = 1, v.ndim = 0``, and ``u.ndim = 0, v.ndim = 1`` - work.

Examples
--------
.. math:: \frac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25

>>> x = np.array([3.0, 5.0, 2.0])
>>> y = np.array([2.0, 1.0])
>>> np.polydiv(x, y)
(array([1.5 , 1.75]), array([0.25]))
*)

val polyfit : ?rcond:float -> ?full:bool -> ?w:[>`Ndarray] Obj.t -> ?cov:[`Bool of bool | `S of string] -> y:[>`Ndarray] Obj.t -> deg:int -> [>`Ndarray] Obj.t -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Least squares polynomial fit.

Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`
to points `(x, y)`. Returns a vector of coefficients `p` that minimises
the squared error in the order `deg`, `deg-1`, ... `0`.

The `Polynomial.fit <numpy.polynomial.polynomial.Polynomial.fit>` class
method is recommended for new code as it is more stable numerically. See
the documentation of the method for more information.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int
    Degree of the fitting polynomial
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (M,), optional
    Weights to apply to the y-coordinates of the sample points. For
    gaussian uncertainties, use 1/sigma (not 1/sigma**2).
cov : bool or str, optional
    If given and not `False`, return not just the estimate but also its
    covariance matrix. By default, the covariance are scaled by
    chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable
    except in a relative sense and everything is scaled such that the
    reduced chi2 is unity. This scaling is omitted if ``cov='unscaled'``,
    as is relevant for the case that the weights are 1/sigma**2, with
    sigma known to be a reliable estimate of the uncertainty.

Returns
-------
p : ndarray, shape (deg + 1,) or (deg + 1, K)
    Polynomial coefficients, highest power first.  If `y` was 2-D, the
    coefficients for `k`-th data set are in ``p[:,k]``.

residuals, rank, singular_values, rcond
    Present only if `full` = True.  Residuals is sum of squared residuals
    of the least-squares fit, the effective rank of the scaled Vandermonde
    coefficient matrix, its singular values, and the specified value of
    `rcond`. For more details, see `linalg.lstsq`.

V : ndarray, shape (M,M) or (M,M,K)
    Present only if `full` = False and `cov`=True.  The covariance
    matrix of the polynomial coefficient estimates.  The diagonal of
    this matrix are the variance estimates for each coefficient.  If y
    is a 2-D array, then the covariance matrix for the `k`-th data set
    are in ``V[:,:,k]``


Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.

    The warnings can be turned off by

    >>> import warnings
    >>> warnings.simplefilter('ignore', np.RankWarning)

See Also
--------
polyval : Compute polynomial values.
linalg.lstsq : Computes a least-squares fit.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution minimizes the squared error

.. math ::
    E = \sum_{j=0}^k |p(x_j) - y_j|^2

in the equations::

    x[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]
    x[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]
    ...
    x[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]

The coefficient matrix of the coefficients `p` is a Vandermonde matrix.

`polyfit` issues a `RankWarning` when the least-squares fit is badly
conditioned. This implies that the best fit is not well-defined due
to numerical error. The results may be improved by lowering the polynomial
degree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter
can also be set to a value smaller than its default, but the resulting
fit may be spurious: including contributions from the small singular
values can add numerical noise to the result.

Note that fitting polynomial coefficients is inherently badly conditioned
when the degree of the polynomial is large or the interval of sample points
is badly centered. The quality of the fit should always be checked in these
cases. When polynomial fits are not satisfactory, splines may be a good
alternative.

References
----------
.. [1] Wikipedia, 'Curve fitting',
       https://en.wikipedia.org/wiki/Curve_fitting
.. [2] Wikipedia, 'Polynomial interpolation',
       https://en.wikipedia.org/wiki/Polynomial_interpolation

Examples
--------
>>> import warnings
>>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])
>>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])
>>> z = np.polyfit(x, y, 3)
>>> z
array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary

It is convenient to use `poly1d` objects for dealing with polynomials:

>>> p = np.poly1d(z)
>>> p(0.5)
0.6143849206349179 # may vary
>>> p(3.5)
-0.34732142857143039 # may vary
>>> p(10)
22.579365079365115 # may vary

High-order polynomials may oscillate wildly:

>>> with warnings.catch_warnings():
...     warnings.simplefilter('ignore', np.RankWarning)
...     p30 = np.poly1d(np.polyfit(x, y, 30))
...
>>> p30(4)
-0.80000000000000204 # may vary
>>> p30(5)
-0.99999999999999445 # may vary
>>> p30(4.5)
-0.10547061179440398 # may vary

Illustration:

>>> import matplotlib.pyplot as plt
>>> xp = np.linspace(-2, 6, 100)
>>> _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')
>>> plt.ylim(-2,2)
(-2, 2)
>>> plt.show()
*)

val polyint : ?m:int -> ?k:[`I of int | `List_of_m_scalars of Py.Object.t | `Bool of bool | `F of float | `S of string] -> p:[`Poly1d of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> unit -> Py.Object.t
(**
Return an antiderivative (indefinite integral) of a polynomial.

The returned order `m` antiderivative `P` of polynomial `p` satisfies
:math:`\frac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1`
integration constants `k`. The constants determine the low-order
polynomial part

.. math:: \frac{k_{m-1}}{0!} x^0 + \ldots + \frac{k_0}{(m-1)!}x^{m-1}

of `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`.

Parameters
----------
p : array_like or poly1d
    Polynomial to integrate.
    A sequence is interpreted as polynomial coefficients, see `poly1d`.
m : int, optional
    Order of the antiderivative. (Default: 1)
k : list of `m` scalars or scalar, optional
    Integration constants. They are given in the order of integration:
    those corresponding to highest-order terms come first.

    If ``None`` (default), all constants are assumed to be zero.
    If `m = 1`, a single scalar can be given instead of a list.

See Also
--------
polyder : derivative of a polynomial
poly1d.integ : equivalent method

Examples
--------
The defining property of the antiderivative:

>>> p = np.poly1d([1,1,1])
>>> P = np.polyint(p)
>>> P
 poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ]) # may vary
>>> np.polyder(P) == p
True

The integration constants default to zero, but can be specified:

>>> P = np.polyint(p, 3)
>>> P(0)
0.0
>>> np.polyder(P)(0)
0.0
>>> np.polyder(P, 2)(0)
0.0
>>> P = np.polyint(p, 3, k=[6,5,3])
>>> P
poly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ]) # may vary

Note that 3 = 6 / 2!, and that the constants are given in the order of
integrations. Constant of the highest-order polynomial term comes first:

>>> np.polyder(P, 2)(0)
6.0
>>> np.polyder(P, 1)(0)
5.0
>>> P(0)
3.0
*)

val polymul : a1:Py.Object.t -> a2:Py.Object.t -> unit -> Py.Object.t
(**
Find the product of two polynomials.

Finds the polynomial resulting from the multiplication of the two input
polynomials. Each input must be either a poly1d object or a 1D sequence
of polynomial coefficients, from highest to lowest degree.

Parameters
----------
a1, a2 : array_like or poly1d object
    Input polynomials.

Returns
-------
out : ndarray or poly1d object
    The polynomial resulting from the multiplication of the inputs. If
    either inputs is a poly1d object, then the output is also a poly1d
    object. Otherwise, it is a 1D array of polynomial coefficients from
    highest to lowest degree.

See Also
--------
poly1d : A one-dimensional polynomial class.
poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval
convolve : Array convolution. Same output as polymul, but has parameter
           for overlap mode.

Examples
--------
>>> np.polymul([1, 2, 3], [9, 5, 1])
array([ 9, 23, 38, 17,  3])

Using poly1d objects:

>>> p1 = np.poly1d([1, 2, 3])
>>> p2 = np.poly1d([9, 5, 1])
>>> print(p1)
   2
1 x + 2 x + 3
>>> print(p2)
   2
9 x + 5 x + 1
>>> print(np.polymul(p1, p2))
   4      3      2
9 x + 23 x + 38 x + 17 x + 3
*)

val polysub : a1:Py.Object.t -> a2:Py.Object.t -> unit -> Py.Object.t
(**
Difference (subtraction) of two polynomials.

Given two polynomials `a1` and `a2`, returns ``a1 - a2``.
`a1` and `a2` can be either array_like sequences of the polynomials'
coefficients (including coefficients equal to zero), or `poly1d` objects.

Parameters
----------
a1, a2 : array_like or poly1d
    Minuend and subtrahend polynomials, respectively.

Returns
-------
out : ndarray or poly1d
    Array or `poly1d` object of the difference polynomial's coefficients.

See Also
--------
polyval, polydiv, polymul, polyadd

Examples
--------
.. math:: (2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)

>>> np.polysub([2, 10, -2], [3, 10, -4])
array([-1,  0,  2])
*)

val polyval : p:[`Poly1d_object of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> [`Poly1d_object of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
Evaluate a polynomial at specific values.

If `p` is of length N, this function returns the value:

    ``p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]``

If `x` is a sequence, then `p(x)` is returned for each element of `x`.
If `x` is another polynomial then the composite polynomial `p(x(t))`
is returned.

Parameters
----------
p : array_like or poly1d object
   1D array of polynomial coefficients (including coefficients equal
   to zero) from highest degree to the constant term, or an
   instance of poly1d.
x : array_like or poly1d object
   A number, an array of numbers, or an instance of poly1d, at
   which to evaluate `p`.

Returns
-------
values : ndarray or poly1d
   If `x` is a poly1d instance, the result is the composition of the two
   polynomials, i.e., `x` is 'substituted' in `p` and the simplified
   result is returned. In addition, the type of `x` - array_like or
   poly1d - governs the type of the output: `x` array_like => `values`
   array_like, `x` a poly1d object => `values` is also.

See Also
--------
poly1d: A polynomial class.

Notes
-----
Horner's scheme [1]_ is used to evaluate the polynomial. Even so,
for polynomials of high degree the values may be inaccurate due to
rounding errors. Use carefully.

If `x` is a subtype of `ndarray` the return value will be of the same type.

References
----------
.. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.
   trans. Ed.), *Handbook of Mathematics*, New York, Van Nostrand
   Reinhold Co., 1985, pg. 720.

Examples
--------
>>> np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1
76
>>> np.polyval([3,0,1], np.poly1d(5))
poly1d([76.])
>>> np.polyval(np.poly1d([3,0,1]), 5)
76
>>> np.polyval(np.poly1d([3,0,1]), np.poly1d(5))
poly1d([76.])
*)

val positive : ?out:Py.Object.t -> ?where:Py.Object.t -> [`I of int | `Ndarray of [>`Ndarray] Obj.t | `Bool of bool | `F of float | `S of string] -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
positive(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Numerical positive, element-wise.

.. versionadded:: 1.13.0

Parameters
----------
x : array_like or scalar
    Input array.

Returns
-------
y : ndarray or scalar
    Returned array or scalar: `y = +x`.
    This is a scalar if `x` is a scalar.

Notes
-----
Equivalent to `x.copy()`, but only defined for types that support
arithmetic.
*)

val power : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

First array elements raised to powers from second array, element-wise.

Raise each base in `x1` to the positionally-corresponding power in
`x2`.  `x1` and `x2` must be broadcastable to the same shape. Note that an
integer type raised to a negative integer power will raise a ValueError.

Parameters
----------
x1 : array_like
    The bases.
x2 : array_like
    The exponents. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The bases in `x1` raised to the exponents in `x2`.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
float_power : power function that promotes integers to float

Examples
--------
Cube each element in a list.

>>> x1 = range(6)
>>> x1
[0, 1, 2, 3, 4, 5]
>>> np.power(x1, 3)
array([  0,   1,   8,  27,  64, 125])

Raise the bases to different exponents.

>>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]
>>> np.power(x1, x2)
array([  0.,   1.,   8.,  27.,  16.,   5.])

The effect of broadcasting.

>>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])
>>> x2
array([[1, 2, 3, 3, 2, 1],
       [1, 2, 3, 3, 2, 1]])
>>> np.power(x1, x2)
array([[ 0,  1,  8, 27, 16,  5],
       [ 0,  1,  8, 27, 16,  5]])
*)

val ppmt : ?fv:[>`Ndarray] Obj.t -> ?when_:[`Begin | `I of int | `PyObject of Py.Object.t] -> rate:[>`Ndarray] Obj.t -> per:[`I of int | `Ndarray of [>`Ndarray] Obj.t] -> nper:[>`Ndarray] Obj.t -> pv:[>`Ndarray] Obj.t -> unit -> Py.Object.t
(**
Compute the payment against loan principal.

.. deprecated:: 1.18

   `ppmt` is deprecated; for details, see NEP 32 [1]_.
   Use the corresponding function in the numpy-financial library,
   https://pypi.org/project/numpy-financial.

Parameters
----------
rate : array_like
    Rate of interest (per period)
per : array_like, int
    Amount paid against the loan changes.  The `per` is the period of
    interest.
nper : array_like
    Number of compounding periods
pv : array_like
    Present value
fv : array_like, optional
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}
    When payments are due ('begin' (1) or 'end' (0))

See Also
--------
pmt, pv, ipmt

References
----------
.. [1] NumPy Enhancement Proposal (NEP) 32,
   https://numpy.org/neps/nep-0032-remove-financial-functions.html
*)

val printoptions : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
Context manager for setting print options.

Set print options for the scope of the `with` block, and restore the old
options at the end. See `set_printoptions` for the full description of
available options.

Examples
--------

>>> from numpy.testing import assert_equal
>>> with np.printoptions(precision=2):
...     np.array([2.0]) / 3
array([0.67])

The `as`-clause of the `with`-statement gives the current print options:

>>> with np.printoptions(precision=2) as opts:
...      assert_equal(opts, np.get_printoptions())

See Also
--------
set_printoptions, get_printoptions
*)

val prod : ?axis:int list -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> ?initial:[`F of float | `I of int | `Bool of bool | `S of string] -> ?where:Py.Object.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Return the product of array elements over a given axis.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    Axis or axes along which a product is performed.  The default,
    axis=None, will calculate the product of all the elements in the
    input array. If axis is negative it counts from the last to the
    first axis.

    .. versionadded:: 1.7.0

    If axis is a tuple of ints, a product is performed on all of the
    axes specified in the tuple instead of a single axis or all the
    axes as before.
dtype : dtype, optional
    The type of the returned array, as well as of the accumulator in
    which the elements are multiplied.  The dtype of `a` is used by
    default unless `a` has an integer dtype of less precision than the
    default platform integer.  In that case, if `a` is signed then the
    platform integer is used while if `a` is unsigned then an unsigned
    integer of the same precision as the platform integer is used.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output, but the type of the output
    values will be cast if necessary.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in the
    result as dimensions with size one. With this option, the result
    will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `prod` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.
initial : scalar, optional
    The starting value for this product. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to include in the product. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.17.0

Returns
-------
product_along_axis : ndarray, see `dtype` parameter above.
    An array shaped as `a` but with the specified axis removed.
    Returns a reference to `out` if specified.

See Also
--------
ndarray.prod : equivalent method
ufuncs-output-type

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:

>>> x = np.array([536870910, 536870910, 536870910, 536870910])
>>> np.prod(x)
16 # may vary

The product of an empty array is the neutral element 1:

>>> np.prod([])
1.0

Examples
--------
By default, calculate the product of all elements:

>>> np.prod([1.,2.])
2.0

Even when the input array is two-dimensional:

>>> np.prod([[1.,2.],[3.,4.]])
24.0

But we can also specify the axis over which to multiply:

>>> np.prod([[1.,2.],[3.,4.]], axis=1)
array([  2.,  12.])

Or select specific elements to include:

>>> np.prod([1., np.nan, 3.], where=[True, False, True])
3.0

If the type of `x` is unsigned, then the output type is
the unsigned platform integer:

>>> x = np.array([1, 2, 3], dtype=np.uint8)
>>> np.prod(x).dtype == np.uint
True

If `x` is of a signed integer type, then the output type
is the default platform integer:

>>> x = np.array([1, 2, 3], dtype=np.int8)
>>> np.prod(x).dtype == int
True

You can also start the product with a value other than one:

>>> np.prod([1, 2], initial=5)
10
*)

val product : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
Return the product of array elements over a given axis.

See Also
--------
prod : equivalent function; see for details.
*)

val promote_types : type1:[`Dtype_specifier of Py.Object.t | `Dtype of Dtype.t] -> type2:[`Dtype_specifier of Py.Object.t | `Dtype of Dtype.t] -> unit -> Dtype.t
(**
promote_types(type1, type2)

Returns the data type with the smallest size and smallest scalar
kind to which both ``type1`` and ``type2`` may be safely cast.
The returned data type is always in native byte order.

This function is symmetric, but rarely associative.

Parameters
----------
type1 : dtype or dtype specifier
    First data type.
type2 : dtype or dtype specifier
    Second data type.

Returns
-------
out : dtype
    The promoted data type.

Notes
-----
.. versionadded:: 1.6.0

Starting in NumPy 1.9, promote_types function now returns a valid string
length when given an integer or float dtype as one argument and a string
dtype as another argument. Previously it always returned the input string
dtype, even if it wasn't long enough to store the max integer/float value
converted to a string.

See Also
--------
result_type, dtype, can_cast

Examples
--------
>>> np.promote_types('f4', 'f8')
dtype('float64')

>>> np.promote_types('i8', 'f4')
dtype('float64')

>>> np.promote_types('>i8', '<c8')
dtype('complex128')

>>> np.promote_types('i4', 'S8')
dtype('S11')

An example of a non-associative case:

>>> p = np.promote_types
>>> p('S', p('i1', 'u1'))
dtype('S6')
>>> p(p('S', 'i1'), 'u1')
dtype('S4')
*)

val ptp : ?axis:int list -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Range of values (maximum - minimum) along an axis.

The name of the function comes from the acronym for 'peak to peak'.

Parameters
----------
a : array_like
    Input values.
axis : None or int or tuple of ints, optional
    Axis along which to find the peaks.  By default, flatten the
    array.  `axis` may be negative, in
    which case it counts from the last to the first axis.

    .. versionadded:: 1.15.0

    If this is a tuple of ints, a reduction is performed on multiple
    axes, instead of a single axis or all the axes as before.
out : array_like
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type of the output values will be cast if necessary.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `ptp` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
ptp : ndarray
    A new array holding the result, unless `out` was
    specified, in which case a reference to `out` is returned.

Examples
--------
>>> x = np.arange(4).reshape((2,2))
>>> x
array([[0, 1],
       [2, 3]])

>>> np.ptp(x, axis=0)
array([2, 2])

>>> np.ptp(x, axis=1)
array([1, 1])
*)

val put : ?mode:[`Raise | `Wrap | `Clip] -> ind:[>`Ndarray] Obj.t -> v:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Replaces specified elements of an array with given values.

The indexing works on the flattened target array. `put` is roughly
equivalent to:

::

    a.flat[ind] = v

Parameters
----------
a : ndarray
    Target array.
ind : array_like
    Target indices, interpreted as integers.
v : array_like
    Values to place in `a` at target indices. If `v` is shorter than
    `ind` it will be repeated as necessary.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.

    * 'raise' -- raise an error (default)
    * 'wrap' -- wrap around
    * 'clip' -- clip to the range

    'clip' mode means that all indices that are too large are replaced
    by the index that addresses the last element along that axis. Note
    that this disables indexing with negative numbers. In 'raise' mode,
    if an exception occurs the target array may still be modified.

See Also
--------
putmask, place
put_along_axis : Put elements by matching the array and the index arrays

Examples
--------
>>> a = np.arange(5)
>>> np.put(a, [0, 2], [-44, -55])
>>> a
array([-44,   1, -55,   3,   4])

>>> a = np.arange(5)
>>> np.put(a, 22, -5, mode='clip')
>>> a
array([ 0,  1,  2,  3, -5])
*)

val put_along_axis : arr:Py.Object.t -> indices:Py.Object.t -> values:Py.Object.t -> axis:int -> unit -> Py.Object.t
(**
Put values into the destination array by matching 1d index and data slices.

This iterates over matching 1d slices oriented along the specified axis in
the index and data arrays, and uses the former to place values into the
latter. These slices can be different lengths.

Functions returning an index along an axis, like `argsort` and
`argpartition`, produce suitable indices for this function.

.. versionadded:: 1.15.0

Parameters
----------
arr: ndarray (Ni..., M, Nk...)
    Destination array.
indices: ndarray (Ni..., J, Nk...)
    Indices to change along each 1d slice of `arr`. This must match the
    dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast
    against `arr`.
values: array_like (Ni..., J, Nk...)
    values to insert at those indices. Its shape and dimension are
    broadcast to match that of `indices`.
axis: int
    The axis to take 1d slices along. If axis is None, the destination
    array is treated as if a flattened 1d view had been created of it.

Notes
-----
This is equivalent to (but faster than) the following use of `ndindex` and
`s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices::

    Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]
    J = indices.shape[axis]  # Need not equal M

    for ii in ndindex(Ni):
        for kk in ndindex(Nk):
            a_1d       = a      [ii + s_[:,] + kk]
            indices_1d = indices[ii + s_[:,] + kk]
            values_1d  = values [ii + s_[:,] + kk]
            for j in range(J):
                a_1d[indices_1d[j]] = values_1d[j]

Equivalently, eliminating the inner loop, the last two lines would be::

            a_1d[indices_1d] = values_1d

See Also
--------
take_along_axis :
    Take values from the input array by matching 1d index and data slices

Examples
--------

For this sample array

>>> a = np.array([[10, 30, 20], [60, 40, 50]])

We can replace the maximum values with:

>>> ai = np.expand_dims(np.argmax(a, axis=1), axis=1)
>>> ai
array([[1],
       [0]])
>>> np.put_along_axis(a, ai, 99, axis=1)
>>> a
array([[10, 99, 20],
       [99, 40, 50]])
*)

val putmask : mask:[>`Ndarray] Obj.t -> values:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
putmask(a, mask, values)

Changes elements of an array based on conditional and input values.

Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.

If `values` is not the same size as `a` and `mask` then it will repeat.
This gives behavior different from ``a[mask] = values``.

Parameters
----------
a : array_like
    Target array.
mask : array_like
    Boolean mask array. It has to be the same shape as `a`.
values : array_like
    Values to put into `a` where `mask` is True. If `values` is smaller
    than `a` it will be repeated.

See Also
--------
place, put, take, copyto

Examples
--------
>>> x = np.arange(6).reshape(2, 3)
>>> np.putmask(x, x>2, x**2)
>>> x
array([[ 0,  1,  2],
       [ 9, 16, 25]])

If `values` is smaller than `a` it is repeated:

>>> x = np.arange(5)
>>> np.putmask(x, x>1, [-33, -44])
>>> x
array([  0,   1, -33, -44, -33])
*)

val pv : ?fv:[>`Ndarray] Obj.t -> ?when_:[`Begin | `I of int | `PyObject of Py.Object.t] -> rate:[>`Ndarray] Obj.t -> nper:[>`Ndarray] Obj.t -> pmt:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the present value.

.. deprecated:: 1.18

   `pv` is deprecated; for details, see NEP 32 [1]_.
   Use the corresponding function in the numpy-financial library,
   https://pypi.org/project/numpy-financial.

Given:
 * a future value, `fv`
 * an interest `rate` compounded once per period, of which
   there are
 * `nper` total
 * a (fixed) payment, `pmt`, paid either
 * at the beginning (`when` = {'begin', 1}) or the end
   (`when` = {'end', 0}) of each period

Return:
   the value now

Parameters
----------
rate : array_like
    Rate of interest (per period)
nper : array_like
    Number of compounding periods
pmt : array_like
    Payment
fv : array_like, optional
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0))

Returns
-------
out : ndarray, float
    Present value of a series of payments or investments.

Notes
-----
The present value is computed by solving the equation::

 fv +
 pv*(1 + rate)**nper +
 pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) = 0

or, when ``rate = 0``::

 fv + pv + pmt * nper = 0

for `pv`, which is then returned.

References
----------
.. [1] NumPy Enhancement Proposal (NEP) 32,
   https://numpy.org/neps/nep-0032-remove-financial-functions.html
.. [2] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).
   Open Document Format for Office Applications (OpenDocument)v1.2,
   Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,
   Pre-Draft 12. Organization for the Advancement of Structured Information
   Standards (OASIS). Billerica, MA, USA. [ODT Document].
   Available:
   http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula
   OpenDocument-formula-20090508.odt

Examples
--------
What is the present value (e.g., the initial investment)
of an investment that needs to total $15692.93
after 10 years of saving $100 every month?  Assume the
interest rate is 5% (annually) compounded monthly.

>>> np.pv(0.05/12, 10*12, -100, 15692.93)
-100.00067131625819

By convention, the negative sign represents cash flow out
(i.e., money not available today).  Thus, to end up with
$15,692.93 in 10 years saving $100 a month at 5% annual
interest, one's initial deposit should also be $100.

If any input is array_like, ``pv`` returns an array of equal shape.
Let's compare different interest rates in the example above:

>>> a = np.array((0.05, 0.04, 0.03))/12
>>> np.pv(a, 10*12, -100, 15692.93)
array([ -100.00067132,  -649.26771385, -1273.78633713]) # may vary

So, to end up with the same $15692.93 under the same $100 per month
'savings plan,' for annual interest rates of 4% and 3%, one would
need initial investments of $649.27 and $1273.79, respectively.
*)

val quantile : ?axis:[`I of int | `Tuple_of_int of Py.Object.t] -> ?out:[>`Ndarray] Obj.t -> ?overwrite_input:bool -> ?interpolation:[`Linear | `Lower | `Higher | `Midpoint | `Nearest] -> ?keepdims:bool -> q:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> Py.Object.t
(**
Compute the q-th quantile of the data along the specified axis.

.. versionadded:: 1.15.0

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
q : array_like of float
    Quantile or sequence of quantiles to compute, which must be between
    0 and 1 inclusive.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the quantiles are computed. The
    default is to compute the quantile(s) along a flattened
    version of the array.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow the input array `a` to be modified by intermediate
    calculations, to save memory. In this case, the contents of the input
    `a` after this function completes is undefined.
interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
    This optional parameter specifies the interpolation method to
    use when the desired quantile lies between two data points
    ``i < j``:

        * linear: ``i + (j - i) * fraction``, where ``fraction``
          is the fractional part of the index surrounded by ``i``
          and ``j``.
        * lower: ``i``.
        * higher: ``j``.
        * nearest: ``i`` or ``j``, whichever is nearest.
        * midpoint: ``(i + j) / 2``.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in
    the result as dimensions with size one. With this option, the
    result will broadcast correctly against the original array `a`.

Returns
-------
quantile : scalar or ndarray
    If `q` is a single quantile and `axis=None`, then the result
    is a scalar. If multiple quantiles are given, first axis of
    the result corresponds to the quantiles. The other axes are
    the axes that remain after the reduction of `a`. If the input
    contains integers or floats smaller than ``float64``, the output
    data-type is ``float64``. Otherwise, the output data-type is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
mean
percentile : equivalent to quantile, but with q in the range [0, 100].
median : equivalent to ``quantile(..., 0.5)``
nanquantile

Notes
-----
Given a vector ``V`` of length ``N``, the q-th quantile of
``V`` is the value ``q`` of the way from the minimum to the
maximum in a sorted copy of ``V``. The values and distances of
the two nearest neighbors as well as the `interpolation` parameter
will determine the quantile if the normalized ranking does not
match the location of ``q`` exactly. This function is the same as
the median if ``q=0.5``, the same as the minimum if ``q=0.0`` and the
same as the maximum if ``q=1.0``.

Examples
--------
>>> a = np.array([[10, 7, 4], [3, 2, 1]])
>>> a
array([[10,  7,  4],
       [ 3,  2,  1]])
>>> np.quantile(a, 0.5)
3.5
>>> np.quantile(a, 0.5, axis=0)
array([6.5, 4.5, 2.5])
>>> np.quantile(a, 0.5, axis=1)
array([7.,  2.])
>>> np.quantile(a, 0.5, axis=1, keepdims=True)
array([[7.],
       [2.]])
>>> m = np.quantile(a, 0.5, axis=0)
>>> out = np.zeros_like(m)
>>> np.quantile(a, 0.5, axis=0, out=out)
array([6.5, 4.5, 2.5])
>>> m
array([6.5, 4.5, 2.5])
>>> b = a.copy()
>>> np.quantile(b, 0.5, axis=1, overwrite_input=True)
array([7.,  2.])
>>> assert not np.all(a == b)
*)

val rad2deg : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
rad2deg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Convert angles from radians to degrees.

Parameters
----------
x : array_like
    Angle in radians.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding angle in degrees.
    This is a scalar if `x` is a scalar.

See Also
--------
deg2rad : Convert angles from degrees to radians.
unwrap : Remove large jumps in angle by wrapping.

Notes
-----
.. versionadded:: 1.3.0

rad2deg(x) is ``180 * x / pi``.

Examples
--------
>>> np.rad2deg(np.pi/2)
90.0
*)

val radians : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
radians(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Convert angles from degrees to radians.

Parameters
----------
x : array_like
    Input array in degrees.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding radian values.
    This is a scalar if `x` is a scalar.

See Also
--------
deg2rad : equivalent function

Examples
--------
Convert a degree array to radians

>>> deg = np.arange(12.) * 30.
>>> np.radians(deg)
array([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,
        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,
        5.23598776,  5.75958653])

>>> out = np.zeros((deg.shape))
>>> ret = np.radians(deg, out)
>>> ret is out
True
*)

val rate : ?when_:[`Begin | `I of int | `PyObject of Py.Object.t] -> ?guess:Py.Object.t -> ?tol:Py.Object.t -> ?maxiter:int -> nper:[>`Ndarray] Obj.t -> pmt:[>`Ndarray] Obj.t -> pv:[>`Ndarray] Obj.t -> fv:[>`Ndarray] Obj.t -> unit -> Py.Object.t
(**
Compute the rate of interest per period.

.. deprecated:: 1.18

   `rate` is deprecated; for details, see NEP 32 [1]_.
   Use the corresponding function in the numpy-financial library,
   https://pypi.org/project/numpy-financial.

Parameters
----------
nper : array_like
    Number of compounding periods
pmt : array_like
    Payment
pv : array_like
    Present value
fv : array_like
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0))
guess : Number, optional
    Starting guess for solving the rate of interest, default 0.1
tol : Number, optional
    Required tolerance for the solution, default 1e-6
maxiter : int, optional
    Maximum iterations in finding the solution

Notes
-----
The rate of interest is computed by iteratively solving the
(non-linear) equation::

 fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate * ((1+rate)**nper - 1) = 0

for ``rate``.

References
----------
.. [1] NumPy Enhancement Proposal (NEP) 32,
   https://numpy.org/neps/nep-0032-remove-financial-functions.html
.. [2] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).
   Open Document Format for Office Applications (OpenDocument)v1.2,
   Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,
   Pre-Draft 12. Organization for the Advancement of Structured Information
   Standards (OASIS). Billerica, MA, USA. [ODT Document].
   Available:
   http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula
   OpenDocument-formula-20090508.odt
*)

val ravel : ?order:[`C | `F | `A | `K] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a contiguous flattened array.

A 1-D array, containing the elements of the input, is returned.  A copy is
made only if needed.

As of NumPy 1.10, the returned array will have the same type as the input
array. (for example, a masked array will be returned for a masked array
input)

Parameters
----------
a : array_like
    Input array.  The elements in `a` are read in the order specified by
    `order`, and packed as a 1-D array.
order : {'C','F', 'A', 'K'}, optional

    The elements of `a` are read using this index order. 'C' means
    to index the elements in row-major, C-style order,
    with the last axis index changing fastest, back to the first
    axis index changing slowest.  'F' means to index the elements
    in column-major, Fortran-style order, with the
    first index changing fastest, and the last index changing
    slowest. Note that the 'C' and 'F' options take no account of
    the memory layout of the underlying array, and only refer to
    the order of axis indexing.  'A' means to read the elements in
    Fortran-like index order if `a` is Fortran *contiguous* in
    memory, C-like order otherwise.  'K' means to read the
    elements in the order they occur in memory, except for
    reversing the data when strides are negative.  By default, 'C'
    index order is used.

Returns
-------
y : array_like
    y is an array of the same subtype as `a`, with shape ``(a.size,)``.
    Note that matrices are special cased for backward compatibility, if `a`
    is a matrix, then y is a 1-D ndarray.

See Also
--------
ndarray.flat : 1-D iterator over an array.
ndarray.flatten : 1-D array copy of the elements of an array
                  in row-major order.
ndarray.reshape : Change the shape of an array without changing its data.

Notes
-----
In row-major, C-style order, in two dimensions, the row index
varies the slowest, and the column index the quickest.  This can
be generalized to multiple dimensions, where row-major order
implies that the index along the first axis varies slowest, and
the index along the last quickest.  The opposite holds for
column-major, Fortran-style index ordering.

When a view is desired in as many cases as possible, ``arr.reshape(-1)``
may be preferable.

Examples
--------
It is equivalent to ``reshape(-1, order=order)``.

>>> x = np.array([[1, 2, 3], [4, 5, 6]])
>>> np.ravel(x)
array([1, 2, 3, 4, 5, 6])

>>> x.reshape(-1)
array([1, 2, 3, 4, 5, 6])

>>> np.ravel(x, order='F')
array([1, 4, 2, 5, 3, 6])

When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:

>>> np.ravel(x.T)
array([1, 4, 2, 5, 3, 6])
>>> np.ravel(x.T, order='A')
array([1, 2, 3, 4, 5, 6])

When ``order`` is 'K', it will preserve orderings that are neither 'C'
nor 'F', but won't reverse axes:

>>> a = np.arange(3)[::-1]; a
array([2, 1, 0])
>>> a.ravel(order='C')
array([2, 1, 0])
>>> a.ravel(order='K')
array([2, 1, 0])

>>> a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a
array([[[ 0,  2,  4],
        [ 1,  3,  5]],
       [[ 6,  8, 10],
        [ 7,  9, 11]]])
>>> a.ravel(order='C')
array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])
>>> a.ravel(order='K')
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
*)

val ravel_multi_index : ?mode:[`Raise | `Wrap | `Clip] -> ?order:[`C | `F] -> multi_index:Py.Object.t -> dims:int list -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
ravel_multi_index(multi_index, dims, mode='raise', order='C')

Converts a tuple of index arrays into an array of flat
indices, applying boundary modes to the multi-index.

Parameters
----------
multi_index : tuple of array_like
    A tuple of integer arrays, one array for each dimension.
dims : tuple of ints
    The shape of array into which the indices from ``multi_index`` apply.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices are handled.  Can specify
    either one mode or a tuple of modes, one mode per index.

    * 'raise' -- raise an error (default)
    * 'wrap' -- wrap around
    * 'clip' -- clip to the range

    In 'clip' mode, a negative index which would normally
    wrap will clip to 0 instead.
order : {'C', 'F'}, optional
    Determines whether the multi-index should be viewed as
    indexing in row-major (C-style) or column-major
    (Fortran-style) order.

Returns
-------
raveled_indices : ndarray
    An array of indices into the flattened version of an array
    of dimensions ``dims``.

See Also
--------
unravel_index

Notes
-----
.. versionadded:: 1.6.0

Examples
--------
>>> arr = np.array([[3,6,6],[4,5,1]])
>>> np.ravel_multi_index(arr, (7,6))
array([22, 41, 37])
>>> np.ravel_multi_index(arr, (7,6), order='F')
array([31, 41, 13])
>>> np.ravel_multi_index(arr, (4,6), mode='clip')
array([22, 23, 19])
>>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))
array([12, 13, 13])

>>> np.ravel_multi_index((3,1,4,1), (6,7,8,9))
1621
*)

val real : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the real part of the complex argument.

Parameters
----------
val : array_like
    Input array.

Returns
-------
out : ndarray or scalar
    The real component of the complex argument. If `val` is real, the type
    of `val` is used for the output.  If `val` has complex elements, the
    returned type is float.

See Also
--------
real_if_close, imag, angle

Examples
--------
>>> a = np.array([1+2j, 3+4j, 5+6j])
>>> a.real
array([1.,  3.,  5.])
>>> a.real = 9
>>> a
array([9.+2.j,  9.+4.j,  9.+6.j])
>>> a.real = np.array([9, 8, 7])
>>> a
array([9.+2.j,  8.+4.j,  7.+6.j])
>>> np.real(1 + 1j)
1.0
*)

val real_if_close : ?tol:float -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
If complex input returns a real array if complex parts are close to zero.

'Close to zero' is defined as `tol` * (machine epsilon of the type for
`a`).

Parameters
----------
a : array_like
    Input array.
tol : float
    Tolerance in machine epsilons for the complex part of the elements
    in the array.

Returns
-------
out : ndarray
    If `a` is real, the type of `a` is used for the output.  If `a`
    has complex elements, the returned type is float.

See Also
--------
real, imag, angle

Notes
-----
Machine epsilon varies from machine to machine and between data types
but Python floats on most platforms have a machine epsilon equal to
2.2204460492503131e-16.  You can use 'np.finfo(float).eps' to print
out the machine epsilon for floats.

Examples
--------
>>> np.finfo(float).eps
2.2204460492503131e-16 # may vary

>>> np.real_if_close([2.1 + 4e-14j], tol=1000)
array([2.1])
>>> np.real_if_close([2.1 + 4e-13j], tol=1000)
array([2.1+4.e-13j])
*)

val recfromcsv : ?kwargs:(string * Py.Object.t) list -> fname:Py.Object.t -> unit -> Py.Object.t
(**
Load ASCII data stored in a comma-separated file.

The returned array is a record array (if ``usemask=False``, see
`recarray`) or a masked record array (if ``usemask=True``,
see `ma.mrecords.MaskedRecords`).

Parameters
----------
fname, kwargs : For a description of input parameters, see `genfromtxt`.

See Also
--------
numpy.genfromtxt : generic function to load ASCII data.

Notes
-----
By default, `dtype` is None, which means that the data-type of the output
array will be determined from the data.
*)

val recfromtxt : ?kwargs:(string * Py.Object.t) list -> fname:Py.Object.t -> unit -> Py.Object.t
(**
Load ASCII data from a file and return it in a record array.

If ``usemask=False`` a standard `recarray` is returned,
if ``usemask=True`` a MaskedRecords array is returned.

Parameters
----------
fname, kwargs : For a description of input parameters, see `genfromtxt`.

See Also
--------
numpy.genfromtxt : generic function

Notes
-----
By default, `dtype` is None, which means that the data-type of the output
array will be determined from the data.
*)

val reciprocal : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
reciprocal(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the reciprocal of the argument, element-wise.

Calculates ``1/x``.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    Return array.
    This is a scalar if `x` is a scalar.

Notes
-----
.. note::
    This function is not designed to work with integers.

For integer arguments with absolute value larger than 1 the result is
always zero because of the way Python handles integer division.  For
integer zero the result is an overflow.

Examples
--------
>>> np.reciprocal(2.)
0.5
>>> np.reciprocal([1, 2., 3.33])
array([ 1.       ,  0.5      ,  0.3003003])
*)

val remainder : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return element-wise remainder of division.

Computes the remainder complementary to the `floor_divide` function.  It is
equivalent to the Python modulus operator``x1 % x2`` and has the same sign
as the divisor `x2`. The MATLAB function equivalent to ``np.remainder``
is ``mod``.

.. warning::

    This should not be confused with:

    * Python 3.7's `math.remainder` and C's ``remainder``, which
      computes the IEEE remainder, which are the complement to
      ``round(x1 / x2)``.
    * The MATLAB ``rem`` function and or the C ``%`` operator which is the
      complement to ``int(x1 / x2)``.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
floor_divide : Equivalent of Python ``//`` operator.
divmod : Simultaneous floor division and remainder.
fmod : Equivalent of the MATLAB ``rem`` function.
divide, floor

Notes
-----
Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)
integers.
``mod`` is an alias of ``remainder``.

Examples
--------
>>> np.remainder([4, 7], [2, 3])
array([0, 1])
>>> np.remainder(np.arange(7), 5)
array([0, 1, 2, 3, 4, 0, 1])
*)

val repeat : ?axis:int -> repeats:[`Array_of_ints of Py.Object.t | `I of int] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Repeat elements of an array.

Parameters
----------
a : array_like
    Input array.
repeats : int or array of ints
    The number of repetitions for each element.  `repeats` is broadcasted
    to fit the shape of the given axis.
axis : int, optional
    The axis along which to repeat values.  By default, use the
    flattened input array, and return a flat output array.

Returns
-------
repeated_array : ndarray
    Output array which has the same shape as `a`, except along
    the given axis.

See Also
--------
tile : Tile an array.

Examples
--------
>>> np.repeat(3, 4)
array([3, 3, 3, 3])
>>> x = np.array([[1,2],[3,4]])
>>> np.repeat(x, 2)
array([1, 1, 2, 2, 3, 3, 4, 4])
>>> np.repeat(x, 3, axis=1)
array([[1, 1, 1, 2, 2, 2],
       [3, 3, 3, 4, 4, 4]])
>>> np.repeat(x, [1, 2], axis=0)
array([[1, 2],
       [3, 4],
       [3, 4]])
*)

val require : ?dtype:Dtype.t -> ?requirements:[`StringList of string list | `S of string] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an ndarray of the provided type that satisfies requirements.

This function is useful to be sure that an array with the correct flags
is returned for passing to compiled code (perhaps through ctypes).

Parameters
----------
a : array_like
   The object to be converted to a type-and-requirement-satisfying array.
dtype : data-type
   The required data-type. If None preserve the current dtype. If your
   application requires the data to be in native byteorder, include
   a byteorder specification as a part of the dtype specification.
requirements : str or list of str
   The requirements list can be any of the following

   * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array
   * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array
   * 'ALIGNED' ('A')      - ensure a data-type aligned array
   * 'WRITEABLE' ('W')    - ensure a writable array
   * 'OWNDATA' ('O')      - ensure an array that owns its own data
   * 'ENSUREARRAY', ('E') - ensure a base array, instead of a subclass

Returns
-------
out : ndarray
    Array with specified requirements and type if given.

See Also
--------
asarray : Convert input to an ndarray.
asanyarray : Convert to an ndarray, but pass through ndarray subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
ndarray.flags : Information about the memory layout of the array.

Notes
-----
The returned array will be guaranteed to have the listed requirements
by making a copy if needed.

Examples
--------
>>> x = np.arange(6).reshape(2,3)
>>> x.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False

>>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])
>>> y.flags
  C_CONTIGUOUS : False
  F_CONTIGUOUS : True
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False
*)

val reshape : ?order:[`C | `F | `A] -> newshape:int list -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Gives a new shape to an array without changing its data.

Parameters
----------
a : array_like
    Array to be reshaped.
newshape : int or tuple of ints
    The new shape should be compatible with the original shape. If
    an integer, then the result will be a 1-D array of that length.
    One shape dimension can be -1. In this case, the value is
    inferred from the length of the array and remaining dimensions.
order : {'C', 'F', 'A'}, optional
    Read the elements of `a` using this index order, and place the
    elements into the reshaped array using this index order.  'C'
    means to read / write the elements using C-like index order,
    with the last axis index changing fastest, back to the first
    axis index changing slowest. 'F' means to read / write the
    elements using Fortran-like index order, with the first index
    changing fastest, and the last index changing slowest. Note that
    the 'C' and 'F' options take no account of the memory layout of
    the underlying array, and only refer to the order of indexing.
    'A' means to read / write the elements in Fortran-like index
    order if `a` is Fortran *contiguous* in memory, C-like order
    otherwise.

Returns
-------
reshaped_array : ndarray
    This will be a new view object if possible; otherwise, it will
    be a copy.  Note there is no guarantee of the *memory layout* (C- or
    Fortran- contiguous) of the returned array.

See Also
--------
ndarray.reshape : Equivalent method.

Notes
-----
It is not always possible to change the shape of an array without
copying the data. If you want an error to be raised when the data is copied,
you should assign the new shape to the shape attribute of the array::

 >>> a = np.zeros((10, 2))

 # A transpose makes the array non-contiguous
 >>> b = a.T

 # Taking a view makes it possible to modify the shape without modifying
 # the initial object.
 >>> c = b.view()
 >>> c.shape = (20)
 Traceback (most recent call last):
    ...
 AttributeError: incompatible shape for a non-contiguous array

The `order` keyword gives the index ordering both for *fetching* the values
from `a`, and then *placing* the values into the output array.
For example, let's say you have an array:

>>> a = np.arange(6).reshape((3, 2))
>>> a
array([[0, 1],
       [2, 3],
       [4, 5]])

You can think of reshaping as first raveling the array (using the given
index order), then inserting the elements from the raveled array into the
new array using the same kind of index ordering as was used for the
raveling.

>>> np.reshape(a, (2, 3)) # C-like index ordering
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.reshape(a, (2, 3), order='F') # Fortran-like index ordering
array([[0, 4, 3],
       [2, 1, 5]])
>>> np.reshape(np.ravel(a, order='F'), (2, 3), order='F')
array([[0, 4, 3],
       [2, 1, 5]])

Examples
--------
>>> a = np.array([[1,2,3], [4,5,6]])
>>> np.reshape(a, 6)
array([1, 2, 3, 4, 5, 6])
>>> np.reshape(a, 6, order='F')
array([1, 4, 2, 5, 3, 6])

>>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2
array([[1, 2],
       [3, 4],
       [5, 6]])
*)

val resize : new_shape:[`I of int | `Tuple_of_int of Py.Object.t] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a new array with the specified shape.

If the new array is larger than the original array, then the new
array is filled with repeated copies of `a`.  Note that this behavior
is different from a.resize(new_shape) which fills with zeros instead
of repeated copies of `a`.

Parameters
----------
a : array_like
    Array to be resized.

new_shape : int or tuple of int
    Shape of resized array.

Returns
-------
reshaped_array : ndarray
    The new array is formed from the data in the old array, repeated
    if necessary to fill out the required number of elements.  The
    data are repeated in the order that they are stored in memory.

See Also
--------
ndarray.resize : resize an array in-place.

Notes
-----
Warning: This functionality does **not** consider axes separately,
i.e. it does not apply interpolation/extrapolation.
It fills the return array with the required number of elements, taken
from `a` as they are laid out in memory, disregarding strides and axes.
(This is in case the new shape is smaller. For larger, see above.)
This functionality is therefore not suitable to resize images,
or data where each axis represents a separate and distinct entity.

Examples
--------
>>> a=np.array([[0,1],[2,3]])
>>> np.resize(a,(2,3))
array([[0, 1, 2],
       [3, 0, 1]])
>>> np.resize(a,(1,4))
array([[0, 1, 2, 3]])
>>> np.resize(a,(2,4))
array([[0, 1, 2, 3],
       [0, 1, 2, 3]])
*)

val result_type : Py.Object.t list -> Dtype.t
(**
result_type( *arrays_and_dtypes)

Returns the type that results from applying the NumPy
type promotion rules to the arguments.

Type promotion in NumPy works similarly to the rules in languages
like C++, with some slight differences.  When both scalars and
arrays are used, the array's type takes precedence and the actual value
of the scalar is taken into account.

For example, calculating 3*a, where a is an array of 32-bit floats,
intuitively should result in a 32-bit float output.  If the 3 is a
32-bit integer, the NumPy rules indicate it can't convert losslessly
into a 32-bit float, so a 64-bit float should be the result type.
By examining the value of the constant, '3', we see that it fits in
an 8-bit integer, which can be cast losslessly into the 32-bit float.

Parameters
----------
arrays_and_dtypes : list of arrays and dtypes
    The operands of some operation whose result type is needed.

Returns
-------
out : dtype
    The result type.

See also
--------
dtype, promote_types, min_scalar_type, can_cast

Notes
-----
.. versionadded:: 1.6.0

The specific algorithm used is as follows.

Categories are determined by first checking which of boolean,
integer (int/uint), or floating point (float/complex) the maximum
kind of all the arrays and the scalars are.

If there are only scalars or the maximum category of the scalars
is higher than the maximum category of the arrays,
the data types are combined with :func:`promote_types`
to produce the return value.

Otherwise, `min_scalar_type` is called on each array, and
the resulting data types are all combined with :func:`promote_types`
to produce the return value.

The set of int values is not a subset of the uint values for types
with the same number of bits, something not reflected in
:func:`min_scalar_type`, but handled as a special case in `result_type`.

Examples
--------
>>> np.result_type(3, np.arange(7, dtype='i1'))
dtype('int8')

>>> np.result_type('i4', 'c8')
dtype('complex128')

>>> np.result_type(3.0, -2)
dtype('float64')
*)

val right_shift : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Shift the bits of an integer to the right.

Bits are shifted to the right `x2`.  Because the internal
representation of numbers is in binary format, this operation is
equivalent to dividing `x1` by ``2**x2``.

Parameters
----------
x1 : array_like, int
    Input values.
x2 : array_like, int
    Number of bits to remove at the right of `x1`. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray, int
    Return `x1` with bits shifted `x2` times to the right.
    This is a scalar if both `x1` and `x2` are scalars.

See Also
--------
left_shift : Shift the bits of an integer to the left.
binary_repr : Return the binary representation of the input number
    as a string.

Examples
--------
>>> np.binary_repr(10)
'1010'
>>> np.right_shift(10, 1)
5
>>> np.binary_repr(5)
'101'

>>> np.right_shift(10, [1,2,3])
array([5, 2, 1])
*)

val rint : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
rint(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Round elements of the array to the nearest integer.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Output array is same shape and type as `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
ceil, floor, trunc

Examples
--------
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.rint(a)
array([-2., -2., -0.,  0.,  2.,  2.,  2.])
*)

val roll : ?axis:int list -> shift:int list -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Roll array elements along a given axis.

Elements that roll beyond the last position are re-introduced at
the first.

Parameters
----------
a : array_like
    Input array.
shift : int or tuple of ints
    The number of places by which elements are shifted.  If a tuple,
    then `axis` must be a tuple of the same size, and each of the
    given axes is shifted by the corresponding number.  If an int
    while `axis` is a tuple of ints, then the same value is used for
    all given axes.
axis : int or tuple of ints, optional
    Axis or axes along which elements are shifted.  By default, the
    array is flattened before shifting, after which the original
    shape is restored.

Returns
-------
res : ndarray
    Output array, with the same shape as `a`.

See Also
--------
rollaxis : Roll the specified axis backwards, until it lies in a
           given position.

Notes
-----
.. versionadded:: 1.12.0

Supports rolling over multiple dimensions simultaneously.

Examples
--------
>>> x = np.arange(10)
>>> np.roll(x, 2)
array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])
>>> np.roll(x, -2)
array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])

>>> x2 = np.reshape(x, (2,5))
>>> x2
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
>>> np.roll(x2, 1)
array([[9, 0, 1, 2, 3],
       [4, 5, 6, 7, 8]])
>>> np.roll(x2, -1)
array([[1, 2, 3, 4, 5],
       [6, 7, 8, 9, 0]])
>>> np.roll(x2, 1, axis=0)
array([[5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4]])
>>> np.roll(x2, -1, axis=0)
array([[5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4]])
>>> np.roll(x2, 1, axis=1)
array([[4, 0, 1, 2, 3],
       [9, 5, 6, 7, 8]])
>>> np.roll(x2, -1, axis=1)
array([[1, 2, 3, 4, 0],
       [6, 7, 8, 9, 5]])
*)

val rollaxis : ?start:int -> axis:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Roll the specified axis backwards, until it lies in a given position.

This function continues to be supported for backward compatibility, but you
should prefer `moveaxis`. The `moveaxis` function was added in NumPy
1.11.

Parameters
----------
a : ndarray
    Input array.
axis : int
    The axis to roll backwards.  The positions of the other axes do not
    change relative to one another.
start : int, optional
    The axis is rolled until it lies before this position.  The default,
    0, results in a 'complete' roll.

Returns
-------
res : ndarray
    For NumPy >= 1.10.0 a view of `a` is always returned. For earlier
    NumPy versions a view of `a` is returned only if the order of the
    axes is changed, otherwise the input array is returned.

See Also
--------
moveaxis : Move array axes to new positions.
roll : Roll the elements of an array by a number of positions along a
    given axis.

Examples
--------
>>> a = np.ones((3,4,5,6))
>>> np.rollaxis(a, 3, 1).shape
(3, 6, 4, 5)
>>> np.rollaxis(a, 2).shape
(5, 3, 4, 6)
>>> np.rollaxis(a, 1, 4).shape
(3, 5, 6, 4)
*)

val roots : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the roots of a polynomial with coefficients given in p.

The values in the rank-1 array `p` are coefficients of a polynomial.
If the length of `p` is n+1 then the polynomial is described by::

  p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]

Parameters
----------
p : array_like
    Rank-1 array of polynomial coefficients.

Returns
-------
out : ndarray
    An array containing the roots of the polynomial.

Raises
------
ValueError
    When `p` cannot be converted to a rank-1 array.

See also
--------
poly : Find the coefficients of a polynomial with a given sequence
       of roots.
polyval : Compute polynomial values.
polyfit : Least squares polynomial fit.
poly1d : A one-dimensional polynomial class.

Notes
-----
The algorithm relies on computing the eigenvalues of the
companion matrix [1]_.

References
----------
.. [1] R. A. Horn & C. R. Johnson, *Matrix Analysis*.  Cambridge, UK:
    Cambridge University Press, 1999, pp. 146-7.

Examples
--------
>>> coeff = [3.2, 2, 1]
>>> np.roots(coeff)
array([-0.3125+0.46351241j, -0.3125-0.46351241j])
*)

val rot90 : ?k:int -> ?axes:Py.Object.t -> m:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Rotate an array by 90 degrees in the plane specified by axes.

Rotation direction is from the first towards the second axis.

Parameters
----------
m : array_like
    Array of two or more dimensions.
k : integer
    Number of times the array is rotated by 90 degrees.
axes: (2,) array_like
    The array is rotated in the plane defined by the axes.
    Axes must be different.

    .. versionadded:: 1.12.0

Returns
-------
y : ndarray
    A rotated view of `m`.

See Also
--------
flip : Reverse the order of elements in an array along the given axis.
fliplr : Flip an array horizontally.
flipud : Flip an array vertically.

Notes
-----
rot90(m, k=1, axes=(1,0)) is the reverse of rot90(m, k=1, axes=(0,1))
rot90(m, k=1, axes=(1,0)) is equivalent to rot90(m, k=-1, axes=(0,1))

Examples
--------
>>> m = np.array([[1,2],[3,4]], int)
>>> m
array([[1, 2],
       [3, 4]])
>>> np.rot90(m)
array([[2, 4],
       [1, 3]])
>>> np.rot90(m, 2)
array([[4, 3],
       [2, 1]])
>>> m = np.arange(8).reshape((2,2,2))
>>> np.rot90(m, 1, (1,2))
array([[[1, 3],
        [0, 2]],
       [[5, 7],
        [4, 6]]])
*)

val round : ?decimals:Py.Object.t -> ?out:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Round an array to the given number of decimals.

See Also
--------
around : equivalent function; see for details.
*)

val row_stack : [>`Ndarray] Obj.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Stack arrays in sequence vertically (row wise).

This is equivalent to concatenation along the first axis after 1-D arrays
of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by
`vsplit`.

This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions `concatenate`, `stack` and
`block` provide more general stacking and concatenation operations.

Parameters
----------
tup : sequence of ndarrays
    The arrays must have the same shape along all but the first axis.
    1-D arrays must have the same length.

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays, will be at least 2-D.

See Also
--------
stack : Join a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
concatenate : Join a sequence of arrays along an existing axis.
vsplit : Split array into a list of multiple sub-arrays vertically.
block : Assemble arrays from blocks.

Examples
--------
>>> a = np.array([1, 2, 3])
>>> b = np.array([2, 3, 4])
>>> np.vstack((a,b))
array([[1, 2, 3],
       [2, 3, 4]])

>>> a = np.array([[1], [2], [3]])
>>> b = np.array([[2], [3], [4]])
>>> np.vstack((a,b))
array([[1],
       [2],
       [3],
       [2],
       [3],
       [4]])
*)

val safe_eval : string -> Py.Object.t
(**
Protected string evaluation.

Evaluate a string containing a Python literal expression without
allowing the execution of arbitrary non-literal code.

Parameters
----------
source : str
    The string to evaluate.

Returns
-------
obj : object
   The result of evaluating `source`.

Raises
------
SyntaxError
    If the code has invalid Python syntax, or if it contains
    non-literal code.

Examples
--------
>>> np.safe_eval('1')
1
>>> np.safe_eval('[1, 2, 3]')
[1, 2, 3]
>>> np.safe_eval('{'foo': ('bar', 10.0)}')
{'foo': ('bar', 10.0)}

>>> np.safe_eval('import os')
Traceback (most recent call last):
  ...
SyntaxError: invalid syntax

>>> np.safe_eval('open('/home/user/.ssh/id_dsa').read()')
Traceback (most recent call last):
  ...
ValueError: malformed node or string: <_ast.Call object at 0x...>
*)

val save : ?allow_pickle:bool -> ?fix_imports:bool -> file:[`S of string | `PyObject of Py.Object.t] -> arr:[>`Ndarray] Obj.t -> unit -> Py.Object.t
(**
Save an array to a binary file in NumPy ``.npy`` format.

Parameters
----------
file : file, str, or pathlib.Path
    File or filename to which the data is saved.  If file is a file-object,
    then the filename is unchanged.  If file is a string or Path, a ``.npy``
    extension will be appended to the filename if it does not already
    have one.
arr : array_like
    Array data to be saved.
allow_pickle : bool, optional
    Allow saving object arrays using Python pickles. Reasons for disallowing
    pickles include security (loading pickled data can execute arbitrary
    code) and portability (pickled objects may not be loadable on different
    Python installations, for example if the stored objects require libraries
    that are not available, and not all pickled data is compatible between
    Python 2 and Python 3).
    Default: True
fix_imports : bool, optional
    Only useful in forcing objects in object arrays on Python 3 to be
    pickled in a Python 2 compatible way. If `fix_imports` is True, pickle
    will try to map the new Python 3 names to the old module names used in
    Python 2, so that the pickle data stream is readable with Python 2.

See Also
--------
savez : Save several arrays into a ``.npz`` archive
savetxt, load

Notes
-----
For a description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.

Any data saved to the file is appended to the end of the file.

Examples
--------
>>> from tempfile import TemporaryFile
>>> outfile = TemporaryFile()

>>> x = np.arange(10)
>>> np.save(outfile, x)

>>> _ = outfile.seek(0) # Only needed here to simulate closing & reopening file
>>> np.load(outfile)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])


>>> with open('test.npy', 'wb') as f:
...     np.save(f, np.array([1, 2]))
...     np.save(f, np.array([1, 3]))
>>> with open('test.npy', 'rb') as f:
...     a = np.load(f)
...     b = np.load(f)
>>> print(a, b)
# [1 2] [1 3]
*)

val savetxt : ?fmt:[`Sequence_of_strs of Py.Object.t | `S of string] -> ?delimiter:string -> ?newline:string -> ?header:string -> ?footer:string -> ?comments:string -> ?encoding:string -> fname:Py.Object.t -> x:Py.Object.t -> unit -> Py.Object.t
(**
Save an array to a text file.

Parameters
----------
fname : filename or file handle
    If the filename ends in ``.gz``, the file is automatically saved in
    compressed gzip format.  `loadtxt` understands gzipped files
    transparently.
X : 1D or 2D array_like
    Data to be saved to a text file.
fmt : str or sequence of strs, optional
    A single format (%10.5f), a sequence of formats, or a
    multi-format string, e.g. 'Iteration %d -- %10.5f', in which
    case `delimiter` is ignored. For complex `X`, the legal options
    for `fmt` are:

    * a single specifier, `fmt='%.4e'`, resulting in numbers formatted
      like `' (%s+%sj)' % (fmt, fmt)`
    * a full string specifying every real and imaginary part, e.g.
      `' %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej'` for 3 columns
    * a list of specifiers, one per column - in this case, the real
      and imaginary part must have separate specifiers,
      e.g. `['%.3e + %.3ej', '(%.15e%+.15ej)']` for 2 columns
delimiter : str, optional
    String or character separating columns.
newline : str, optional
    String or character separating lines.

    .. versionadded:: 1.5.0
header : str, optional
    String that will be written at the beginning of the file.

    .. versionadded:: 1.7.0
footer : str, optional
    String that will be written at the end of the file.

    .. versionadded:: 1.7.0
comments : str, optional
    String that will be prepended to the ``header`` and ``footer`` strings,
    to mark them as comments. Default: '# ',  as expected by e.g.
    ``numpy.loadtxt``.

    .. versionadded:: 1.7.0
encoding : {None, str}, optional
    Encoding used to encode the outputfile. Does not apply to output
    streams. If the encoding is something other than 'bytes' or 'latin1'
    you will not be able to load the file in NumPy versions < 1.14. Default
    is 'latin1'.

    .. versionadded:: 1.14.0


See Also
--------
save : Save an array to a binary file in NumPy ``.npy`` format
savez : Save several arrays into an uncompressed ``.npz`` archive
savez_compressed : Save several arrays into a compressed ``.npz`` archive

Notes
-----
Further explanation of the `fmt` parameter
(``%[flag]width[.precision]specifier``):

flags:
    ``-`` : left justify

    ``+`` : Forces to precede result with + or -.

    ``0`` : Left pad the number with zeros instead of space (see width).

width:
    Minimum number of characters to be printed. The value is not truncated
    if it has more characters.

precision:
    - For integer specifiers (eg. ``d,i,o,x``), the minimum number of
      digits.
    - For ``e, E`` and ``f`` specifiers, the number of digits to print
      after the decimal point.
    - For ``g`` and ``G``, the maximum number of significant digits.
    - For ``s``, the maximum number of characters.

specifiers:
    ``c`` : character

    ``d`` or ``i`` : signed decimal integer

    ``e`` or ``E`` : scientific notation with ``e`` or ``E``.

    ``f`` : decimal floating point

    ``g,G`` : use the shorter of ``e,E`` or ``f``

    ``o`` : signed octal

    ``s`` : string of characters

    ``u`` : unsigned decimal integer

    ``x,X`` : unsigned hexadecimal integer

This explanation of ``fmt`` is not complete, for an exhaustive
specification see [1]_.

References
----------
.. [1] `Format Specification Mini-Language
       <https://docs.python.org/library/string.html#format-specification-mini-language>`_,
       Python Documentation.

Examples
--------
>>> x = y = z = np.arange(0.0,5.0,1.0)
>>> np.savetxt('test.out', x, delimiter=',')   # X is an array
>>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays
>>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation
*)

val savez : ?kwds:(string * Py.Object.t) list -> file:[`File of Py.Object.t | `S of string] -> Py.Object.t list -> Py.Object.t
(**
Save several arrays into a single file in uncompressed ``.npz`` format.

If arguments are passed in with no keywords, the corresponding variable
names, in the ``.npz`` file, are 'arr_0', 'arr_1', etc. If keyword
arguments are given, the corresponding variable names, in the ``.npz``
file will match the keyword names.

Parameters
----------
file : str or file
    Either the filename (string) or an open file (file-like object)
    where the data will be saved. If file is a string or a Path, the
    ``.npz`` extension will be appended to the filename if it is not
    already there.
args : Arguments, optional
    Arrays to save to the file. Since it is not possible for Python to
    know the names of the arrays outside `savez`, the arrays will be saved
    with names 'arr_0', 'arr_1', and so on. These arguments can be any
    expression.
kwds : Keyword arguments, optional
    Arrays to save to the file. Arrays will be saved in the file with the
    keyword names.

Returns
-------
None

See Also
--------
save : Save a single array to a binary file in NumPy format.
savetxt : Save an array to a file as plain text.
savez_compressed : Save several arrays into a compressed ``.npz`` archive

Notes
-----
The ``.npz`` file format is a zipped archive of files named after the
variables they contain.  The archive is not compressed and each file
in the archive contains one variable in ``.npy`` format. For a
description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.

When opening the saved ``.npz`` file with `load` a `NpzFile` object is
returned. This is a dictionary-like object which can be queried for
its list of arrays (with the ``.files`` attribute), and for the arrays
themselves.

When saving dictionaries, the dictionary keys become filenames
inside the ZIP archive. Therefore, keys should be valid filenames.
E.g., avoid keys that begin with ``/`` or contain ``.``.

Examples
--------
>>> from tempfile import TemporaryFile
>>> outfile = TemporaryFile()
>>> x = np.arange(10)
>>> y = np.sin(x)

Using `savez` with \*args, the arrays are saved with default names.

>>> np.savez(outfile, x, y)
>>> _ = outfile.seek(0) # Only needed here to simulate closing & reopening file
>>> npzfile = np.load(outfile)
>>> npzfile.files
['arr_0', 'arr_1']
>>> npzfile['arr_0']
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

Using `savez` with \**kwds, the arrays are saved with the keyword names.

>>> outfile = TemporaryFile()
>>> np.savez(outfile, x=x, y=y)
>>> _ = outfile.seek(0)
>>> npzfile = np.load(outfile)
>>> sorted(npzfile.files)
['x', 'y']
>>> npzfile['x']
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
*)

val savez_compressed : ?kwds:(string * Py.Object.t) list -> file:[`File of Py.Object.t | `S of string] -> Py.Object.t list -> Py.Object.t
(**
Save several arrays into a single file in compressed ``.npz`` format.

If keyword arguments are given, then filenames are taken from the keywords.
If arguments are passed in with no keywords, then stored filenames are
arr_0, arr_1, etc.

Parameters
----------
file : str or file
    Either the filename (string) or an open file (file-like object)
    where the data will be saved. If file is a string or a Path, the
    ``.npz`` extension will be appended to the filename if it is not
    already there.
args : Arguments, optional
    Arrays to save to the file. Since it is not possible for Python to
    know the names of the arrays outside `savez`, the arrays will be saved
    with names 'arr_0', 'arr_1', and so on. These arguments can be any
    expression.
kwds : Keyword arguments, optional
    Arrays to save to the file. Arrays will be saved in the file with the
    keyword names.

Returns
-------
None

See Also
--------
numpy.save : Save a single array to a binary file in NumPy format.
numpy.savetxt : Save an array to a file as plain text.
numpy.savez : Save several arrays into an uncompressed ``.npz`` file format
numpy.load : Load the files created by savez_compressed.

Notes
-----
The ``.npz`` file format is a zipped archive of files named after the
variables they contain.  The archive is compressed with
``zipfile.ZIP_DEFLATED`` and each file in the archive contains one variable
in ``.npy`` format. For a description of the ``.npy`` format, see 
:py:mod:`numpy.lib.format`.


When opening the saved ``.npz`` file with `load` a `NpzFile` object is
returned. This is a dictionary-like object which can be queried for
its list of arrays (with the ``.files`` attribute), and for the arrays
themselves.

Examples
--------
>>> test_array = np.random.rand(3, 2)
>>> test_vector = np.random.rand(4)
>>> np.savez_compressed('/tmp/123', a=test_array, b=test_vector)
>>> loaded = np.load('/tmp/123.npz')
>>> print(np.array_equal(test_array, loaded['a']))
True
>>> print(np.array_equal(test_vector, loaded['b']))
True
*)

val sctype2char : Py.Object.t -> string
(**
Return the string representation of a scalar dtype.

Parameters
----------
sctype : scalar dtype or object
    If a scalar dtype, the corresponding string character is
    returned. If an object, `sctype2char` tries to infer its scalar type
    and then return the corresponding string character.

Returns
-------
typechar : str
    The string character corresponding to the scalar type.

Raises
------
ValueError
    If `sctype` is an object for which the type can not be inferred.

See Also
--------
obj2sctype, issctype, issubsctype, mintypecode

Examples
--------
>>> for sctype in [np.int32, np.double, np.complex_, np.string_, np.ndarray]:
...     print(np.sctype2char(sctype))
l # may vary
d
D
S
O

>>> x = np.array([1., 2-1.j])
>>> np.sctype2char(x)
'D'
>>> np.sctype2char(list)
'O'
*)

val searchsorted : ?side:[`Left | `Right] -> ?sorter:Py.Object.t -> v:[>`Ndarray] Obj.t -> Py.Object.t -> Py.Object.t
(**
Find indices where elements should be inserted to maintain order.

Find the indices into a sorted array `a` such that, if the
corresponding elements in `v` were inserted before the indices, the
order of `a` would be preserved.

Assuming that `a` is sorted:

======  ============================
`side`  returned index `i` satisfies
======  ============================
left    ``a[i-1] < v <= a[i]``
right   ``a[i-1] <= v < a[i]``
======  ============================

Parameters
----------
a : 1-D array_like
    Input array. If `sorter` is None, then it must be sorted in
    ascending order, otherwise `sorter` must be an array of indices
    that sort it.
v : array_like
    Values to insert into `a`.
side : {'left', 'right'}, optional
    If 'left', the index of the first suitable location found is given.
    If 'right', return the last such index.  If there is no suitable
    index, return either 0 or N (where N is the length of `a`).
sorter : 1-D array_like, optional
    Optional array of integer indices that sort array a into ascending
    order. They are typically the result of argsort.

    .. versionadded:: 1.7.0

Returns
-------
indices : array of ints
    Array of insertion points with the same shape as `v`.

See Also
--------
sort : Return a sorted copy of an array.
histogram : Produce histogram from 1-D data.

Notes
-----
Binary search is used to find the required insertion points.

As of NumPy 1.4.0 `searchsorted` works with real/complex arrays containing
`nan` values. The enhanced sort order is documented in `sort`.

This function uses the same algorithm as the builtin python `bisect.bisect_left`
(``side='left'``) and `bisect.bisect_right` (``side='right'``) functions,
which is also vectorized in the `v` argument.

Examples
--------
>>> np.searchsorted([1,2,3,4,5], 3)
2
>>> np.searchsorted([1,2,3,4,5], 3, side='right')
3
>>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])
array([0, 5, 1, 2])
*)

val select : ?default:[`F of float | `I of int | `Bool of bool | `S of string] -> condlist:Py.Object.t -> choicelist:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an array drawn from elements in choicelist, depending on conditions.

Parameters
----------
condlist : list of bool ndarrays
    The list of conditions which determine from which array in `choicelist`
    the output elements are taken. When multiple conditions are satisfied,
    the first one encountered in `condlist` is used.
choicelist : list of ndarrays
    The list of arrays from which the output elements are taken. It has
    to be of the same length as `condlist`.
default : scalar, optional
    The element inserted in `output` when all conditions evaluate to False.

Returns
-------
output : ndarray
    The output at position m is the m-th element of the array in
    `choicelist` where the m-th element of the corresponding array in
    `condlist` is True.

See Also
--------
where : Return elements from one of two arrays depending on condition.
take, choose, compress, diag, diagonal

Examples
--------
>>> x = np.arange(10)
>>> condlist = [x<3, x>5]
>>> choicelist = [x, x**2]
>>> np.select(condlist, choicelist)
array([ 0,  1,  2, ..., 49, 64, 81])
*)

val set_printoptions : ?precision:int -> ?threshold:int -> ?edgeitems:int -> ?linewidth:int -> ?suppress:bool -> ?nanstr:string -> ?infstr:string -> ?formatter:Py.Object.t -> ?sign:[`Space | `Plus | `Minus] -> ?floatmode:string -> ?kwarg:(string * Py.Object.t) list -> unit -> Py.Object.t
(**
Set printing options.

These options determine the way floating point numbers, arrays and
other NumPy objects are displayed.

Parameters
----------
precision : int or None, optional
    Number of digits of precision for floating point output (default 8).
    May be None if `floatmode` is not `fixed`, to print as many digits as
    necessary to uniquely specify the value.
threshold : int, optional
    Total number of array elements which trigger summarization
    rather than full repr (default 1000).
    To always use the full repr without summarization, pass `sys.maxsize`.
edgeitems : int, optional
    Number of array items in summary at beginning and end of
    each dimension (default 3).
linewidth : int, optional
    The number of characters per line for the purpose of inserting
    line breaks (default 75).
suppress : bool, optional
    If True, always print floating point numbers using fixed point
    notation, in which case numbers equal to zero in the current precision
    will print as zero.  If False, then scientific notation is used when
    absolute value of the smallest number is < 1e-4 or the ratio of the
    maximum absolute value to the minimum is > 1e3. The default is False.
nanstr : str, optional
    String representation of floating point not-a-number (default nan).
infstr : str, optional
    String representation of floating point infinity (default inf).
sign : string, either '-', '+', or ' ', optional
    Controls printing of the sign of floating-point types. If '+', always
    print the sign of positive values. If ' ', always prints a space
    (whitespace character) in the sign position of positive values.  If
    '-', omit the sign character of positive values. (default '-')
formatter : dict of callables, optional
    If not None, the keys should indicate the type(s) that the respective
    formatting function applies to.  Callables should return a string.
    Types that are not specified (by their corresponding keys) are handled
    by the default formatters.  Individual types for which a formatter
    can be set are:

    - 'bool'
    - 'int'
    - 'timedelta' : a `numpy.timedelta64`
    - 'datetime' : a `numpy.datetime64`
    - 'float'
    - 'longfloat' : 128-bit floats
    - 'complexfloat'
    - 'longcomplexfloat' : composed of two 128-bit floats
    - 'numpystr' : types `numpy.string_` and `numpy.unicode_`
    - 'object' : `np.object_` arrays
    - 'str' : all other strings

    Other keys that can be used to set a group of types at once are:

    - 'all' : sets all types
    - 'int_kind' : sets 'int'
    - 'float_kind' : sets 'float' and 'longfloat'
    - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
    - 'str_kind' : sets 'str' and 'numpystr'
floatmode : str, optional
    Controls the interpretation of the `precision` option for
    floating-point types. Can take the following values
    (default maxprec_equal):

    * 'fixed': Always print exactly `precision` fractional digits,
            even if this would print more or fewer digits than
            necessary to specify the value uniquely.
    * 'unique': Print the minimum number of fractional digits necessary
            to represent each value uniquely. Different elements may
            have a different number of digits. The value of the
            `precision` option is ignored.
    * 'maxprec': Print at most `precision` fractional digits, but if
            an element can be uniquely represented with fewer digits
            only print it with that many.
    * 'maxprec_equal': Print at most `precision` fractional digits,
            but if every element in the array can be uniquely
            represented with an equal number of fewer digits, use that
            many digits for all elements.
legacy : string or `False`, optional
    If set to the string `'1.13'` enables 1.13 legacy printing mode. This
    approximates numpy 1.13 print output by including a space in the sign
    position of floats and different behavior for 0d arrays. If set to
    `False`, disables legacy mode. Unrecognized strings will be ignored
    with a warning for forward compatibility.

    .. versionadded:: 1.14.0

See Also
--------
get_printoptions, printoptions, set_string_function, array2string

Notes
-----
`formatter` is always reset with a call to `set_printoptions`.

Use `printoptions` as a context manager to set the values temporarily.

Examples
--------
Floating point precision can be set:

>>> np.set_printoptions(precision=4)
>>> np.array([1.123456789])
[1.1235]

Long arrays can be summarised:

>>> np.set_printoptions(threshold=5)
>>> np.arange(10)
array([0, 1, 2, ..., 7, 8, 9])

Small results can be suppressed:

>>> eps = np.finfo(float).eps
>>> x = np.arange(4.)
>>> x**2 - (x + eps)**2
array([-4.9304e-32, -4.4409e-16,  0.0000e+00,  0.0000e+00])
>>> np.set_printoptions(suppress=True)
>>> x**2 - (x + eps)**2
array([-0., -0.,  0.,  0.])

A custom formatter can be used to display array elements as desired:

>>> np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x)})
>>> x = np.arange(3)
>>> x
array([int: 0, int: -1, int: -2])
>>> np.set_printoptions()  # formatter gets reset
>>> x
array([0, 1, 2])

To put back the default options, you can use:

>>> np.set_printoptions(edgeitems=3, infstr='inf',
... linewidth=75, nanstr='nan', precision=8,
... suppress=False, threshold=1000, formatter=None)

Also to temporarily override options, use `printoptions` as a context manager:

>>> with np.printoptions(precision=2, suppress=True, threshold=5):
...     np.linspace(0, 10, 10)
array([ 0.  ,  1.11,  2.22, ...,  7.78,  8.89, 10.  ])
*)

val set_string_function : ?repr:bool -> f:[`Callable of Py.Object.t | `None] -> unit -> Py.Object.t
(**
Set a Python function to be used when pretty printing arrays.

Parameters
----------
f : function or None
    Function to be used to pretty print arrays. The function should expect
    a single array argument and return a string of the representation of
    the array. If None, the function is reset to the default NumPy function
    to print arrays.
repr : bool, optional
    If True (default), the function for pretty printing (``__repr__``)
    is set, if False the function that returns the default string
    representation (``__str__``) is set.

See Also
--------
set_printoptions, get_printoptions

Examples
--------
>>> def pprint(arr):
...     return 'HA! - What are you going to do now?'
...
>>> np.set_string_function(pprint)
>>> a = np.arange(10)
>>> a
HA! - What are you going to do now?
>>> _ = a
>>> # [0 1 2 3 4 5 6 7 8 9]

We can reset the function to the default:

>>> np.set_string_function(None)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

`repr` affects either pretty printing or normal string representation.
Note that ``__repr__`` is still affected by setting ``__str__``
because the width of each array element in the returned string becomes
equal to the length of the result of ``__str__()``.

>>> x = np.arange(4)
>>> np.set_string_function(lambda x:'random', repr=False)
>>> x.__str__()
'random'
>>> x.__repr__()
'array([0, 1, 2, 3])'
*)

val setbufsize : int -> Py.Object.t
(**
Set the size of the buffer used in ufuncs.

Parameters
----------
size : int
    Size of buffer.
*)

val setdiff1d : ?assume_unique:bool -> ar1:[>`Ndarray] Obj.t -> ar2:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Find the set difference of two arrays.

Return the unique values in `ar1` that are not in `ar2`.

Parameters
----------
ar1 : array_like
    Input array.
ar2 : array_like
    Input comparison array.
assume_unique : bool
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.

Returns
-------
setdiff1d : ndarray
    1D array of values in `ar1` that are not in `ar2`. The result
    is sorted when `assume_unique=False`, but otherwise only sorted
    if the input is sorted.

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Examples
--------
>>> a = np.array([1, 2, 3, 2, 4, 1])
>>> b = np.array([3, 4, 5, 6])
>>> np.setdiff1d(a, b)
array([1, 2])
*)

val seterr : ?all:[`Log | `Warn | `Raise | `Ignore | `Print | `Call] -> ?divide:[`Log | `Warn | `Raise | `Ignore | `Print | `Call] -> ?over:[`Log | `Warn | `Raise | `Ignore | `Print | `Call] -> ?under:[`Log | `Warn | `Raise | `Ignore | `Print | `Call] -> ?invalid:[`Log | `Warn | `Raise | `Ignore | `Print | `Call] -> unit -> Py.Object.t
(**
Set how floating-point errors are handled.

Note that operations on integer scalar types (such as `int16`) are
handled like floating point, and are affected by these settings.

Parameters
----------
all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Set treatment for all types of floating-point errors at once:

    - ignore: Take no action when the exception occurs.
    - warn: Print a `RuntimeWarning` (via the Python `warnings` module).
    - raise: Raise a `FloatingPointError`.
    - call: Call a function specified using the `seterrcall` function.
    - print: Print a warning directly to ``stdout``.
    - log: Record error in a Log object specified by `seterrcall`.

    The default is not to change the current behavior.
divide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Treatment for division by zero.
over : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Treatment for floating-point overflow.
under : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Treatment for floating-point underflow.
invalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Treatment for invalid floating-point operation.

Returns
-------
old_settings : dict
    Dictionary containing the old settings.

See also
--------
seterrcall : Set a callback function for the 'call' mode.
geterr, geterrcall, errstate

Notes
-----
The floating-point exceptions are defined in the IEEE 754 standard [1]_:

- Division by zero: infinite result obtained from finite numbers.
- Overflow: result too large to be expressed.
- Underflow: result so close to zero that some precision
  was lost.
- Invalid operation: result is not an expressible number, typically
  indicates that a NaN was produced.

.. [1] https://en.wikipedia.org/wiki/IEEE_754

Examples
--------
>>> old_settings = np.seterr(all='ignore')  #seterr to known value
>>> np.seterr(over='raise')
{'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}
>>> np.seterr( **old_settings)  # reset to default
{'divide': 'ignore', 'over': 'raise', 'under': 'ignore', 'invalid': 'ignore'}

>>> np.int16(32000) * np.int16(3)
30464
>>> old_settings = np.seterr(all='warn', over='raise')
>>> np.int16(32000) * np.int16(3)
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
FloatingPointError: overflow encountered in short_scalars

>>> from collections import OrderedDict
>>> old_settings = np.seterr(all='print')
>>> OrderedDict(np.geterr())
OrderedDict([('divide', 'print'), ('over', 'print'), ('under', 'print'), ('invalid', 'print')])
>>> np.int16(32000) * np.int16(3)
30464
*)

val seterrcall : Py.Object.t -> Py.Object.t option
(**
Set the floating-point error callback function or log object.

There are two ways to capture floating-point error messages.  The first
is to set the error-handler to 'call', using `seterr`.  Then, set
the function to call using this function.

The second is to set the error-handler to 'log', using `seterr`.
Floating-point errors then trigger a call to the 'write' method of
the provided object.

Parameters
----------
func : callable f(err, flag) or object with write method
    Function to call upon floating-point errors ('call'-mode) or
    object whose 'write' method is used to log such message ('log'-mode).

    The call function takes two arguments. The first is a string describing
    the type of error (such as 'divide by zero', 'overflow', 'underflow',
    or 'invalid value'), and the second is the status flag.  The flag is a
    byte, whose four least-significant bits indicate the type of error, one
    of 'divide', 'over', 'under', 'invalid'::

      [0 0 0 0 divide over under invalid]

    In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.

    If an object is provided, its write method should take one argument,
    a string.

Returns
-------
h : callable, log instance or None
    The old error handler.

See Also
--------
seterr, geterr, geterrcall

Examples
--------
Callback upon error:

>>> def err_handler(type, flag):
...     print('Floating point error (%s), with flag %s' % (type, flag))
...

>>> saved_handler = np.seterrcall(err_handler)
>>> save_err = np.seterr(all='call')
>>> from collections import OrderedDict

>>> np.array([1, 2, 3]) / 0.0
Floating point error (divide by zero), with flag 1
array([inf, inf, inf])

>>> np.seterrcall(saved_handler)
<function err_handler at 0x...>
>>> OrderedDict(sorted(np.seterr( **save_err).items()))
OrderedDict([('divide', 'call'), ('invalid', 'call'), ('over', 'call'), ('under', 'call')])

Log error message:

>>> class Log(object):
...     def write(self, msg):
...         print('LOG: %s' % msg)
...

>>> log = Log()
>>> saved_handler = np.seterrcall(log)
>>> save_err = np.seterr(all='log')

>>> np.array([1, 2, 3]) / 0.0
LOG: Warning: divide by zero encountered in true_divide
array([inf, inf, inf])

>>> np.seterrcall(saved_handler)
<numpy.core.numeric.Log object at 0x...>
>>> OrderedDict(sorted(np.seterr( **save_err).items()))
OrderedDict([('divide', 'log'), ('invalid', 'log'), ('over', 'log'), ('under', 'log')])
*)

val seterrobj : [>`Ndarray] Obj.t -> Py.Object.t
(**
seterrobj(errobj)

Set the object that defines floating-point error handling.

The error object contains all information that defines the error handling
behavior in NumPy. `seterrobj` is used internally by the other
functions that set error handling behavior (`seterr`, `seterrcall`).

Parameters
----------
errobj : list
    The error object, a list containing three elements:
    [internal numpy buffer size, error mask, error callback function].

    The error mask is a single integer that holds the treatment information
    on all four floating point errors. The information for each error type
    is contained in three bits of the integer. If we print it in base 8, we
    can see what treatment is set for 'invalid', 'under', 'over', and
    'divide' (in that order). The printed string can be interpreted with

    * 0 : 'ignore'
    * 1 : 'warn'
    * 2 : 'raise'
    * 3 : 'call'
    * 4 : 'print'
    * 5 : 'log'

See Also
--------
geterrobj, seterr, geterr, seterrcall, geterrcall
getbufsize, setbufsize

Notes
-----
For complete documentation of the types of floating-point exceptions and
treatment options, see `seterr`.

Examples
--------
>>> old_errobj = np.geterrobj()  # first get the defaults
>>> old_errobj
[8192, 521, None]

>>> def err_handler(type, flag):
...     print('Floating point error (%s), with flag %s' % (type, flag))
...
>>> new_errobj = [20000, 12, err_handler]
>>> np.seterrobj(new_errobj)
>>> np.base_repr(12, 8)  # int for divide=4 ('print') and over=1 ('warn')
'14'
>>> np.geterr()
{'over': 'warn', 'divide': 'print', 'invalid': 'ignore', 'under': 'ignore'}
>>> np.geterrcall() is err_handler
True
*)

val setxor1d : ?assume_unique:bool -> ar1:Py.Object.t -> ar2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Find the set exclusive-or of two arrays.

Return the sorted, unique values that are in only one (not both) of the
input arrays.

Parameters
----------
ar1, ar2 : array_like
    Input arrays.
assume_unique : bool
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.

Returns
-------
setxor1d : ndarray
    Sorted 1D array of unique values that are in only one of the input
    arrays.

Examples
--------
>>> a = np.array([1, 2, 3, 2, 4])
>>> b = np.array([2, 3, 5, 7, 5])
>>> np.setxor1d(a,b)
array([1, 4, 5, 7])
*)

val shape : [>`Ndarray] Obj.t -> int array
(**
Return the shape of an array.

Parameters
----------
a : array_like
    Input array.

Returns
-------
shape : tuple of ints
    The elements of the shape tuple give the lengths of the
    corresponding array dimensions.

See Also
--------
alen
ndarray.shape : Equivalent array method.

Examples
--------
>>> np.shape(np.eye(3))
(3, 3)
>>> np.shape([[1, 2]])
(1, 2)
>>> np.shape([0])
(1,)
>>> np.shape(0)
()

>>> a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
>>> np.shape(a)
(2,)
>>> a.shape
(2,)
*)

val shares_memory : ?max_work:int -> b:Py.Object.t -> Py.Object.t -> bool
(**
shares_memory(a, b, max_work=None)

Determine if two arrays share memory

Parameters
----------
a, b : ndarray
    Input arrays
max_work : int, optional
    Effort to spend on solving the overlap problem (maximum number
    of candidate solutions to consider). The following special
    values are recognized:

    max_work=MAY_SHARE_EXACT  (default)
        The problem is solved exactly. In this case, the function returns
        True only if there is an element shared between the arrays.
    max_work=MAY_SHARE_BOUNDS
        Only the memory bounds of a and b are checked.

Raises
------
numpy.TooHardError
    Exceeded max_work.

Returns
-------
out : bool

See Also
--------
may_share_memory

Examples
--------
>>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))
False
*)

val show_config : unit -> Py.Object.t
(**
None
*)

val sign : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
sign(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Returns an element-wise indication of the sign of a number.

The `sign` function returns ``-1 if x < 0, 0 if x==0, 1 if x > 0``.  nan
is returned for nan inputs.

For complex inputs, the `sign` function returns
``sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j``.

complex(nan, 0) is returned for complex nan inputs.

Parameters
----------
x : array_like
    Input values.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The sign of `x`.
    This is a scalar if `x` is a scalar.

Notes
-----
There is more than one definition of sign in common use for complex
numbers.  The definition used here is equivalent to :math:`x/\sqrt{x*x}`
which is different from a common alternative, :math:`x/|x|`.

Examples
--------
>>> np.sign([-5., 4.5])
array([-1.,  1.])
>>> np.sign(0)
0
>>> np.sign(5-2j)
(1+0j)
*)

val signbit : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
signbit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Returns element-wise True where signbit is set (less than zero).

Parameters
----------
x : array_like
    The input value(s).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
result : ndarray of bool
    Output array, or reference to `out` if that was supplied.
    This is a scalar if `x` is a scalar.

Examples
--------
>>> np.signbit(-1.2)
True
>>> np.signbit(np.array([1, -2.3, 2.1]))
array([False,  True, False])
*)

val sin : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Trigonometric sine, element-wise.

Parameters
----------
x : array_like
    Angle, in radians (:math:`2 \pi` rad equals 360 degrees).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : array_like
    The sine of each element of x.
    This is a scalar if `x` is a scalar.

See Also
--------
arcsin, sinh, cos

Notes
-----
The sine is one of the fundamental functions of trigonometry (the
mathematical study of triangles).  Consider a circle of radius 1
centered on the origin.  A ray comes in from the :math:`+x` axis, makes
an angle at the origin (measured counter-clockwise from that axis), and
departs from the origin.  The :math:`y` coordinate of the outgoing
ray's intersection with the unit circle is the sine of that angle.  It
ranges from -1 for :math:`x=3\pi / 2` to +1 for :math:`\pi / 2.`  The
function has zeroes where the angle is a multiple of :math:`\pi`.
Sines of angles between :math:`\pi` and :math:`2\pi` are negative.
The numerous properties of the sine and related functions are included
in any standard trigonometry text.

Examples
--------
Print sine of one angle:

>>> np.sin(np.pi/2.)
1.0

Print sines of an array of angles given in degrees:

>>> np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )
array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])

Plot the sine function:

>>> import matplotlib.pylab as plt
>>> x = np.linspace(-np.pi, np.pi, 201)
>>> plt.plot(x, np.sin(x))
>>> plt.xlabel('Angle [rad]')
>>> plt.ylabel('sin(x)')
>>> plt.axis('tight')
>>> plt.show()
*)

val sinc : [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the sinc function.

The sinc function is :math:`\sin(\pi x)/(\pi x)`.

Parameters
----------
x : ndarray
    Array (possibly multi-dimensional) of values for which to to
    calculate ``sinc(x)``.

Returns
-------
out : ndarray
    ``sinc(x)``, which has the same shape as the input.

Notes
-----
``sinc(0)`` is the limit value 1.

The name sinc is short for 'sine cardinal' or 'sinus cardinalis'.

The sinc function is used in various signal processing applications,
including in anti-aliasing, in the construction of a Lanczos resampling
filter, and in interpolation.

For bandlimited interpolation of discrete-time signals, the ideal
interpolation kernel is proportional to the sinc function.

References
----------
.. [1] Weisstein, Eric W. 'Sinc Function.' From MathWorld--A Wolfram Web
       Resource. http://mathworld.wolfram.com/SincFunction.html
.. [2] Wikipedia, 'Sinc function',
       https://en.wikipedia.org/wiki/Sinc_function

Examples
--------
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-4, 4, 41)
>>> np.sinc(x)
 array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary
        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
        6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
        8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
        3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
        7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
        9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
        2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
       -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
       -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
        1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
        -4.92362781e-02,  -3.89804309e-17])

>>> plt.plot(x, np.sinc(x))
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title('Sinc Function')
Text(0.5, 1.0, 'Sinc Function')
>>> plt.ylabel('Amplitude')
Text(0, 0.5, 'Amplitude')
>>> plt.xlabel('X')
Text(0.5, 0, 'X')
>>> plt.show()
*)

val sinh : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Hyperbolic sine, element-wise.

Equivalent to ``1/2 * (np.exp(x) - np.exp(-x))`` or
``-1j * np.sin(1j*x)``.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding hyperbolic sine values.
    This is a scalar if `x` is a scalar.

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972, pg. 83.

Examples
--------
>>> np.sinh(0)
0.0
>>> np.sinh(np.pi*1j/2)
1j
>>> np.sinh(np.pi*1j) # (exact value is 0)
1.2246063538223773e-016j
>>> # Discrepancy due to vagaries of floating point arithmetic.

>>> # Example of providing the optional output parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.sinh([0.1], out1)
>>> out2 is out1
True

>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.sinh(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
*)

val size : ?axis:int -> [>`Ndarray] Obj.t -> int
(**
Return the number of elements along a given axis.

Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which the elements are counted.  By default, give
    the total number of elements.

Returns
-------
element_count : int
    Number of elements along the specified axis.

See Also
--------
shape : dimensions of array
ndarray.shape : dimensions of array
ndarray.size : number of elements in array

Examples
--------
>>> a = np.array([[1,2,3],[4,5,6]])
>>> np.size(a)
6
>>> np.size(a,1)
3
>>> np.size(a,0)
2
*)

val sometrue : ?kwargs:(string * Py.Object.t) list -> Py.Object.t list -> Py.Object.t
(**
Check whether some values are true.

Refer to `any` for full documentation.

See Also
--------
any : equivalent function; see for details.
*)

val sort : ?axis:[`I of int | `None] -> ?kind:[`Quicksort | `Heapsort | `Stable | `Mergesort] -> ?order:[`StringList of string list | `S of string] -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return a sorted copy of an array.

Parameters
----------
a : array_like
    Array to be sorted.
axis : int or None, optional
    Axis along which to sort. If None, the array is flattened before
    sorting. The default is -1, which sorts along the last axis.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
    Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
    and 'mergesort' use timsort or radix sort under the covers and, in general,
    the actual implementation will vary with data type. The 'mergesort' option
    is retained for backwards compatibility.

    .. versionchanged:: 1.15.0.
       The 'stable' option was added.

order : str or list of str, optional
    When `a` is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  A single field can
    be specified as a string, and not all fields need be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.
partition : Partial sort.

Notes
-----
The various sorting algorithms are characterized by their average speed,
worst case performance, work space size, and whether they are stable. A
stable sort keeps items with the same key in the same relative
order. The four algorithms implemented in NumPy have the following
properties:

=========== ======= ============= ============ ========
   kind      speed   worst case    work space   stable
=========== ======= ============= ============ ========
'quicksort'    1     O(n^2)            0          no
'heapsort'     3     O(n*log(n))       0          no
'mergesort'    2     O(n*log(n))      ~n/2        yes
'timsort'      2     O(n*log(n))      ~n/2        yes
=========== ======= ============= ============ ========

.. note:: The datatype determines which of 'mergesort' or 'timsort'
   is actually used, even if 'mergesort' is specified. User selection
   at a finer scale is not currently available.

All the sort algorithms make temporary copies of the data when
sorting along any but the last axis.  Consequently, sorting along
the last axis is faster and uses less space than sorting along
any other axis.

The sort order for complex numbers is lexicographic. If both the real
and imaginary parts are non-nan then the order is determined by the
real parts except when they are equal, in which case the order is
determined by the imaginary parts.

Previous to numpy 1.4.0 sorting real and complex arrays containing nan
values led to undefined behaviour. In numpy versions >= 1.4.0 nan
values are sorted to the end. The extended sort order is:

  * Real: [R, nan]
  * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]

where R is a non-nan real value. Complex values with the same nan
placements are sorted according to the non-nan part if it exists.
Non-nan values are sorted as before.

.. versionadded:: 1.12.0

quicksort has been changed to `introsort <https://en.wikipedia.org/wiki/Introsort>`_.
When sorting does not make enough progress it switches to
`heapsort <https://en.wikipedia.org/wiki/Heapsort>`_.
This implementation makes quicksort O(n*log(n)) in the worst case.

'stable' automatically chooses the best stable sorting algorithm
for the data type being sorted.
It, along with 'mergesort' is currently mapped to
`timsort <https://en.wikipedia.org/wiki/Timsort>`_
or `radix sort <https://en.wikipedia.org/wiki/Radix_sort>`_
depending on the data type.
API forward compatibility currently limits the
ability to select the implementation and it is hardwired for the different
data types.

.. versionadded:: 1.17.0

Timsort is added for better performance on already or nearly
sorted data. On random data timsort is almost identical to
mergesort. It is now used for stable sort while quicksort is still the
default sort if none is chosen. For timsort details, refer to
`CPython listsort.txt <https://github.com/python/cpython/blob/3.7/Objects/listsort.txt>`_.
'mergesort' and 'stable' are mapped to radix sort for integer data types. Radix sort is an
O(n) sort instead of O(n log n).

.. versionchanged:: 1.17.0

NaT now sorts to the end of arrays for consistency with NaN.

Examples
--------
>>> a = np.array([[1,4],[3,1]])
>>> np.sort(a)                # sort along the last axis
array([[1, 4],
       [1, 3]])
>>> np.sort(a, axis=None)     # sort the flattened array
array([1, 1, 3, 4])
>>> np.sort(a, axis=0)        # sort along the first axis
array([[1, 1],
       [3, 4]])

Use the `order` keyword to specify a field to use when sorting a
structured array:

>>> dtype = [('name', 'S10'), ('height', float), ('age', int)]
>>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),
...           ('Galahad', 1.7, 38)]
>>> a = np.array(values, dtype=dtype)       # create a structured array
>>> np.sort(a, order='height')                        # doctest: +SKIP
array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),
       ('Lancelot', 1.8999999999999999, 38)],
      dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])

Sort by age, then height if ages are equal:

>>> np.sort(a, order=['age', 'height'])               # doctest: +SKIP
array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),
       ('Arthur', 1.8, 41)],
      dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])
*)

val sort_complex : [>`Ndarray] Obj.t -> Py.Object.t
(**
Sort a complex array using the real part first, then the imaginary part.

Parameters
----------
a : array_like
    Input array

Returns
-------
out : complex ndarray
    Always returns a sorted complex array.

Examples
--------
>>> np.sort_complex([5, 3, 6, 2, 1])
array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])

>>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])
array([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])
*)

val source : ?output:Py.Object.t -> object_:Py.Object.t -> unit -> Py.Object.t
(**
Print or write to a file the source code for a NumPy object.

The source code is only returned for objects written in Python. Many
functions and classes are defined in C and will therefore not return
useful information.

Parameters
----------
object : numpy object
    Input object. This can be any object (function, class, module,
    ...).
output : file object, optional
    If `output` not supplied then source code is printed to screen
    (sys.stdout).  File object must be created with either write 'w' or
    append 'a' modes.

See Also
--------
lookfor, info

Examples
--------
>>> np.source(np.interp)                        #doctest: +SKIP
In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py
def interp(x, xp, fp, left=None, right=None):
    '''.... (full docstring printed)'''
    if isinstance(x, (float, int, number)):
        return compiled_interp([x], xp, fp, left, right).item()
    else:
        return compiled_interp(x, xp, fp, left, right)

The source code is only returned for objects written in Python.

>>> np.source(np.array)                         #doctest: +SKIP
Not available for this object.
*)

val spacing : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
spacing(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the distance between x and the nearest adjacent number.

Parameters
----------
x : array_like
    Values to find the spacing of.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    The spacing of values of `x`.
    This is a scalar if `x` is a scalar.

Notes
-----
It can be considered as a generalization of EPS:
``spacing(np.float64(1)) == np.finfo(np.float64).eps``, and there
should not be any representable number between ``x + spacing(x)`` and
x for any finite x.

Spacing of +- inf and NaN is NaN.

Examples
--------
>>> np.spacing(1) == np.finfo(np.float64).eps
True
*)

val split : ?axis:int -> ary:[>`Ndarray] Obj.t -> indices_or_sections:[`T1_D_array of Py.Object.t | `I of int] -> unit -> Py.Object.t
(**
Split an array into multiple sub-arrays as views into `ary`.

Parameters
----------
ary : ndarray
    Array to be divided into sub-arrays.
indices_or_sections : int or 1-D array
    If `indices_or_sections` is an integer, N, the array will be divided
    into N equal arrays along `axis`.  If such a split is not possible,
    an error is raised.

    If `indices_or_sections` is a 1-D array of sorted integers, the entries
    indicate where along `axis` the array is split.  For example,
    ``[2, 3]`` would, for ``axis=0``, result in

      - ary[:2]
      - ary[2:3]
      - ary[3:]

    If an index exceeds the dimension of the array along `axis`,
    an empty sub-array is returned correspondingly.
axis : int, optional
    The axis along which to split, default is 0.

Returns
-------
sub-arrays : list of ndarrays
    A list of sub-arrays as views into `ary`.

Raises
------
ValueError
    If `indices_or_sections` is given as an integer, but
    a split does not result in equal division.

See Also
--------
array_split : Split an array into multiple sub-arrays of equal or
              near-equal size.  Does not raise an exception if
              an equal division cannot be made.
hsplit : Split array into multiple sub-arrays horizontally (column-wise).
vsplit : Split array into multiple sub-arrays vertically (row wise).
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise).
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third dimension).

Examples
--------
>>> x = np.arange(9.0)
>>> np.split(x, 3)
[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.,  8.])]

>>> x = np.arange(8.0)
>>> np.split(x, [3, 5, 6, 10])
[array([0.,  1.,  2.]),
 array([3.,  4.]),
 array([5.]),
 array([6.,  7.]),
 array([], dtype=float64)]
*)

val sqrt : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the non-negative square-root of an array, element-wise.

Parameters
----------
x : array_like
    The values whose square-roots are required.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    An array of the same shape as `x`, containing the positive
    square-root of each element in `x`.  If any element in `x` is
    complex, a complex array is returned (and the square-roots of
    negative reals are calculated).  If all of the elements in `x`
    are real, so is `y`, with negative elements returning ``nan``.
    If `out` was provided, `y` is a reference to it.
    This is a scalar if `x` is a scalar.

See Also
--------
lib.scimath.sqrt
    A version which returns complex numbers when given negative reals.

Notes
-----
*sqrt* has--consistent with common convention--as its branch cut the
real 'interval' [`-inf`, 0), and is continuous from above on it.
A branch cut is a curve in the complex plane across which a given
complex function fails to be continuous.

Examples
--------
>>> np.sqrt([1,4,9])
array([ 1.,  2.,  3.])

>>> np.sqrt([4, -1, -3+4J])
array([ 2.+0.j,  0.+1.j,  1.+2.j])

>>> np.sqrt([4, -1, np.inf])
array([ 2., nan, inf])
*)

val square : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the element-wise square of the input.

Parameters
----------
x : array_like
    Input data.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    Element-wise `x*x`, of the same shape and dtype as `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
numpy.linalg.matrix_power
sqrt
power

Examples
--------
>>> np.square([-1j, 1])
array([-1.-0.j,  1.+0.j])
*)

val squeeze : ?axis:int list -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Remove single-dimensional entries from the shape of an array.

Parameters
----------
a : array_like
    Input data.
axis : None or int or tuple of ints, optional
    .. versionadded:: 1.7.0

    Selects a subset of the single-dimensional entries in the
    shape. If an axis is selected with shape entry greater than
    one, an error is raised.

Returns
-------
squeezed : ndarray
    The input array, but with all or a subset of the
    dimensions of length 1 removed. This is always `a` itself
    or a view into `a`.

Raises
------
ValueError
    If `axis` is not None, and an axis being squeezed is not of length 1

See Also
--------
expand_dims : The inverse operation, adding singleton dimensions
reshape : Insert, remove, and combine dimensions, and resize existing ones

Examples
--------
>>> x = np.array([[[0], [1], [2]]])
>>> x.shape
(1, 3, 1)
>>> np.squeeze(x).shape
(3,)
>>> np.squeeze(x, axis=0).shape
(3, 1)
>>> np.squeeze(x, axis=1).shape
Traceback (most recent call last):
...
ValueError: cannot select an axis to squeeze out which has size not equal to one
>>> np.squeeze(x, axis=2).shape
(1, 3)
*)

val stack : ?axis:int -> ?out:[>`Ndarray] Obj.t -> arrays:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Join a sequence of arrays along a new axis.

The ``axis`` parameter specifies the index of the new axis in the
dimensions of the result. For example, if ``axis=0`` it will be the first
dimension and if ``axis=-1`` it will be the last dimension.

.. versionadded:: 1.10.0

Parameters
----------
arrays : sequence of array_like
    Each array must have the same shape.

axis : int, optional
    The axis in the result array along which the input arrays are stacked.

out : ndarray, optional
    If provided, the destination to place the result. The shape must be
    correct, matching that of what stack would have returned if no
    out argument were specified.

Returns
-------
stacked : ndarray
    The stacked array has one more dimension than the input arrays.

See Also
--------
concatenate : Join a sequence of arrays along an existing axis.
split : Split array into a list of multiple sub-arrays of equal size.
block : Assemble arrays from blocks.

Examples
--------
>>> arrays = [np.random.randn(3, 4) for _ in range(10)]
>>> np.stack(arrays, axis=0).shape
(10, 3, 4)

>>> np.stack(arrays, axis=1).shape
(3, 10, 4)

>>> np.stack(arrays, axis=2).shape
(3, 4, 10)

>>> a = np.array([1, 2, 3])
>>> b = np.array([2, 3, 4])
>>> np.stack((a, b))
array([[1, 2, 3],
       [2, 3, 4]])

>>> np.stack((a, b), axis=-1)
array([[1, 2],
       [2, 3],
       [3, 4]])
*)

val std : ?axis:int list -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?ddof:int -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the standard deviation along the specified axis.

Returns the standard deviation, a measure of the spread of a distribution,
of the array elements. The standard deviation is computed for the
flattened array by default, otherwise over the specified axis.

Parameters
----------
a : array_like
    Calculate the standard deviation of these values.
axis : None or int or tuple of ints, optional
    Axis or axes along which the standard deviation is computed. The
    default is to compute the standard deviation of the flattened array.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a standard deviation is performed over
    multiple axes, instead of a single axis or all the axes as before.
dtype : dtype, optional
    Type to use in computing the standard deviation. For arrays of
    integer type the default is float64, for arrays of float types it is
    the same as the array type.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type (of the calculated
    values) will be cast if necessary.
ddof : int, optional
    Means Delta Degrees of Freedom.  The divisor used in calculations
    is ``N - ddof``, where ``N`` represents the number of elements.
    By default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `std` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
standard_deviation : ndarray, see dtype parameter above.
    If `out` is None, return a new array containing the standard deviation,
    otherwise return a reference to the output array.

See Also
--------
var, mean, nanmean, nanstd, nanvar
ufuncs-output-type

Notes
-----
The standard deviation is the square root of the average of the squared
deviations from the mean, i.e., ``std = sqrt(mean(abs(x - x.mean())**2))``.

The average squared deviation is normally calculated as
``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,
the divisor ``N - ddof`` is used instead. In standard statistical
practice, ``ddof=1`` provides an unbiased estimator of the variance
of the infinite population. ``ddof=0`` provides a maximum likelihood
estimate of the variance for normally distributed variables. The
standard deviation computed in this function is the square root of
the estimated variance, so even with ``ddof=1``, it will not be an
unbiased estimate of the standard deviation per se.

Note that, for complex numbers, `std` takes the absolute
value before squaring, so that the result is always real and nonnegative.

For floating-point input, the *std* is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example below).
Specifying a higher-accuracy accumulator using the `dtype` keyword can
alleviate this issue.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> np.std(a)
1.1180339887498949 # may vary
>>> np.std(a, axis=0)
array([1.,  1.])
>>> np.std(a, axis=1)
array([0.5,  0.5])

In single precision, std() can be inaccurate:

>>> a = np.zeros((2, 512*512), dtype=np.float32)
>>> a[0, :] = 1.0
>>> a[1, :] = 0.1
>>> np.std(a)
0.45000005

Computing the standard deviation in float64 is more accurate:

>>> np.std(a, dtype=np.float64)
0.44999999925494177 # may vary
*)

val subtract : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Subtract arguments, element-wise.

Parameters
----------
x1, x2 : array_like
    The arrays to be subtracted from each other. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The difference of `x1` and `x2`, element-wise.
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
Equivalent to ``x1 - x2`` in terms of array broadcasting.

Examples
--------
>>> np.subtract(1.0, 4.0)
-3.0

>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.subtract(x1, x2)
array([[ 0.,  0.,  0.],
       [ 3.,  3.,  3.],
       [ 6.,  6.,  6.]])
*)

val sum : ?axis:int list -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?keepdims:bool -> ?initial:[`F of float | `I of int | `Bool of bool | `S of string] -> ?where:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Sum of array elements over a given axis.

Parameters
----------
a : array_like
    Elements to sum.
axis : None or int or tuple of ints, optional
    Axis or axes along which a sum is performed.  The default,
    axis=None, will sum all of the elements of the input array.  If
    axis is negative it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If axis is a tuple of ints, a sum is performed on all of the axes
    specified in the tuple instead of a single axis or all the axes as
    before.
dtype : dtype, optional
    The type of the returned array and of the accumulator in which the
    elements are summed.  The dtype of `a` is used by default unless `a`
    has an integer dtype of less precision than the default platform
    integer.  In that case, if `a` is signed then the platform integer
    is used while if `a` is unsigned then an unsigned integer of the
    same precision as the platform integer is used.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output, but the type of the output
    values will be cast if necessary.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `sum` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.
initial : scalar, optional
    Starting value for the sum. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.15.0

where : array_like of bool, optional
    Elements to include in the sum. See `~numpy.ufunc.reduce` for details.

    .. versionadded:: 1.17.0

Returns
-------
sum_along_axis : ndarray
    An array with the same shape as `a`, with the specified
    axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar
    is returned.  If an output array is specified, a reference to
    `out` is returned.

See Also
--------
ndarray.sum : Equivalent method.

add.reduce : Equivalent functionality of `add`.

cumsum : Cumulative sum of array elements.

trapz : Integration of array values using the composite trapezoidal rule.

mean, average

Notes
-----
Arithmetic is modular when using integer types, and no error is
raised on overflow.

The sum of an empty array is the neutral element 0:

>>> np.sum([])
0.0

For floating point numbers the numerical precision of sum (and
``np.add.reduce``) is in general limited by directly adding each number
individually to the result causing rounding errors in every step.
However, often numpy will use a  numerically better approach (partial
pairwise summation) leading to improved precision in many use-cases.
This improved precision is always provided when no ``axis`` is given.
When ``axis`` is given, it will depend on which axis is summed.
Technically, to provide the best speed possible, the improved precision
is only used when the summation is along the fast axis in memory.
Note that the exact precision may vary depending on other parameters.
In contrast to NumPy, Python's ``math.fsum`` function uses a slower but
more precise approach to summation.
Especially when summing a large number of lower precision floating point
numbers, such as ``float32``, numerical errors can become significant.
In such cases it can be advisable to use `dtype='float64'` to use a higher
precision for the output.

Examples
--------
>>> np.sum([0.5, 1.5])
2.0
>>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)
1
>>> np.sum([[0, 1], [0, 5]])
6
>>> np.sum([[0, 1], [0, 5]], axis=0)
array([0, 6])
>>> np.sum([[0, 1], [0, 5]], axis=1)
array([1, 5])
>>> np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)
array([1., 5.])

If the accumulator is too small, overflow occurs:

>>> np.ones(128, dtype=np.int8).sum(dtype=np.int8)
-128

You can also start the sum with a value other than zero:

>>> np.sum([10], initial=5)
15
*)

val swapaxes : axis1:int -> axis2:int -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Interchange two axes of an array.

Parameters
----------
a : array_like
    Input array.
axis1 : int
    First axis.
axis2 : int
    Second axis.

Returns
-------
a_swapped : ndarray
    For NumPy >= 1.10.0, if `a` is an ndarray, then a view of `a` is
    returned; otherwise a new array is created. For earlier NumPy
    versions a view of `a` is returned only if the order of the
    axes is changed, otherwise the input array is returned.

Examples
--------
>>> x = np.array([[1,2,3]])
>>> np.swapaxes(x,0,1)
array([[1],
       [2],
       [3]])

>>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])
>>> x
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])

>>> np.swapaxes(x,0,2)
array([[[0, 4],
        [2, 6]],
       [[1, 5],
        [3, 7]]])
*)

val take : ?axis:int -> ?out:[`T_Ni_Nj_Nk_ of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?mode:[`Raise | `Wrap | `Clip] -> indices:Py.Object.t -> Py.Object.t -> Py.Object.t
(**
Take elements from an array along an axis.

When axis is not None, this function does the same thing as 'fancy'
indexing (indexing arrays using arrays); however, it can be easier to use
if you need elements along a given axis. A call such as
``np.take(arr, indices, axis=3)`` is equivalent to
``arr[:,:,:,indices,...]``.

Explained without fancy indexing, this is equivalent to the following use
of `ndindex`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of
indices::

    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
    Nj = indices.shape
    for ii in ndindex(Ni):
        for jj in ndindex(Nj):
            for kk in ndindex(Nk):
                out[ii + jj + kk] = a[ii + (indices[jj],) + kk]

Parameters
----------
a : array_like (Ni..., M, Nk...)
    The source array.
indices : array_like (Nj...)
    The indices of the values to extract.

    .. versionadded:: 1.8.0

    Also allow scalars for indices.
axis : int, optional
    The axis over which to select values. By default, the flattened
    input array is used.
out : ndarray, optional (Ni..., Nj..., Nk...)
    If provided, the result will be placed in this array. It should
    be of the appropriate shape and dtype. Note that `out` is always
    buffered if `mode='raise'`; use other modes for better performance.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.

    * 'raise' -- raise an error (default)
    * 'wrap' -- wrap around
    * 'clip' -- clip to the range

    'clip' mode means that all indices that are too large are replaced
    by the index that addresses the last element along that axis. Note
    that this disables indexing with negative numbers.

Returns
-------
out : ndarray (Ni..., Nj..., Nk...)
    The returned array has the same type as `a`.

See Also
--------
compress : Take elements using a boolean mask
ndarray.take : equivalent method
take_along_axis : Take elements by matching the array and the index arrays

Notes
-----

By eliminating the inner loop in the description above, and using `s_` to
build simple slice objects, `take` can be expressed  in terms of applying
fancy indexing to each 1-d slice::

    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
    for ii in ndindex(Ni):
        for kk in ndindex(Nj):
            out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]

For this reason, it is equivalent to (but faster than) the following use
of `apply_along_axis`::

    out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)

Examples
--------
>>> a = [4, 3, 5, 7, 6, 8]
>>> indices = [0, 1, 4]
>>> np.take(a, indices)
array([4, 3, 6])

In this example if `a` is an ndarray, 'fancy' indexing can be used.

>>> a = np.array(a)
>>> a[indices]
array([4, 3, 6])

If `indices` is not one dimensional, the output also has these dimensions.

>>> np.take(a, [[0, 1], [2, 3]])
array([[4, 3],
       [5, 7]])
*)

val take_along_axis : arr:Py.Object.t -> indices:Py.Object.t -> axis:int -> unit -> Py.Object.t
(**
Take values from the input array by matching 1d index and data slices.

This iterates over matching 1d slices oriented along the specified axis in
the index and data arrays, and uses the former to look up values in the
latter. These slices can be different lengths.

Functions returning an index along an axis, like `argsort` and
`argpartition`, produce suitable indices for this function.

.. versionadded:: 1.15.0

Parameters
----------
arr: ndarray (Ni..., M, Nk...)
    Source array
indices: ndarray (Ni..., J, Nk...)
    Indices to take along each 1d slice of `arr`. This must match the
    dimension of arr, but dimensions Ni and Nj only need to broadcast
    against `arr`.
axis: int
    The axis to take 1d slices along. If axis is None, the input array is
    treated as if it had first been flattened to 1d, for consistency with
    `sort` and `argsort`.

Returns
-------
out: ndarray (Ni..., J, Nk...)
    The indexed result.

Notes
-----
This is equivalent to (but faster than) the following use of `ndindex` and
`s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices::

    Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]
    J = indices.shape[axis]  # Need not equal M
    out = np.empty(Ni + (J,) + Nk)

    for ii in ndindex(Ni):
        for kk in ndindex(Nk):
            a_1d       = a      [ii + s_[:,] + kk]
            indices_1d = indices[ii + s_[:,] + kk]
            out_1d     = out    [ii + s_[:,] + kk]
            for j in range(J):
                out_1d[j] = a_1d[indices_1d[j]]

Equivalently, eliminating the inner loop, the last two lines would be::

            out_1d[:] = a_1d[indices_1d]

See Also
--------
take : Take along an axis, using the same indices for every 1d slice
put_along_axis :
    Put values into the destination array by matching 1d index and data slices

Examples
--------

For this sample array

>>> a = np.array([[10, 30, 20], [60, 40, 50]])

We can sort either by using sort directly, or argsort and this function

>>> np.sort(a, axis=1)
array([[10, 20, 30],
       [40, 50, 60]])
>>> ai = np.argsort(a, axis=1); ai
array([[0, 2, 1],
       [1, 2, 0]])
>>> np.take_along_axis(a, ai, axis=1)
array([[10, 20, 30],
       [40, 50, 60]])

The same works for max and min, if you expand the dimensions:

>>> np.expand_dims(np.max(a, axis=1), axis=1)
array([[30],
       [60]])
>>> ai = np.expand_dims(np.argmax(a, axis=1), axis=1)
>>> ai
array([[1],
       [0]])
>>> np.take_along_axis(a, ai, axis=1)
array([[30],
       [60]])

If we want to get the max and min at the same time, we can stack the
indices first

>>> ai_min = np.expand_dims(np.argmin(a, axis=1), axis=1)
>>> ai_max = np.expand_dims(np.argmax(a, axis=1), axis=1)
>>> ai = np.concatenate([ai_min, ai_max], axis=1)
>>> ai
array([[0, 1],
       [1, 0]])
>>> np.take_along_axis(a, ai, axis=1)
array([[10, 30],
       [40, 60]])
*)

val tan : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute tangent element-wise.

Equivalent to ``np.sin(x)/np.cos(x)`` element-wise.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding tangent values.
    This is a scalar if `x` is a scalar.

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.

Examples
--------
>>> from math import pi
>>> np.tan(np.array([-pi,pi/2,pi]))
array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])
>>>
>>> # Example of providing the optional output parameter illustrating
>>> # that what is returned is a reference to said parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.cos([0.1], out1)
>>> out2 is out1
True
>>>
>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
*)

val tanh : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Compute hyperbolic tangent element-wise.

Equivalent to ``np.sinh(x)/np.cosh(x)`` or ``-1j * np.tan(1j*x)``.

Parameters
----------
x : array_like
    Input array.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray
    The corresponding hyperbolic tangent values.
    This is a scalar if `x` is a scalar.

Notes
-----
If `out` is provided, the function writes the result into it,
and returns a reference to `out`.  (See Examples)

References
----------
.. [1] M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
       New York, NY: Dover, 1972, pg. 83.
       http://www.math.sfu.ca/~cbm/aands/

.. [2] Wikipedia, 'Hyperbolic function',
       https://en.wikipedia.org/wiki/Hyperbolic_function

Examples
--------
>>> np.tanh((0, np.pi*1j, np.pi*1j/2))
array([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])

>>> # Example of providing the optional output parameter illustrating
>>> # that what is returned is a reference to said parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.tanh([0.1], out1)
>>> out2 is out1
True

>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.tanh(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)
*)

val tensordot : ?axes:[`I of int | `T_2_array_like of Py.Object.t] -> b:Py.Object.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute tensor dot product along specified axes.

Given two tensors, `a` and `b`, and an array_like object containing
two array_like objects, ``(a_axes, b_axes)``, sum the products of
`a`'s and `b`'s elements (components) over the axes specified by
``a_axes`` and ``b_axes``. The third argument can be a single non-negative
integer_like scalar, ``N``; if it is such, then the last ``N`` dimensions
of `a` and the first ``N`` dimensions of `b` are summed over.

Parameters
----------
a, b : array_like
    Tensors to 'dot'.

axes : int or (2,) array_like
    * integer_like
      If an int N, sum over the last N axes of `a` and the first N axes
      of `b` in order. The sizes of the corresponding axes must match.
    * (2,) array_like
      Or, a list of axes to be summed over, first sequence applying to `a`,
      second to `b`. Both elements array_like must be of the same length.

Returns
-------
output : ndarray
    The tensor dot product of the input.

See Also
--------
dot, einsum

Notes
-----
Three common use cases are:
    * ``axes = 0`` : tensor product :math:`a\otimes b`
    * ``axes = 1`` : tensor dot product :math:`a\cdot b`
    * ``axes = 2`` : (default) tensor double contraction :math:`a:b`

When `axes` is integer_like, the sequence for evaluation will be: first
the -Nth axis in `a` and 0th axis in `b`, and the -1th axis in `a` and
Nth axis in `b` last.

When there is more than one axis to sum over - and they are not the last
(first) axes of `a` (`b`) - the argument `axes` should consist of
two sequences of the same length, with the first axis to sum over given
first in both sequences, the second axis second, and so forth.

The shape of the result consists of the non-contracted axes of the
first tensor, followed by the non-contracted axes of the second.

Examples
--------
A 'traditional' example:

>>> a = np.arange(60.).reshape(3,4,5)
>>> b = np.arange(24.).reshape(4,3,2)
>>> c = np.tensordot(a,b, axes=([1,0],[0,1]))
>>> c.shape
(5, 2)
>>> c
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
>>> # A slower but equivalent way of computing the same...
>>> d = np.zeros((5,2))
>>> for i in range(5):
...   for j in range(2):
...     for k in range(3):
...       for n in range(4):
...         d[i,j] += a[k,n,i] * b[n,k,j]
>>> c == d
array([[ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True]])

An extended example taking advantage of the overloading of + and \*:

>>> a = np.array(range(1, 9))
>>> a.shape = (2, 2, 2)
>>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)
>>> A.shape = (2, 2)
>>> a; A
array([[[1, 2],
        [3, 4]],
       [[5, 6],
        [7, 8]]])
array([['a', 'b'],
       ['c', 'd']], dtype=object)

>>> np.tensordot(a, A) # third argument default is 2 for double-contraction
array(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)

>>> np.tensordot(a, A, 1)
array([[['acc', 'bdd'],
        ['aaacccc', 'bbbdddd']],
       [['aaaaacccccc', 'bbbbbdddddd'],
        ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)

>>> np.tensordot(a, A, 0) # tensor product (result too long to incl.)
array([[[[['a', 'b'],
          ['c', 'd']],
          ...

>>> np.tensordot(a, A, (0, 1))
array([[['abbbbb', 'cddddd'],
        ['aabbbbbb', 'ccdddddd']],
       [['aaabbbbbbb', 'cccddddddd'],
        ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)

>>> np.tensordot(a, A, (2, 1))
array([[['abb', 'cdd'],
        ['aaabbbb', 'cccdddd']],
       [['aaaaabbbbbb', 'cccccdddddd'],
        ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)

>>> np.tensordot(a, A, ((0, 1), (0, 1)))
array(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)

>>> np.tensordot(a, A, ((2, 1), (1, 0)))
array(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)
*)

val tile : a:[>`Ndarray] Obj.t -> reps:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Construct an array by repeating A the number of times given by reps.

If `reps` has length ``d``, the result will have dimension of
``max(d, A.ndim)``.

If ``A.ndim < d``, `A` is promoted to be d-dimensional by prepending new
axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,
or shape (1, 1, 3) for 3-D replication. If this is not the desired
behavior, promote `A` to d-dimensions manually before calling this
function.

If ``A.ndim > d``, `reps` is promoted to `A`.ndim by pre-pending 1's to it.
Thus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as
(1, 1, 2, 2).

Note : Although tile may be used for broadcasting, it is strongly
recommended to use numpy's broadcasting operations and functions.

Parameters
----------
A : array_like
    The input array.
reps : array_like
    The number of repetitions of `A` along each axis.

Returns
-------
c : ndarray
    The tiled output array.

See Also
--------
repeat : Repeat elements of an array.
broadcast_to : Broadcast an array to a new shape

Examples
--------
>>> a = np.array([0, 1, 2])
>>> np.tile(a, 2)
array([0, 1, 2, 0, 1, 2])
>>> np.tile(a, (2, 2))
array([[0, 1, 2, 0, 1, 2],
       [0, 1, 2, 0, 1, 2]])
>>> np.tile(a, (2, 1, 2))
array([[[0, 1, 2, 0, 1, 2]],
       [[0, 1, 2, 0, 1, 2]]])

>>> b = np.array([[1, 2], [3, 4]])
>>> np.tile(b, 2)
array([[1, 2, 1, 2],
       [3, 4, 3, 4]])
>>> np.tile(b, (2, 1))
array([[1, 2],
       [3, 4],
       [1, 2],
       [3, 4]])

>>> c = np.array([1,2,3,4])
>>> np.tile(c,(4,1))
array([[1, 2, 3, 4],
       [1, 2, 3, 4],
       [1, 2, 3, 4],
       [1, 2, 3, 4]])
*)

val trace : ?offset:int -> ?axis1:Py.Object.t -> ?axis2:Py.Object.t -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return the sum along diagonals of the array.

If `a` is 2-D, the sum along its diagonal with the given offset
is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.

If `a` has more than two dimensions, then the axes specified by axis1 and
axis2 are used to determine the 2-D sub-arrays whose traces are returned.
The shape of the resulting array is the same as that of `a` with `axis1`
and `axis2` removed.

Parameters
----------
a : array_like
    Input array, from which the diagonals are taken.
offset : int, optional
    Offset of the diagonal from the main diagonal. Can be both positive
    and negative. Defaults to 0.
axis1, axis2 : int, optional
    Axes to be used as the first and second axis of the 2-D sub-arrays
    from which the diagonals should be taken. Defaults are the first two
    axes of `a`.
dtype : dtype, optional
    Determines the data-type of the returned array and of the accumulator
    where the elements are summed. If dtype has the value None and `a` is
    of integer type of precision less than the default integer
    precision, then the default integer precision is used. Otherwise,
    the precision is the same as that of `a`.
out : ndarray, optional
    Array into which the output is placed. Its type is preserved and
    it must be of the right shape to hold the output.

Returns
-------
sum_along_diagonals : ndarray
    If `a` is 2-D, the sum along the diagonal is returned.  If `a` has
    larger dimensions, then an array of sums along diagonals is returned.

See Also
--------
diag, diagonal, diagflat

Examples
--------
>>> np.trace(np.eye(3))
3.0
>>> a = np.arange(8).reshape((2,2,2))
>>> np.trace(a)
array([6, 8])

>>> a = np.arange(24).reshape((2,2,2,3))
>>> np.trace(a).shape
(2, 3)
*)

val transpose : ?axes:Py.Object.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Permute the dimensions of an array.

Parameters
----------
a : array_like
    Input array.
axes : list of ints, optional
    By default, reverse the dimensions, otherwise permute the axes
    according to the values given.

Returns
-------
p : ndarray
    `a` with its axes permuted.  A view is returned whenever
    possible.

See Also
--------
moveaxis
argsort

Notes
-----
Use `transpose(a, argsort(axes))` to invert the transposition of tensors
when using the `axes` keyword argument.

Transposing a 1-D array returns an unchanged view of the original array.

Examples
--------
>>> x = np.arange(4).reshape((2,2))
>>> x
array([[0, 1],
       [2, 3]])

>>> np.transpose(x)
array([[0, 2],
       [1, 3]])

>>> x = np.ones((1, 2, 3))
>>> np.transpose(x, (1, 0, 2)).shape
(2, 1, 3)
*)

val trapz : ?x:[>`Ndarray] Obj.t -> ?dx:[`F of float | `I of int | `Bool of bool | `S of string] -> ?axis:int -> y:[>`Ndarray] Obj.t -> unit -> float
(**
Integrate along the given axis using the composite trapezoidal rule.

Integrate `y` (`x`) along given axis.

Parameters
----------
y : array_like
    Input array to integrate.
x : array_like, optional
    The sample points corresponding to the `y` values. If `x` is None,
    the sample points are assumed to be evenly spaced `dx` apart. The
    default is None.
dx : scalar, optional
    The spacing between sample points when `x` is None. The default is 1.
axis : int, optional
    The axis along which to integrate.

Returns
-------
trapz : float
    Definite integral as approximated by trapezoidal rule.

See Also
--------
sum, cumsum

Notes
-----
Image [2]_ illustrates trapezoidal rule -- y-axis locations of points
will be taken from `y` array, by default x-axis distances between
points will be 1.0, alternatively they can be provided with `x` array
or with `dx` scalar.  Return value will be equal to combined area under
the red lines.


References
----------
.. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule

.. [2] Illustration image:
       https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png

Examples
--------
>>> np.trapz([1,2,3])
4.0
>>> np.trapz([1,2,3], x=[4,6,8])
8.0
>>> np.trapz([1,2,3], dx=2)
8.0
>>> a = np.arange(6).reshape(2, 3)
>>> a
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.trapz(a, axis=0)
array([1.5, 2.5, 3.5])
>>> np.trapz(a, axis=1)
array([2.,  8.])
*)

val tri : ?m:int -> ?k:int -> ?dtype:Dtype.t -> n:int -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
An array with ones at and below the given diagonal and zeros elsewhere.

Parameters
----------
N : int
    Number of rows in the array.
M : int, optional
    Number of columns in the array.
    By default, `M` is taken equal to `N`.
k : int, optional
    The sub-diagonal at and below which the array is filled.
    `k` = 0 is the main diagonal, while `k` < 0 is below it,
    and `k` > 0 is above.  The default is 0.
dtype : dtype, optional
    Data type of the returned array.  The default is float.

Returns
-------
tri : ndarray of shape (N, M)
    Array with its lower triangle filled with ones and zero elsewhere;
    in other words ``T[i,j] == 1`` for ``j <= i + k``, 0 otherwise.

Examples
--------
>>> np.tri(3, 5, 2, dtype=int)
array([[1, 1, 1, 0, 0],
       [1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1]])

>>> np.tri(3, 5, -1)
array([[0.,  0.,  0.,  0.,  0.],
       [1.,  0.,  0.,  0.,  0.],
       [1.,  1.,  0.,  0.,  0.]])
*)

val tril : ?k:int -> m:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Lower triangle of an array.

Return a copy of an array with elements above the `k`-th diagonal zeroed.

Parameters
----------
m : array_like, shape (M, N)
    Input array.
k : int, optional
    Diagonal above which to zero elements.  `k = 0` (the default) is the
    main diagonal, `k < 0` is below it and `k > 0` is above.

Returns
-------
tril : ndarray, shape (M, N)
    Lower triangle of `m`, of same shape and data-type as `m`.

See Also
--------
triu : same thing, only for the upper triangle

Examples
--------
>>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 0,  0,  0],
       [ 4,  0,  0],
       [ 7,  8,  0],
       [10, 11, 12]])
*)

val tril_indices : ?k:int -> ?m:int -> n:int -> unit -> Py.Object.t
(**
Return the indices for the lower-triangle of an (n, m) array.

Parameters
----------
n : int
    The row dimension of the arrays for which the returned
    indices will be valid.
k : int, optional
    Diagonal offset (see `tril` for details).
m : int, optional
    .. versionadded:: 1.9.0

    The column dimension of the arrays for which the returned
    arrays will be valid.
    By default `m` is taken equal to `n`.


Returns
-------
inds : tuple of arrays
    The indices for the triangle. The returned tuple contains two arrays,
    each with the indices along one dimension of the array.

See also
--------
triu_indices : similar function, for upper-triangular.
mask_indices : generic function accepting an arbitrary mask function.
tril, triu

Notes
-----
.. versionadded:: 1.4.0

Examples
--------
Compute two different sets of indices to access 4x4 arrays, one for the
lower triangular part starting at the main diagonal, and one starting two
diagonals further right:

>>> il1 = np.tril_indices(4)
>>> il2 = np.tril_indices(4, 2)

Here is how they can be used with a sample array:

>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

Both for indexing:

>>> a[il1]
array([ 0,  4,  5, ..., 13, 14, 15])

And for assigning values:

>>> a[il1] = -1
>>> a
array([[-1,  1,  2,  3],
       [-1, -1,  6,  7],
       [-1, -1, -1, 11],
       [-1, -1, -1, -1]])

These cover almost the whole array (two diagonals right of the main one):

>>> a[il2] = -10
>>> a
array([[-10, -10, -10,   3],
       [-10, -10, -10, -10],
       [-10, -10, -10, -10],
       [-10, -10, -10, -10]])
*)

val tril_indices_from : ?k:int -> arr:[>`Ndarray] Obj.t -> unit -> Py.Object.t
(**
Return the indices for the lower-triangle of arr.

See `tril_indices` for full details.

Parameters
----------
arr : array_like
    The indices will be valid for square arrays whose dimensions are
    the same as arr.
k : int, optional
    Diagonal offset (see `tril` for details).

See Also
--------
tril_indices, tril

Notes
-----
.. versionadded:: 1.4.0
*)

val trim_zeros : ?trim:string -> filt:Py.Object.t -> unit -> Py.Object.t
(**
Trim the leading and/or trailing zeros from a 1-D array or sequence.

Parameters
----------
filt : 1-D array or sequence
    Input array.
trim : str, optional
    A string with 'f' representing trim from front and 'b' to trim from
    back. Default is 'fb', trim zeros from both front and back of the
    array.

Returns
-------
trimmed : 1-D array or sequence
    The result of trimming the input. The input data type is preserved.

Examples
--------
>>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))
>>> np.trim_zeros(a)
array([1, 2, 3, 0, 2, 1])

>>> np.trim_zeros(a, 'b')
array([0, 0, 0, ..., 0, 2, 1])

The input data type is preserved, list/tuple in means list/tuple out.

>>> np.trim_zeros([0, 1, 2, 0])
[1, 2]
*)

val triu : ?k:Py.Object.t -> m:Py.Object.t -> unit -> Py.Object.t
(**
Upper triangle of an array.

Return a copy of a matrix with the elements below the `k`-th diagonal
zeroed.

Please refer to the documentation for `tril` for further details.

See Also
--------
tril : lower triangle of an array

Examples
--------
>>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 0,  8,  9],
       [ 0,  0, 12]])
*)

val triu_indices : ?k:int -> ?m:int -> n:int -> unit -> Py.Object.t
(**
Return the indices for the upper-triangle of an (n, m) array.

Parameters
----------
n : int
    The size of the arrays for which the returned indices will
    be valid.
k : int, optional
    Diagonal offset (see `triu` for details).
m : int, optional
    .. versionadded:: 1.9.0

    The column dimension of the arrays for which the returned
    arrays will be valid.
    By default `m` is taken equal to `n`.


Returns
-------
inds : tuple, shape(2) of ndarrays, shape(`n`)
    The indices for the triangle. The returned tuple contains two arrays,
    each with the indices along one dimension of the array.  Can be used
    to slice a ndarray of shape(`n`, `n`).

See also
--------
tril_indices : similar function, for lower-triangular.
mask_indices : generic function accepting an arbitrary mask function.
triu, tril

Notes
-----
.. versionadded:: 1.4.0

Examples
--------
Compute two different sets of indices to access 4x4 arrays, one for the
upper triangular part starting at the main diagonal, and one starting two
diagonals further right:

>>> iu1 = np.triu_indices(4)
>>> iu2 = np.triu_indices(4, 2)

Here is how they can be used with a sample array:

>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

Both for indexing:

>>> a[iu1]
array([ 0,  1,  2, ..., 10, 11, 15])

And for assigning values:

>>> a[iu1] = -1
>>> a
array([[-1, -1, -1, -1],
       [ 4, -1, -1, -1],
       [ 8,  9, -1, -1],
       [12, 13, 14, -1]])

These cover only a small part of the whole array (two diagonals right
of the main one):

>>> a[iu2] = -10
>>> a
array([[ -1,  -1, -10, -10],
       [  4,  -1,  -1, -10],
       [  8,   9,  -1,  -1],
       [ 12,  13,  14,  -1]])
*)

val triu_indices_from : ?k:int -> arr:[>`Ndarray] Obj.t -> unit -> Py.Object.t
(**
Return the indices for the upper-triangle of arr.

See `triu_indices` for full details.

Parameters
----------
arr : ndarray, shape(N, N)
    The indices will be valid for square arrays.
k : int, optional
    Diagonal offset (see `triu` for details).

Returns
-------
triu_indices_from : tuple, shape(2) of ndarray, shape(N)
    Indices for the upper-triangle of `arr`.

See Also
--------
triu_indices, triu

Notes
-----
.. versionadded:: 1.4.0
*)

val true_divide : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> Py.Object.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Returns a true division of the inputs, element-wise.

Instead of the Python traditional 'floor division', this returns a true
division.  True division adjusts the output type to present the best
answer, regardless of input types.

Parameters
----------
x1 : array_like
    Dividend array.
x2 : array_like
    Divisor array. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
out : ndarray or scalar
    This is a scalar if both `x1` and `x2` are scalars.

Notes
-----
The floor division operator ``//`` was added in Python 2.2 making
``//`` and ``/`` equivalent operators.  The default floor division
operation of ``/`` can be replaced by true division with ``from
__future__ import division``.

In Python 3.0, ``//`` is the floor division operator and ``/`` the
true division operator.  The ``true_divide(x1, x2)`` function is
equivalent to true division in Python.

Examples
--------
>>> x = np.arange(5)
>>> np.true_divide(x, 4)
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])

>>> x//4
array([0, 0, 0, 0, 1])

>>> from __future__ import division
>>> x/4
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
>>> x//4
array([0, 0, 0, 0, 1])
*)

val trunc : ?out:[`Tuple_of_ndarray_and_None of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> ?where:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
trunc(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])

Return the truncated value of the input, element-wise.

The truncated value of the scalar `x` is the nearest integer `i` which
is closer to zero than `x` is. In short, the fractional part of the
signed number `x` is discarded.

Parameters
----------
x : array_like
    Input data.
out : ndarray, None, or tuple of ndarray and None, optional
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.
where : array_like, optional
    This condition is broadcast over the input. At locations where the
    condition is True, the `out` array will be set to the ufunc result.
    Elsewhere, the `out` array will retain its original value.
    Note that if an uninitialized `out` array is created via the default
    ``out=None``, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:`ufunc docs <ufuncs.kwargs>`.

Returns
-------
y : ndarray or scalar
    The truncated value of each element in `x`.
    This is a scalar if `x` is a scalar.

See Also
--------
ceil, floor, rint

Notes
-----
.. versionadded:: 1.3.0

Examples
--------
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.trunc(a)
array([-1., -1., -0.,  0.,  1.,  1.,  2.])
*)

val typename : string -> string
(**
Return a description for the given data type code.

Parameters
----------
char : str
    Data type code.

Returns
-------
out : str
    Description of the input data type code.

See Also
--------
dtype, typecodes

Examples
--------
>>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',
...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']
>>> for typechar in typechars:
...     print(typechar, ' : ', np.typename(typechar))
...
S1  :  character
?  :  bool
B  :  unsigned char
D  :  complex double precision
G  :  complex long double precision
F  :  complex single precision
I  :  unsigned integer
H  :  unsigned short
L  :  unsigned long integer
O  :  object
Q  :  unsigned long long integer
S  :  string
U  :  unicode
V  :  void
b  :  signed char
d  :  double precision
g  :  long precision
f  :  single precision
i  :  integer
h  :  short
l  :  long integer
q  :  long long integer
*)

val union1d : ar1:Py.Object.t -> ar2:Py.Object.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Find the union of two arrays.

Return the unique, sorted array of values that are in either of the two
input arrays.

Parameters
----------
ar1, ar2 : array_like
    Input arrays. They are flattened if they are not already 1D.

Returns
-------
union1d : ndarray
    Unique, sorted union of the input arrays.

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Examples
--------
>>> np.union1d([-1, 0, 1], [-2, 0, 2])
array([-2, -1,  0,  1,  2])

To find the union of more than two arrays, use functools.reduce:

>>> from functools import reduce
>>> reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
array([1, 2, 3, 4, 6])
*)

val unique : ?return_index:bool -> ?return_inverse:bool -> ?return_counts:bool -> ?axis:int -> ar:[>`Ndarray] Obj.t -> unit -> ([`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t * [`ArrayLike|`Ndarray|`Object] Obj.t)
(**
Find the unique elements of an array.

Returns the sorted unique elements of an array. There are three optional
outputs in addition to the unique elements:

* the indices of the input array that give the unique values
* the indices of the unique array that reconstruct the input array
* the number of times each unique value comes up in the input array

Parameters
----------
ar : array_like
    Input array. Unless `axis` is specified, this will be flattened if it
    is not already 1-D.
return_index : bool, optional
    If True, also return the indices of `ar` (along the specified axis,
    if provided, or in the flattened array) that result in the unique array.
return_inverse : bool, optional
    If True, also return the indices of the unique array (for the specified
    axis, if provided) that can be used to reconstruct `ar`.
return_counts : bool, optional
    If True, also return the number of times each unique item appears
    in `ar`.

    .. versionadded:: 1.9.0

axis : int or None, optional
    The axis to operate on. If None, `ar` will be flattened. If an integer,
    the subarrays indexed by the given axis will be flattened and treated
    as the elements of a 1-D array with the dimension of the given axis,
    see the notes for more details.  Object arrays or structured arrays
    that contain objects are not supported if the `axis` kwarg is used. The
    default is None.

    .. versionadded:: 1.13.0

Returns
-------
unique : ndarray
    The sorted unique values.
unique_indices : ndarray, optional
    The indices of the first occurrences of the unique values in the
    original array. Only provided if `return_index` is True.
unique_inverse : ndarray, optional
    The indices to reconstruct the original array from the
    unique array. Only provided if `return_inverse` is True.
unique_counts : ndarray, optional
    The number of times each of the unique values comes up in the
    original array. Only provided if `return_counts` is True.

    .. versionadded:: 1.9.0

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Notes
-----
When an axis is specified the subarrays indexed by the axis are sorted.
This is done by making the specified axis the first dimension of the array
(move the axis to the first dimension to keep the order of the other axes)
and then flattening the subarrays in C order. The flattened subarrays are
then viewed as a structured type with each element given a label, with the
effect that we end up with a 1-D array of structured types that can be
treated in the same way as any other 1-D array. The result is that the
flattened subarrays are sorted in lexicographic order starting with the
first element.

Examples
--------
>>> np.unique([1, 1, 2, 2, 3, 3])
array([1, 2, 3])
>>> a = np.array([[1, 1], [2, 3]])
>>> np.unique(a)
array([1, 2, 3])

Return the unique rows of a 2D array

>>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
>>> np.unique(a, axis=0)
array([[1, 0, 0], [2, 3, 4]])

Return the indices of the original array that give the unique values:

>>> a = np.array(['a', 'b', 'b', 'c', 'a'])
>>> u, indices = np.unique(a, return_index=True)
>>> u
array(['a', 'b', 'c'], dtype='<U1')
>>> indices
array([0, 1, 3])
>>> a[indices]
array(['a', 'b', 'c'], dtype='<U1')

Reconstruct the input array from the unique values:

>>> a = np.array([1, 2, 6, 4, 2, 3, 2])
>>> u, indices = np.unique(a, return_inverse=True)
>>> u
array([1, 2, 3, 4, 6])
>>> indices
array([0, 1, 4, ..., 1, 2, 1])
>>> u[indices]
array([1, 2, 6, ..., 2, 3, 2])
*)

val unpackbits : ?axis:int -> ?count:int -> ?bitorder:[`Big | `Little] -> [`Uint8_type of Py.Object.t | `Ndarray of [>`Ndarray] Obj.t] -> Py.Object.t
(**
unpackbits(a, axis=None, count=None, bitorder='big')

Unpacks elements of a uint8 array into a binary-valued output array.

Each element of `a` represents a bit-field that should be unpacked
into a binary-valued output array. The shape of the output array is
either 1-D (if `axis` is ``None``) or the same shape as the input
array with unpacking done along the axis specified.

Parameters
----------
a : ndarray, uint8 type
   Input array.
axis : int, optional
    The dimension over which bit-unpacking is done.
    ``None`` implies unpacking the flattened array.
count : int or None, optional
    The number of elements to unpack along `axis`, provided as a way
    of undoing the effect of packing a size that is not a multiple
    of eight. A non-negative number means to only unpack `count`
    bits. A negative number means to trim off that many bits from
    the end. ``None`` means to unpack the entire array (the
    default). Counts larger than the available number of bits will
    add zero padding to the output. Negative counts must not
    exceed the available number of bits.

    .. versionadded:: 1.17.0

bitorder : {'big', 'little'}, optional
    The order of the returned bits. 'big' will mimic bin(val),
    ``3 = 0b00000011 => [0, 0, 0, 0, 0, 0, 1, 1]``, 'little' will reverse
    the order to ``[1, 1, 0, 0, 0, 0, 0, 0]``.
    Defaults to 'big'.

    .. versionadded:: 1.17.0

Returns
-------
unpacked : ndarray, uint8 type
   The elements are binary-valued (0 or 1).

See Also
--------
packbits : Packs the elements of a binary-valued array into bits in
           a uint8 array.

Examples
--------
>>> a = np.array([[2], [7], [23]], dtype=np.uint8)
>>> a
array([[ 2],
       [ 7],
       [23]], dtype=uint8)
>>> b = np.unpackbits(a, axis=1)
>>> b
array([[0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)
>>> c = np.unpackbits(a, axis=1, count=-3)
>>> c
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0]], dtype=uint8)

>>> p = np.packbits(b, axis=0)
>>> np.unpackbits(p, axis=0)
array([[0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
>>> np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0]))
True
*)

val unravel_index : ?order:[`C | `F] -> indices:[>`Ndarray] Obj.t -> int list -> Py.Object.t
(**
unravel_index(indices, shape, order='C')

Converts a flat index or array of flat indices into a tuple
of coordinate arrays.

Parameters
----------
indices : array_like
    An integer array whose elements are indices into the flattened
    version of an array of dimensions ``shape``. Before version 1.6.0,
    this function accepted just one index value.
shape : tuple of ints
    The shape of the array to use for unraveling ``indices``.

    .. versionchanged:: 1.16.0
        Renamed from ``dims`` to ``shape``.

order : {'C', 'F'}, optional
    Determines whether the indices should be viewed as indexing in
    row-major (C-style) or column-major (Fortran-style) order.

    .. versionadded:: 1.6.0

Returns
-------
unraveled_coords : tuple of ndarray
    Each array in the tuple has the same shape as the ``indices``
    array.

See Also
--------
ravel_multi_index

Examples
--------
>>> np.unravel_index([22, 41, 37], (7,6))
(array([3, 6, 6]), array([4, 5, 1]))
>>> np.unravel_index([31, 41, 13], (7,6), order='F')
(array([3, 6, 6]), array([4, 5, 1]))

>>> np.unravel_index(1621, (6,7,8,9))
(3, 1, 4, 1)
*)

val unwrap : ?discont:float -> ?axis:int -> p:[>`Ndarray] Obj.t -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Unwrap by changing deltas between values to 2*pi complement.

Unwrap radian phase `p` by changing absolute jumps greater than
`discont` to their 2*pi complement along the given axis.

Parameters
----------
p : array_like
    Input array.
discont : float, optional
    Maximum discontinuity between values, default is ``pi``.
axis : int, optional
    Axis along which unwrap will operate, default is the last axis.

Returns
-------
out : ndarray
    Output array.

See Also
--------
rad2deg, deg2rad

Notes
-----
If the discontinuity in `p` is smaller than ``pi``, but larger than
`discont`, no unwrapping is done because taking the 2*pi complement
would only make the discontinuity larger.

Examples
--------
>>> phase = np.linspace(0, np.pi, num=5)
>>> phase[3:] += np.pi
>>> phase
array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary
>>> np.unwrap(phase)
array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary
*)

val vander : ?n:int -> ?increasing:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Generate a Vandermonde matrix.

The columns of the output matrix are powers of the input vector. The
order of the powers is determined by the `increasing` boolean argument.
Specifically, when `increasing` is False, the `i`-th output column is
the input vector raised element-wise to the power of ``N - i - 1``. Such
a matrix with a geometric progression in each row is named for Alexandre-
Theophile Vandermonde.

Parameters
----------
x : array_like
    1-D input array.
N : int, optional
    Number of columns in the output.  If `N` is not specified, a square
    array is returned (``N = len(x)``).
increasing : bool, optional
    Order of the powers of the columns.  If True, the powers increase
    from left to right, if False (the default) they are reversed.

    .. versionadded:: 1.9.0

Returns
-------
out : ndarray
    Vandermonde matrix.  If `increasing` is False, the first column is
    ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is
    True, the columns are ``x^0, x^1, ..., x^(N-1)``.

See Also
--------
polynomial.polynomial.polyvander

Examples
--------
>>> x = np.array([1, 2, 3, 5])
>>> N = 3
>>> np.vander(x, N)
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

>>> np.column_stack([x**(N-1-i) for i in range(N)])
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

>>> x = np.array([1, 2, 3, 5])
>>> np.vander(x)
array([[  1,   1,   1,   1],
       [  8,   4,   2,   1],
       [ 27,   9,   3,   1],
       [125,  25,   5,   1]])
>>> np.vander(x, increasing=True)
array([[  1,   1,   1,   1],
       [  1,   2,   4,   8],
       [  1,   3,   9,  27],
       [  1,   5,  25, 125]])

The determinant of a square Vandermonde matrix is the product
of the differences between the values of the input vector:

>>> np.linalg.det(np.vander(x))
48.000000000000043 # may vary
>>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)
48
*)

val var : ?axis:int list -> ?dtype:Dtype.t -> ?out:[>`Ndarray] Obj.t -> ?ddof:int -> ?keepdims:bool -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Compute the variance along the specified axis.

Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.

Parameters
----------
a : array_like
    Array containing numbers whose variance is desired.  If `a` is not an
    array, a conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which the variance is computed.  The default is to
    compute the variance of the flattened array.

    .. versionadded:: 1.7.0

    If this is a tuple of ints, a variance is performed over multiple axes,
    instead of a single axis or all the axes as before.
dtype : data-type, optional
    Type to use in computing the variance.  For arrays of integer type
    the default is `float64`; for arrays of float types it is the same as
    the array type.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output, but the type is cast if
    necessary.
ddof : int, optional
    'Delta Degrees of Freedom': the divisor used in the calculation is
    ``N - ddof``, where ``N`` represents the number of elements. By
    default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    If the default value is passed, then `keepdims` will not be
    passed through to the `var` method of sub-classes of
    `ndarray`, however any non-default value will be.  If the
    sub-class' method does not implement `keepdims` any
    exceptions will be raised.

Returns
-------
variance : ndarray, see dtype parameter above
    If ``out=None``, returns a new array containing the variance;
    otherwise, a reference to the output array is returned.

See Also
--------
std, mean, nanmean, nanstd, nanvar
ufuncs-output-type

Notes
-----
The variance is the average of the squared deviations from the mean,
i.e.,  ``var = mean(abs(x - x.mean())**2)``.

The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
If, however, `ddof` is specified, the divisor ``N - ddof`` is used
instead.  In standard statistical practice, ``ddof=1`` provides an
unbiased estimator of the variance of a hypothetical infinite population.
``ddof=0`` provides a maximum likelihood estimate of the variance for
normally distributed variables.

Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.

For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32` (see example
below).  Specifying a higher-accuracy accumulator using the ``dtype``
keyword can alleviate this issue.

Examples
--------
>>> a = np.array([[1, 2], [3, 4]])
>>> np.var(a)
1.25
>>> np.var(a, axis=0)
array([1.,  1.])
>>> np.var(a, axis=1)
array([0.25,  0.25])

In single precision, var() can be inaccurate:

>>> a = np.zeros((2, 512*512), dtype=np.float32)
>>> a[0, :] = 1.0
>>> a[1, :] = 0.1
>>> np.var(a)
0.20250003

Computing the variance in float64 is more accurate:

>>> np.var(a, dtype=np.float64)
0.20249999932944759 # may vary
>>> ((1-0.55)**2 + (0.1-0.55)**2)/2
0.2025
*)

val vdot : b:[>`Ndarray] Obj.t -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
vdot(a, b)

Return the dot product of two vectors.

The vdot(`a`, `b`) function handles complex numbers differently than
dot(`a`, `b`).  If the first argument is complex the complex conjugate
of the first argument is used for the calculation of the dot product.

Note that `vdot` handles multidimensional arrays differently than `dot`:
it does *not* perform a matrix product, but flattens input arguments
to 1-D vectors first. Consequently, it should only be used for vectors.

Parameters
----------
a : array_like
    If `a` is complex the complex conjugate is taken before calculation
    of the dot product.
b : array_like
    Second argument to the dot product.

Returns
-------
output : ndarray
    Dot product of `a` and `b`.  Can be an int, float, or
    complex depending on the types of `a` and `b`.

See Also
--------
dot : Return the dot product without using the complex conjugate of the
      first argument.

Examples
--------
>>> a = np.array([1+2j,3+4j])
>>> b = np.array([5+6j,7+8j])
>>> np.vdot(a, b)
(70-8j)
>>> np.vdot(b, a)
(70+8j)

Note that higher-dimensional arrays are flattened!

>>> a = np.array([[1, 4], [5, 6]])
>>> b = np.array([[4, 1], [2, 2]])
>>> np.vdot(a, b)
30
>>> np.vdot(b, a)
30
>>> 1*4 + 4*1 + 5*2 + 6*2
30
*)

val vsplit : ary:Py.Object.t -> indices_or_sections:Py.Object.t -> unit -> Py.Object.t
(**
Split an array into multiple sub-arrays vertically (row-wise).

Please refer to the ``split`` documentation.  ``vsplit`` is equivalent
to ``split`` with `axis=0` (default), the array is always split along the
first axis regardless of the array dimension.

See Also
--------
split : Split an array into multiple sub-arrays of equal size.

Examples
--------
>>> x = np.arange(16.0).reshape(4, 4)
>>> x
array([[ 0.,   1.,   2.,   3.],
       [ 4.,   5.,   6.,   7.],
       [ 8.,   9.,  10.,  11.],
       [12.,  13.,  14.,  15.]])
>>> np.vsplit(x, 2)
[array([[0., 1., 2., 3.],
       [4., 5., 6., 7.]]), array([[ 8.,  9., 10., 11.],
       [12., 13., 14., 15.]])]
>>> np.vsplit(x, np.array([3, 6]))
[array([[ 0.,  1.,  2.,  3.],
       [ 4.,  5.,  6.,  7.],
       [ 8.,  9., 10., 11.]]), array([[12., 13., 14., 15.]]), array([], shape=(0, 4), dtype=float64)]

With a higher dimensional array the split is still along the first axis.

>>> x = np.arange(8.0).reshape(2, 2, 2)
>>> x
array([[[0.,  1.],
        [2.,  3.]],
       [[4.,  5.],
        [6.,  7.]]])
>>> np.vsplit(x, 2)
[array([[[0., 1.],
        [2., 3.]]]), array([[[4., 5.],
        [6., 7.]]])]
*)

val vstack : [>`Ndarray] Obj.t list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Stack arrays in sequence vertically (row wise).

This is equivalent to concatenation along the first axis after 1-D arrays
of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by
`vsplit`.

This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions `concatenate`, `stack` and
`block` provide more general stacking and concatenation operations.

Parameters
----------
tup : sequence of ndarrays
    The arrays must have the same shape along all but the first axis.
    1-D arrays must have the same length.

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays, will be at least 2-D.

See Also
--------
stack : Join a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
concatenate : Join a sequence of arrays along an existing axis.
vsplit : Split array into a list of multiple sub-arrays vertically.
block : Assemble arrays from blocks.

Examples
--------
>>> a = np.array([1, 2, 3])
>>> b = np.array([2, 3, 4])
>>> np.vstack((a,b))
array([[1, 2, 3],
       [2, 3, 4]])

>>> a = np.array([[1], [2], [3]])
>>> b = np.array([[2], [3], [4]])
>>> np.vstack((a,b))
array([[1],
       [2],
       [3],
       [2],
       [3],
       [4]])
*)

val where : ?x:Py.Object.t -> ?y:Py.Object.t -> condition:[`Bool of bool | `Ndarray of [>`Ndarray] Obj.t] -> unit -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
where(condition, [x, y])

Return elements chosen from `x` or `y` depending on `condition`.

.. note::
    When only `condition` is provided, this function is a shorthand for
    ``np.asarray(condition).nonzero()``. Using `nonzero` directly should be
    preferred, as it behaves correctly for subclasses. The rest of this
    documentation covers only the case where all three arguments are
    provided.

Parameters
----------
condition : array_like, bool
    Where True, yield `x`, otherwise yield `y`.
x, y : array_like
    Values from which to choose. `x`, `y` and `condition` need to be
    broadcastable to some shape.

Returns
-------
out : ndarray
    An array with elements from `x` where `condition` is True, and elements
    from `y` elsewhere.

See Also
--------
choose
nonzero : The function that is called when x and y are omitted

Notes
-----
If all the arrays are 1-D, `where` is equivalent to::

    [xv if c else yv
     for c, xv, yv in zip(condition, x, y)]

Examples
--------
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.where(a < 5, a, 10*a)
array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])

This can be used on multidimensional arrays too:

>>> np.where([[True, False], [True, True]],
...          [[1, 2], [3, 4]],
...          [[9, 8], [7, 6]])
array([[1, 8],
       [3, 4]])

The shapes of x, y, and the condition are broadcast together:

>>> x, y = np.ogrid[:3, :4]
>>> np.where(x < y, x, 10 + y)  # both x and 10+y are broadcast
array([[10,  0,  0,  0],
       [10, 11,  1,  1],
       [10, 11, 12,  2]])

>>> a = np.array([[0, 1, 2],
...               [0, 2, 4],
...               [0, 3, 6]])
>>> np.where(a < 4, a, -1)  # -1 is broadcast
array([[ 0,  1,  2],
       [ 0,  2, -1],
       [ 0,  3, -1]])
*)

val who : ?vardict:Py.Object.t -> unit -> Py.Object.t
(**
Print the NumPy arrays in the given dictionary.

If there is no dictionary passed in or `vardict` is None then returns
NumPy arrays in the globals() dictionary (all NumPy arrays in the
namespace).

Parameters
----------
vardict : dict, optional
    A dictionary possibly containing ndarrays.  Default is globals().

Returns
-------
out : None
    Returns 'None'.

Notes
-----
Prints out the name, shape, bytes and type of all of the ndarrays
present in `vardict`.

Examples
--------
>>> a = np.arange(10)
>>> b = np.ones(20)
>>> np.who()
Name            Shape            Bytes            Type
===========================================================
a               10               80               int64
b               20               160              float64
Upper bound on total bytes  =       240

>>> d = {'x': np.arange(2.0), 'y': np.arange(3.0), 'txt': 'Some str',
... 'idx':5}
>>> np.who(d)
Name            Shape            Bytes            Type
===========================================================
x               2                16               float64
y               3                24               float64
Upper bound on total bytes  =       40
*)

val zeros : ?dtype:Dtype.t -> ?order:[`C | `F] -> int list -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
zeros(shape, dtype=float, order='C')

Return a new array of given shape and type, filled with zeros.

Parameters
----------
shape : int or tuple of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: 'C'
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of zeros with the given shape, dtype, and order.

See Also
--------
zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.

Examples
--------
>>> np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])

>>> np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])

>>> np.zeros((2, 1))
array([[ 0.],
       [ 0.]])

>>> s = (2,2)
>>> np.zeros(s)
array([[ 0.,  0.],
       [ 0.,  0.]])

>>> np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
      dtype=[('x', '<i4'), ('y', '<i4')])
*)

val zeros_like : ?dtype:Dtype.t -> ?order:[`F | `A | `PyObject of Py.Object.t] -> ?subok:bool -> ?shape:int list -> [>`Ndarray] Obj.t -> [`ArrayLike|`Ndarray|`Object] Obj.t
(**
Return an array of zeros with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of 'a', otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of zeros with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
full_like : Return a new array with shape of input filled with value.
zeros : Return a new array setting values to zero.

Examples
--------
>>> x = np.arange(6)
>>> x = x.reshape((2, 3))
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.zeros_like(x)
array([[0, 0, 0],
       [0, 0, 0]])

>>> y = np.arange(3, dtype=float)
>>> y
array([0., 1., 2.])
>>> np.zeros_like(y)
array([0.,  0.,  0.])
*)

